{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Drawing = require('../../components/drawing');\n\nvar Lib = require('../../lib');\n\nvar strScale = Lib.strScale;\nvar strTranslate = Lib.strTranslate;\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar barPlot = require('../bar/plot');\n\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar pieHelpers = require('../pie/helpers');\n\nvar piePlot = require('../pie/plot');\n\nvar attachFxHandlers = piePlot.attachFxHandlers;\nvar determineInsideTextFont = piePlot.determineInsideTextFont;\nvar layoutAreas = piePlot.layoutAreas;\nvar prerenderTitles = piePlot.prerenderTitles;\nvar positionTitleOutside = piePlot.positionTitleOutside;\nvar formatSliceLabel = piePlot.formatSliceLabel;\n\nmodule.exports = function plot(gd, cdModule) {\n  var isStatic = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  clearMinTextSize('funnelarea', fullLayout);\n  prerenderTitles(cdModule, gd);\n  layoutAreas(cdModule, fullLayout._size);\n  Lib.makeTraceGroups(fullLayout._funnelarealayer, cdModule, 'trace').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    setCoords(cd);\n    plotGroup.each(function () {\n      var slices = d3.select(this).selectAll('g.slice').data(cd);\n      slices.enter().append('g').classed('slice', true);\n      slices.exit().remove();\n      slices.each(function (pt, i) {\n        if (pt.hidden) {\n          d3.select(this).selectAll('path,g').remove();\n          return;\n        } // to have consistent event data compared to other traces\n\n\n        pt.pointNumber = pt.i;\n        pt.curveNumber = trace.index;\n        var cx = cd0.cx;\n        var cy = cd0.cy;\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.selectAll('path.surface').data([pt]);\n        slicePath.enter().append('path').classed('surface', true).style({\n          'pointer-events': isStatic ? 'none' : 'all'\n        });\n        sliceTop.call(attachFxHandlers, gd, cd);\n        var shape = 'M' + (cx + pt.TR[0]) + ',' + (cy + pt.TR[1]) + line(pt.TR, pt.BR) + line(pt.BR, pt.BL) + line(pt.BL, pt.TL) + 'Z';\n        slicePath.attr('d', shape); // add text\n\n        formatSliceLabel(gd, pt, cd0);\n        var textPosition = pieHelpers.castOption(trace.textposition, pt.pts);\n        var sliceTextGroup = sliceTop.selectAll('g.slicetext').data(pt.text && textPosition !== 'none' ? [0] : []);\n        sliceTextGroup.enter().append('g').classed('slicetext', true);\n        sliceTextGroup.exit().remove();\n        sliceTextGroup.each(function () {\n          var sliceText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n          });\n          var font = Lib.ensureUniformFontSize(gd, determineInsideTextFont(trace, pt, fullLayout.font));\n          sliceText.text(pt.text).attr({\n            'class': 'slicetext',\n            transform: '',\n            'text-anchor': 'middle'\n          }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd); // position the text relative to the slice\n\n          var textBB = Drawing.bBox(sliceText.node());\n          var transform;\n          var x0, x1;\n          var y0 = Math.min(pt.BL[1], pt.BR[1]) + cy;\n          var y1 = Math.max(pt.TL[1], pt.TR[1]) + cy;\n          x0 = Math.max(pt.TL[0], pt.BL[0]) + cx;\n          x1 = Math.min(pt.TR[0], pt.BR[0]) + cx;\n          transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n            isHorizontal: true,\n            constrained: true,\n            angle: 0,\n            anchor: 'middle'\n          });\n          transform.fontSize = font.size;\n          recordMinTextSize(trace.type, transform, fullLayout);\n          cd[i].transform = transform;\n          Lib.setTransormAndDisplay(sliceText, transform);\n        });\n      }); // add the title\n\n      var titleTextGroup = d3.select(this).selectAll('g.titletext').data(trace.title.text ? [0] : []);\n      titleTextGroup.enter().append('g').classed('titletext', true);\n      titleTextGroup.exit().remove();\n      titleTextGroup.each(function () {\n        var titleText = Lib.ensureSingle(d3.select(this), 'text', '', function (s) {\n          // prohibit tex interpretation as above\n          s.attr('data-notex', 1);\n        });\n        var txt = trace.title.text;\n\n        if (trace._meta) {\n          txt = Lib.templateString(txt, trace._meta);\n        }\n\n        titleText.text(txt).attr({\n          'class': 'titletext',\n          transform: '',\n          'text-anchor': 'middle'\n        }).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);\n        var transform = positionTitleOutside(cd0, fullLayout._size);\n        titleText.attr('transform', strTranslate(transform.x, transform.y) + strScale(Math.min(1, transform.scale)) + strTranslate(transform.tx, transform.ty));\n      });\n    });\n  });\n};\n\nfunction line(a, b) {\n  var dx = b[0] - a[0];\n  var dy = b[1] - a[1];\n  return 'l' + dx + ',' + dy;\n}\n\nfunction getBetween(a, b) {\n  return [0.5 * (a[0] + b[0]), 0.5 * (a[1] + b[1])];\n}\n\nfunction setCoords(cd) {\n  if (!cd.length) return;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var aspectratio = trace.aspectratio;\n  var h = trace.baseratio;\n  if (h > 0.999) h = 0.999; // TODO: may handle this case separately\n\n  var h2 = Math.pow(h, 2);\n  var v1 = cd0.vTotal;\n  var v0 = v1 * h2 / (1 - h2);\n  var totalValues = v1;\n  var sumSteps = v0 / v1;\n\n  function calcPos() {\n    var q = Math.sqrt(sumSteps);\n    return {\n      x: q,\n      y: -q\n    };\n  }\n\n  function getPoint() {\n    var pos = calcPos();\n    return [pos.x, pos.y];\n  }\n\n  var p;\n  var allPoints = [];\n  allPoints.push(getPoint());\n  var i, cdi;\n\n  for (i = cd.length - 1; i > -1; i--) {\n    cdi = cd[i];\n    if (cdi.hidden) continue;\n    var step = cdi.v / totalValues;\n    sumSteps += step;\n    allPoints.push(getPoint());\n  }\n\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  for (i = 0; i < allPoints.length; i++) {\n    p = allPoints[i];\n    minY = Math.min(minY, p[1]);\n    maxY = Math.max(maxY, p[1]);\n  } // center the shape\n\n\n  for (i = 0; i < allPoints.length; i++) {\n    allPoints[i][1] -= (maxY + minY) / 2;\n  }\n\n  var lastX = allPoints[allPoints.length - 1][0]; // get pie r\n\n  var r = cd0.r;\n  var rY = (maxY - minY) / 2;\n  var scaleX = r / lastX;\n  var scaleY = r / rY * aspectratio; // set funnelarea r\n\n  cd0.r = scaleY * rY; // scale the shape\n\n  for (i = 0; i < allPoints.length; i++) {\n    allPoints[i][0] *= scaleX;\n    allPoints[i][1] *= scaleY;\n  } // record first position\n\n\n  p = allPoints[0];\n  var prevLeft = [-p[0], p[1]];\n  var prevRight = [p[0], p[1]];\n  var n = 0; // note we skip the very first point.\n\n  for (i = cd.length - 1; i > -1; i--) {\n    cdi = cd[i];\n    if (cdi.hidden) continue;\n    n += 1;\n    var x = allPoints[n][0];\n    var y = allPoints[n][1];\n    cdi.TL = [-x, y];\n    cdi.TR = [x, y];\n    cdi.BL = prevLeft;\n    cdi.BR = prevRight;\n    cdi.pxmid = getBetween(cdi.TR, cdi.BR);\n    prevLeft = cdi.TL;\n    prevRight = cdi.TR;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}