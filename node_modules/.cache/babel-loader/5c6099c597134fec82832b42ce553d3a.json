{"ast":null,"code":"'use strict';\n/* eslint-disable no-bitwise */\n\n/* eslint-disable consistent-return */\n\nvar str2arr = require('../common').str2arr;\n\nvar sliceEq = require('../common').sliceEq;\n\nvar readUInt16LE = require('../common').readUInt16LE;\n\nvar readUInt32LE = require('../common').readUInt32LE;\n\nvar exif = require('../exif_utils');\n\nvar SIG_RIFF = str2arr('RIFF');\nvar SIG_WEBP = str2arr('WEBP');\n\nfunction parseVP8(data, offset) {\n  if (data[offset + 3] !== 0x9D || data[offset + 4] !== 0x01 || data[offset + 5] !== 0x2A) {\n    // bad code block signature\n    return;\n  }\n\n  return {\n    width: readUInt16LE(data, offset + 6) & 0x3FFF,\n    height: readUInt16LE(data, offset + 8) & 0x3FFF,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nfunction parseVP8L(data, offset) {\n  if (data[offset] !== 0x2F) return;\n  var bits = readUInt32LE(data, offset + 1);\n  return {\n    width: (bits & 0x3FFF) + 1,\n    height: (bits >> 14 & 0x3FFF) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nfunction parseVP8X(data, offset) {\n  return {\n    // TODO: replace with `data.readUIntLE(8, 3) + 1`\n    //       when 0.10 support is dropped\n    width: (data[offset + 6] << 16 | data[offset + 5] << 8 | data[offset + 4]) + 1,\n    height: (data[offset + 9] << offset | data[offset + 8] << 8 | data[offset + 7]) + 1,\n    type: 'webp',\n    mime: 'image/webp',\n    wUnits: 'px',\n    hUnits: 'px'\n  };\n}\n\nmodule.exports = function (data) {\n  if (data.length < 16) return; // check /^RIFF....WEBPVP8([ LX])$/ signature\n\n  if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;\n  var offset = 12;\n  var result = null;\n  var exif_orientation = 0;\n  var fileLength = readUInt32LE(data, 4) + 8;\n  if (fileLength > data.length) return;\n\n  while (offset + 8 < fileLength) {\n    if (data[offset] === 0) {\n      // after each chunk of odd size there should be 0 byte of padding, skip those\n      offset++;\n      continue;\n    }\n\n    var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));\n    var length = readUInt32LE(data, offset + 4);\n\n    if (header === 'VP8 ' && length >= 10) {\n      result = result || parseVP8(data, offset + 8);\n    } else if (header === 'VP8L' && length >= 9) {\n      result = result || parseVP8L(data, offset + 8);\n    } else if (header === 'VP8X' && length >= 10) {\n      result = result || parseVP8X(data, offset + 8);\n    } else if (header === 'EXIF') {\n      exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length)); // exif is the last chunk we care about, stop after it\n\n      offset = Infinity;\n    }\n\n    offset += 8 + length;\n  }\n\n  if (!result) return;\n\n  if (exif_orientation > 0) {\n    result.orientation = exif_orientation;\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}