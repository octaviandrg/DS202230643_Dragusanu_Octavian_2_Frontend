{"ast":null,"code":"'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\n\nvar colorAttributes = require('../../components/colorscale/attributes');\n\nvar axisHoverFormat = require('../../plots/cartesian/axis_format_attributes').axisHoverFormat;\n\nvar hovertemplateAttrs = require('../../plots/template_attributes').hovertemplateAttrs;\n\nvar texttemplateAttrs = require('../../plots/template_attributes').texttemplateAttrs;\n\nvar baseAttrs = require('../../plots/attributes');\n\nvar DASHES = require('../../constants/gl3d_dashes');\n\nvar MARKER_SYMBOLS = require('../../constants/gl3d_markers');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar overrideAll = require('../../plot_api/edit_types').overrideAll;\n\nvar sortObjectKeys = require('../../lib/sort_object_keys');\n\nvar scatterLineAttrs = scatterAttrs.line;\nvar scatterMarkerAttrs = scatterAttrs.marker;\nvar scatterMarkerLineAttrs = scatterMarkerAttrs.line;\nvar lineAttrs = extendFlat({\n  width: scatterLineAttrs.width,\n  dash: {\n    valType: 'enumerated',\n    values: sortObjectKeys(DASHES),\n    dflt: 'solid',\n    description: 'Sets the dash style of the lines.'\n  }\n}, colorAttributes('line'));\n\nfunction makeProjectionAttr(axLetter) {\n  return {\n    show: {\n      valType: 'boolean',\n      dflt: false,\n      description: ['Sets whether or not projections are shown along the', axLetter, 'axis.'].join(' ')\n    },\n    opacity: {\n      valType: 'number',\n      min: 0,\n      max: 1,\n      dflt: 1,\n      description: 'Sets the projection color.'\n    },\n    scale: {\n      valType: 'number',\n      min: 0,\n      max: 10,\n      dflt: 2 / 3,\n      description: ['Sets the scale factor determining the size of the', 'projection marker points.'].join(' ')\n    }\n  };\n}\n\nvar attrs = module.exports = overrideAll({\n  x: scatterAttrs.x,\n  y: scatterAttrs.y,\n  z: {\n    valType: 'data_array',\n    description: 'Sets the z coordinates.'\n  },\n  text: extendFlat({}, scatterAttrs.text, {\n    description: ['Sets text elements associated with each (x,y,z) triplet.', 'If a single string, the same string appears over', 'all the data points.', 'If an array of string, the items are mapped in order to the', 'this trace\\'s (x,y,z) coordinates.', 'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,', 'these elements will be seen in the hover labels.'].join(' ')\n  }),\n  texttemplate: texttemplateAttrs({}, {}),\n  hovertext: extendFlat({}, scatterAttrs.hovertext, {\n    description: ['Sets text elements associated with each (x,y,z) triplet.', 'If a single string, the same string appears over', 'all the data points.', 'If an array of string, the items are mapped in order to the', 'this trace\\'s (x,y,z) coordinates.', 'To be seen, trace `hoverinfo` must contain a *text* flag.'].join(' ')\n  }),\n  hovertemplate: hovertemplateAttrs(),\n  xhoverformat: axisHoverFormat('x'),\n  yhoverformat: axisHoverFormat('y'),\n  zhoverformat: axisHoverFormat('z'),\n  mode: extendFlat({}, scatterAttrs.mode, // shouldn't this be on-par with 2D?\n  {\n    dflt: 'lines+markers'\n  }),\n  surfaceaxis: {\n    valType: 'enumerated',\n    values: [-1, 0, 1, 2],\n    dflt: -1,\n    description: ['If *-1*, the scatter points are not fill with a surface', 'If *0*, *1*, *2*, the scatter points are filled with', 'a Delaunay surface about the x, y, z respectively.'].join(' ')\n  },\n  surfacecolor: {\n    valType: 'color',\n    description: 'Sets the surface fill color.'\n  },\n  projection: {\n    x: makeProjectionAttr('x'),\n    y: makeProjectionAttr('y'),\n    z: makeProjectionAttr('z')\n  },\n  connectgaps: scatterAttrs.connectgaps,\n  line: lineAttrs,\n  marker: extendFlat({\n    // Parity with scatter.js?\n    symbol: {\n      valType: 'enumerated',\n      values: sortObjectKeys(MARKER_SYMBOLS),\n      dflt: 'circle',\n      arrayOk: true,\n      description: 'Sets the marker symbol type.'\n    },\n    size: extendFlat({}, scatterMarkerAttrs.size, {\n      dflt: 8\n    }),\n    sizeref: scatterMarkerAttrs.sizeref,\n    sizemin: scatterMarkerAttrs.sizemin,\n    sizemode: scatterMarkerAttrs.sizemode,\n    opacity: extendFlat({}, scatterMarkerAttrs.opacity, {\n      arrayOk: false,\n      description: ['Sets the marker opacity.', 'Note that the marker opacity for scatter3d traces', 'must be a scalar value for performance reasons.', 'To set a blending opacity value', '(i.e. which is not transparent), set *marker.color*', 'to an rgba color and use its alpha channel.'].join(' ')\n    }),\n    colorbar: scatterMarkerAttrs.colorbar,\n    line: extendFlat({\n      width: extendFlat({}, scatterMarkerLineAttrs.width, {\n        arrayOk: false\n      })\n    }, colorAttributes('marker.line'))\n  }, colorAttributes('marker')),\n  textposition: extendFlat({}, scatterAttrs.textposition, {\n    dflt: 'top center'\n  }),\n  textfont: {\n    color: scatterAttrs.textfont.color,\n    size: scatterAttrs.textfont.size,\n    family: extendFlat({}, scatterAttrs.textfont.family, {\n      arrayOk: false\n    })\n  },\n  opacity: baseAttrs.opacity,\n  hoverinfo: extendFlat({}, baseAttrs.hoverinfo)\n}, 'calc', 'nested');\nattrs.x.editType = attrs.y.editType = attrs.z.editType = 'calc+clearAxisTypes';","map":null,"metadata":{},"sourceType":"script"}