{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\n\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar constants = require('./constants');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar axesNames = constants.axesNames;\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: 'geo',\n    attributes: layoutAttributes,\n    handleDefaults: handleGeoDefaults,\n    fullData: fullData,\n    partition: 'y'\n  });\n};\n\nfunction handleGeoDefaults(geoLayoutIn, geoLayoutOut, coerce, opts) {\n  var subplotData = getSubplotData(opts.fullData, 'geo', opts.id);\n  var traceIndices = subplotData.map(function (t) {\n    return t._expandedIndex;\n  });\n  var resolution = coerce('resolution');\n  var scope = coerce('scope');\n  var scopeParams = constants.scopeDefaults[scope];\n  var projType = coerce('projection.type', scopeParams.projType);\n  var isAlbersUsa = geoLayoutOut._isAlbersUsa = projType === 'albers usa'; // no other scopes are allowed for 'albers usa' projection\n\n  if (isAlbersUsa) scope = geoLayoutOut.scope = 'usa';\n  var isScoped = geoLayoutOut._isScoped = scope !== 'world';\n  var isSatellite = geoLayoutOut._isSatellite = projType === 'satellite';\n  var isConic = geoLayoutOut._isConic = projType.indexOf('conic') !== -1 || projType === 'albers';\n  var isClipped = geoLayoutOut._isClipped = !!constants.lonaxisSpan[projType];\n\n  if (geoLayoutIn.visible === false) {\n    // should override template.layout.geo.show* - see issue 4482\n    // make a copy\n    var newTemplate = Lib.extendDeep({}, geoLayoutOut._template); // override show*\n\n    newTemplate.showcoastlines = false;\n    newTemplate.showcountries = false;\n    newTemplate.showframe = false;\n    newTemplate.showlakes = false;\n    newTemplate.showland = false;\n    newTemplate.showocean = false;\n    newTemplate.showrivers = false;\n    newTemplate.showsubunits = false;\n    if (newTemplate.lonaxis) newTemplate.lonaxis.showgrid = false;\n    if (newTemplate.lataxis) newTemplate.lataxis.showgrid = false; // set ref to copy\n\n    geoLayoutOut._template = newTemplate;\n  }\n\n  var visible = coerce('visible');\n  var show;\n\n  for (var i = 0; i < axesNames.length; i++) {\n    var axisName = axesNames[i];\n    var dtickDflt = [30, 10][i];\n    var rangeDflt;\n\n    if (isScoped) {\n      rangeDflt = scopeParams[axisName + 'Range'];\n    } else {\n      var dfltSpans = constants[axisName + 'Span'];\n      var hSpan = (dfltSpans[projType] || dfltSpans['*']) / 2;\n      var rot = coerce('projection.rotation.' + axisName.substr(0, 3), scopeParams.projRotate[i]);\n      rangeDflt = [rot - hSpan, rot + hSpan];\n    }\n\n    var range = coerce(axisName + '.range', rangeDflt);\n    coerce(axisName + '.tick0');\n    coerce(axisName + '.dtick', dtickDflt);\n    show = coerce(axisName + '.showgrid', !visible ? false : undefined);\n\n    if (show) {\n      coerce(axisName + '.gridcolor');\n      coerce(axisName + '.gridwidth');\n      coerce(axisName + '.griddash');\n    } // mock axis for autorange computations\n\n\n    geoLayoutOut[axisName]._ax = {\n      type: 'linear',\n      _id: axisName.slice(0, 3),\n      _traceIndices: traceIndices,\n      setScale: Lib.identity,\n      c2l: Lib.identity,\n      r2l: Lib.identity,\n      autorange: true,\n      range: range.slice(),\n      _m: 1,\n      _input: {}\n    };\n  }\n\n  var lonRange = geoLayoutOut.lonaxis.range;\n  var latRange = geoLayoutOut.lataxis.range; // to cross antimeridian w/o ambiguity\n\n  var lon0 = lonRange[0];\n  var lon1 = lonRange[1];\n  if (lon0 > 0 && lon1 < 0) lon1 += 360;\n  var centerLon = (lon0 + lon1) / 2;\n  var projLon;\n\n  if (!isAlbersUsa) {\n    var dfltProjRotate = isScoped ? scopeParams.projRotate : [centerLon, 0, 0];\n    projLon = coerce('projection.rotation.lon', dfltProjRotate[0]);\n    coerce('projection.rotation.lat', dfltProjRotate[1]);\n    coerce('projection.rotation.roll', dfltProjRotate[2]);\n    show = coerce('showcoastlines', !isScoped && visible);\n\n    if (show) {\n      coerce('coastlinecolor');\n      coerce('coastlinewidth');\n    }\n\n    show = coerce('showocean', !visible ? false : undefined);\n    if (show) coerce('oceancolor');\n  }\n\n  var centerLonDflt;\n  var centerLatDflt;\n\n  if (isAlbersUsa) {\n    // 'albers usa' does not have a 'center',\n    // these values were found using via:\n    //   projection.invert([geoLayout.center.lon, geoLayoutIn.center.lat])\n    centerLonDflt = -96.6;\n    centerLatDflt = 38.7;\n  } else {\n    centerLonDflt = isScoped ? centerLon : projLon;\n    centerLatDflt = (latRange[0] + latRange[1]) / 2;\n  }\n\n  coerce('center.lon', centerLonDflt);\n  coerce('center.lat', centerLatDflt);\n\n  if (isSatellite) {\n    coerce('projection.tilt');\n    coerce('projection.distance');\n  }\n\n  if (isConic) {\n    var dfltProjParallels = scopeParams.projParallels || [0, 60];\n    coerce('projection.parallels', dfltProjParallels);\n  }\n\n  coerce('projection.scale');\n  show = coerce('showland', !visible ? false : undefined);\n  if (show) coerce('landcolor');\n  show = coerce('showlakes', !visible ? false : undefined);\n  if (show) coerce('lakecolor');\n  show = coerce('showrivers', !visible ? false : undefined);\n\n  if (show) {\n    coerce('rivercolor');\n    coerce('riverwidth');\n  }\n\n  show = coerce('showcountries', isScoped && scope !== 'usa' && visible);\n\n  if (show) {\n    coerce('countrycolor');\n    coerce('countrywidth');\n  }\n\n  if (scope === 'usa' || scope === 'north america' && resolution === 50) {\n    // Only works for:\n    //   USA states at 110m\n    //   USA states + Canada provinces at 50m\n    coerce('showsubunits', visible);\n    coerce('subunitcolor');\n    coerce('subunitwidth');\n  }\n\n  if (!isScoped) {\n    // Does not work in non-world scopes\n    show = coerce('showframe', visible);\n\n    if (show) {\n      coerce('framecolor');\n      coerce('framewidth');\n    }\n  }\n\n  coerce('bgcolor');\n  var fitBounds = coerce('fitbounds'); // clear attributes that will get auto-filled later\n\n  if (fitBounds) {\n    delete geoLayoutOut.projection.scale;\n\n    if (isScoped) {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n    } else if (isClipped) {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n      delete geoLayoutOut.projection.rotation.lon;\n      delete geoLayoutOut.projection.rotation.lat;\n      delete geoLayoutOut.lonaxis.range;\n      delete geoLayoutOut.lataxis.range;\n    } else {\n      delete geoLayoutOut.center.lon;\n      delete geoLayoutOut.center.lat;\n      delete geoLayoutOut.projection.rotation.lon;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}