{"ast":null,"code":"/* eslint-disable no-bitwise */\n\n/* eslint-disable consistent-return */\n'use strict'; //////////////////////////////////////////////////////////////////////////\n// Helpers\n//\n\nfunction error(message, code) {\n  var err = new Error(message);\n  err.code = code;\n  return err;\n}\n\nfunction utf8_decode(str) {\n  try {\n    return decodeURIComponent(escape(str));\n  } catch (_) {\n    return str;\n  }\n} //////////////////////////////////////////////////////////////////////////\n// Exif parser\n//\n// Input:\n//  - jpeg_bin:   Uint8Array - jpeg file\n//  - exif_start: Number     - start of TIFF header (after Exif\\0\\0)\n//  - exif_end:   Number     - end of Exif segment\n//  - on_entry:   Number     - callback\n//\n\n\nfunction ExifParser(jpeg_bin, exif_start, exif_end) {\n  // Uint8Array, exif without signature (which isn't included in offsets)\n  this.input = jpeg_bin.subarray(exif_start, exif_end); // offset correction for `on_entry` callback\n\n  this.start = exif_start; // Check TIFF header (includes byte alignment and first IFD offset)\n\n  var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));\n\n  if (sig !== 'II\\x2A\\0' && sig !== 'MM\\0\\x2A') {\n    throw error('invalid TIFF signature', 'EBADDATA');\n  } // true if motorola (big endian) byte alignment, false if intel\n\n\n  this.big_endian = sig[0] === 'M';\n}\n\nExifParser.prototype.each = function (on_entry) {\n  // allow premature exit\n  this.aborted = false;\n  var offset = this.read_uint32(4);\n  this.ifds_to_read = [{\n    id: 0,\n    offset: offset\n  }];\n\n  while (this.ifds_to_read.length > 0 && !this.aborted) {\n    var i = this.ifds_to_read.shift();\n    if (!i.offset) continue;\n    this.scan_ifd(i.id, i.offset, on_entry);\n  }\n};\n\nExifParser.prototype.read_uint16 = function (offset) {\n  var d = this.input;\n  if (offset + 2 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x100 + d[offset + 1] : d[offset] + d[offset + 1] * 0x100;\n};\n\nExifParser.prototype.read_uint32 = function (offset) {\n  var d = this.input;\n  if (offset + 4 > d.length) throw error('unexpected EOF', 'EBADDATA');\n  return this.big_endian ? d[offset] * 0x1000000 + d[offset + 1] * 0x10000 + d[offset + 2] * 0x100 + d[offset + 3] : d[offset] + d[offset + 1] * 0x100 + d[offset + 2] * 0x10000 + d[offset + 3] * 0x1000000;\n};\n\nExifParser.prototype.is_subifd_link = function (ifd, tag) {\n  return ifd === 0 && tag === 0x8769 || // SubIFD\n  ifd === 0 && tag === 0x8825 || // GPS Info\n  ifd === 0x8769 && tag === 0xA005; // Interop IFD\n}; // Returns byte length of a single component of a given format\n//\n\n\nExifParser.prototype.exif_format_length = function (format) {\n  switch (format) {\n    case 1: // byte\n\n    case 2: // ascii\n\n    case 6: // sbyte\n\n    case 7:\n      // undefined\n      return 1;\n\n    case 3: // short\n\n    case 8:\n      // sshort\n      return 2;\n\n    case 4: // long\n\n    case 9: // slong\n\n    case 11:\n      // float\n      return 4;\n\n    case 5: // rational\n\n    case 10: // srational\n\n    case 12:\n      // double\n      return 8;\n\n    default:\n      // unknown type\n      return 0;\n  }\n}; // Reads Exif data\n//\n\n\nExifParser.prototype.exif_format_read = function (format, offset) {\n  var v;\n\n  switch (format) {\n    case 1: // byte\n\n    case 2:\n      // ascii\n      v = this.input[offset];\n      return v;\n\n    case 6:\n      // sbyte\n      v = this.input[offset];\n      return v | (v & 0x80) * 0x1fffffe;\n\n    case 3:\n      // short\n      v = this.read_uint16(offset);\n      return v;\n\n    case 8:\n      // sshort\n      v = this.read_uint16(offset);\n      return v | (v & 0x8000) * 0x1fffe;\n\n    case 4:\n      // long\n      v = this.read_uint32(offset);\n      return v;\n\n    case 9:\n      // slong\n      v = this.read_uint32(offset);\n      return v | 0;\n\n    case 5: // rational\n\n    case 10: // srational\n\n    case 11: // float\n\n    case 12:\n      // double\n      return null;\n    // not implemented\n\n    case 7:\n      // undefined\n      return null;\n    // blob\n\n    default:\n      // unknown type\n      return null;\n  }\n};\n\nExifParser.prototype.scan_ifd = function (ifd_no, offset, on_entry) {\n  var entry_count = this.read_uint16(offset);\n  offset += 2;\n\n  for (var i = 0; i < entry_count; i++) {\n    var tag = this.read_uint16(offset);\n    var format = this.read_uint16(offset + 2);\n    var count = this.read_uint32(offset + 4);\n    var comp_length = this.exif_format_length(format);\n    var data_length = count * comp_length;\n    var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);\n    var is_subifd_link = false;\n\n    if (data_offset + data_length > this.input.length) {\n      throw error('unexpected EOF', 'EBADDATA');\n    }\n\n    var value = [];\n    var comp_offset = data_offset;\n\n    for (var j = 0; j < count; j++, comp_offset += comp_length) {\n      var item = this.exif_format_read(format, comp_offset);\n\n      if (item === null) {\n        value = null;\n        break;\n      }\n\n      value.push(item);\n    }\n\n    if (Array.isArray(value) && format === 2) {\n      value = utf8_decode(String.fromCharCode.apply(null, value));\n      if (value && value[value.length - 1] === '\\0') value = value.slice(0, -1);\n    }\n\n    if (this.is_subifd_link(ifd_no, tag)) {\n      if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {\n        this.ifds_to_read.push({\n          id: tag,\n          offset: value[0]\n        });\n        is_subifd_link = true;\n      }\n    }\n\n    var entry = {\n      is_big_endian: this.big_endian,\n      ifd: ifd_no,\n      tag: tag,\n      format: format,\n      count: count,\n      entry_offset: offset + this.start,\n      data_length: data_length,\n      data_offset: data_offset + this.start,\n      value: value,\n      is_subifd_link: is_subifd_link\n    };\n\n    if (on_entry(entry) === false) {\n      this.aborted = true;\n      return;\n    }\n\n    offset += 12;\n  }\n\n  if (ifd_no === 0) {\n    this.ifds_to_read.push({\n      id: 1,\n      offset: this.read_uint32(offset)\n    });\n  }\n};\n\nmodule.exports.ExifParser = ExifParser; // returns orientation stored in Exif (1-8), 0 if none was found, -1 if error\n\nmodule.exports.get_orientation = function (data) {\n  var orientation = 0;\n\n  try {\n    new ExifParser(data, 0, data.length).each(function (entry) {\n      if (entry.ifd === 0 && entry.tag === 0x112 && Array.isArray(entry.value)) {\n        orientation = entry.value[0];\n        return false;\n      }\n    });\n    return orientation;\n  } catch (err) {\n    return -1;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}