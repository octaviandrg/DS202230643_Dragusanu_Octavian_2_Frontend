{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar Drawing = require('../../components/drawing');\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar convertTextOpts = require('../../plots/mapbox/convert_text_opts');\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar NEWLINES = require('../../lib/svg_text_utils').NEWLINES;\n\nvar BR_TAG_ALL = require('../../lib/svg_text_utils').BR_TAG_ALL;\n\nmodule.exports = function convert(gd, calcTrace) {\n  var trace = calcTrace[0].trace;\n  var isVisible = trace.visible === true && trace._length !== 0;\n  var hasFill = trace.fill !== 'none';\n  var hasLines = subTypes.hasLines(trace);\n  var hasMarkers = subTypes.hasMarkers(trace);\n  var hasText = subTypes.hasText(trace);\n  var hasCircles = hasMarkers && trace.marker.symbol === 'circle';\n  var hasSymbols = hasMarkers && trace.marker.symbol !== 'circle';\n  var hasCluster = trace.cluster && trace.cluster.enabled;\n  var fill = initContainer('fill');\n  var line = initContainer('line');\n  var circle = initContainer('circle');\n  var symbol = initContainer('symbol');\n  var opts = {\n    fill: fill,\n    line: line,\n    circle: circle,\n    symbol: symbol\n  }; // early return if not visible or placeholder\n\n  if (!isVisible) return opts; // fill layer and line layer use the same coords\n\n  var lineCoords;\n\n  if (hasFill || hasLines) {\n    lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n  }\n\n  if (hasFill) {\n    fill.geojson = geoJsonUtils.makePolygon(lineCoords);\n    fill.layout.visibility = 'visible';\n    Lib.extendFlat(fill.paint, {\n      'fill-color': trace.fillcolor\n    });\n  }\n\n  if (hasLines) {\n    line.geojson = geoJsonUtils.makeLine(lineCoords);\n    line.layout.visibility = 'visible';\n    Lib.extendFlat(line.paint, {\n      'line-width': trace.line.width,\n      'line-color': trace.line.color,\n      'line-opacity': trace.opacity\n    }); // TODO convert line.dash into line-dasharray\n  }\n\n  if (hasCircles) {\n    var circleOpts = makeCircleOpts(calcTrace);\n    circle.geojson = circleOpts.geojson;\n    circle.layout.visibility = 'visible';\n\n    if (hasCluster) {\n      circle.filter = ['!', ['has', 'point_count']];\n      opts.cluster = {\n        type: 'circle',\n        filter: ['has', 'point_count'],\n        layout: {\n          visibility: 'visible'\n        },\n        paint: {\n          'circle-color': arrayifyAttribute(trace.cluster.color, trace.cluster.step),\n          'circle-radius': arrayifyAttribute(trace.cluster.size, trace.cluster.step),\n          'circle-opacity': arrayifyAttribute(trace.cluster.opacity, trace.cluster.step)\n        }\n      };\n      opts.clusterCount = {\n        type: 'symbol',\n        filter: ['has', 'point_count'],\n        paint: {},\n        layout: {\n          'text-field': '{point_count_abbreviated}',\n          'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'],\n          'text-size': 12\n        }\n      };\n    }\n\n    Lib.extendFlat(circle.paint, {\n      'circle-color': circleOpts.mcc,\n      'circle-radius': circleOpts.mrc,\n      'circle-opacity': circleOpts.mo\n    });\n  }\n\n  if (hasCircles && hasCluster) {\n    circle.filter = ['!', ['has', 'point_count']];\n  }\n\n  if (hasSymbols || hasText) {\n    symbol.geojson = makeSymbolGeoJSON(calcTrace, gd);\n    Lib.extendFlat(symbol.layout, {\n      visibility: 'visible',\n      'icon-image': '{symbol}-15',\n      'text-field': '{text}'\n    });\n\n    if (hasSymbols) {\n      Lib.extendFlat(symbol.layout, {\n        'icon-size': trace.marker.size / 10\n      });\n\n      if ('angle' in trace.marker && trace.marker.angle !== 'auto') {\n        Lib.extendFlat(symbol.layout, {\n          // unfortunately cant use {angle} do to this issue:\n          // https://github.com/mapbox/mapbox-gl-js/issues/873\n          'icon-rotate': {\n            type: 'identity',\n            property: 'angle'\n          },\n          'icon-rotation-alignment': 'map'\n        });\n      }\n\n      symbol.layout['icon-allow-overlap'] = trace.marker.allowoverlap;\n      Lib.extendFlat(symbol.paint, {\n        'icon-opacity': trace.opacity * trace.marker.opacity,\n        // TODO does not work ??\n        'icon-color': trace.marker.color\n      });\n    }\n\n    if (hasText) {\n      var iconSize = (trace.marker || {}).size;\n      var textOpts = convertTextOpts(trace.textposition, iconSize); // all data-driven below !!\n\n      Lib.extendFlat(symbol.layout, {\n        'text-size': trace.textfont.size,\n        'text-anchor': textOpts.anchor,\n        'text-offset': textOpts.offset // TODO font family\n        // 'text-font': symbol.textfont.family.split(', '),\n\n      });\n      Lib.extendFlat(symbol.paint, {\n        'text-color': trace.textfont.color,\n        'text-opacity': trace.opacity\n      });\n    }\n  }\n\n  return opts;\n};\n\nfunction initContainer(type) {\n  return {\n    type: type,\n    geojson: geoJsonUtils.makeBlank(),\n    layout: {\n      visibility: 'none'\n    },\n    filter: null,\n    paint: {}\n  };\n}\n\nfunction makeCircleOpts(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker;\n  var selectedpoints = trace.selectedpoints;\n  var arrayColor = Lib.isArrayOrTypedArray(marker.color);\n  var arraySize = Lib.isArrayOrTypedArray(marker.size);\n  var arrayOpacity = Lib.isArrayOrTypedArray(marker.opacity);\n  var i;\n\n  function addTraceOpacity(o) {\n    return trace.opacity * o;\n  }\n\n  function size2radius(s) {\n    return s / 2;\n  }\n\n  var colorFn;\n\n  if (arrayColor) {\n    if (Colorscale.hasColorscale(trace, 'marker')) {\n      colorFn = Colorscale.makeColorScaleFuncFromTrace(marker);\n    } else {\n      colorFn = Lib.identity;\n    }\n  }\n\n  var sizeFn;\n\n  if (arraySize) {\n    sizeFn = makeBubbleSizeFn(trace);\n  }\n\n  var opacityFn;\n\n  if (arrayOpacity) {\n    opacityFn = function opacityFn(mo) {\n      var mo2 = isNumeric(mo) ? +Lib.constrain(mo, 0, 1) : 0;\n      return addTraceOpacity(mo2);\n    };\n  }\n\n  var features = [];\n\n  for (i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    var lonlat = calcPt.lonlat;\n    if (isBADNUM(lonlat)) continue;\n    var props = {};\n    if (colorFn) props.mcc = calcPt.mcc = colorFn(calcPt.mc);\n    if (sizeFn) props.mrc = calcPt.mrc = sizeFn(calcPt.ms);\n    if (opacityFn) props.mo = opacityFn(calcPt.mo);\n    if (selectedpoints) props.selected = calcPt.selected || 0;\n    features.push({\n      type: 'Feature',\n      id: i + 1,\n      geometry: {\n        type: 'Point',\n        coordinates: lonlat\n      },\n      properties: props\n    });\n  }\n\n  var fns;\n\n  if (selectedpoints) {\n    fns = Drawing.makeSelectedPointStyleFns(trace);\n\n    for (i = 0; i < features.length; i++) {\n      var d = features[i].properties;\n\n      if (fns.selectedOpacityFn) {\n        d.mo = addTraceOpacity(fns.selectedOpacityFn(d));\n      }\n\n      if (fns.selectedColorFn) {\n        d.mcc = fns.selectedColorFn(d);\n      }\n\n      if (fns.selectedSizeFn) {\n        d.mrc = fns.selectedSizeFn(d);\n      }\n    }\n  }\n\n  return {\n    geojson: {\n      type: 'FeatureCollection',\n      features: features\n    },\n    mcc: arrayColor || fns && fns.selectedColorFn ? {\n      type: 'identity',\n      property: 'mcc'\n    } : marker.color,\n    mrc: arraySize || fns && fns.selectedSizeFn ? {\n      type: 'identity',\n      property: 'mrc'\n    } : size2radius(marker.size),\n    mo: arrayOpacity || fns && fns.selectedOpacityFn ? {\n      type: 'identity',\n      property: 'mo'\n    } : addTraceOpacity(marker.opacity)\n  };\n}\n\nfunction makeSymbolGeoJSON(calcTrace, gd) {\n  var fullLayout = gd._fullLayout;\n  var trace = calcTrace[0].trace;\n  var marker = trace.marker || {};\n  var symbol = marker.symbol;\n  var angle = marker.angle;\n  var fillSymbol = symbol !== 'circle' ? getFillFunc(symbol) : blankFillFunc;\n  var fillAngle = angle !== 'auto' ? getFillFunc(angle, true) : blankFillFunc;\n  var fillText = subTypes.hasText(trace) ? getFillFunc(trace.text) : blankFillFunc;\n  var features = [];\n\n  for (var i = 0; i < calcTrace.length; i++) {\n    var calcPt = calcTrace[i];\n    if (isBADNUM(calcPt.lonlat)) continue;\n    var texttemplate = trace.texttemplate;\n    var text;\n\n    if (texttemplate) {\n      var tt = Array.isArray(texttemplate) ? texttemplate[i] || '' : texttemplate;\n\n      var labels = trace._module.formatLabels(calcPt, trace, fullLayout);\n\n      var pointValues = {};\n      appendArrayPointValue(pointValues, trace, calcPt.i);\n      var meta = trace._meta || {};\n      text = Lib.texttemplateString(tt, labels, fullLayout._d3locale, pointValues, calcPt, meta);\n    } else {\n      text = fillText(i);\n    }\n\n    if (text) {\n      text = text.replace(NEWLINES, '').replace(BR_TAG_ALL, '\\n');\n    }\n\n    features.push({\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: calcPt.lonlat\n      },\n      properties: {\n        symbol: fillSymbol(i),\n        angle: fillAngle(i),\n        text: text\n      }\n    });\n  }\n\n  return {\n    type: 'FeatureCollection',\n    features: features\n  };\n}\n\nfunction getFillFunc(attr, numeric) {\n  if (Lib.isArrayOrTypedArray(attr)) {\n    if (numeric) {\n      return function (i) {\n        return isNumeric(attr[i]) ? +attr[i] : 0;\n      };\n    }\n\n    return function (i) {\n      return attr[i];\n    };\n  } else if (attr) {\n    return function () {\n      return attr;\n    };\n  } else {\n    return blankFillFunc;\n  }\n}\n\nfunction blankFillFunc() {\n  return '';\n} // only need to check lon (OR lat)\n\n\nfunction isBADNUM(lonlat) {\n  return lonlat[0] === BADNUM;\n}\n\nfunction arrayifyAttribute(values, step) {\n  var newAttribute;\n\n  if (Lib.isArrayOrTypedArray(values) && Lib.isArrayOrTypedArray(step)) {\n    newAttribute = ['step', ['get', 'point_count'], values[0]];\n\n    for (var idx = 1; idx < values.length; idx++) {\n      newAttribute.push(step[idx - 1], values[idx]);\n    }\n  } else {\n    newAttribute = values;\n  }\n\n  return newAttribute;\n}","map":null,"metadata":{},"sourceType":"script"}