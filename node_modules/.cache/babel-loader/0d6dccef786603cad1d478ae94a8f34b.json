{"ast":null,"code":"'use strict';\n\nvar parseSvgPath = require('parse-svg-path');\n\nvar constants = require('./constants');\n\nvar CIRCLE_SIDES = constants.CIRCLE_SIDES;\nvar SQRT2 = constants.SQRT2;\n\nvar cartesianHelpers = require('../../selections/helpers');\n\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\nvar iC = [0, 3, 4, 5, 6, 1, 2];\nvar iQS = [0, 3, 4, 1, 2];\n\nexports.writePaths = function (polygons) {\n  var nI = polygons.length;\n  if (!nI) return 'M0,0Z';\n  var str = '';\n\n  for (var i = 0; i < nI; i++) {\n    var nJ = polygons[i].length;\n\n    for (var j = 0; j < nJ; j++) {\n      var w = polygons[i][j][0];\n\n      if (w === 'Z') {\n        str += 'Z';\n      } else {\n        var nK = polygons[i][j].length;\n\n        for (var k = 0; k < nK; k++) {\n          var realK = k;\n\n          if (w === 'Q' || w === 'S') {\n            realK = iQS[k];\n          } else if (w === 'C') {\n            realK = iC[k];\n          }\n\n          str += polygons[i][j][realK];\n\n          if (k > 0 && k < nK - 1) {\n            str += ',';\n          }\n        }\n      }\n    }\n  }\n\n  return str;\n};\n\nexports.readPaths = function (str, gd, plotinfo, isActiveShape) {\n  var cmd = parseSvgPath(str);\n  var polys = [];\n  var n = -1;\n\n  var newPoly = function newPoly() {\n    n++;\n    polys[n] = [];\n  };\n\n  var k;\n  var x = 0;\n  var y = 0;\n  var initX;\n  var initY;\n\n  var recStart = function recStart() {\n    initX = x;\n    initY = y;\n  };\n\n  recStart();\n\n  for (var i = 0; i < cmd.length; i++) {\n    var newPos = [];\n    var x1, x2, y1, y2; // i.e. extra params for curves\n\n    var c = cmd[i][0];\n    var w = c;\n\n    switch (c) {\n      case 'M':\n        newPoly();\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        recStart();\n        break;\n\n      case 'Q':\n      case 'S':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x = +cmd[i][3];\n        y = +cmd[i][4];\n        newPos.push([w, x, y, x1, y1]); // -> iQS order\n\n        break;\n\n      case 'C':\n        x1 = +cmd[i][1];\n        y1 = +cmd[i][2];\n        x2 = +cmd[i][3];\n        y2 = +cmd[i][4];\n        x = +cmd[i][5];\n        y = +cmd[i][6];\n        newPos.push([w, x, y, x1, y1, x2, y2]); // -> iC order\n\n        break;\n\n      case 'T':\n      case 'L':\n        x = +cmd[i][1];\n        y = +cmd[i][2];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'H':\n        w = 'L'; // convert to line (for now)\n\n        x = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'V':\n        w = 'L'; // convert to line (for now)\n\n        y = +cmd[i][1];\n        newPos.push([w, x, y]);\n        break;\n\n      case 'A':\n        w = 'L'; // convert to line to handle circle\n\n        var rx = +cmd[i][1];\n        var ry = +cmd[i][2];\n\n        if (!+cmd[i][4]) {\n          rx = -rx;\n          ry = -ry;\n        }\n\n        var cenX = x - rx;\n        var cenY = y;\n\n        for (k = 1; k <= CIRCLE_SIDES / 2; k++) {\n          var t = 2 * Math.PI * k / CIRCLE_SIDES;\n          newPos.push([w, cenX + rx * Math.cos(t), cenY + ry * Math.sin(t)]);\n        }\n\n        break;\n\n      case 'Z':\n        if (x !== initX || y !== initY) {\n          x = initX;\n          y = initY;\n          newPos.push([w, x, y]);\n        }\n\n        break;\n    }\n\n    var domain = (plotinfo || {}).domain;\n    var size = gd._fullLayout._size;\n    var xPixelSized = plotinfo && plotinfo.xsizemode === 'pixel';\n    var yPixelSized = plotinfo && plotinfo.ysizemode === 'pixel';\n    var noOffset = isActiveShape === false;\n\n    for (var j = 0; j < newPos.length; j++) {\n      for (k = 0; k + 2 < 7; k += 2) {\n        var _x = newPos[j][k + 1];\n        var _y = newPos[j][k + 2];\n        if (_x === undefined || _y === undefined) continue; // keep track of end point for Z\n\n        x = _x;\n        y = _y;\n\n        if (plotinfo) {\n          if (plotinfo.xaxis && plotinfo.xaxis.p2r) {\n            if (noOffset) _x -= plotinfo.xaxis._offset;\n\n            if (xPixelSized) {\n              _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;\n            } else {\n              _x = p2r(plotinfo.xaxis, _x);\n            }\n          } else {\n            if (noOffset) _x -= size.l;\n            if (domain) _x = domain.x[0] + _x / size.w;else _x = _x / size.w;\n          }\n\n          if (plotinfo.yaxis && plotinfo.yaxis.p2r) {\n            if (noOffset) _y -= plotinfo.yaxis._offset;\n\n            if (yPixelSized) {\n              _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;\n            } else {\n              _y = p2r(plotinfo.yaxis, _y);\n            }\n          } else {\n            if (noOffset) _y -= size.t;\n            if (domain) _y = domain.y[1] - _y / size.h;else _y = 1 - _y / size.h;\n          }\n        }\n\n        newPos[j][k + 1] = _x;\n        newPos[j][k + 2] = _y;\n      }\n\n      polys[n].push(newPos[j].slice());\n    }\n  }\n\n  return polys;\n};\n\nfunction almostEq(a, b) {\n  return Math.abs(a - b) <= 1e-6;\n}\n\nfunction dist(a, b) {\n  var dx = b[1] - a[1];\n  var dy = b[2] - a[2];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexports.pointsOnRectangle = function (cell) {\n  var len = cell.length;\n  if (len !== 5) return false;\n\n  for (var j = 1; j < 3; j++) {\n    var e01 = cell[0][j] - cell[1][j];\n    var e32 = cell[3][j] - cell[2][j];\n    if (!almostEq(e01, e32)) return false;\n    var e03 = cell[0][j] - cell[3][j];\n    var e12 = cell[1][j] - cell[2][j];\n    if (!almostEq(e03, e12)) return false;\n  } // N.B. rotated rectangles are not valid rects since rotation is not supported in shapes for now.\n\n\n  if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false; // reject cases with zero area\n\n  return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));\n};\n\nexports.pointsOnEllipse = function (cell) {\n  var len = cell.length;\n  if (len !== CIRCLE_SIDES + 1) return false; // opposite diagonals should be the same\n\n  len = CIRCLE_SIDES;\n\n  for (var i = 0; i < len; i++) {\n    var k = (len * 2 - i) % len;\n    var k2 = (len / 2 + k) % len;\n    var i2 = (len / 2 + i) % len;\n    if (!almostEq(dist(cell[i], cell[i2]), dist(cell[k], cell[k2]))) return false;\n  }\n\n  return true;\n};\n\nexports.handleEllipse = function (isEllipse, start, end) {\n  if (!isEllipse) return [start, end]; // i.e. case of line\n\n  var pos = exports.ellipseOver({\n    x0: start[0],\n    y0: start[1],\n    x1: end[0],\n    y1: end[1]\n  });\n  var cx = (pos.x1 + pos.x0) / 2;\n  var cy = (pos.y1 + pos.y0) / 2;\n  var rx = (pos.x1 - pos.x0) / 2;\n  var ry = (pos.y1 - pos.y0) / 2; // make a circle when one dimension is zero\n\n  if (!rx) rx = ry = ry / SQRT2;\n  if (!ry) ry = rx = rx / SQRT2;\n  var cell = [];\n\n  for (var i = 0; i < CIRCLE_SIDES; i++) {\n    var t = i * 2 * Math.PI / CIRCLE_SIDES;\n    cell.push([cx + rx * Math.cos(t), cy + ry * Math.sin(t)]);\n  }\n\n  return cell;\n};\n\nexports.ellipseOver = function (pos) {\n  var x0 = pos.x0;\n  var y0 = pos.y0;\n  var x1 = pos.x1;\n  var y1 = pos.y1;\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n  x0 -= dx;\n  y0 -= dy;\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var scale = SQRT2;\n  dx *= scale;\n  dy *= scale;\n  return {\n    x0: cx - dx,\n    y0: cy - dy,\n    x1: cx + dx,\n    y1: cy + dy\n  };\n};\n\nexports.fixDatesForPaths = function (polygons, xaxis, yaxis) {\n  var xIsDate = xaxis.type === 'date';\n  var yIsDate = yaxis.type === 'date';\n  if (!xIsDate && !yIsDate) return polygons;\n\n  for (var i = 0; i < polygons.length; i++) {\n    for (var j = 0; j < polygons[i].length; j++) {\n      for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {\n        if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(' ', '_');\n        if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(' ', '_');\n      }\n    }\n  }\n\n  return polygons;\n};","map":null,"metadata":{},"sourceType":"script"}