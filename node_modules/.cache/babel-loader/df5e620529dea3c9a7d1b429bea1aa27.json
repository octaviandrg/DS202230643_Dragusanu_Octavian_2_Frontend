{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Registry = require('../../registry');\n\nvar tickText = require('../../plots/cartesian/axes').tickText;\n\nvar uniformText = require('./uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\nvar clearMinTextSize = uniformText.clearMinTextSize;\n\nvar style = require('./style');\n\nvar helpers = require('./helpers');\n\nvar constants = require('./constants');\n\nvar attributes = require('./attributes');\n\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar TEXTPAD = constants.TEXTPAD;\n\nfunction keyFunc(d) {\n  return d.id;\n}\n\nfunction getKeyFunc(trace) {\n  if (trace.ids) {\n    return keyFunc;\n  }\n}\n\nfunction dirSign(a, b) {\n  return a < b ? 1 : -1;\n}\n\nfunction getXY(di, xa, ya, isHorizontal) {\n  var s = [];\n  var p = [];\n  var sAxis = isHorizontal ? xa : ya;\n  var pAxis = isHorizontal ? ya : xa;\n  s[0] = sAxis.c2p(di.s0, true);\n  p[0] = pAxis.c2p(di.p0, true);\n  s[1] = sAxis.c2p(di.s1, true);\n  p[1] = pAxis.c2p(di.p1, true);\n  return isHorizontal ? [s, p] : [p, s];\n}\n\nfunction transition(selection, fullLayout, opts, makeOnCompleteCallback) {\n  if (!fullLayout.uniformtext.mode && hasTransition(opts)) {\n    var onComplete;\n\n    if (makeOnCompleteCallback) {\n      onComplete = makeOnCompleteCallback();\n    }\n\n    return selection.transition().duration(opts.duration).ease(opts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n  } else {\n    return selection;\n  }\n}\n\nfunction hasTransition(transitionOpts) {\n  return transitionOpts && transitionOpts.duration > 0;\n}\n\nfunction plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n\n  if (!opts) {\n    opts = {\n      mode: fullLayout.barmode,\n      norm: fullLayout.barmode,\n      gap: fullLayout.bargap,\n      groupgap: fullLayout.bargroupgap\n    }; // don't clear bar when this is called from waterfall or funnel\n\n    clearMinTextSize('bar', fullLayout);\n  }\n\n  var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var trace = cd[0].trace;\n    var isWaterfall = trace.type === 'waterfall';\n    var isFunnel = trace.type === 'funnel';\n    var isBar = trace.type === 'bar';\n    var shouldDisplayZeros = isBar || isFunnel;\n    var adjustPixel = 0;\n\n    if (isWaterfall && trace.connector.visible && trace.connector.mode === 'between') {\n      adjustPixel = trace.connector.line.width / 2;\n    }\n\n    var isHorizontal = trace.orientation === 'h';\n    var withTransition = hasTransition(opts);\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var keyFunc = getKeyFunc(trace);\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity, keyFunc);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this); // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n\n      var xy = getXY(di, xa, ya, isHorizontal);\n      var x0 = xy[0][0];\n      var x1 = xy[0][1];\n      var y0 = xy[1][0];\n      var y1 = xy[1][1]; // empty bars\n\n      var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0; // display zeros if line.width > 0\n\n      if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {\n        isBlank = false;\n      } // skip nulls\n\n\n      if (!isBlank) {\n        isBlank = !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1);\n      } // record isBlank\n\n\n      di.isBlank = isBlank; // for blank bars, ensure start and end positions are equal - important for smooth transitions\n\n      if (isBlank) {\n        if (isHorizontal) {\n          x1 = x0;\n        } else {\n          y1 = y0;\n        }\n      } // in waterfall mode `between` we need to adjust bar end points to match the connector width\n\n\n      if (adjustPixel && !isBlank) {\n        if (isHorizontal) {\n          x0 -= dirSign(x0, x1) * adjustPixel;\n          x1 += dirSign(x0, x1) * adjustPixel;\n        } else {\n          y0 -= dirSign(y0, y1) * adjustPixel;\n          y1 += dirSign(y0, y1) * adjustPixel;\n        }\n      }\n\n      var lw;\n      var mc;\n\n      if (trace.type === 'waterfall') {\n        if (!isBlank) {\n          var cont = trace[di.dir].marker;\n          lw = cont.line.width;\n          mc = cont.color;\n        }\n      } else {\n        lw = helpers.getLineWidth(trace, di);\n        mc = di.mc || trace.marker.color;\n      }\n\n      function roundWithLine(v) {\n        var offset = d3.round(lw / 2 % 1, 2); // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n\n        return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n\n      function expandToVisible(v, vc, hideZeroSpan) {\n        if (hideZeroSpan && v === vc) {\n          // should not expand zero span bars\n          // when start and end positions are identical\n          // i.e. for vertical when y0 === y1\n          // and for horizontal when x0 === x1\n          return v;\n        } // if it's not in danger of disappearing entirely,\n        // round more precisely\n\n\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) : // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n        var op = Color.opacity(mc);\n        var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n        x0 = fixpx(x0, x1, isHorizontal);\n        x1 = fixpx(x1, x0, isHorizontal);\n        y0 = fixpx(y0, y1, !isHorizontal);\n        y1 = fixpx(y1, y0, !isHorizontal);\n      }\n\n      var sel = transition(Lib.ensureSingle(bar, 'path'), fullLayout, opts, makeOnCompleteCallback);\n      sel.style('vector-effect', 'non-scaling-stroke').attr('d', isNaN((x1 - x0) * (y1 - y0)) || isBlank && gd._context.staticPlot ? 'M0,0Z' : 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z').call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n      if (!fullLayout.uniformtext.mode && withTransition) {\n        var styleFns = Drawing.makePointStyleFns(trace);\n        Drawing.singlePointStyle(di, sel, trace, styleFns, gd);\n      }\n\n      appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback);\n\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    }); // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  }); // error bars are on the top\n\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo, opts);\n}\n\nfunction appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, opts, makeOnCompleteCallback) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var textPosition;\n\n  function appendTextNode(bar, text, font) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      'class': 'bartext bartext-' + textPosition,\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  } // get trace attributes\n\n\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var text = getText(fullLayout, cd, i, xa, ya);\n  textPosition = getTextPosition(trace, i); // compute text position\n\n  var inStackOrRelativeMode = opts.mode === 'stack' || opts.mode === 'relative';\n  var calcBar = cd[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n  if (!text || textPosition === 'none' || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === 'auto' || textPosition === 'inside')) {\n    bar.select('text').remove();\n    return;\n  }\n\n  var layoutFont = fullLayout.font;\n  var barColor = style.getBarColor(cd[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont); // Special case: don't use the c2p(v, true) value on log size axes,\n  // so that we can get correctly inside text scaling\n\n  var di = bar.datum();\n\n  if (isHorizontal) {\n    if (xa.type === 'log' && di.s0 <= 0) {\n      if (xa.range[0] < xa.range[1]) {\n        x0 = 0;\n      } else {\n        x0 = xa._length;\n      }\n    }\n  } else {\n    if (ya.type === 'log' && di.s0 <= 0) {\n      if (ya.range[0] < ya.range[1]) {\n        y0 = ya._length;\n      } else {\n        y0 = 0;\n      }\n    }\n  } // padding excluded\n\n\n  var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;\n  var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n  var font;\n\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      font = Lib.ensureUniformFontSize(gd, insideTextFont);\n      textSelection = appendTextNode(bar, text, font);\n      textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n      var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n      var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n\n      if (textHasSize && (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else {\n      textPosition = 'inside';\n    }\n  }\n\n  if (!textSelection) {\n    font = Lib.ensureUniformFontSize(gd, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    textSelection = appendTextNode(bar, text, font);\n    var currentTransform = textSelection.attr('transform');\n    textSelection.attr('transform', '');\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    textSelection.attr('transform', currentTransform);\n\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  }\n\n  var angle = trace.textangle; // compute text transform\n\n  var transform, constrained;\n\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle\n    });\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: isHorizontal,\n      constrained: constrained,\n      angle: angle,\n      anchor: trace.insidetextanchor\n    });\n  }\n\n  transform.fontSize = font.size;\n  recordMinTextSize(trace.type === 'histogram' ? 'bar' : trace.type, transform, fullLayout);\n  calcBar.transform = transform;\n  var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);\n  Lib.setTransormAndDisplay(s, transform);\n}\n\nfunction getRotateFromAngle(angle) {\n  return angle === 'auto' ? 0 : angle;\n}\n\nfunction getRotatedTextSize(textBB, rotate) {\n  var a = Math.PI / 180 * rotate;\n  var absSin = Math.abs(Math.sin(a));\n  var absCos = Math.abs(Math.cos(a));\n  return {\n    x: textBB.width * absCos + textBB.height * absSin,\n    y: textBB.width * absSin + textBB.height * absCos\n  };\n}\n\nfunction toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var anchor = opts.anchor || 'end';\n  var isEnd = anchor === 'end';\n  var isStart = anchor === 'start';\n  var leftToRight = opts.leftToRight || 0; // left: -1, center: 0, right: 1\n\n  var toRight = (leftToRight + 1) / 2;\n  var toLeft = 1 - toRight;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0); // compute remaining space\n\n  var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  lx -= 2 * textpad;\n  ly -= 2 * textpad;\n  var rotate = getRotateFromAngle(angle);\n\n  if (angle === 'auto' && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {\n    rotate += 90;\n  }\n\n  var t = getRotatedTextSize(textBB, rotate);\n  var scale = 1;\n\n  if (constrained) {\n    scale = Math.min(1, lx / t.x, ly / t.y);\n  } // compute text and target positions\n\n\n  var textX = textBB.left * toLeft + textBB.right * toRight;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + TEXTPAD) * toLeft + (x1 - TEXTPAD) * toRight;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n\n  if (isStart || isEnd) {\n    var extrapad = (isHorizontal ? t.x : t.y) / 2;\n    var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);\n\n    if (isHorizontal) {\n      if (isStart) {\n        targetX = x0 + dir * textpad;\n        anchorX = -dir * extrapad;\n      } else {\n        targetX = x1 - dir * textpad;\n        anchorX = dir * extrapad;\n      }\n    } else {\n      if (isStart) {\n        targetY = y0 + dir * textpad;\n        anchorY = -dir * extrapad;\n      } else {\n        targetY = y1 - dir * textpad;\n        anchorY = dir * extrapad;\n      }\n    }\n  }\n\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {\n  var isHorizontal = !!opts.isHorizontal;\n  var constrained = !!opts.constrained;\n  var angle = opts.angle || 0;\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var lx = Math.abs(x1 - x0);\n  var ly = Math.abs(y1 - y0);\n  var textpad; // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n\n  if (isHorizontal) {\n    textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;\n  } else {\n    textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;\n  } // compute rotate and scale\n\n\n  var scale = 1;\n\n  if (constrained) {\n    scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);\n  }\n\n  var rotate = getRotateFromAngle(angle);\n  var t = getRotatedTextSize(textBB, rotate); // compute text and target positions\n\n  var extrapad = (isHorizontal ? t.x : t.y) / 2;\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetX = (x0 + x1) / 2;\n  var targetY = (y0 + y1) / 2;\n  var anchorX = 0;\n  var anchorY = 0;\n  var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);\n\n  if (isHorizontal) {\n    targetX = x1 - dir * textpad;\n    anchorX = dir * extrapad;\n  } else {\n    targetY = y1 + dir * textpad;\n    anchorY = -dir * extrapad;\n  }\n\n  return {\n    textX: textX,\n    textY: textY,\n    targetX: targetX,\n    targetY: targetY,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    scale: scale,\n    rotate: rotate\n  };\n}\n\nfunction getText(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = trace.texttemplate;\n  var value;\n\n  if (texttemplate) {\n    value = calcTexttemplate(fullLayout, cd, index, xa, ya);\n  } else if (trace.textinfo) {\n    value = calcTextinfo(cd, index, xa, ya);\n  } else {\n    value = helpers.getValue(trace.text, index);\n  }\n\n  return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n\nfunction calcTexttemplate(fullLayout, cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var texttemplate = Lib.castOption(trace, index, 'texttemplate');\n  if (!texttemplate) return '';\n  var isHistogram = trace.type === 'histogram';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n  var isHorizontal = trace.orientation === 'h';\n  var pLetter, pAxis;\n  var vLetter, vAxis;\n\n  if (isHorizontal) {\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n\n  function formatLabel(u) {\n    return tickText(pAxis, pAxis.c2l(u), true).text;\n  }\n\n  function formatNumber(v) {\n    return tickText(vAxis, vAxis.c2l(v), true).text;\n  }\n\n  var cdi = cd[index];\n  var obj = {};\n  obj.label = cdi.p;\n  obj.labelLabel = obj[pLetter + 'Label'] = formatLabel(cdi.p);\n  var tx = Lib.castOption(trace, cdi.i, 'text');\n  if (tx === 0 || tx) obj.text = tx;\n  obj.value = cdi.s;\n  obj.valueLabel = obj[vLetter + 'Label'] = formatNumber(cdi.s);\n  var pt = {};\n  appendArrayPointValue(pt, trace, cdi.i);\n  if (isHistogram || pt.x === undefined) pt.x = isHorizontal ? obj.value : obj.label;\n  if (isHistogram || pt.y === undefined) pt.y = isHorizontal ? obj.label : obj.value;\n  if (isHistogram || pt.xLabel === undefined) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;\n  if (isHistogram || pt.yLabel === undefined) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;\n\n  if (isWaterfall) {\n    obj.delta = +cdi.rawS || cdi.s;\n    obj.deltaLabel = formatNumber(obj.delta);\n    obj.final = cdi.v;\n    obj.finalLabel = formatNumber(obj.final);\n    obj.initial = obj.final - obj.delta;\n    obj.initialLabel = formatNumber(obj.initial);\n  }\n\n  if (isFunnel) {\n    obj.value = cdi.s;\n    obj.valueLabel = formatNumber(obj.value);\n    obj.percentInitial = cdi.begR;\n    obj.percentInitialLabel = Lib.formatPercent(cdi.begR);\n    obj.percentPrevious = cdi.difR;\n    obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);\n    obj.percentTotal = cdi.sumR;\n    obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);\n  }\n\n  var customdata = Lib.castOption(trace, cdi.i, 'customdata');\n  if (customdata) obj.customdata = customdata;\n  return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});\n}\n\nfunction calcTextinfo(cd, index, xa, ya) {\n  var trace = cd[0].trace;\n  var isHorizontal = trace.orientation === 'h';\n  var isWaterfall = trace.type === 'waterfall';\n  var isFunnel = trace.type === 'funnel';\n\n  function formatLabel(u) {\n    var pAxis = isHorizontal ? ya : xa;\n    return tickText(pAxis, u, true).text;\n  }\n\n  function formatNumber(v) {\n    var sAxis = isHorizontal ? xa : ya;\n    return tickText(sAxis, +v, true).text;\n  }\n\n  var textinfo = trace.textinfo;\n  var cdi = cd[index];\n  var parts = textinfo.split('+');\n  var text = [];\n  var tx;\n\n  var hasFlag = function hasFlag(flag) {\n    return parts.indexOf(flag) !== -1;\n  };\n\n  if (hasFlag('label')) {\n    text.push(formatLabel(cd[index].p));\n  }\n\n  if (hasFlag('text')) {\n    tx = Lib.castOption(trace, cdi.i, 'text');\n    if (tx === 0 || tx) text.push(tx);\n  }\n\n  if (isWaterfall) {\n    var delta = +cdi.rawS || cdi.s;\n    var final = cdi.v;\n    var initial = final - delta;\n    if (hasFlag('initial')) text.push(formatNumber(initial));\n    if (hasFlag('delta')) text.push(formatNumber(delta));\n    if (hasFlag('final')) text.push(formatNumber(final));\n  }\n\n  if (isFunnel) {\n    if (hasFlag('value')) text.push(formatNumber(cdi.s));\n    var nPercent = 0;\n    if (hasFlag('percent initial')) nPercent++;\n    if (hasFlag('percent previous')) nPercent++;\n    if (hasFlag('percent total')) nPercent++;\n    var hasMultiplePercents = nPercent > 1;\n\n    if (hasFlag('percent initial')) {\n      tx = Lib.formatPercent(cdi.begR);\n      if (hasMultiplePercents) tx += ' of initial';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent previous')) {\n      tx = Lib.formatPercent(cdi.difR);\n      if (hasMultiplePercents) tx += ' of previous';\n      text.push(tx);\n    }\n\n    if (hasFlag('percent total')) {\n      tx = Lib.formatPercent(cdi.sumR);\n      if (hasMultiplePercents) tx += ' of total';\n      text.push(tx);\n    }\n  }\n\n  return text.join('<br>');\n}\n\nmodule.exports = {\n  plot: plot,\n  toMoveInsideBar: toMoveInsideBar\n};","map":null,"metadata":{},"sourceType":"script"}