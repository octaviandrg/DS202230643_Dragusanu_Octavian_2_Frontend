{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar traceIs = require('../../registry').traceIs;\n\nvar handleGroupingDefaults = require('../bar/defaults').handleGroupingDefaults;\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar BINATTRS = [{\n  aStr: {\n    x: 'xbins.start',\n    y: 'ybins.start'\n  },\n  name: 'start'\n}, {\n  aStr: {\n    x: 'xbins.end',\n    y: 'ybins.end'\n  },\n  name: 'end'\n}, {\n  aStr: {\n    x: 'xbins.size',\n    y: 'ybins.size'\n  },\n  name: 'size'\n}, {\n  aStr: {\n    x: 'nbinsx',\n    y: 'nbinsy'\n  },\n  name: 'nbins'\n}];\nvar BINDIRECTIONS = ['x', 'y']; // handle bin attrs and relink auto-determined values so fullData is complete\n\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n  var allBinOpts = fullLayout._histogramBinOpts = {};\n  var histTraces = [];\n  var mustMatchTracesLookup = {};\n  var otherTracesList = [];\n  var traceOut, traces, groupName, binDir;\n  var i, j, k;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr, dflt);\n  }\n\n  function orientation2binDir(traceOut) {\n    return traceOut.orientation === 'v' ? 'x' : 'y';\n  }\n\n  function getAxisType(traceOut, binDir) {\n    var ax = axisIds.getFromTrace({\n      _fullLayout: fullLayout\n    }, traceOut, binDir);\n    return ax.type;\n  }\n\n  function fillBinOpts(traceOut, groupName, binDir) {\n    // N.B. group traces that don't have a bingroup with themselves\n    var fallbackGroupName = traceOut.uid + '__' + binDir;\n    if (!groupName) groupName = fallbackGroupName;\n    var axType = getAxisType(traceOut, binDir);\n    var calendar = traceOut[binDir + 'calendar'] || '';\n    var binOpts = allBinOpts[groupName];\n    var needsNewItem = true;\n\n    if (binOpts) {\n      if (axType === binOpts.axType && calendar === binOpts.calendar) {\n        needsNewItem = false;\n        binOpts.traces.push(traceOut);\n        binOpts.dirs.push(binDir);\n      } else {\n        groupName = fallbackGroupName;\n\n        if (axType !== binOpts.axType) {\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set on a', 'type:' + axType, 'axis', 'with bins on', 'type:' + binOpts.axType, 'axis.'].join(' '));\n        }\n\n        if (calendar !== binOpts.calendar) {\n          // prohibit bingroup for traces using different calendar,\n          // there's probably a way to make this work, but skip for now\n          Lib.warn(['Attempted to group the bins of trace', traceOut.index, 'set with a', calendar, 'calendar', 'with bins', binOpts.calendar ? 'on a ' + binOpts.calendar + ' calendar' : 'w/o a set calendar'].join(' '));\n        }\n      }\n    }\n\n    if (needsNewItem) {\n      allBinOpts[groupName] = {\n        traces: [traceOut],\n        dirs: [binDir],\n        axType: axType,\n        calendar: traceOut[binDir + 'calendar'] || ''\n      };\n    }\n\n    traceOut['_' + binDir + 'bingroup'] = groupName;\n  }\n\n  for (i = 0; i < fullData.length; i++) {\n    traceOut = fullData[i];\n\n    if (traceIs(traceOut, 'histogram')) {\n      histTraces.push(traceOut); // TODO: this shouldn't be relinked as it's only used within calc\n      // https://github.com/plotly/plotly.js/issues/749\n\n      delete traceOut._xautoBinFinished;\n      delete traceOut._yautoBinFinished; // N.B. need to coerce *alignmentgroup* before *bingroup*, as traces\n      // in same alignmentgroup \"have to match\"\n\n      if (!traceIs(traceOut, '2dMap')) {\n        handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce);\n      }\n    }\n  }\n\n  var alignmentOpts = fullLayout._alignmentOpts || {}; // Look for traces that \"have to match\", that is:\n  // - 1d histogram traces on the same subplot with same orientation under barmode:stack,\n  // - 1d histogram traces on the same subplot with same orientation under barmode:group\n  // - 1d histogram traces on the same position axis with the same orientation\n  //   and the same *alignmentgroup* (coerced under barmode:group)\n  // - Once `stackgroup` gets implemented (see https://github.com/plotly/plotly.js/issues/3614),\n  //   traces within the same stackgroup will also \"have to match\"\n\n  for (i = 0; i < histTraces.length; i++) {\n    traceOut = histTraces[i];\n    groupName = '';\n\n    if (!traceIs(traceOut, '2dMap')) {\n      binDir = orientation2binDir(traceOut);\n\n      if (fullLayout.barmode === 'group' && traceOut.alignmentgroup) {\n        var pa = traceOut[binDir + 'axis'];\n        var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;\n\n        if ((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {\n          groupName = aGroupId;\n        }\n      }\n\n      if (!groupName && fullLayout.barmode !== 'overlay') {\n        groupName = getAxisGroup(fullLayout, traceOut.xaxis) + getAxisGroup(fullLayout, traceOut.yaxis) + orientation2binDir(traceOut);\n      }\n    }\n\n    if (groupName) {\n      if (!mustMatchTracesLookup[groupName]) {\n        mustMatchTracesLookup[groupName] = [];\n      }\n\n      mustMatchTracesLookup[groupName].push(traceOut);\n    } else {\n      otherTracesList.push(traceOut);\n    }\n  } // Setup binOpts for traces that have to match,\n  // if the traces have a valid bingroup, use that\n  // if not use axis+binDir groupName\n\n\n  for (groupName in mustMatchTracesLookup) {\n    traces = mustMatchTracesLookup[groupName]; // no need to 'force' anything when a single\n    // trace is detected as \"must match\"\n\n    if (traces.length === 1) {\n      otherTracesList.push(traces[0]);\n      continue;\n    }\n\n    var binGroupFound = false;\n\n    if (traces.length) {\n      traceOut = traces[0];\n      binGroupFound = coerce('bingroup');\n    }\n\n    groupName = binGroupFound || groupName;\n\n    for (i = 0; i < traces.length; i++) {\n      traceOut = traces[i];\n      var bingroupIn = traceOut._input.bingroup;\n\n      if (bingroupIn && bingroupIn !== groupName) {\n        Lib.warn(['Trace', traceOut.index, 'must match', 'within bingroup', groupName + '.', 'Ignoring its bingroup:', bingroupIn, 'setting.'].join(' '));\n      }\n\n      traceOut.bingroup = groupName; // N.B. no need to worry about 2dMap case\n      // (where both bin direction are set in each trace)\n      // as 2dMap trace never \"have to match\"\n\n      fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));\n    }\n  } // setup binOpts for traces that can but don't have to match,\n  // notice that these traces can be matched with traces that have to match\n\n\n  for (i = 0; i < otherTracesList.length; i++) {\n    traceOut = otherTracesList[i];\n    var binGroup = coerce('bingroup');\n\n    if (traceIs(traceOut, '2dMap')) {\n      for (k = 0; k < 2; k++) {\n        binDir = BINDIRECTIONS[k];\n        var binGroupInDir = coerce(binDir + 'bingroup', binGroup ? binGroup + '__' + binDir : null);\n        fillBinOpts(traceOut, binGroupInDir, binDir);\n      }\n    } else {\n      fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));\n    }\n  } // coerce bin attrs!\n\n\n  for (groupName in allBinOpts) {\n    var binOpts = allBinOpts[groupName];\n    traces = binOpts.traces;\n\n    for (j = 0; j < BINATTRS.length; j++) {\n      var attrSpec = BINATTRS[j];\n      var attr = attrSpec.name;\n      var aStr;\n      var autoVals; // nbins(x|y) is moot if we have a size. This depends on\n      // nbins coming after size in binAttrs.\n\n      if (attr === 'nbins' && binOpts.sizeFound) continue;\n\n      for (i = 0; i < traces.length; i++) {\n        traceOut = traces[i];\n        binDir = binOpts.dirs[i];\n        aStr = attrSpec.aStr[binDir];\n\n        if (nestedProperty(traceOut._input, aStr).get() !== undefined) {\n          binOpts[attr] = coerce(aStr);\n          binOpts[attr + 'Found'] = true;\n          break;\n        }\n\n        autoVals = (traceOut._autoBin || {})[binDir] || {};\n\n        if (autoVals[attr]) {\n          // if this is the *first* autoval\n          nestedProperty(traceOut, aStr).set(autoVals[attr]);\n        }\n      } // start and end we need to coerce anyway, after having collected the\n      // first of each into binOpts, in case a trace wants to restrict its\n      // data to a certain range\n\n\n      if (attr === 'start' || attr === 'end') {\n        for (; i < traces.length; i++) {\n          traceOut = traces[i];\n\n          if (traceOut['_' + binDir + 'bingroup']) {\n            autoVals = (traceOut._autoBin || {})[binDir] || {};\n            coerce(aStr, autoVals[attr]);\n          }\n        }\n      }\n\n      if (attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n        traceOut = traces[0];\n        binOpts[attr] = coerce(aStr);\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}