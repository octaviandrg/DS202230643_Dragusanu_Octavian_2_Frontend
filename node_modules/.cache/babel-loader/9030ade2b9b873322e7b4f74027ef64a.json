{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar _ = Lib._;\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar alignPeriod = require('../../plots/cartesian/align_period');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var tickLen = convertTickWidth(gd, xa, trace);\n  var minDiff = trace._minDiff;\n  trace._minDiff = null;\n  var origX = trace._origX;\n  trace._origX = null;\n  var x = trace._xcalc;\n  trace._xcalc = null;\n  var cd = calcCommon(gd, trace, origX, x, ya, ptFunc);\n  trace._extremes[xa._id] = Axes.findExtremes(xa, x, {\n    vpad: minDiff / 2\n  });\n\n  if (cd.length) {\n    Lib.extendFlat(cd[0].t, {\n      wHover: minDiff / 2,\n      tickLen: tickLen\n    });\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}\n\nfunction ptFunc(o, h, l, c) {\n  return {\n    o: o,\n    h: h,\n    l: l,\n    c: c\n  };\n} // shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\n\n\nfunction calcCommon(gd, trace, origX, x, ya, ptFunc) {\n  var o = ya.makeCalcdata(trace, 'open');\n  var h = ya.makeCalcdata(trace, 'high');\n  var l = ya.makeCalcdata(trace, 'low');\n  var c = ya.makeCalcdata(trace, 'close');\n  var hasTextArray = Array.isArray(trace.text);\n  var hasHovertextArray = Array.isArray(trace.hovertext); // we're optimists - before we have any changing data, assume increasing\n\n  var increasing = true;\n  var cPrev = null;\n  var hasPeriod = !!trace.xperiodalignment;\n  var cd = [];\n\n  for (var i = 0; i < x.length; i++) {\n    var xi = x[i];\n    var oi = o[i];\n    var hi = h[i];\n    var li = l[i];\n    var ci = c[i];\n\n    if (xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n      if (ci === oi) {\n        // if open == close, look for a change from the previous close\n        if (cPrev !== null && ci !== cPrev) increasing = ci > cPrev; // else (c === cPrev or cPrev is null) no change\n      } else increasing = ci > oi;\n\n      cPrev = ci;\n      var pt = ptFunc(oi, hi, li, ci);\n      pt.pos = xi;\n      pt.yc = (oi + ci) / 2;\n      pt.i = i;\n      pt.dir = increasing ? 'increasing' : 'decreasing'; // For categoryorder, store low and high\n\n      pt.x = pt.pos;\n      pt.y = [li, hi];\n      if (hasPeriod) pt.orig_p = origX[i]; // used by hover\n\n      if (hasTextArray) pt.tx = trace.text[i];\n      if (hasHovertextArray) pt.htx = trace.hovertext[i];\n      cd.push(pt);\n    } else {\n      cd.push({\n        pos: xi,\n        empty: true\n      });\n    }\n  }\n\n  trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {\n    padded: true\n  });\n\n  if (cd.length) {\n    cd[0].t = {\n      labels: {\n        open: _(gd, 'open:') + ' ',\n        high: _(gd, 'high:') + ' ',\n        low: _(gd, 'low:') + ' ',\n        close: _(gd, 'close:') + ' '\n      }\n    };\n  }\n\n  return cd;\n}\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc (and _origX) on the trace\n */\n\n\nfunction convertTickWidth(gd, xa, trace) {\n  var minDiff = trace._minDiff;\n\n  if (!minDiff) {\n    var fullData = gd._fullData;\n    var ohlcTracesOnThisXaxis = [];\n    minDiff = Infinity;\n    var i;\n\n    for (i = 0; i < fullData.length; i++) {\n      var tracei = fullData[i];\n\n      if (tracei.type === 'ohlc' && tracei.visible === true && tracei.xaxis === xa._id) {\n        ohlcTracesOnThisXaxis.push(tracei);\n        var origX = xa.makeCalcdata(tracei, 'x');\n        tracei._origX = origX;\n        var xcalc = alignPeriod(trace, xa, 'x', origX).vals;\n        tracei._xcalc = xcalc;\n        var _minDiff = Lib.distinctVals(xcalc).minDiff;\n\n        if (_minDiff && isFinite(_minDiff)) {\n          minDiff = Math.min(minDiff, _minDiff);\n        }\n      }\n    } // if minDiff is still Infinity here, set it to 1\n\n\n    if (minDiff === Infinity) minDiff = 1;\n\n    for (i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n      ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n    }\n  }\n\n  return minDiff * trace.tickwidth;\n}\n\nmodule.exports = {\n  calc: calc,\n  calcCommon: calcCommon\n};","map":null,"metadata":{},"sourceType":"script"}