{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar handleSubplotDefaults = require('../subplot_defaults');\n\nvar getSubplotData = require('../get_data').getSubplotData;\n\nvar handleTickValueDefaults = require('../cartesian/tick_value_defaults');\n\nvar handleTickMarkDefaults = require('../cartesian/tick_mark_defaults');\n\nvar handleTickLabelDefaults = require('../cartesian/tick_label_defaults');\n\nvar handlePrefixSuffixDefaults = require('../cartesian/prefix_suffix_defaults');\n\nvar handleCategoryOrderDefaults = require('../cartesian/category_order_defaults');\n\nvar handleLineGridDefaults = require('../cartesian/line_grid_defaults');\n\nvar autoType = require('../cartesian/axis_autotype');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar setConvert = require('./set_convert');\n\nvar constants = require('./constants');\n\nvar axisNames = constants.axisNames;\n\nfunction handleDefaults(contIn, contOut, coerce, opts) {\n  var bgColor = coerce('bgcolor');\n  opts.bgColor = Color.combine(bgColor, opts.paper_bgcolor);\n  var sector = coerce('sector');\n  coerce('hole'); // could optimize, subplotData is not always needed!\n\n  var subplotData = getSubplotData(opts.fullData, constants.name, opts.id);\n  var layoutOut = opts.layoutOut;\n  var axName;\n\n  function coerceAxis(attr, dflt) {\n    return coerce(axName + '.' + attr, dflt);\n  }\n\n  for (var i = 0; i < axisNames.length; i++) {\n    axName = axisNames[i];\n\n    if (!Lib.isPlainObject(contIn[axName])) {\n      contIn[axName] = {};\n    }\n\n    var axIn = contIn[axName];\n    var axOut = Template.newContainer(contOut, axName);\n    axOut._id = axOut._name = axName;\n    axOut._attr = opts.id + '.' + axName;\n    axOut._traceIndices = subplotData.map(function (t) {\n      return t._expandedIndex;\n    });\n    var dataAttr = constants.axisName2dataArray[axName];\n    var axType = handleAxisTypeDefaults(axIn, axOut, coerceAxis, subplotData, dataAttr, opts);\n    handleCategoryOrderDefaults(axIn, axOut, coerceAxis, {\n      axData: subplotData,\n      dataAttr: dataAttr\n    });\n    var visible = coerceAxis('visible');\n    setConvert(axOut, contOut, layoutOut);\n    coerceAxis('uirevision', contOut.uirevision); // We don't want to make downstream code call ax.setScale,\n    // as both radial and angular axes don't have a set domain.\n    // Furthermore, angular axes don't have a set range.\n    //\n    // Mocked domains and ranges are set by the polar subplot instances,\n    // but Axes.findExtremes uses the sign of _m to determine which padding value\n    // to use.\n    //\n    // By setting, _m to 1 here, we make Axes.findExtremes think that\n    // range[1] > range[0], and vice-versa for `autorange: 'reversed'` below.\n\n    axOut._m = 1;\n\n    switch (axName) {\n      case 'radialaxis':\n        var autoRange = coerceAxis('autorange', !axOut.isValidRange(axIn.range));\n        axIn.autorange = autoRange;\n        if (autoRange && (axType === 'linear' || axType === '-')) coerceAxis('rangemode');\n        if (autoRange === 'reversed') axOut._m = -1;\n        coerceAxis('range');\n        axOut.cleanRange('range', {\n          dfltRange: [0, 1]\n        });\n        break;\n\n      case 'angularaxis':\n        // We do not support 'true' date angular axes yet,\n        // users can still plot dates on angular axes by setting\n        // `angularaxis.type: 'category'`.\n        //\n        // Here, if a date angular axes is detected, we make\n        // all its corresponding traces invisible, so that\n        // when we do add support for data angular axes, the new\n        // behavior won't conflict with existing behavior\n        if (axType === 'date') {\n          Lib.log('Polar plots do not support date angular axes yet.');\n\n          for (var j = 0; j < subplotData.length; j++) {\n            subplotData[j].visible = false;\n          } // turn this into a 'dummy' linear axis so that\n          // the subplot still renders ok\n\n\n          axType = axIn.type = axOut.type = 'linear';\n        }\n\n        if (axType === 'linear') {\n          coerceAxis('thetaunit');\n        } else {\n          coerceAxis('period');\n        }\n\n        var direction = coerceAxis('direction');\n        coerceAxis('rotation', {\n          counterclockwise: 0,\n          clockwise: 90\n        }[direction]);\n        break;\n    }\n\n    handlePrefixSuffixDefaults(axIn, axOut, coerceAxis, axOut.type, {\n      tickSuffixDflt: axOut.thetaunit === 'degrees' ? 'Â°' : undefined\n    });\n\n    if (visible) {\n      var dfltColor;\n      var dfltFontColor;\n      var dfltFontSize;\n      var dfltFontFamily;\n      var font = opts.font || {};\n      dfltColor = coerceAxis('color');\n      dfltFontColor = dfltColor === axIn.color ? dfltColor : font.color;\n      dfltFontSize = font.size;\n      dfltFontFamily = font.family;\n      handleTickValueDefaults(axIn, axOut, coerceAxis, axOut.type);\n      handleTickLabelDefaults(axIn, axOut, coerceAxis, axOut.type, {\n        font: {\n          color: dfltFontColor,\n          size: dfltFontSize,\n          family: dfltFontFamily\n        }\n      });\n      handleTickMarkDefaults(axIn, axOut, coerceAxis, {\n        outerTicks: true\n      });\n      handleLineGridDefaults(axIn, axOut, coerceAxis, {\n        dfltColor: dfltColor,\n        bgColor: opts.bgColor,\n        // default grid color is darker here (60%, vs cartesian default ~91%)\n        // because the grid is not square so the eye needs heavier cues to follow\n        blend: 60,\n        showLine: true,\n        showGrid: true,\n        noZeroLine: true,\n        attributes: layoutAttributes[axName]\n      });\n      coerceAxis('layer');\n\n      if (axName === 'radialaxis') {\n        coerceAxis('side');\n        coerceAxis('angle', sector[0]);\n        coerceAxis('title.text');\n        Lib.coerceFont(coerceAxis, 'title.font', {\n          color: dfltFontColor,\n          size: Lib.bigFont(dfltFontSize),\n          family: dfltFontFamily\n        });\n      }\n    }\n\n    if (axType !== 'category') coerceAxis('hoverformat');\n    axOut._input = axIn;\n  }\n\n  if (contOut.angularaxis.type === 'category') {\n    coerce('gridshape');\n  }\n}\n\nfunction handleAxisTypeDefaults(axIn, axOut, coerce, subplotData, dataAttr, options) {\n  var autotypenumbers = coerce('autotypenumbers', options.autotypenumbersDflt);\n  var axType = coerce('type');\n\n  if (axType === '-') {\n    var trace;\n\n    for (var i = 0; i < subplotData.length; i++) {\n      if (subplotData[i].visible) {\n        trace = subplotData[i];\n        break;\n      }\n    }\n\n    if (trace && trace[dataAttr]) {\n      axOut.type = autoType(trace[dataAttr], 'gregorian', {\n        noMultiCategory: true,\n        autotypenumbers: autotypenumbers\n      });\n    }\n\n    if (axOut.type === '-') {\n      axOut.type = 'linear';\n    } else {\n      // copy autoType back to input axis\n      // note that if this object didn't exist\n      // in the input layout, we have to put it in\n      // this happens in the main supplyDefaults function\n      axIn.type = axOut.type;\n    }\n  }\n\n  return axOut.type;\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: constants.name,\n    attributes: layoutAttributes,\n    handleDefaults: handleDefaults,\n    font: layoutOut.font,\n    autotypenumbersDflt: layoutOut.autotypenumbers,\n    paper_bgcolor: layoutOut.paper_bgcolor,\n    fullData: fullData,\n    layoutOut: layoutOut\n  });\n};","map":null,"metadata":{},"sourceType":"script"}