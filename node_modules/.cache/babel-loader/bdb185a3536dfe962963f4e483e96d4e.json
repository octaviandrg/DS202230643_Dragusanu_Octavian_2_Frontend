{"ast":null,"code":"'use strict';\n\nmodule.exports = calcSDF;\nvar INF = 1e20;\n\nfunction calcSDF(src, options) {\n  if (!options) options = {};\n  var cutoff = options.cutoff == null ? 0.25 : options.cutoff;\n  var radius = options.radius == null ? 8 : options.radius;\n  var channel = options.channel || 0;\n  var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l; // handle image container\n\n  if (ArrayBuffer.isView(src) || Array.isArray(src)) {\n    if (!options.width || !options.height) throw Error('For raw data width and height should be provided by options');\n    w = options.width, h = options.height;\n    data = src;\n    if (!options.stride) stride = Math.floor(src.length / w / h);else stride = options.stride;\n  } else {\n    if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {\n      canvas = src;\n      ctx = canvas.getContext('2d');\n      w = canvas.width, h = canvas.height;\n      imgData = ctx.getImageData(0, 0, w, h);\n      data = imgData.data;\n      stride = 4;\n    } else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {\n      canvas = src.canvas;\n      ctx = src;\n      w = canvas.width, h = canvas.height;\n      imgData = ctx.getImageData(0, 0, w, h);\n      data = imgData.data;\n      stride = 4;\n    } else if (window.ImageData && src instanceof window.ImageData) {\n      imgData = src;\n      w = src.width, h = src.height;\n      data = imgData.data;\n      stride = 4;\n    }\n  }\n\n  size = Math.max(w, h); //convert int data to floats\n\n  if (window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray || window.Uint8Array && data instanceof window.Uint8Array) {\n    intData = data;\n    data = Array(w * h);\n\n    for (i = 0, l = Math.floor(intData.length / stride); i < l; i++) {\n      data[i] = intData[i * stride + channel] / 255;\n    }\n  } else {\n    if (stride !== 1) throw Error('Raw data can have only 1 value per pixel');\n  } // temporary arrays for the distance transform\n\n\n  var gridOuter = Array(w * h);\n  var gridInner = Array(w * h);\n  var f = Array(size);\n  var d = Array(size);\n  var z = Array(size + 1);\n  var v = Array(size);\n\n  for (i = 0, l = w * h; i < l; i++) {\n    var a = data[i];\n    gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);\n    gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);\n  }\n\n  edt(gridOuter, w, h, f, d, v, z);\n  edt(gridInner, w, h, f, d, v, z);\n  var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h);\n\n  for (i = 0, l = w * h; i < l; i++) {\n    dist[i] = Math.min(Math.max(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0), 1);\n  }\n\n  return dist;\n} // 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/\n\n\nfunction edt(data, width, height, f, d, v, z) {\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      f[y] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, height);\n\n    for (y = 0; y < height; y++) {\n      data[y * width + x] = d[y];\n    }\n  }\n\n  for (y = 0; y < height; y++) {\n    for (x = 0; x < width; x++) {\n      f[x] = data[y * width + x];\n    }\n\n    edt1d(f, d, v, z, width);\n\n    for (x = 0; x < width; x++) {\n      data[y * width + x] = Math.sqrt(d[x]);\n    }\n  }\n} // 1D squared distance transform\n\n\nfunction edt1d(f, d, v, z, n) {\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = +INF;\n\n  for (var q = 1, k = 0; q < n; q++) {\n    var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n\n    while (s <= z[k]) {\n      k--;\n      s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);\n    }\n\n    k++;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = +INF;\n  }\n\n  for (q = 0, k = 0; q < n; q++) {\n    while (z[k + 1] < q) {\n      k++;\n    }\n\n    d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}