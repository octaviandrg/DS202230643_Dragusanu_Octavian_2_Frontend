{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../../lib');\n\nvar Color = require('../../../components/color');\n\nvar Registry = require('../../../registry');\n\nvar handleSubplotDefaults = require('../../subplot_defaults');\n\nvar supplyGl3dAxisLayoutDefaults = require('./axis_defaults');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar getSubplotData = require('../../get_data').getSubplotData;\n\nvar GL3D = 'gl3d';\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var hasNon3D = layoutOut._basePlotModules.length > 1; // some layout-wide attribute are used in all scenes\n  // if 3D is the only visible plot type\n\n  function getDfltFromLayout(attr) {\n    if (hasNon3D) return;\n    var isValid = Lib.validate(layoutIn[attr], layoutAttributes[attr]);\n    if (isValid) return layoutIn[attr];\n  }\n\n  handleSubplotDefaults(layoutIn, layoutOut, fullData, {\n    type: GL3D,\n    attributes: layoutAttributes,\n    handleDefaults: handleGl3dDefaults,\n    fullLayout: layoutOut,\n    font: layoutOut.font,\n    fullData: fullData,\n    getDfltFromLayout: getDfltFromLayout,\n    autotypenumbersDflt: layoutOut.autotypenumbers,\n    paper_bgcolor: layoutOut.paper_bgcolor,\n    calendar: layoutOut.calendar\n  });\n};\n\nfunction handleGl3dDefaults(sceneLayoutIn, sceneLayoutOut, coerce, opts) {\n  /*\n   * Scene numbering proceeds as follows\n   * scene\n   * scene2\n   * scene3\n   *\n   * and d.scene will be undefined or some number or number string\n   *\n   * Also write back a blank scene object to user layout so that some\n   * attributes like aspectratio can be written back dynamically.\n   */\n  var bgcolor = coerce('bgcolor');\n  var bgColorCombined = Color.combine(bgcolor, opts.paper_bgcolor);\n  var cameraKeys = ['up', 'center', 'eye'];\n\n  for (var j = 0; j < cameraKeys.length; j++) {\n    coerce('camera.' + cameraKeys[j] + '.x');\n    coerce('camera.' + cameraKeys[j] + '.y');\n    coerce('camera.' + cameraKeys[j] + '.z');\n  }\n\n  coerce('camera.projection.type');\n  /*\n   * coerce to positive number (min 0) but also do not accept 0 (>0 not >=0)\n   * note that 0's go false with the !! call\n   */\n\n  var hasAspect = !!coerce('aspectratio.x') && !!coerce('aspectratio.y') && !!coerce('aspectratio.z');\n  var defaultAspectMode = hasAspect ? 'manual' : 'auto';\n  var aspectMode = coerce('aspectmode', defaultAspectMode);\n  /*\n   * We need aspectratio object in all the Layouts as it is dynamically set\n   * in the calculation steps, ie, we cant set the correct data now, it happens later.\n   * We must also account for the case the user sends bad ratio data with 'manual' set\n   * for the mode. In this case we must force change it here as the default coerce\n   * misses it above.\n   */\n\n  if (!hasAspect) {\n    sceneLayoutIn.aspectratio = sceneLayoutOut.aspectratio = {\n      x: 1,\n      y: 1,\n      z: 1\n    };\n    if (aspectMode === 'manual') sceneLayoutOut.aspectmode = 'auto';\n    /*\n     * kind of like autorange - we need the calculated aspectmode back in\n     * the input layout or relayout can cause problems later\n     */\n\n    sceneLayoutIn.aspectmode = sceneLayoutOut.aspectmode;\n  }\n\n  var fullGl3dData = getSubplotData(opts.fullData, GL3D, opts.id);\n  supplyGl3dAxisLayoutDefaults(sceneLayoutIn, sceneLayoutOut, {\n    font: opts.font,\n    scene: opts.id,\n    data: fullGl3dData,\n    bgColor: bgColorCombined,\n    calendar: opts.calendar,\n    autotypenumbersDflt: opts.autotypenumbersDflt,\n    fullLayout: opts.fullLayout\n  });\n  Registry.getComponentMethod('annotations3d', 'handleDefaults')(sceneLayoutIn, sceneLayoutOut, opts);\n  var dragmode = opts.getDfltFromLayout('dragmode');\n\n  if (dragmode !== false) {\n    if (!dragmode) {\n      dragmode = 'orbit';\n\n      if (sceneLayoutIn.camera && sceneLayoutIn.camera.up) {\n        var x = sceneLayoutIn.camera.up.x;\n        var y = sceneLayoutIn.camera.up.y;\n        var z = sceneLayoutIn.camera.up.z;\n\n        if (z !== 0) {\n          if (!x || !y || !z) {\n            dragmode = 'turntable';\n          } else if (z / Math.sqrt(x * x + y * y + z * z) > 0.999) {\n            dragmode = 'turntable';\n          }\n        }\n      } else {\n        dragmode = 'turntable';\n      }\n    }\n  }\n\n  coerce('dragmode', dragmode);\n  coerce('hovermode', opts.getDfltFromLayout('hovermode'));\n}","map":null,"metadata":{},"sourceType":"script"}