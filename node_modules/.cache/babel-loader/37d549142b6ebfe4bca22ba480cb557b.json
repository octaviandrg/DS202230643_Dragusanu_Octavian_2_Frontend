{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.createREGL = factory();\n})(this, function () {\n  'use strict';\n\n  var extend = function extend(base, opts) {\n    var keys = Object.keys(opts);\n\n    for (var i = 0; i < keys.length; ++i) {\n      base[keys[i]] = opts[keys[i]];\n    }\n\n    return base;\n  };\n\n  var VARIABLE_COUNTER = 0;\n  var DYN_FUNC = 0;\n  var DYN_CONSTANT = 5;\n  var DYN_ARRAY = 6;\n\n  function DynamicVariable(type, data) {\n    this.id = VARIABLE_COUNTER++;\n    this.type = type;\n    this.data = data;\n  }\n\n  function escapeStr(str) {\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"');\n  }\n\n  function splitParts(str) {\n    if (str.length === 0) {\n      return [];\n    }\n\n    var firstChar = str.charAt(0);\n    var lastChar = str.charAt(str.length - 1);\n\n    if (str.length > 1 && firstChar === lastChar && (firstChar === '\"' || firstChar === \"'\")) {\n      return ['\"' + escapeStr(str.substr(1, str.length - 2)) + '\"'];\n    }\n\n    var parts = /\\[(false|true|null|\\d+|'[^']*'|\"[^\"]*\")\\]/.exec(str);\n\n    if (parts) {\n      return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));\n    }\n\n    var subparts = str.split('.');\n\n    if (subparts.length === 1) {\n      return ['\"' + escapeStr(str) + '\"'];\n    }\n\n    var result = [];\n\n    for (var i = 0; i < subparts.length; ++i) {\n      result = result.concat(splitParts(subparts[i]));\n    }\n\n    return result;\n  }\n\n  function toAccessorString(str) {\n    return '[' + splitParts(str).join('][') + ']';\n  }\n\n  function defineDynamic(type, data) {\n    return new DynamicVariable(type, toAccessorString(data + ''));\n  }\n\n  function isDynamic(x) {\n    return typeof x === 'function' && !x._reglType || x instanceof DynamicVariable;\n  }\n\n  function unbox(x, path) {\n    if (typeof x === 'function') {\n      return new DynamicVariable(DYN_FUNC, x);\n    } else if (typeof x === 'number' || typeof x === 'boolean') {\n      return new DynamicVariable(DYN_CONSTANT, x);\n    } else if (Array.isArray(x)) {\n      return new DynamicVariable(DYN_ARRAY, x.map(function (y, i) {\n        return unbox(y, path + '[' + i + ']');\n      }));\n    } else if (x instanceof DynamicVariable) {\n      return x;\n    }\n  }\n\n  var dynamic = {\n    DynamicVariable: DynamicVariable,\n    define: defineDynamic,\n    isDynamic: isDynamic,\n    unbox: unbox,\n    accessor: toAccessorString\n  };\n  /* globals requestAnimationFrame, cancelAnimationFrame */\n\n  var raf = {\n    next: typeof requestAnimationFrame === 'function' ? function (cb) {\n      return requestAnimationFrame(cb);\n    } : function (cb) {\n      return setTimeout(cb, 16);\n    },\n    cancel: typeof cancelAnimationFrame === 'function' ? function (raf) {\n      return cancelAnimationFrame(raf);\n    } : clearTimeout\n  };\n  /* globals performance */\n\n  var clock = typeof performance !== 'undefined' && performance.now ? function () {\n    return performance.now();\n  } : function () {\n    return +new Date();\n  };\n\n  function createStringStore() {\n    var stringIds = {\n      '': 0\n    };\n    var stringValues = [''];\n    return {\n      id: function id(str) {\n        var result = stringIds[str];\n\n        if (result) {\n          return result;\n        }\n\n        result = stringIds[str] = stringValues.length;\n        stringValues.push(str);\n        return result;\n      },\n      str: function str(id) {\n        return stringValues[id];\n      }\n    };\n  } // Context and canvas creation helper functions\n\n\n  function createCanvas(element, onDone, pixelRatio) {\n    var canvas = document.createElement('canvas');\n    extend(canvas.style, {\n      border: 0,\n      margin: 0,\n      padding: 0,\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%'\n    });\n    element.appendChild(canvas);\n\n    if (element === document.body) {\n      canvas.style.position = 'absolute';\n      extend(element.style, {\n        margin: 0,\n        padding: 0\n      });\n    }\n\n    function resize() {\n      var w = window.innerWidth;\n      var h = window.innerHeight;\n\n      if (element !== document.body) {\n        var bounds = canvas.getBoundingClientRect();\n        w = bounds.right - bounds.left;\n        h = bounds.bottom - bounds.top;\n      }\n\n      canvas.width = pixelRatio * w;\n      canvas.height = pixelRatio * h;\n    }\n\n    var resizeObserver;\n\n    if (element !== document.body && typeof ResizeObserver === 'function') {\n      // ignore 'ResizeObserver' is not defined\n      // eslint-disable-next-line\n      resizeObserver = new ResizeObserver(function () {\n        // setTimeout to avoid flicker\n        setTimeout(resize);\n      });\n      resizeObserver.observe(element);\n    } else {\n      window.addEventListener('resize', resize, false);\n    }\n\n    function onDestroy() {\n      if (resizeObserver) {\n        resizeObserver.disconnect();\n      } else {\n        window.removeEventListener('resize', resize);\n      }\n\n      element.removeChild(canvas);\n    }\n\n    resize();\n    return {\n      canvas: canvas,\n      onDestroy: onDestroy\n    };\n  }\n\n  function createContext(canvas, contextAttributes) {\n    function get(name) {\n      try {\n        return canvas.getContext(name, contextAttributes);\n      } catch (e) {\n        return null;\n      }\n    }\n\n    return get('webgl') || get('experimental-webgl') || get('webgl-experimental');\n  }\n\n  function isHTMLElement(obj) {\n    return typeof obj.nodeName === 'string' && typeof obj.appendChild === 'function' && typeof obj.getBoundingClientRect === 'function';\n  }\n\n  function isWebGLContext(obj) {\n    return typeof obj.drawArrays === 'function' || typeof obj.drawElements === 'function';\n  }\n\n  function parseExtensions(input) {\n    if (typeof input === 'string') {\n      return input.split();\n    }\n\n    return input;\n  }\n\n  function getElement(desc) {\n    if (typeof desc === 'string') {\n      return document.querySelector(desc);\n    }\n\n    return desc;\n  }\n\n  function parseArgs(args_) {\n    var args = args_ || {};\n    var element, container, canvas, gl;\n    var contextAttributes = {};\n    var extensions = [];\n    var optionalExtensions = [];\n    var pixelRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio;\n    var profile = false;\n    var cachedCode = {};\n\n    var onDone = function onDone(err) {\n      if (err) {}\n    };\n\n    var onDestroy = function onDestroy() {};\n\n    if (typeof args === 'string') {\n      element = document.querySelector(args);\n    } else if (typeof args === 'object') {\n      if (isHTMLElement(args)) {\n        element = args;\n      } else if (isWebGLContext(args)) {\n        gl = args;\n        canvas = gl.canvas;\n      } else {\n        if ('gl' in args) {\n          gl = args.gl;\n        } else if ('canvas' in args) {\n          canvas = getElement(args.canvas);\n        } else if ('container' in args) {\n          container = getElement(args.container);\n        }\n\n        if ('attributes' in args) {\n          contextAttributes = args.attributes;\n        }\n\n        if ('extensions' in args) {\n          extensions = parseExtensions(args.extensions);\n        }\n\n        if ('optionalExtensions' in args) {\n          optionalExtensions = parseExtensions(args.optionalExtensions);\n        }\n\n        if ('onDone' in args) {\n          onDone = args.onDone;\n        }\n\n        if ('profile' in args) {\n          profile = !!args.profile;\n        }\n\n        if ('pixelRatio' in args) {\n          pixelRatio = +args.pixelRatio;\n        }\n\n        if ('cachedCode' in args) {\n          cachedCode = args.cachedCode;\n        }\n      }\n    } else {}\n\n    if (element) {\n      if (element.nodeName.toLowerCase() === 'canvas') {\n        canvas = element;\n      } else {\n        container = element;\n      }\n    }\n\n    if (!gl) {\n      if (!canvas) {\n        var result = createCanvas(container || document.body, onDone, pixelRatio);\n\n        if (!result) {\n          return null;\n        }\n\n        canvas = result.canvas;\n        onDestroy = result.onDestroy;\n      } // workaround for chromium bug, premultiplied alpha value is platform dependent\n\n\n      if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true;\n      gl = createContext(canvas, contextAttributes);\n    }\n\n    if (!gl) {\n      onDestroy();\n      onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');\n      return null;\n    }\n\n    return {\n      gl: gl,\n      canvas: canvas,\n      container: container,\n      extensions: extensions,\n      optionalExtensions: optionalExtensions,\n      pixelRatio: pixelRatio,\n      profile: profile,\n      cachedCode: cachedCode,\n      onDone: onDone,\n      onDestroy: onDestroy\n    };\n  }\n\n  function createExtensionCache(gl, config) {\n    var extensions = {};\n\n    function tryLoadExtension(name_) {\n      var name = name_.toLowerCase();\n      var ext;\n\n      try {\n        ext = extensions[name] = gl.getExtension(name);\n      } catch (e) {}\n\n      return !!ext;\n    }\n\n    for (var i = 0; i < config.extensions.length; ++i) {\n      var name = config.extensions[i];\n\n      if (!tryLoadExtension(name)) {\n        config.onDestroy();\n        config.onDone('\"' + name + '\" extension is not supported by the current WebGL context, try upgrading your system or a different browser');\n        return null;\n      }\n    }\n\n    config.optionalExtensions.forEach(tryLoadExtension);\n    return {\n      extensions: extensions,\n      restore: function restore() {\n        Object.keys(extensions).forEach(function (name) {\n          if (extensions[name] && !tryLoadExtension(name)) {\n            throw new Error('(regl): error restoring extension ' + name);\n          }\n        });\n      }\n    };\n  }\n\n  function loop(n, f) {\n    var result = Array(n);\n\n    for (var i = 0; i < n; ++i) {\n      result[i] = f(i);\n    }\n\n    return result;\n  }\n\n  var GL_BYTE = 5120;\n  var GL_UNSIGNED_BYTE$1 = 5121;\n  var GL_SHORT = 5122;\n  var GL_UNSIGNED_SHORT = 5123;\n  var GL_INT = 5124;\n  var GL_UNSIGNED_INT = 5125;\n  var GL_FLOAT$1 = 5126;\n\n  function nextPow16(v) {\n    for (var i = 16; i <= 1 << 28; i *= 16) {\n      if (v <= i) {\n        return i;\n      }\n    }\n\n    return 0;\n  }\n\n  function log2(v) {\n    var r, shift;\n    r = (v > 0xFFFF) << 4;\n    v >>>= r;\n    shift = (v > 0xFF) << 3;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 0xF) << 2;\n    v >>>= shift;\n    r |= shift;\n    shift = (v > 0x3) << 1;\n    v >>>= shift;\n    r |= shift;\n    return r | v >> 1;\n  }\n\n  function createPool() {\n    var bufferPool = loop(8, function () {\n      return [];\n    });\n\n    function alloc(n) {\n      var sz = nextPow16(n);\n      var bin = bufferPool[log2(sz) >> 2];\n\n      if (bin.length > 0) {\n        return bin.pop();\n      }\n\n      return new ArrayBuffer(sz);\n    }\n\n    function free(buf) {\n      bufferPool[log2(buf.byteLength) >> 2].push(buf);\n    }\n\n    function allocType(type, n) {\n      var result = null;\n\n      switch (type) {\n        case GL_BYTE:\n          result = new Int8Array(alloc(n), 0, n);\n          break;\n\n        case GL_UNSIGNED_BYTE$1:\n          result = new Uint8Array(alloc(n), 0, n);\n          break;\n\n        case GL_SHORT:\n          result = new Int16Array(alloc(2 * n), 0, n);\n          break;\n\n        case GL_UNSIGNED_SHORT:\n          result = new Uint16Array(alloc(2 * n), 0, n);\n          break;\n\n        case GL_INT:\n          result = new Int32Array(alloc(4 * n), 0, n);\n          break;\n\n        case GL_UNSIGNED_INT:\n          result = new Uint32Array(alloc(4 * n), 0, n);\n          break;\n\n        case GL_FLOAT$1:\n          result = new Float32Array(alloc(4 * n), 0, n);\n          break;\n\n        default:\n          return null;\n      }\n\n      if (result.length !== n) {\n        return result.subarray(0, n);\n      }\n\n      return result;\n    }\n\n    function freeType(array) {\n      free(array.buffer);\n    }\n\n    return {\n      alloc: alloc,\n      free: free,\n      allocType: allocType,\n      freeType: freeType\n    };\n  }\n\n  var pool = createPool(); // zero pool for initial zero data\n\n  pool.zero = createPool();\n  var GL_SUBPIXEL_BITS = 0x0D50;\n  var GL_RED_BITS = 0x0D52;\n  var GL_GREEN_BITS = 0x0D53;\n  var GL_BLUE_BITS = 0x0D54;\n  var GL_ALPHA_BITS = 0x0D55;\n  var GL_DEPTH_BITS = 0x0D56;\n  var GL_STENCIL_BITS = 0x0D57;\n  var GL_ALIASED_POINT_SIZE_RANGE = 0x846D;\n  var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;\n  var GL_MAX_TEXTURE_SIZE = 0x0D33;\n  var GL_MAX_VIEWPORT_DIMS = 0x0D3A;\n  var GL_MAX_VERTEX_ATTRIBS = 0x8869;\n  var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;\n  var GL_MAX_VARYING_VECTORS = 0x8DFC;\n  var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\n  var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;\n  var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;\n  var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;\n  var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\n  var GL_MAX_RENDERBUFFER_SIZE = 0x84E8;\n  var GL_VENDOR = 0x1F00;\n  var GL_RENDERER = 0x1F01;\n  var GL_VERSION = 0x1F02;\n  var GL_SHADING_LANGUAGE_VERSION = 0x8B8C;\n  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n  var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;\n  var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;\n  var GL_TEXTURE_2D = 0x0DE1;\n  var GL_TEXTURE_CUBE_MAP = 0x8513;\n  var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\n  var GL_TEXTURE0 = 0x84C0;\n  var GL_RGBA = 0x1908;\n  var GL_FLOAT = 0x1406;\n  var GL_UNSIGNED_BYTE = 0x1401;\n  var GL_FRAMEBUFFER = 0x8D40;\n  var GL_FRAMEBUFFER_COMPLETE = 0x8CD5;\n  var GL_COLOR_ATTACHMENT0 = 0x8CE0;\n  var GL_COLOR_BUFFER_BIT$1 = 0x4000;\n\n  var wrapLimits = function wrapLimits(gl, extensions) {\n    var maxAnisotropic = 1;\n\n    if (extensions.ext_texture_filter_anisotropic) {\n      maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    }\n\n    var maxDrawbuffers = 1;\n    var maxColorAttachments = 1;\n\n    if (extensions.webgl_draw_buffers) {\n      maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);\n      maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);\n    } // detect if reading float textures is available (Safari doesn't support)\n\n\n    var readFloat = !!extensions.oes_texture_float;\n\n    if (readFloat) {\n      var readFloatTexture = gl.createTexture();\n      gl.bindTexture(GL_TEXTURE_2D, readFloatTexture);\n      gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT, null);\n      var fbo = gl.createFramebuffer();\n      gl.bindFramebuffer(GL_FRAMEBUFFER, fbo);\n      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);\n      gl.bindTexture(GL_TEXTURE_2D, null);\n      if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;else {\n        gl.viewport(0, 0, 1, 1);\n        gl.clearColor(1.0, 0.0, 0.0, 1.0);\n        gl.clear(GL_COLOR_BUFFER_BIT$1);\n        var pixels = pool.allocType(GL_FLOAT, 4);\n        gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT, pixels);\n        if (gl.getError()) readFloat = false;else {\n          gl.deleteFramebuffer(fbo);\n          gl.deleteTexture(readFloatTexture);\n          readFloat = pixels[0] === 1.0;\n        }\n        pool.freeType(pixels);\n      }\n    } // detect non power of two cube textures support (IE doesn't support)\n\n\n    var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));\n    var npotTextureCube = true;\n\n    if (!isIE) {\n      var cubeTexture = gl.createTexture();\n      var data = pool.allocType(GL_UNSIGNED_BYTE, 36);\n      gl.activeTexture(GL_TEXTURE0);\n      gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);\n      gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n      pool.freeType(data);\n      gl.bindTexture(GL_TEXTURE_CUBE_MAP, null);\n      gl.deleteTexture(cubeTexture);\n      npotTextureCube = !gl.getError();\n    }\n\n    return {\n      // drawing buffer bit depth\n      colorBits: [gl.getParameter(GL_RED_BITS), gl.getParameter(GL_GREEN_BITS), gl.getParameter(GL_BLUE_BITS), gl.getParameter(GL_ALPHA_BITS)],\n      depthBits: gl.getParameter(GL_DEPTH_BITS),\n      stencilBits: gl.getParameter(GL_STENCIL_BITS),\n      subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),\n      // supported extensions\n      extensions: Object.keys(extensions).filter(function (ext) {\n        return !!extensions[ext];\n      }),\n      // max aniso samples\n      maxAnisotropic: maxAnisotropic,\n      // max draw buffers\n      maxDrawbuffers: maxDrawbuffers,\n      maxColorAttachments: maxColorAttachments,\n      // point and line size ranges\n      pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),\n      lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),\n      maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),\n      maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),\n      maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),\n      maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),\n      maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),\n      maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),\n      maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),\n      maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),\n      maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),\n      maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),\n      maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),\n      // vendor info\n      glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),\n      renderer: gl.getParameter(GL_RENDERER),\n      vendor: gl.getParameter(GL_VENDOR),\n      version: gl.getParameter(GL_VERSION),\n      // quirks\n      readFloat: readFloat,\n      npotTextureCube: npotTextureCube\n    };\n  };\n\n  var isTypedArray = function isTypedArray(x) {\n    return x instanceof Uint8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Uint8ClampedArray;\n  };\n\n  function isNDArrayLike(obj) {\n    return !!obj && typeof obj === 'object' && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === 'number' && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));\n  }\n\n  var values = function values(obj) {\n    return Object.keys(obj).map(function (key) {\n      return obj[key];\n    });\n  };\n\n  var flattenUtils = {\n    shape: arrayShape$1,\n    flatten: flattenArray\n  };\n\n  function flatten1D(array, nx, out) {\n    for (var i = 0; i < nx; ++i) {\n      out[i] = array[i];\n    }\n  }\n\n  function flatten2D(array, nx, ny, out) {\n    var ptr = 0;\n\n    for (var i = 0; i < nx; ++i) {\n      var row = array[i];\n\n      for (var j = 0; j < ny; ++j) {\n        out[ptr++] = row[j];\n      }\n    }\n  }\n\n  function flatten3D(array, nx, ny, nz, out, ptr_) {\n    var ptr = ptr_;\n\n    for (var i = 0; i < nx; ++i) {\n      var row = array[i];\n\n      for (var j = 0; j < ny; ++j) {\n        var col = row[j];\n\n        for (var k = 0; k < nz; ++k) {\n          out[ptr++] = col[k];\n        }\n      }\n    }\n  }\n\n  function flattenRec(array, shape, level, out, ptr) {\n    var stride = 1;\n\n    for (var i = level + 1; i < shape.length; ++i) {\n      stride *= shape[i];\n    }\n\n    var n = shape[level];\n\n    if (shape.length - level === 4) {\n      var nx = shape[level + 1];\n      var ny = shape[level + 2];\n      var nz = shape[level + 3];\n\n      for (i = 0; i < n; ++i) {\n        flatten3D(array[i], nx, ny, nz, out, ptr);\n        ptr += stride;\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        flattenRec(array[i], shape, level + 1, out, ptr);\n        ptr += stride;\n      }\n    }\n  }\n\n  function flattenArray(array, shape, type, out_) {\n    var sz = 1;\n\n    if (shape.length) {\n      for (var i = 0; i < shape.length; ++i) {\n        sz *= shape[i];\n      }\n    } else {\n      sz = 0;\n    }\n\n    var out = out_ || pool.allocType(type, sz);\n\n    switch (shape.length) {\n      case 0:\n        break;\n\n      case 1:\n        flatten1D(array, shape[0], out);\n        break;\n\n      case 2:\n        flatten2D(array, shape[0], shape[1], out);\n        break;\n\n      case 3:\n        flatten3D(array, shape[0], shape[1], shape[2], out, 0);\n        break;\n\n      default:\n        flattenRec(array, shape, 0, out, 0);\n    }\n\n    return out;\n  }\n\n  function arrayShape$1(array_) {\n    var shape = [];\n\n    for (var array = array_; array.length; array = array[0]) {\n      shape.push(array.length);\n    }\n\n    return shape;\n  }\n\n  var arrayTypes = {\n    \"[object Int8Array]\": 5120,\n    \"[object Int16Array]\": 5122,\n    \"[object Int32Array]\": 5124,\n    \"[object Uint8Array]\": 5121,\n    \"[object Uint8ClampedArray]\": 5121,\n    \"[object Uint16Array]\": 5123,\n    \"[object Uint32Array]\": 5125,\n    \"[object Float32Array]\": 5126,\n    \"[object Float64Array]\": 5121,\n    \"[object ArrayBuffer]\": 5121\n  };\n  var int8 = 5120;\n  var int16 = 5122;\n  var int32 = 5124;\n  var uint8 = 5121;\n  var uint16 = 5123;\n  var uint32 = 5125;\n  var float = 5126;\n  var float32 = 5126;\n  var glTypes = {\n    int8: int8,\n    int16: int16,\n    int32: int32,\n    uint8: uint8,\n    uint16: uint16,\n    uint32: uint32,\n    float: float,\n    float32: float32\n  };\n  var dynamic$1 = 35048;\n  var stream = 35040;\n  var usageTypes = {\n    dynamic: dynamic$1,\n    stream: stream,\n    \"static\": 35044\n  };\n  var arrayFlatten = flattenUtils.flatten;\n  var arrayShape = flattenUtils.shape;\n  var GL_STATIC_DRAW = 0x88E4;\n  var GL_STREAM_DRAW = 0x88E0;\n  var GL_UNSIGNED_BYTE$2 = 5121;\n  var GL_FLOAT$2 = 5126;\n  var DTYPES_SIZES = [];\n  DTYPES_SIZES[5120] = 1; // int8\n\n  DTYPES_SIZES[5122] = 2; // int16\n\n  DTYPES_SIZES[5124] = 4; // int32\n\n  DTYPES_SIZES[5121] = 1; // uint8\n\n  DTYPES_SIZES[5123] = 2; // uint16\n\n  DTYPES_SIZES[5125] = 4; // uint32\n\n  DTYPES_SIZES[5126] = 4; // float32\n\n  function typedArrayCode(data) {\n    return arrayTypes[Object.prototype.toString.call(data)] | 0;\n  }\n\n  function copyArray(out, inp) {\n    for (var i = 0; i < inp.length; ++i) {\n      out[i] = inp[i];\n    }\n  }\n\n  function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {\n    var ptr = 0;\n\n    for (var i = 0; i < shapeX; ++i) {\n      for (var j = 0; j < shapeY; ++j) {\n        result[ptr++] = data[strideX * i + strideY * j + offset];\n      }\n    }\n  }\n\n  function wrapBufferState(gl, stats, config, destroyBuffer) {\n    var bufferCount = 0;\n    var bufferSet = {};\n\n    function REGLBuffer(type) {\n      this.id = bufferCount++;\n      this.buffer = gl.createBuffer();\n      this.type = type;\n      this.usage = GL_STATIC_DRAW;\n      this.byteLength = 0;\n      this.dimension = 1;\n      this.dtype = GL_UNSIGNED_BYTE$2;\n      this.persistentData = null;\n\n      if (config.profile) {\n        this.stats = {\n          size: 0\n        };\n      }\n    }\n\n    REGLBuffer.prototype.bind = function () {\n      gl.bindBuffer(this.type, this.buffer);\n    };\n\n    REGLBuffer.prototype.destroy = function () {\n      destroy(this);\n    };\n\n    var streamPool = [];\n\n    function createStream(type, data) {\n      var buffer = streamPool.pop();\n\n      if (!buffer) {\n        buffer = new REGLBuffer(type);\n      }\n\n      buffer.bind();\n      initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);\n      return buffer;\n    }\n\n    function destroyStream(stream$$1) {\n      streamPool.push(stream$$1);\n    }\n\n    function initBufferFromTypedArray(buffer, data, usage) {\n      buffer.byteLength = data.byteLength;\n      gl.bufferData(buffer.type, data, usage);\n    }\n\n    function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {\n      var shape;\n      buffer.usage = usage;\n\n      if (Array.isArray(data)) {\n        buffer.dtype = dtype || GL_FLOAT$2;\n\n        if (data.length > 0) {\n          var flatData;\n\n          if (Array.isArray(data[0])) {\n            shape = arrayShape(data);\n            var dim = 1;\n\n            for (var i = 1; i < shape.length; ++i) {\n              dim *= shape[i];\n            }\n\n            buffer.dimension = dim;\n            flatData = arrayFlatten(data, shape, buffer.dtype);\n            initBufferFromTypedArray(buffer, flatData, usage);\n\n            if (persist) {\n              buffer.persistentData = flatData;\n            } else {\n              pool.freeType(flatData);\n            }\n          } else if (typeof data[0] === 'number') {\n            buffer.dimension = dimension;\n            var typedData = pool.allocType(buffer.dtype, data.length);\n            copyArray(typedData, data);\n            initBufferFromTypedArray(buffer, typedData, usage);\n\n            if (persist) {\n              buffer.persistentData = typedData;\n            } else {\n              pool.freeType(typedData);\n            }\n          } else if (isTypedArray(data[0])) {\n            buffer.dimension = data[0].length;\n            buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$2;\n            flatData = arrayFlatten(data, [data.length, data[0].length], buffer.dtype);\n            initBufferFromTypedArray(buffer, flatData, usage);\n\n            if (persist) {\n              buffer.persistentData = flatData;\n            } else {\n              pool.freeType(flatData);\n            }\n          } else {}\n        }\n      } else if (isTypedArray(data)) {\n        buffer.dtype = dtype || typedArrayCode(data);\n        buffer.dimension = dimension;\n        initBufferFromTypedArray(buffer, data, usage);\n\n        if (persist) {\n          buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));\n        }\n      } else if (isNDArrayLike(data)) {\n        shape = data.shape;\n        var stride = data.stride;\n        var offset = data.offset;\n        var shapeX = 0;\n        var shapeY = 0;\n        var strideX = 0;\n        var strideY = 0;\n\n        if (shape.length === 1) {\n          shapeX = shape[0];\n          shapeY = 1;\n          strideX = stride[0];\n          strideY = 0;\n        } else if (shape.length === 2) {\n          shapeX = shape[0];\n          shapeY = shape[1];\n          strideX = stride[0];\n          strideY = stride[1];\n        } else {}\n\n        buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$2;\n        buffer.dimension = shapeY;\n        var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);\n        transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, offset);\n        initBufferFromTypedArray(buffer, transposeData, usage);\n\n        if (persist) {\n          buffer.persistentData = transposeData;\n        } else {\n          pool.freeType(transposeData);\n        }\n      } else if (data instanceof ArrayBuffer) {\n        buffer.dtype = GL_UNSIGNED_BYTE$2;\n        buffer.dimension = dimension;\n        initBufferFromTypedArray(buffer, data, usage);\n\n        if (persist) {\n          buffer.persistentData = new Uint8Array(new Uint8Array(data));\n        }\n      } else {}\n    }\n\n    function destroy(buffer) {\n      stats.bufferCount--; // remove attribute link\n\n      destroyBuffer(buffer);\n      var handle = buffer.buffer;\n      gl.deleteBuffer(handle);\n      buffer.buffer = null;\n      delete bufferSet[buffer.id];\n    }\n\n    function createBuffer(options, type, deferInit, persistent) {\n      stats.bufferCount++;\n      var buffer = new REGLBuffer(type);\n      bufferSet[buffer.id] = buffer;\n\n      function reglBuffer(options) {\n        var usage = GL_STATIC_DRAW;\n        var data = null;\n        var byteLength = 0;\n        var dtype = 0;\n        var dimension = 1;\n\n        if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options) || options instanceof ArrayBuffer) {\n          data = options;\n        } else if (typeof options === 'number') {\n          byteLength = options | 0;\n        } else if (options) {\n          if ('data' in options) {\n            data = options.data;\n          }\n\n          if ('usage' in options) {\n            usage = usageTypes[options.usage];\n          }\n\n          if ('type' in options) {\n            dtype = glTypes[options.type];\n          }\n\n          if ('dimension' in options) {\n            dimension = options.dimension | 0;\n          }\n\n          if ('length' in options) {\n            byteLength = options.length | 0;\n          }\n        }\n\n        buffer.bind();\n\n        if (!data) {\n          // #475\n          if (byteLength) gl.bufferData(buffer.type, byteLength, usage);\n          buffer.dtype = dtype || GL_UNSIGNED_BYTE$2;\n          buffer.usage = usage;\n          buffer.dimension = dimension;\n          buffer.byteLength = byteLength;\n        } else {\n          initBufferFromData(buffer, data, usage, dtype, dimension, persistent);\n        }\n\n        if (config.profile) {\n          buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];\n        }\n\n        return reglBuffer;\n      }\n\n      function setSubData(data, offset) {\n        gl.bufferSubData(buffer.type, offset, data);\n      }\n\n      function subdata(data, offset_) {\n        var offset = (offset_ || 0) | 0;\n        var shape;\n        buffer.bind();\n\n        if (isTypedArray(data) || data instanceof ArrayBuffer) {\n          setSubData(data, offset);\n        } else if (Array.isArray(data)) {\n          if (data.length > 0) {\n            if (typeof data[0] === 'number') {\n              var converted = pool.allocType(buffer.dtype, data.length);\n              copyArray(converted, data);\n              setSubData(converted, offset);\n              pool.freeType(converted);\n            } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {\n              shape = arrayShape(data);\n              var flatData = arrayFlatten(data, shape, buffer.dtype);\n              setSubData(flatData, offset);\n              pool.freeType(flatData);\n            } else {}\n          }\n        } else if (isNDArrayLike(data)) {\n          shape = data.shape;\n          var stride = data.stride;\n          var shapeX = 0;\n          var shapeY = 0;\n          var strideX = 0;\n          var strideY = 0;\n\n          if (shape.length === 1) {\n            shapeX = shape[0];\n            shapeY = 1;\n            strideX = stride[0];\n            strideY = 0;\n          } else if (shape.length === 2) {\n            shapeX = shape[0];\n            shapeY = shape[1];\n            strideX = stride[0];\n            strideY = stride[1];\n          } else {}\n\n          var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);\n          var transposeData = pool.allocType(dtype, shapeX * shapeY);\n          transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, data.offset);\n          setSubData(transposeData, offset);\n          pool.freeType(transposeData);\n        } else {}\n\n        return reglBuffer;\n      }\n\n      if (!deferInit) {\n        reglBuffer(options);\n      }\n\n      reglBuffer._reglType = 'buffer';\n      reglBuffer._buffer = buffer;\n      reglBuffer.subdata = subdata;\n\n      if (config.profile) {\n        reglBuffer.stats = buffer.stats;\n      }\n\n      reglBuffer.destroy = function () {\n        destroy(buffer);\n      };\n\n      return reglBuffer;\n    }\n\n    function restoreBuffers() {\n      values(bufferSet).forEach(function (buffer) {\n        buffer.buffer = gl.createBuffer();\n        gl.bindBuffer(buffer.type, buffer.buffer);\n        gl.bufferData(buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);\n      });\n    }\n\n    if (config.profile) {\n      stats.getTotalBufferSize = function () {\n        var total = 0; // TODO: Right now, the streams are not part of the total count.\n\n        Object.keys(bufferSet).forEach(function (key) {\n          total += bufferSet[key].stats.size;\n        });\n        return total;\n      };\n    }\n\n    return {\n      create: createBuffer,\n      createStream: createStream,\n      destroyStream: destroyStream,\n      clear: function clear() {\n        values(bufferSet).forEach(destroy);\n        streamPool.forEach(destroy);\n      },\n      getBuffer: function getBuffer(wrapper) {\n        if (wrapper && wrapper._buffer instanceof REGLBuffer) {\n          return wrapper._buffer;\n        }\n\n        return null;\n      },\n      restore: restoreBuffers,\n      _initBuffer: initBufferFromData\n    };\n  }\n\n  var points = 0;\n  var point = 0;\n  var lines = 1;\n  var line = 1;\n  var triangles = 4;\n  var triangle = 4;\n  var primTypes = {\n    points: points,\n    point: point,\n    lines: lines,\n    line: line,\n    triangles: triangles,\n    triangle: triangle,\n    \"line loop\": 2,\n    \"line strip\": 3,\n    \"triangle strip\": 5,\n    \"triangle fan\": 6\n  };\n  var GL_POINTS = 0;\n  var GL_LINES = 1;\n  var GL_TRIANGLES = 4;\n  var GL_BYTE$1 = 5120;\n  var GL_UNSIGNED_BYTE$3 = 5121;\n  var GL_SHORT$1 = 5122;\n  var GL_UNSIGNED_SHORT$1 = 5123;\n  var GL_INT$1 = 5124;\n  var GL_UNSIGNED_INT$1 = 5125;\n  var GL_ELEMENT_ARRAY_BUFFER = 34963;\n  var GL_STREAM_DRAW$1 = 0x88E0;\n  var GL_STATIC_DRAW$1 = 0x88E4;\n\n  function wrapElementsState(gl, extensions, bufferState, stats) {\n    var elementSet = {};\n    var elementCount = 0;\n    var elementTypes = {\n      'uint8': GL_UNSIGNED_BYTE$3,\n      'uint16': GL_UNSIGNED_SHORT$1\n    };\n\n    if (extensions.oes_element_index_uint) {\n      elementTypes.uint32 = GL_UNSIGNED_INT$1;\n    }\n\n    function REGLElementBuffer(buffer) {\n      this.id = elementCount++;\n      elementSet[this.id] = this;\n      this.buffer = buffer;\n      this.primType = GL_TRIANGLES;\n      this.vertCount = 0;\n      this.type = 0;\n    }\n\n    REGLElementBuffer.prototype.bind = function () {\n      this.buffer.bind();\n    };\n\n    var bufferPool = [];\n\n    function createElementStream(data) {\n      var result = bufferPool.pop();\n\n      if (!result) {\n        result = new REGLElementBuffer(bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true, false)._buffer);\n      }\n\n      initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);\n      return result;\n    }\n\n    function destroyElementStream(elements) {\n      bufferPool.push(elements);\n    }\n\n    function initElements(elements, data, usage, prim, count, byteLength, type) {\n      elements.buffer.bind();\n      var dtype;\n\n      if (data) {\n        var predictedType = type;\n\n        if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {\n          predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$1 : GL_UNSIGNED_SHORT$1;\n        }\n\n        bufferState._initBuffer(elements.buffer, data, usage, predictedType, 3);\n      } else {\n        gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);\n        elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;\n        elements.buffer.usage = usage;\n        elements.buffer.dimension = 3;\n        elements.buffer.byteLength = byteLength;\n      }\n\n      dtype = type;\n\n      if (!type) {\n        switch (elements.buffer.dtype) {\n          case GL_UNSIGNED_BYTE$3:\n          case GL_BYTE$1:\n            dtype = GL_UNSIGNED_BYTE$3;\n            break;\n\n          case GL_UNSIGNED_SHORT$1:\n          case GL_SHORT$1:\n            dtype = GL_UNSIGNED_SHORT$1;\n            break;\n\n          case GL_UNSIGNED_INT$1:\n          case GL_INT$1:\n            dtype = GL_UNSIGNED_INT$1;\n            break;\n\n          default:\n        }\n\n        elements.buffer.dtype = dtype;\n      }\n\n      elements.type = dtype; // Check oes_element_index_uint extension\n      // try to guess default primitive type and arguments\n\n      var vertCount = count;\n\n      if (vertCount < 0) {\n        vertCount = elements.buffer.byteLength;\n\n        if (dtype === GL_UNSIGNED_SHORT$1) {\n          vertCount >>= 1;\n        } else if (dtype === GL_UNSIGNED_INT$1) {\n          vertCount >>= 2;\n        }\n      }\n\n      elements.vertCount = vertCount; // try to guess primitive type from cell dimension\n\n      var primType = prim;\n\n      if (prim < 0) {\n        primType = GL_TRIANGLES;\n        var dimension = elements.buffer.dimension;\n        if (dimension === 1) primType = GL_POINTS;\n        if (dimension === 2) primType = GL_LINES;\n        if (dimension === 3) primType = GL_TRIANGLES;\n      }\n\n      elements.primType = primType;\n    }\n\n    function destroyElements(elements) {\n      stats.elementsCount--;\n      delete elementSet[elements.id];\n      elements.buffer.destroy();\n      elements.buffer = null;\n    }\n\n    function createElements(options, persistent) {\n      var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);\n      var elements = new REGLElementBuffer(buffer._buffer);\n      stats.elementsCount++;\n\n      function reglElements(options) {\n        if (!options) {\n          buffer();\n          elements.primType = GL_TRIANGLES;\n          elements.vertCount = 0;\n          elements.type = GL_UNSIGNED_BYTE$3;\n        } else if (typeof options === 'number') {\n          buffer(options);\n          elements.primType = GL_TRIANGLES;\n          elements.vertCount = options | 0;\n          elements.type = GL_UNSIGNED_BYTE$3;\n        } else {\n          var data = null;\n          var usage = GL_STATIC_DRAW$1;\n          var primType = -1;\n          var vertCount = -1;\n          var byteLength = 0;\n          var dtype = 0;\n\n          if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {\n            data = options;\n          } else {\n            if ('data' in options) {\n              data = options.data;\n            }\n\n            if ('usage' in options) {\n              usage = usageTypes[options.usage];\n            }\n\n            if ('primitive' in options) {\n              primType = primTypes[options.primitive];\n            }\n\n            if ('count' in options) {\n              vertCount = options.count | 0;\n            }\n\n            if ('type' in options) {\n              dtype = elementTypes[options.type];\n            }\n\n            if ('length' in options) {\n              byteLength = options.length | 0;\n            } else {\n              byteLength = vertCount;\n\n              if (dtype === GL_UNSIGNED_SHORT$1 || dtype === GL_SHORT$1) {\n                byteLength *= 2;\n              } else if (dtype === GL_UNSIGNED_INT$1 || dtype === GL_INT$1) {\n                byteLength *= 4;\n              }\n            }\n          }\n\n          initElements(elements, data, usage, primType, vertCount, byteLength, dtype);\n        }\n\n        return reglElements;\n      }\n\n      reglElements(options);\n      reglElements._reglType = 'elements';\n      reglElements._elements = elements;\n\n      reglElements.subdata = function (data, offset) {\n        buffer.subdata(data, offset);\n        return reglElements;\n      };\n\n      reglElements.destroy = function () {\n        destroyElements(elements);\n      };\n\n      return reglElements;\n    }\n\n    return {\n      create: createElements,\n      createStream: createElementStream,\n      destroyStream: destroyElementStream,\n      getElements: function getElements(elements) {\n        if (typeof elements === 'function' && elements._elements instanceof REGLElementBuffer) {\n          return elements._elements;\n        }\n\n        return null;\n      },\n      clear: function clear() {\n        values(elementSet).forEach(destroyElements);\n      }\n    };\n  }\n\n  var FLOAT = new Float32Array(1);\n  var INT = new Uint32Array(FLOAT.buffer);\n  var GL_UNSIGNED_SHORT$3 = 5123;\n\n  function convertToHalfFloat(array) {\n    var ushorts = pool.allocType(GL_UNSIGNED_SHORT$3, array.length);\n\n    for (var i = 0; i < array.length; ++i) {\n      if (isNaN(array[i])) {\n        ushorts[i] = 0xffff;\n      } else if (array[i] === Infinity) {\n        ushorts[i] = 0x7c00;\n      } else if (array[i] === -Infinity) {\n        ushorts[i] = 0xfc00;\n      } else {\n        FLOAT[0] = array[i];\n        var x = INT[0];\n        var sgn = x >>> 31 << 15;\n        var exp = (x << 1 >>> 24) - 127;\n        var frac = x >> 13 & (1 << 10) - 1;\n\n        if (exp < -24) {\n          // round non-representable denormals to 0\n          ushorts[i] = sgn;\n        } else if (exp < -14) {\n          // handle denormals\n          var s = -14 - exp;\n          ushorts[i] = sgn + (frac + (1 << 10) >> s);\n        } else if (exp > 15) {\n          // round overflow to +/- Infinity\n          ushorts[i] = sgn + 0x7c00;\n        } else {\n          // otherwise convert directly\n          ushorts[i] = sgn + (exp + 15 << 10) + frac;\n        }\n      }\n    }\n\n    return ushorts;\n  }\n\n  function isArrayLike(s) {\n    return Array.isArray(s) || isTypedArray(s);\n  }\n\n  var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;\n  var GL_TEXTURE_2D$1 = 0x0DE1;\n  var GL_TEXTURE_CUBE_MAP$1 = 0x8513;\n  var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;\n  var GL_RGBA$1 = 0x1908;\n  var GL_ALPHA = 0x1906;\n  var GL_RGB = 0x1907;\n  var GL_LUMINANCE = 0x1909;\n  var GL_LUMINANCE_ALPHA = 0x190A;\n  var GL_RGBA4 = 0x8056;\n  var GL_RGB5_A1 = 0x8057;\n  var GL_RGB565 = 0x8D62;\n  var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n  var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n  var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;\n  var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;\n  var GL_DEPTH_COMPONENT = 0x1902;\n  var GL_DEPTH_STENCIL = 0x84F9;\n  var GL_SRGB_EXT = 0x8C40;\n  var GL_SRGB_ALPHA_EXT = 0x8C42;\n  var GL_HALF_FLOAT_OES = 0x8D61;\n  var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\n  var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\n  var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\n  var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n  var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\n  var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\n  var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n  var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\n  var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\n  var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\n  var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n  var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\n  var GL_UNSIGNED_BYTE$4 = 0x1401;\n  var GL_UNSIGNED_SHORT$2 = 0x1403;\n  var GL_UNSIGNED_INT$2 = 0x1405;\n  var GL_FLOAT$3 = 0x1406;\n  var GL_TEXTURE_WRAP_S = 0x2802;\n  var GL_TEXTURE_WRAP_T = 0x2803;\n  var GL_REPEAT = 0x2901;\n  var GL_CLAMP_TO_EDGE = 0x812F;\n  var GL_MIRRORED_REPEAT = 0x8370;\n  var GL_TEXTURE_MAG_FILTER = 0x2800;\n  var GL_TEXTURE_MIN_FILTER = 0x2801;\n  var GL_NEAREST = 0x2600;\n  var GL_LINEAR = 0x2601;\n  var GL_NEAREST_MIPMAP_NEAREST = 0x2700;\n  var GL_LINEAR_MIPMAP_NEAREST = 0x2701;\n  var GL_NEAREST_MIPMAP_LINEAR = 0x2702;\n  var GL_LINEAR_MIPMAP_LINEAR = 0x2703;\n  var GL_GENERATE_MIPMAP_HINT = 0x8192;\n  var GL_DONT_CARE = 0x1100;\n  var GL_FASTEST = 0x1101;\n  var GL_NICEST = 0x1102;\n  var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\n  var GL_UNPACK_ALIGNMENT = 0x0CF5;\n  var GL_UNPACK_FLIP_Y_WEBGL = 0x9240;\n  var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\n  var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\n  var GL_BROWSER_DEFAULT_WEBGL = 0x9244;\n  var GL_TEXTURE0$1 = 0x84C0;\n  var MIPMAP_FILTERS = [GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR];\n  var CHANNELS_FORMAT = [0, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA$1];\n  var FORMAT_CHANNELS = {};\n  FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;\n  FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;\n  FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;\n  FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;\n\n  function objectName(str) {\n    return '[object ' + str + ']';\n  }\n\n  var CANVAS_CLASS = objectName('HTMLCanvasElement');\n  var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas');\n  var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');\n  var BITMAP_CLASS = objectName('ImageBitmap');\n  var IMAGE_CLASS = objectName('HTMLImageElement');\n  var VIDEO_CLASS = objectName('HTMLVideoElement');\n  var PIXEL_CLASSES = Object.keys(arrayTypes).concat([CANVAS_CLASS, OFFSCREENCANVAS_CLASS, CONTEXT2D_CLASS, BITMAP_CLASS, IMAGE_CLASS, VIDEO_CLASS]); // for every texture type, store\n  // the size in bytes.\n\n  var TYPE_SIZES = [];\n  TYPE_SIZES[GL_UNSIGNED_BYTE$4] = 1;\n  TYPE_SIZES[GL_FLOAT$3] = 4;\n  TYPE_SIZES[GL_HALF_FLOAT_OES] = 2;\n  TYPE_SIZES[GL_UNSIGNED_SHORT$2] = 2;\n  TYPE_SIZES[GL_UNSIGNED_INT$2] = 4;\n  var FORMAT_SIZES_SPECIAL = [];\n  FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;\n  FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;\n  FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;\n  FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;\n  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;\n\n  function isNumericArray(arr) {\n    return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === 'number');\n  }\n\n  function isRectArray(arr) {\n    if (!Array.isArray(arr)) {\n      return false;\n    }\n\n    var width = arr.length;\n\n    if (width === 0 || !isArrayLike(arr[0])) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function classString(x) {\n    return Object.prototype.toString.call(x);\n  }\n\n  function isCanvasElement(object) {\n    return classString(object) === CANVAS_CLASS;\n  }\n\n  function isOffscreenCanvas(object) {\n    return classString(object) === OFFSCREENCANVAS_CLASS;\n  }\n\n  function isContext2D(object) {\n    return classString(object) === CONTEXT2D_CLASS;\n  }\n\n  function isBitmap(object) {\n    return classString(object) === BITMAP_CLASS;\n  }\n\n  function isImageElement(object) {\n    return classString(object) === IMAGE_CLASS;\n  }\n\n  function isVideoElement(object) {\n    return classString(object) === VIDEO_CLASS;\n  }\n\n  function isPixelData(object) {\n    if (!object) {\n      return false;\n    }\n\n    var className = classString(object);\n\n    if (PIXEL_CLASSES.indexOf(className) >= 0) {\n      return true;\n    }\n\n    return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);\n  }\n\n  function typedArrayCode$1(data) {\n    return arrayTypes[Object.prototype.toString.call(data)] | 0;\n  }\n\n  function convertData(result, data) {\n    var n = data.length;\n\n    switch (result.type) {\n      case GL_UNSIGNED_BYTE$4:\n      case GL_UNSIGNED_SHORT$2:\n      case GL_UNSIGNED_INT$2:\n      case GL_FLOAT$3:\n        var converted = pool.allocType(result.type, n);\n        converted.set(data);\n        result.data = converted;\n        break;\n\n      case GL_HALF_FLOAT_OES:\n        result.data = convertToHalfFloat(data);\n        break;\n\n      default:\n    }\n  }\n\n  function preConvert(image, n) {\n    return pool.allocType(image.type === GL_HALF_FLOAT_OES ? GL_FLOAT$3 : image.type, n);\n  }\n\n  function postConvert(image, data) {\n    if (image.type === GL_HALF_FLOAT_OES) {\n      image.data = convertToHalfFloat(data);\n      pool.freeType(data);\n    } else {\n      image.data = data;\n    }\n  }\n\n  function transposeData(image, array, strideX, strideY, strideC, offset) {\n    var w = image.width;\n    var h = image.height;\n    var c = image.channels;\n    var n = w * h * c;\n    var data = preConvert(image, n);\n    var p = 0;\n\n    for (var i = 0; i < h; ++i) {\n      for (var j = 0; j < w; ++j) {\n        for (var k = 0; k < c; ++k) {\n          data[p++] = array[strideX * j + strideY * i + strideC * k + offset];\n        }\n      }\n    }\n\n    postConvert(image, data);\n  }\n\n  function getTextureSize(format, type, width, height, isMipmap, isCube) {\n    var s;\n\n    if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {\n      // we have a special array for dealing with weird color formats such as RGB5A1\n      s = FORMAT_SIZES_SPECIAL[format];\n    } else {\n      s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];\n    }\n\n    if (isCube) {\n      s *= 6;\n    }\n\n    if (isMipmap) {\n      // compute the total size of all the mipmaps.\n      var total = 0;\n      var w = width;\n\n      while (w >= 1) {\n        // we can only use mipmaps on a square image,\n        // so we can simply use the width and ignore the height:\n        total += s * w * w;\n        w /= 2;\n      }\n\n      return total;\n    } else {\n      return s * width * height;\n    }\n  }\n\n  function createTextureSet(gl, extensions, limits, reglPoll, contextState, stats, config) {\n    // -------------------------------------------------------\n    // Initialize constants and parameter tables here\n    // -------------------------------------------------------\n    var mipmapHint = {\n      \"don't care\": GL_DONT_CARE,\n      'dont care': GL_DONT_CARE,\n      'nice': GL_NICEST,\n      'fast': GL_FASTEST\n    };\n    var wrapModes = {\n      'repeat': GL_REPEAT,\n      'clamp': GL_CLAMP_TO_EDGE,\n      'mirror': GL_MIRRORED_REPEAT\n    };\n    var magFilters = {\n      'nearest': GL_NEAREST,\n      'linear': GL_LINEAR\n    };\n    var minFilters = extend({\n      'mipmap': GL_LINEAR_MIPMAP_LINEAR,\n      'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST,\n      'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST,\n      'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR,\n      'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR\n    }, magFilters);\n    var colorSpace = {\n      'none': 0,\n      'browser': GL_BROWSER_DEFAULT_WEBGL\n    };\n    var textureTypes = {\n      'uint8': GL_UNSIGNED_BYTE$4,\n      'rgba4': GL_UNSIGNED_SHORT_4_4_4_4,\n      'rgb565': GL_UNSIGNED_SHORT_5_6_5,\n      'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1\n    };\n    var textureFormats = {\n      'alpha': GL_ALPHA,\n      'luminance': GL_LUMINANCE,\n      'luminance alpha': GL_LUMINANCE_ALPHA,\n      'rgb': GL_RGB,\n      'rgba': GL_RGBA$1,\n      'rgba4': GL_RGBA4,\n      'rgb5 a1': GL_RGB5_A1,\n      'rgb565': GL_RGB565\n    };\n    var compressedTextureFormats = {};\n\n    if (extensions.ext_srgb) {\n      textureFormats.srgb = GL_SRGB_EXT;\n      textureFormats.srgba = GL_SRGB_ALPHA_EXT;\n    }\n\n    if (extensions.oes_texture_float) {\n      textureTypes.float32 = textureTypes.float = GL_FLOAT$3;\n    }\n\n    if (extensions.oes_texture_half_float) {\n      textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES;\n    }\n\n    if (extensions.webgl_depth_texture) {\n      extend(textureFormats, {\n        'depth': GL_DEPTH_COMPONENT,\n        'depth stencil': GL_DEPTH_STENCIL\n      });\n      extend(textureTypes, {\n        'uint16': GL_UNSIGNED_SHORT$2,\n        'uint32': GL_UNSIGNED_INT$2,\n        'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL\n      });\n    }\n\n    if (extensions.webgl_compressed_texture_s3tc) {\n      extend(compressedTextureFormats, {\n        'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,\n        'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,\n        'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,\n        'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT\n      });\n    }\n\n    if (extensions.webgl_compressed_texture_atc) {\n      extend(compressedTextureFormats, {\n        'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,\n        'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n        'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n      });\n    }\n\n    if (extensions.webgl_compressed_texture_pvrtc) {\n      extend(compressedTextureFormats, {\n        'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n        'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,\n        'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n        'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\n      });\n    }\n\n    if (extensions.webgl_compressed_texture_etc1) {\n      compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;\n    } // Copy over all texture formats\n\n\n    var supportedCompressedFormats = Array.prototype.slice.call(gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));\n    Object.keys(compressedTextureFormats).forEach(function (name) {\n      var format = compressedTextureFormats[name];\n\n      if (supportedCompressedFormats.indexOf(format) >= 0) {\n        textureFormats[name] = format;\n      }\n    });\n    var supportedFormats = Object.keys(textureFormats);\n    limits.textureFormats = supportedFormats; // associate with every format string its\n    // corresponding GL-value.\n\n    var textureFormatsInvert = [];\n    Object.keys(textureFormats).forEach(function (key) {\n      var val = textureFormats[key];\n      textureFormatsInvert[val] = key;\n    }); // associate with every type string its\n    // corresponding GL-value.\n\n    var textureTypesInvert = [];\n    Object.keys(textureTypes).forEach(function (key) {\n      var val = textureTypes[key];\n      textureTypesInvert[val] = key;\n    });\n    var magFiltersInvert = [];\n    Object.keys(magFilters).forEach(function (key) {\n      var val = magFilters[key];\n      magFiltersInvert[val] = key;\n    });\n    var minFiltersInvert = [];\n    Object.keys(minFilters).forEach(function (key) {\n      var val = minFilters[key];\n      minFiltersInvert[val] = key;\n    });\n    var wrapModesInvert = [];\n    Object.keys(wrapModes).forEach(function (key) {\n      var val = wrapModes[key];\n      wrapModesInvert[val] = key;\n    }); // colorFormats[] gives the format (channels) associated to an\n    // internalformat\n\n    var colorFormats = supportedFormats.reduce(function (color, key) {\n      var glenum = textureFormats[key];\n\n      if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {\n        color[glenum] = glenum;\n      } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {\n        color[glenum] = GL_RGBA$1;\n      } else {\n        color[glenum] = GL_RGB;\n      }\n\n      return color;\n    }, {});\n\n    function TexFlags() {\n      // format info\n      this.internalformat = GL_RGBA$1;\n      this.format = GL_RGBA$1;\n      this.type = GL_UNSIGNED_BYTE$4;\n      this.compressed = false; // pixel storage\n\n      this.premultiplyAlpha = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.colorSpace = GL_BROWSER_DEFAULT_WEBGL; // shape info\n\n      this.width = 0;\n      this.height = 0;\n      this.channels = 0;\n    }\n\n    function copyFlags(result, other) {\n      result.internalformat = other.internalformat;\n      result.format = other.format;\n      result.type = other.type;\n      result.compressed = other.compressed;\n      result.premultiplyAlpha = other.premultiplyAlpha;\n      result.flipY = other.flipY;\n      result.unpackAlignment = other.unpackAlignment;\n      result.colorSpace = other.colorSpace;\n      result.width = other.width;\n      result.height = other.height;\n      result.channels = other.channels;\n    }\n\n    function parseFlags(flags, options) {\n      if (typeof options !== 'object' || !options) {\n        return;\n      }\n\n      if ('premultiplyAlpha' in options) {\n        flags.premultiplyAlpha = options.premultiplyAlpha;\n      }\n\n      if ('flipY' in options) {\n        flags.flipY = options.flipY;\n      }\n\n      if ('alignment' in options) {\n        flags.unpackAlignment = options.alignment;\n      }\n\n      if ('colorSpace' in options) {\n        flags.colorSpace = colorSpace[options.colorSpace];\n      }\n\n      if ('type' in options) {\n        var type = options.type;\n        flags.type = textureTypes[type];\n      }\n\n      var w = flags.width;\n      var h = flags.height;\n      var c = flags.channels;\n      var hasChannels = false;\n\n      if ('shape' in options) {\n        w = options.shape[0];\n        h = options.shape[1];\n\n        if (options.shape.length === 3) {\n          c = options.shape[2];\n          hasChannels = true;\n        }\n      } else {\n        if ('radius' in options) {\n          w = h = options.radius;\n        }\n\n        if ('width' in options) {\n          w = options.width;\n        }\n\n        if ('height' in options) {\n          h = options.height;\n        }\n\n        if ('channels' in options) {\n          c = options.channels;\n          hasChannels = true;\n        }\n      }\n\n      flags.width = w | 0;\n      flags.height = h | 0;\n      flags.channels = c | 0;\n      var hasFormat = false;\n\n      if ('format' in options) {\n        var formatStr = options.format;\n        var internalformat = flags.internalformat = textureFormats[formatStr];\n        flags.format = colorFormats[internalformat];\n\n        if (formatStr in textureTypes) {\n          if (!('type' in options)) {\n            flags.type = textureTypes[formatStr];\n          }\n        }\n\n        if (formatStr in compressedTextureFormats) {\n          flags.compressed = true;\n        }\n\n        hasFormat = true;\n      } // Reconcile channels and format\n\n\n      if (!hasChannels && hasFormat) {\n        flags.channels = FORMAT_CHANNELS[flags.format];\n      } else if (hasChannels && !hasFormat) {\n        if (flags.channels !== CHANNELS_FORMAT[flags.format]) {\n          flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];\n        }\n      } else if (hasFormat && hasChannels) {}\n    }\n\n    function setFlags(flags) {\n      gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);\n      gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);\n      gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);\n      gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);\n    } // -------------------------------------------------------\n    // Tex image data\n    // -------------------------------------------------------\n\n\n    function TexImage() {\n      TexFlags.call(this);\n      this.xOffset = 0;\n      this.yOffset = 0; // data\n\n      this.data = null;\n      this.needsFree = false; // html element\n\n      this.element = null; // copyTexImage info\n\n      this.needsCopy = false;\n    }\n\n    function parseImage(image, options) {\n      var data = null;\n\n      if (isPixelData(options)) {\n        data = options;\n      } else if (options) {\n        parseFlags(image, options);\n\n        if ('x' in options) {\n          image.xOffset = options.x | 0;\n        }\n\n        if ('y' in options) {\n          image.yOffset = options.y | 0;\n        }\n\n        if (isPixelData(options.data)) {\n          data = options.data;\n        }\n      }\n\n      if (options.copy) {\n        var viewW = contextState.viewportWidth;\n        var viewH = contextState.viewportHeight;\n        image.width = image.width || viewW - image.xOffset;\n        image.height = image.height || viewH - image.yOffset;\n        image.needsCopy = true;\n      } else if (!data) {\n        image.width = image.width || 1;\n        image.height = image.height || 1;\n        image.channels = image.channels || 4;\n      } else if (isTypedArray(data)) {\n        image.channels = image.channels || 4;\n        image.data = data;\n\n        if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$4) {\n          image.type = typedArrayCode$1(data);\n        }\n      } else if (isNumericArray(data)) {\n        image.channels = image.channels || 4;\n        convertData(image, data);\n        image.alignment = 1;\n        image.needsFree = true;\n      } else if (isNDArrayLike(data)) {\n        var array = data.data;\n\n        if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$4) {\n          image.type = typedArrayCode$1(array);\n        }\n\n        var shape = data.shape;\n        var stride = data.stride;\n        var shapeX, shapeY, shapeC, strideX, strideY, strideC;\n\n        if (shape.length === 3) {\n          shapeC = shape[2];\n          strideC = stride[2];\n        } else {\n          shapeC = 1;\n          strideC = 1;\n        }\n\n        shapeX = shape[0];\n        shapeY = shape[1];\n        strideX = stride[0];\n        strideY = stride[1];\n        image.alignment = 1;\n        image.width = shapeX;\n        image.height = shapeY;\n        image.channels = shapeC;\n        image.format = image.internalformat = CHANNELS_FORMAT[shapeC];\n        image.needsFree = true;\n        transposeData(image, array, strideX, strideY, strideC, data.offset);\n      } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {\n        if (isCanvasElement(data) || isOffscreenCanvas(data)) {\n          image.element = data;\n        } else {\n          image.element = data.canvas;\n        }\n\n        image.width = image.element.width;\n        image.height = image.element.height;\n        image.channels = 4;\n      } else if (isBitmap(data)) {\n        image.element = data;\n        image.width = data.width;\n        image.height = data.height;\n        image.channels = 4;\n      } else if (isImageElement(data)) {\n        image.element = data;\n        image.width = data.naturalWidth;\n        image.height = data.naturalHeight;\n        image.channels = 4;\n      } else if (isVideoElement(data)) {\n        image.element = data;\n        image.width = data.videoWidth;\n        image.height = data.videoHeight;\n        image.channels = 4;\n      } else if (isRectArray(data)) {\n        var w = image.width || data[0].length;\n        var h = image.height || data.length;\n        var c = image.channels;\n\n        if (isArrayLike(data[0][0])) {\n          c = c || data[0][0].length;\n        } else {\n          c = c || 1;\n        }\n\n        var arrayShape = flattenUtils.shape(data);\n        var n = 1;\n\n        for (var dd = 0; dd < arrayShape.length; ++dd) {\n          n *= arrayShape[dd];\n        }\n\n        var allocData = preConvert(image, n);\n        flattenUtils.flatten(data, arrayShape, '', allocData);\n        postConvert(image, allocData);\n        image.alignment = 1;\n        image.width = w;\n        image.height = h;\n        image.channels = c;\n        image.format = image.internalformat = CHANNELS_FORMAT[c];\n        image.needsFree = true;\n      }\n\n      if (image.type === GL_FLOAT$3) {} else if (image.type === GL_HALF_FLOAT_OES) {} // do compressed texture  validation here.\n\n    }\n\n    function setImage(info, target, miplevel) {\n      var element = info.element;\n      var data = info.data;\n      var internalformat = info.internalformat;\n      var format = info.format;\n      var type = info.type;\n      var width = info.width;\n      var height = info.height;\n      setFlags(info);\n\n      if (element) {\n        gl.texImage2D(target, miplevel, format, format, type, element);\n      } else if (info.compressed) {\n        gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);\n      } else if (info.needsCopy) {\n        reglPoll();\n        gl.copyTexImage2D(target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);\n      } else {\n        gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null);\n      }\n    }\n\n    function setSubImage(info, target, x, y, miplevel) {\n      var element = info.element;\n      var data = info.data;\n      var internalformat = info.internalformat;\n      var format = info.format;\n      var type = info.type;\n      var width = info.width;\n      var height = info.height;\n      setFlags(info);\n\n      if (element) {\n        gl.texSubImage2D(target, miplevel, x, y, format, type, element);\n      } else if (info.compressed) {\n        gl.compressedTexSubImage2D(target, miplevel, x, y, internalformat, width, height, data);\n      } else if (info.needsCopy) {\n        reglPoll();\n        gl.copyTexSubImage2D(target, miplevel, x, y, info.xOffset, info.yOffset, width, height);\n      } else {\n        gl.texSubImage2D(target, miplevel, x, y, width, height, format, type, data);\n      }\n    } // texImage pool\n\n\n    var imagePool = [];\n\n    function allocImage() {\n      return imagePool.pop() || new TexImage();\n    }\n\n    function freeImage(image) {\n      if (image.needsFree) {\n        pool.freeType(image.data);\n      }\n\n      TexImage.call(image);\n      imagePool.push(image);\n    } // -------------------------------------------------------\n    // Mip map\n    // -------------------------------------------------------\n\n\n    function MipMap() {\n      TexFlags.call(this);\n      this.genMipmaps = false;\n      this.mipmapHint = GL_DONT_CARE;\n      this.mipmask = 0;\n      this.images = Array(16);\n    }\n\n    function parseMipMapFromShape(mipmap, width, height) {\n      var img = mipmap.images[0] = allocImage();\n      mipmap.mipmask = 1;\n      img.width = mipmap.width = width;\n      img.height = mipmap.height = height;\n      img.channels = mipmap.channels = 4;\n    }\n\n    function parseMipMapFromObject(mipmap, options) {\n      var imgData = null;\n\n      if (isPixelData(options)) {\n        imgData = mipmap.images[0] = allocImage();\n        copyFlags(imgData, mipmap);\n        parseImage(imgData, options);\n        mipmap.mipmask = 1;\n      } else {\n        parseFlags(mipmap, options);\n\n        if (Array.isArray(options.mipmap)) {\n          var mipData = options.mipmap;\n\n          for (var i = 0; i < mipData.length; ++i) {\n            imgData = mipmap.images[i] = allocImage();\n            copyFlags(imgData, mipmap);\n            imgData.width >>= i;\n            imgData.height >>= i;\n            parseImage(imgData, mipData[i]);\n            mipmap.mipmask |= 1 << i;\n          }\n        } else {\n          imgData = mipmap.images[0] = allocImage();\n          copyFlags(imgData, mipmap);\n          parseImage(imgData, options);\n          mipmap.mipmask = 1;\n        }\n      }\n\n      copyFlags(mipmap, mipmap.images[0]); // For textures of the compressed format WEBGL_compressed_texture_s3tc\n      // we must have that\n      //\n      // \"When level equals zero width and height must be a multiple of 4.\n      // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. \"\n      //\n      // but we do not yet support having multiple mipmap levels for compressed textures,\n      // so we only test for level zero.\n\n      if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {}\n    }\n\n    function setMipMap(mipmap, target) {\n      var images = mipmap.images;\n\n      for (var i = 0; i < images.length; ++i) {\n        if (!images[i]) {\n          return;\n        }\n\n        setImage(images[i], target, i);\n      }\n    }\n\n    var mipPool = [];\n\n    function allocMipMap() {\n      var result = mipPool.pop() || new MipMap();\n      TexFlags.call(result);\n      result.mipmask = 0;\n\n      for (var i = 0; i < 16; ++i) {\n        result.images[i] = null;\n      }\n\n      return result;\n    }\n\n    function freeMipMap(mipmap) {\n      var images = mipmap.images;\n\n      for (var i = 0; i < images.length; ++i) {\n        if (images[i]) {\n          freeImage(images[i]);\n        }\n\n        images[i] = null;\n      }\n\n      mipPool.push(mipmap);\n    } // -------------------------------------------------------\n    // Tex info\n    // -------------------------------------------------------\n\n\n    function TexInfo() {\n      this.minFilter = GL_NEAREST;\n      this.magFilter = GL_NEAREST;\n      this.wrapS = GL_CLAMP_TO_EDGE;\n      this.wrapT = GL_CLAMP_TO_EDGE;\n      this.anisotropic = 1;\n      this.genMipmaps = false;\n      this.mipmapHint = GL_DONT_CARE;\n    }\n\n    function parseTexInfo(info, options) {\n      if ('min' in options) {\n        var minFilter = options.min;\n        info.minFilter = minFilters[minFilter];\n\n        if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {\n          info.genMipmaps = true;\n        }\n      }\n\n      if ('mag' in options) {\n        var magFilter = options.mag;\n        info.magFilter = magFilters[magFilter];\n      }\n\n      var wrapS = info.wrapS;\n      var wrapT = info.wrapT;\n\n      if ('wrap' in options) {\n        var wrap = options.wrap;\n\n        if (typeof wrap === 'string') {\n          wrapS = wrapT = wrapModes[wrap];\n        } else if (Array.isArray(wrap)) {\n          wrapS = wrapModes[wrap[0]];\n          wrapT = wrapModes[wrap[1]];\n        }\n      } else {\n        if ('wrapS' in options) {\n          var optWrapS = options.wrapS;\n          wrapS = wrapModes[optWrapS];\n        }\n\n        if ('wrapT' in options) {\n          var optWrapT = options.wrapT;\n          wrapT = wrapModes[optWrapT];\n        }\n      }\n\n      info.wrapS = wrapS;\n      info.wrapT = wrapT;\n\n      if ('anisotropic' in options) {\n        var anisotropic = options.anisotropic;\n        info.anisotropic = options.anisotropic;\n      }\n\n      if ('mipmap' in options) {\n        var hasMipMap = false;\n\n        switch (typeof options.mipmap) {\n          case 'string':\n            info.mipmapHint = mipmapHint[options.mipmap];\n            info.genMipmaps = true;\n            hasMipMap = true;\n            break;\n\n          case 'boolean':\n            hasMipMap = info.genMipmaps = options.mipmap;\n            break;\n\n          case 'object':\n            info.genMipmaps = false;\n            hasMipMap = true;\n            break;\n\n          default:\n        }\n\n        if (hasMipMap && !('min' in options)) {\n          info.minFilter = GL_NEAREST_MIPMAP_NEAREST;\n        }\n      }\n    }\n\n    function setTexInfo(info, target) {\n      gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);\n      gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);\n      gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);\n      gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);\n\n      if (extensions.ext_texture_filter_anisotropic) {\n        gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);\n      }\n\n      if (info.genMipmaps) {\n        gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);\n        gl.generateMipmap(target);\n      }\n    } // -------------------------------------------------------\n    // Full texture object\n    // -------------------------------------------------------\n\n\n    var textureCount = 0;\n    var textureSet = {};\n    var numTexUnits = limits.maxTextureUnits;\n    var textureUnits = Array(numTexUnits).map(function () {\n      return null;\n    });\n\n    function REGLTexture(target) {\n      TexFlags.call(this);\n      this.mipmask = 0;\n      this.internalformat = GL_RGBA$1;\n      this.id = textureCount++;\n      this.refCount = 1;\n      this.target = target;\n      this.texture = gl.createTexture();\n      this.unit = -1;\n      this.bindCount = 0;\n      this.texInfo = new TexInfo();\n\n      if (config.profile) {\n        this.stats = {\n          size: 0\n        };\n      }\n    }\n\n    function tempBind(texture) {\n      gl.activeTexture(GL_TEXTURE0$1);\n      gl.bindTexture(texture.target, texture.texture);\n    }\n\n    function tempRestore() {\n      var prev = textureUnits[0];\n\n      if (prev) {\n        gl.bindTexture(prev.target, prev.texture);\n      } else {\n        gl.bindTexture(GL_TEXTURE_2D$1, null);\n      }\n    }\n\n    function destroy(texture) {\n      var handle = texture.texture;\n      var unit = texture.unit;\n      var target = texture.target;\n\n      if (unit >= 0) {\n        gl.activeTexture(GL_TEXTURE0$1 + unit);\n        gl.bindTexture(target, null);\n        textureUnits[unit] = null;\n      }\n\n      gl.deleteTexture(handle);\n      texture.texture = null;\n      texture.params = null;\n      texture.pixels = null;\n      texture.refCount = 0;\n      delete textureSet[texture.id];\n      stats.textureCount--;\n    }\n\n    extend(REGLTexture.prototype, {\n      bind: function bind() {\n        var texture = this;\n        texture.bindCount += 1;\n        var unit = texture.unit;\n\n        if (unit < 0) {\n          for (var i = 0; i < numTexUnits; ++i) {\n            var other = textureUnits[i];\n\n            if (other) {\n              if (other.bindCount > 0) {\n                continue;\n              }\n\n              other.unit = -1;\n            }\n\n            textureUnits[i] = texture;\n            unit = i;\n            break;\n          }\n\n          if (unit >= numTexUnits) {}\n\n          if (config.profile && stats.maxTextureUnits < unit + 1) {\n            stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based\n          }\n\n          texture.unit = unit;\n          gl.activeTexture(GL_TEXTURE0$1 + unit);\n          gl.bindTexture(texture.target, texture.texture);\n        }\n\n        return unit;\n      },\n      unbind: function unbind() {\n        this.bindCount -= 1;\n      },\n      decRef: function decRef() {\n        if (--this.refCount <= 0) {\n          destroy(this);\n        }\n      }\n    });\n\n    function createTexture2D(a, b) {\n      var texture = new REGLTexture(GL_TEXTURE_2D$1);\n      textureSet[texture.id] = texture;\n      stats.textureCount++;\n\n      function reglTexture2D(a, b) {\n        var texInfo = texture.texInfo;\n        TexInfo.call(texInfo);\n        var mipData = allocMipMap();\n\n        if (typeof a === 'number') {\n          if (typeof b === 'number') {\n            parseMipMapFromShape(mipData, a | 0, b | 0);\n          } else {\n            parseMipMapFromShape(mipData, a | 0, a | 0);\n          }\n        } else if (a) {\n          parseTexInfo(texInfo, a);\n          parseMipMapFromObject(mipData, a);\n        } else {\n          // empty textures get assigned a default shape of 1x1\n          parseMipMapFromShape(mipData, 1, 1);\n        }\n\n        if (texInfo.genMipmaps) {\n          mipData.mipmask = (mipData.width << 1) - 1;\n        }\n\n        texture.mipmask = mipData.mipmask;\n        copyFlags(texture, mipData);\n        texture.internalformat = mipData.internalformat;\n        reglTexture2D.width = mipData.width;\n        reglTexture2D.height = mipData.height;\n        tempBind(texture);\n        setMipMap(mipData, GL_TEXTURE_2D$1);\n        setTexInfo(texInfo, GL_TEXTURE_2D$1);\n        tempRestore();\n        freeMipMap(mipData);\n\n        if (config.profile) {\n          texture.stats.size = getTextureSize(texture.internalformat, texture.type, mipData.width, mipData.height, texInfo.genMipmaps, false);\n        }\n\n        reglTexture2D.format = textureFormatsInvert[texture.internalformat];\n        reglTexture2D.type = textureTypesInvert[texture.type];\n        reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];\n        reglTexture2D.min = minFiltersInvert[texInfo.minFilter];\n        reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];\n        reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];\n        return reglTexture2D;\n      }\n\n      function subimage(image, x_, y_, level_) {\n        var x = x_ | 0;\n        var y = y_ | 0;\n        var level = level_ | 0;\n        var imageData = allocImage();\n        copyFlags(imageData, texture);\n        imageData.width = 0;\n        imageData.height = 0;\n        parseImage(imageData, image);\n        imageData.width = imageData.width || (texture.width >> level) - x;\n        imageData.height = imageData.height || (texture.height >> level) - y;\n        tempBind(texture);\n        setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);\n        tempRestore();\n        freeImage(imageData);\n        return reglTexture2D;\n      }\n\n      function resize(w_, h_) {\n        var w = w_ | 0;\n        var h = h_ | 0 || w;\n\n        if (w === texture.width && h === texture.height) {\n          return reglTexture2D;\n        }\n\n        reglTexture2D.width = texture.width = w;\n        reglTexture2D.height = texture.height = h;\n        tempBind(texture);\n\n        for (var i = 0; texture.mipmask >> i; ++i) {\n          var _w = w >> i;\n\n          var _h = h >> i;\n\n          if (!_w || !_h) break;\n          gl.texImage2D(GL_TEXTURE_2D$1, i, texture.format, _w, _h, 0, texture.format, texture.type, null);\n        }\n\n        tempRestore(); // also, recompute the texture size.\n\n        if (config.profile) {\n          texture.stats.size = getTextureSize(texture.internalformat, texture.type, w, h, false, false);\n        }\n\n        return reglTexture2D;\n      }\n\n      reglTexture2D(a, b);\n      reglTexture2D.subimage = subimage;\n      reglTexture2D.resize = resize;\n      reglTexture2D._reglType = 'texture2d';\n      reglTexture2D._texture = texture;\n\n      if (config.profile) {\n        reglTexture2D.stats = texture.stats;\n      }\n\n      reglTexture2D.destroy = function () {\n        texture.decRef();\n      };\n\n      return reglTexture2D;\n    }\n\n    function createTextureCube(a0, a1, a2, a3, a4, a5) {\n      var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);\n      textureSet[texture.id] = texture;\n      stats.cubeCount++;\n      var faces = new Array(6);\n\n      function reglTextureCube(a0, a1, a2, a3, a4, a5) {\n        var i;\n        var texInfo = texture.texInfo;\n        TexInfo.call(texInfo);\n\n        for (i = 0; i < 6; ++i) {\n          faces[i] = allocMipMap();\n        }\n\n        if (typeof a0 === 'number' || !a0) {\n          var s = a0 | 0 || 1;\n\n          for (i = 0; i < 6; ++i) {\n            parseMipMapFromShape(faces[i], s, s);\n          }\n        } else if (typeof a0 === 'object') {\n          if (a1) {\n            parseMipMapFromObject(faces[0], a0);\n            parseMipMapFromObject(faces[1], a1);\n            parseMipMapFromObject(faces[2], a2);\n            parseMipMapFromObject(faces[3], a3);\n            parseMipMapFromObject(faces[4], a4);\n            parseMipMapFromObject(faces[5], a5);\n          } else {\n            parseTexInfo(texInfo, a0);\n            parseFlags(texture, a0);\n\n            if ('faces' in a0) {\n              var faceInput = a0.faces;\n\n              for (i = 0; i < 6; ++i) {\n                copyFlags(faces[i], texture);\n                parseMipMapFromObject(faces[i], faceInput[i]);\n              }\n            } else {\n              for (i = 0; i < 6; ++i) {\n                parseMipMapFromObject(faces[i], a0);\n              }\n            }\n          }\n        } else {}\n\n        copyFlags(texture, faces[0]);\n\n        if (texInfo.genMipmaps) {\n          texture.mipmask = (faces[0].width << 1) - 1;\n        } else {\n          texture.mipmask = faces[0].mipmask;\n        }\n\n        texture.internalformat = faces[0].internalformat;\n        reglTextureCube.width = faces[0].width;\n        reglTextureCube.height = faces[0].height;\n        tempBind(texture);\n\n        for (i = 0; i < 6; ++i) {\n          setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);\n        }\n\n        setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);\n        tempRestore();\n\n        if (config.profile) {\n          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, texInfo.genMipmaps, true);\n        }\n\n        reglTextureCube.format = textureFormatsInvert[texture.internalformat];\n        reglTextureCube.type = textureTypesInvert[texture.type];\n        reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];\n        reglTextureCube.min = minFiltersInvert[texInfo.minFilter];\n        reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];\n        reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];\n\n        for (i = 0; i < 6; ++i) {\n          freeMipMap(faces[i]);\n        }\n\n        return reglTextureCube;\n      }\n\n      function subimage(face, image, x_, y_, level_) {\n        var x = x_ | 0;\n        var y = y_ | 0;\n        var level = level_ | 0;\n        var imageData = allocImage();\n        copyFlags(imageData, texture);\n        imageData.width = 0;\n        imageData.height = 0;\n        parseImage(imageData, image);\n        imageData.width = imageData.width || (texture.width >> level) - x;\n        imageData.height = imageData.height || (texture.height >> level) - y;\n        tempBind(texture);\n        setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);\n        tempRestore();\n        freeImage(imageData);\n        return reglTextureCube;\n      }\n\n      function resize(radius_) {\n        var radius = radius_ | 0;\n\n        if (radius === texture.width) {\n          return;\n        }\n\n        reglTextureCube.width = texture.width = radius;\n        reglTextureCube.height = texture.height = radius;\n        tempBind(texture);\n\n        for (var i = 0; i < 6; ++i) {\n          for (var j = 0; texture.mipmask >> j; ++j) {\n            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i, j, texture.format, radius >> j, radius >> j, 0, texture.format, texture.type, null);\n          }\n        }\n\n        tempRestore();\n\n        if (config.profile) {\n          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, false, true);\n        }\n\n        return reglTextureCube;\n      }\n\n      reglTextureCube(a0, a1, a2, a3, a4, a5);\n      reglTextureCube.subimage = subimage;\n      reglTextureCube.resize = resize;\n      reglTextureCube._reglType = 'textureCube';\n      reglTextureCube._texture = texture;\n\n      if (config.profile) {\n        reglTextureCube.stats = texture.stats;\n      }\n\n      reglTextureCube.destroy = function () {\n        texture.decRef();\n      };\n\n      return reglTextureCube;\n    } // Called when regl is destroyed\n\n\n    function destroyTextures() {\n      for (var i = 0; i < numTexUnits; ++i) {\n        gl.activeTexture(GL_TEXTURE0$1 + i);\n        gl.bindTexture(GL_TEXTURE_2D$1, null);\n        textureUnits[i] = null;\n      }\n\n      values(textureSet).forEach(destroy);\n      stats.cubeCount = 0;\n      stats.textureCount = 0;\n    }\n\n    if (config.profile) {\n      stats.getTotalTextureSize = function () {\n        var total = 0;\n        Object.keys(textureSet).forEach(function (key) {\n          total += textureSet[key].stats.size;\n        });\n        return total;\n      };\n    }\n\n    function restoreTextures() {\n      for (var i = 0; i < numTexUnits; ++i) {\n        var tex = textureUnits[i];\n\n        if (tex) {\n          tex.bindCount = 0;\n          tex.unit = -1;\n          textureUnits[i] = null;\n        }\n      }\n\n      values(textureSet).forEach(function (texture) {\n        texture.texture = gl.createTexture();\n        gl.bindTexture(texture.target, texture.texture);\n\n        for (var i = 0; i < 32; ++i) {\n          if ((texture.mipmask & 1 << i) === 0) {\n            continue;\n          }\n\n          if (texture.target === GL_TEXTURE_2D$1) {\n            gl.texImage2D(GL_TEXTURE_2D$1, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);\n          } else {\n            for (var j = 0; j < 6; ++j) {\n              gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);\n            }\n          }\n        }\n\n        setTexInfo(texture.texInfo, texture.target);\n      });\n    }\n\n    function refreshTextures() {\n      for (var i = 0; i < numTexUnits; ++i) {\n        var tex = textureUnits[i];\n\n        if (tex) {\n          tex.bindCount = 0;\n          tex.unit = -1;\n          textureUnits[i] = null;\n        }\n\n        gl.activeTexture(GL_TEXTURE0$1 + i);\n        gl.bindTexture(GL_TEXTURE_2D$1, null);\n        gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);\n      }\n    }\n\n    return {\n      create2D: createTexture2D,\n      createCube: createTextureCube,\n      clear: destroyTextures,\n      getTexture: function getTexture(wrapper) {\n        return null;\n      },\n      restore: restoreTextures,\n      refresh: refreshTextures\n    };\n  }\n\n  var GL_RENDERBUFFER = 0x8D41;\n  var GL_RGBA4$1 = 0x8056;\n  var GL_RGB5_A1$1 = 0x8057;\n  var GL_RGB565$1 = 0x8D62;\n  var GL_DEPTH_COMPONENT16 = 0x81A5;\n  var GL_STENCIL_INDEX8 = 0x8D48;\n  var GL_DEPTH_STENCIL$1 = 0x84F9;\n  var GL_SRGB8_ALPHA8_EXT = 0x8C43;\n  var GL_RGBA32F_EXT = 0x8814;\n  var GL_RGBA16F_EXT = 0x881A;\n  var GL_RGB16F_EXT = 0x881B;\n  var FORMAT_SIZES = [];\n  FORMAT_SIZES[GL_RGBA4$1] = 2;\n  FORMAT_SIZES[GL_RGB5_A1$1] = 2;\n  FORMAT_SIZES[GL_RGB565$1] = 2;\n  FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;\n  FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;\n  FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;\n  FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;\n  FORMAT_SIZES[GL_RGBA32F_EXT] = 16;\n  FORMAT_SIZES[GL_RGBA16F_EXT] = 8;\n  FORMAT_SIZES[GL_RGB16F_EXT] = 6;\n\n  function getRenderbufferSize(format, width, height) {\n    return FORMAT_SIZES[format] * width * height;\n  }\n\n  var wrapRenderbuffers = function wrapRenderbuffers(gl, extensions, limits, stats, config) {\n    var formatTypes = {\n      'rgba4': GL_RGBA4$1,\n      'rgb565': GL_RGB565$1,\n      'rgb5 a1': GL_RGB5_A1$1,\n      'depth': GL_DEPTH_COMPONENT16,\n      'stencil': GL_STENCIL_INDEX8,\n      'depth stencil': GL_DEPTH_STENCIL$1\n    };\n\n    if (extensions.ext_srgb) {\n      formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;\n    }\n\n    if (extensions.ext_color_buffer_half_float) {\n      formatTypes['rgba16f'] = GL_RGBA16F_EXT;\n      formatTypes['rgb16f'] = GL_RGB16F_EXT;\n    }\n\n    if (extensions.webgl_color_buffer_float) {\n      formatTypes['rgba32f'] = GL_RGBA32F_EXT;\n    }\n\n    var formatTypesInvert = [];\n    Object.keys(formatTypes).forEach(function (key) {\n      var val = formatTypes[key];\n      formatTypesInvert[val] = key;\n    });\n    var renderbufferCount = 0;\n    var renderbufferSet = {};\n\n    function REGLRenderbuffer(renderbuffer) {\n      this.id = renderbufferCount++;\n      this.refCount = 1;\n      this.renderbuffer = renderbuffer;\n      this.format = GL_RGBA4$1;\n      this.width = 0;\n      this.height = 0;\n\n      if (config.profile) {\n        this.stats = {\n          size: 0\n        };\n      }\n    }\n\n    REGLRenderbuffer.prototype.decRef = function () {\n      if (--this.refCount <= 0) {\n        destroy(this);\n      }\n    };\n\n    function destroy(rb) {\n      var handle = rb.renderbuffer;\n      gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n      gl.deleteRenderbuffer(handle);\n      rb.renderbuffer = null;\n      rb.refCount = 0;\n      delete renderbufferSet[rb.id];\n      stats.renderbufferCount--;\n    }\n\n    function createRenderbuffer(a, b) {\n      var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());\n      renderbufferSet[renderbuffer.id] = renderbuffer;\n      stats.renderbufferCount++;\n\n      function reglRenderbuffer(a, b) {\n        var w = 0;\n        var h = 0;\n        var format = GL_RGBA4$1;\n\n        if (typeof a === 'object' && a) {\n          var options = a;\n\n          if ('shape' in options) {\n            var shape = options.shape;\n            w = shape[0] | 0;\n            h = shape[1] | 0;\n          } else {\n            if ('radius' in options) {\n              w = h = options.radius | 0;\n            }\n\n            if ('width' in options) {\n              w = options.width | 0;\n            }\n\n            if ('height' in options) {\n              h = options.height | 0;\n            }\n          }\n\n          if ('format' in options) {\n            format = formatTypes[options.format];\n          }\n        } else if (typeof a === 'number') {\n          w = a | 0;\n\n          if (typeof b === 'number') {\n            h = b | 0;\n          } else {\n            h = w;\n          }\n        } else if (!a) {\n          w = h = 1;\n        } else {} // check shape\n\n\n        if (w === renderbuffer.width && h === renderbuffer.height && format === renderbuffer.format) {\n          return;\n        }\n\n        reglRenderbuffer.width = renderbuffer.width = w;\n        reglRenderbuffer.height = renderbuffer.height = h;\n        renderbuffer.format = format;\n        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);\n        gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);\n\n        if (config.profile) {\n          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);\n        }\n\n        reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];\n        return reglRenderbuffer;\n      }\n\n      function resize(w_, h_) {\n        var w = w_ | 0;\n        var h = h_ | 0 || w;\n\n        if (w === renderbuffer.width && h === renderbuffer.height) {\n          return reglRenderbuffer;\n        } // check shape\n\n\n        reglRenderbuffer.width = renderbuffer.width = w;\n        reglRenderbuffer.height = renderbuffer.height = h;\n        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);\n        gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h); // also, recompute size.\n\n        if (config.profile) {\n          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);\n        }\n\n        return reglRenderbuffer;\n      }\n\n      reglRenderbuffer(a, b);\n      reglRenderbuffer.resize = resize;\n      reglRenderbuffer._reglType = 'renderbuffer';\n      reglRenderbuffer._renderbuffer = renderbuffer;\n\n      if (config.profile) {\n        reglRenderbuffer.stats = renderbuffer.stats;\n      }\n\n      reglRenderbuffer.destroy = function () {\n        renderbuffer.decRef();\n      };\n\n      return reglRenderbuffer;\n    }\n\n    if (config.profile) {\n      stats.getTotalRenderbufferSize = function () {\n        var total = 0;\n        Object.keys(renderbufferSet).forEach(function (key) {\n          total += renderbufferSet[key].stats.size;\n        });\n        return total;\n      };\n    }\n\n    function restoreRenderbuffers() {\n      values(renderbufferSet).forEach(function (rb) {\n        rb.renderbuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);\n        gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);\n      });\n      gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n    }\n\n    return {\n      create: createRenderbuffer,\n      clear: function clear() {\n        values(renderbufferSet).forEach(destroy);\n      },\n      restore: restoreRenderbuffers\n    };\n  }; // We store these constants so that the minifier can inline them\n\n\n  var GL_FRAMEBUFFER$1 = 0x8D40;\n  var GL_RENDERBUFFER$1 = 0x8D41;\n  var GL_TEXTURE_2D$2 = 0x0DE1;\n  var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515;\n  var GL_COLOR_ATTACHMENT0$1 = 0x8CE0;\n  var GL_DEPTH_ATTACHMENT = 0x8D00;\n  var GL_STENCIL_ATTACHMENT = 0x8D20;\n  var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;\n  var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5;\n  var GL_HALF_FLOAT_OES$1 = 0x8D61;\n  var GL_UNSIGNED_BYTE$5 = 0x1401;\n  var GL_FLOAT$4 = 0x1406;\n  var GL_RGB$1 = 0x1907;\n  var GL_RGBA$2 = 0x1908; // for every texture format, store\n  // the number of channels\n\n  var textureFormatChannels = [];\n  textureFormatChannels[GL_RGBA$2] = 4;\n  textureFormatChannels[GL_RGB$1] = 3; // for every texture type, store\n  // the size in bytes.\n\n  var textureTypeSizes = [];\n  textureTypeSizes[GL_UNSIGNED_BYTE$5] = 1;\n  textureTypeSizes[GL_FLOAT$4] = 4;\n  textureTypeSizes[GL_HALF_FLOAT_OES$1] = 2;\n\n  function wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats) {\n    var framebufferState = {\n      cur: null,\n      next: null,\n      dirty: false,\n      setFBO: null\n    };\n    var colorTextureFormats = ['rgba'];\n    var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];\n\n    if (extensions.ext_srgb) {\n      colorRenderbufferFormats.push('srgba');\n    }\n\n    if (extensions.ext_color_buffer_half_float) {\n      colorRenderbufferFormats.push('rgba16f', 'rgb16f');\n    }\n\n    if (extensions.webgl_color_buffer_float) {\n      colorRenderbufferFormats.push('rgba32f');\n    }\n\n    var colorTypes = ['uint8'];\n\n    if (extensions.oes_texture_half_float) {\n      colorTypes.push('half float', 'float16');\n    }\n\n    if (extensions.oes_texture_float) {\n      colorTypes.push('float', 'float32');\n    }\n\n    function FramebufferAttachment(target, texture, renderbuffer) {\n      this.target = target;\n      this.texture = texture;\n      this.renderbuffer = renderbuffer;\n      var w = 0;\n      var h = 0;\n\n      if (texture) {\n        w = texture.width;\n        h = texture.height;\n      } else if (renderbuffer) {\n        w = renderbuffer.width;\n        h = renderbuffer.height;\n      }\n\n      this.width = w;\n      this.height = h;\n    }\n\n    function decRef(attachment) {\n      if (attachment) {\n        if (attachment.texture) {\n          attachment.texture._texture.decRef();\n        }\n\n        if (attachment.renderbuffer) {\n          attachment.renderbuffer._renderbuffer.decRef();\n        }\n      }\n    }\n\n    function incRefAndCheckShape(attachment, width, height) {\n      if (!attachment) {\n        return;\n      }\n\n      if (attachment.texture) {\n        var texture = attachment.texture._texture;\n        var tw = Math.max(1, texture.width);\n        var th = Math.max(1, texture.height);\n        texture.refCount += 1;\n      } else {\n        var renderbuffer = attachment.renderbuffer._renderbuffer;\n        renderbuffer.refCount += 1;\n      }\n    }\n\n    function attach(location, attachment) {\n      if (attachment) {\n        if (attachment.texture) {\n          gl.framebufferTexture2D(GL_FRAMEBUFFER$1, location, attachment.target, attachment.texture._texture.texture, 0);\n        } else {\n          gl.framebufferRenderbuffer(GL_FRAMEBUFFER$1, location, GL_RENDERBUFFER$1, attachment.renderbuffer._renderbuffer.renderbuffer);\n        }\n      }\n    }\n\n    function parseAttachment(attachment) {\n      var target = GL_TEXTURE_2D$2;\n      var texture = null;\n      var renderbuffer = null;\n      var data = attachment;\n\n      if (typeof attachment === 'object') {\n        data = attachment.data;\n\n        if ('target' in attachment) {\n          target = attachment.target | 0;\n        }\n      }\n\n      var type = data._reglType;\n\n      if (type === 'texture2d') {\n        texture = data;\n      } else if (type === 'textureCube') {\n        texture = data;\n      } else if (type === 'renderbuffer') {\n        renderbuffer = data;\n        target = GL_RENDERBUFFER$1;\n      } else {}\n\n      return new FramebufferAttachment(target, texture, renderbuffer);\n    }\n\n    function allocAttachment(width, height, isTexture, format, type) {\n      if (isTexture) {\n        var texture = textureState.create2D({\n          width: width,\n          height: height,\n          format: format,\n          type: type\n        });\n        texture._texture.refCount = 0;\n        return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);\n      } else {\n        var rb = renderbufferState.create({\n          width: width,\n          height: height,\n          format: format\n        });\n        rb._renderbuffer.refCount = 0;\n        return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);\n      }\n    }\n\n    function unwrapAttachment(attachment) {\n      return attachment && (attachment.texture || attachment.renderbuffer);\n    }\n\n    function resizeAttachment(attachment, w, h) {\n      if (attachment) {\n        if (attachment.texture) {\n          attachment.texture.resize(w, h);\n        } else if (attachment.renderbuffer) {\n          attachment.renderbuffer.resize(w, h);\n        }\n\n        attachment.width = w;\n        attachment.height = h;\n      }\n    }\n\n    var framebufferCount = 0;\n    var framebufferSet = {};\n\n    function REGLFramebuffer() {\n      this.id = framebufferCount++;\n      framebufferSet[this.id] = this;\n      this.framebuffer = gl.createFramebuffer();\n      this.width = 0;\n      this.height = 0;\n      this.colorAttachments = [];\n      this.depthAttachment = null;\n      this.stencilAttachment = null;\n      this.depthStencilAttachment = null;\n    }\n\n    function decFBORefs(framebuffer) {\n      framebuffer.colorAttachments.forEach(decRef);\n      decRef(framebuffer.depthAttachment);\n      decRef(framebuffer.stencilAttachment);\n      decRef(framebuffer.depthStencilAttachment);\n    }\n\n    function _destroy(framebuffer) {\n      var handle = framebuffer.framebuffer;\n      gl.deleteFramebuffer(handle);\n      framebuffer.framebuffer = null;\n      stats.framebufferCount--;\n      delete framebufferSet[framebuffer.id];\n    }\n\n    function updateFramebuffer(framebuffer) {\n      var i;\n      gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);\n      var colorAttachments = framebuffer.colorAttachments;\n\n      for (i = 0; i < colorAttachments.length; ++i) {\n        attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);\n      }\n\n      for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {\n        gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_COLOR_ATTACHMENT0$1 + i, GL_TEXTURE_2D$2, null, 0);\n      }\n\n      gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n      gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n      gl.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);\n      attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);\n      attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);\n      attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment); // Check status code\n\n      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1);\n\n      if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {}\n\n      gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);\n      framebufferState.cur = framebufferState.next; // FIXME: Clear error code here.  This is a work around for a bug in\n      // headless-gl\n\n      gl.getError();\n    }\n\n    function createFBO(a0, a1) {\n      var framebuffer = new REGLFramebuffer();\n      stats.framebufferCount++;\n\n      function reglFramebuffer(a, b) {\n        var i;\n        var width = 0;\n        var height = 0;\n        var needsDepth = true;\n        var needsStencil = true;\n        var colorBuffer = null;\n        var colorTexture = true;\n        var colorFormat = 'rgba';\n        var colorType = 'uint8';\n        var colorCount = 1;\n        var depthBuffer = null;\n        var stencilBuffer = null;\n        var depthStencilBuffer = null;\n        var depthStencilTexture = false;\n\n        if (typeof a === 'number') {\n          width = a | 0;\n          height = b | 0 || width;\n        } else if (!a) {\n          width = height = 1;\n        } else {\n          var options = a;\n\n          if ('shape' in options) {\n            var shape = options.shape;\n            width = shape[0];\n            height = shape[1];\n          } else {\n            if ('radius' in options) {\n              width = height = options.radius;\n            }\n\n            if ('width' in options) {\n              width = options.width;\n            }\n\n            if ('height' in options) {\n              height = options.height;\n            }\n          }\n\n          if ('color' in options || 'colors' in options) {\n            colorBuffer = options.color || options.colors;\n\n            if (Array.isArray(colorBuffer)) {}\n          }\n\n          if (!colorBuffer) {\n            if ('colorCount' in options) {\n              colorCount = options.colorCount | 0;\n            }\n\n            if ('colorTexture' in options) {\n              colorTexture = !!options.colorTexture;\n              colorFormat = 'rgba4';\n            }\n\n            if ('colorType' in options) {\n              colorType = options.colorType;\n\n              if (!colorTexture) {\n                if (colorType === 'half float' || colorType === 'float16') {\n                  colorFormat = 'rgba16f';\n                } else if (colorType === 'float' || colorType === 'float32') {\n                  colorFormat = 'rgba32f';\n                }\n              } else {}\n            }\n\n            if ('colorFormat' in options) {\n              colorFormat = options.colorFormat;\n\n              if (colorTextureFormats.indexOf(colorFormat) >= 0) {\n                colorTexture = true;\n              } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {\n                colorTexture = false;\n              } else {}\n            }\n          }\n\n          if ('depthTexture' in options || 'depthStencilTexture' in options) {\n            depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);\n          }\n\n          if ('depth' in options) {\n            if (typeof options.depth === 'boolean') {\n              needsDepth = options.depth;\n            } else {\n              depthBuffer = options.depth;\n              needsStencil = false;\n            }\n          }\n\n          if ('stencil' in options) {\n            if (typeof options.stencil === 'boolean') {\n              needsStencil = options.stencil;\n            } else {\n              stencilBuffer = options.stencil;\n              needsDepth = false;\n            }\n          }\n\n          if ('depthStencil' in options) {\n            if (typeof options.depthStencil === 'boolean') {\n              needsDepth = needsStencil = options.depthStencil;\n            } else {\n              depthStencilBuffer = options.depthStencil;\n              needsDepth = false;\n              needsStencil = false;\n            }\n          }\n        } // parse attachments\n\n\n        var colorAttachments = null;\n        var depthAttachment = null;\n        var stencilAttachment = null;\n        var depthStencilAttachment = null; // Set up color attachments\n\n        if (Array.isArray(colorBuffer)) {\n          colorAttachments = colorBuffer.map(parseAttachment);\n        } else if (colorBuffer) {\n          colorAttachments = [parseAttachment(colorBuffer)];\n        } else {\n          colorAttachments = new Array(colorCount);\n\n          for (i = 0; i < colorCount; ++i) {\n            colorAttachments[i] = allocAttachment(width, height, colorTexture, colorFormat, colorType);\n          }\n        }\n\n        width = width || colorAttachments[0].width;\n        height = height || colorAttachments[0].height;\n\n        if (depthBuffer) {\n          depthAttachment = parseAttachment(depthBuffer);\n        } else if (needsDepth && !needsStencil) {\n          depthAttachment = allocAttachment(width, height, depthStencilTexture, 'depth', 'uint32');\n        }\n\n        if (stencilBuffer) {\n          stencilAttachment = parseAttachment(stencilBuffer);\n        } else if (needsStencil && !needsDepth) {\n          stencilAttachment = allocAttachment(width, height, false, 'stencil', 'uint8');\n        }\n\n        if (depthStencilBuffer) {\n          depthStencilAttachment = parseAttachment(depthStencilBuffer);\n        } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {\n          depthStencilAttachment = allocAttachment(width, height, depthStencilTexture, 'depth stencil', 'depth stencil');\n        }\n\n        var commonColorAttachmentSize = null;\n\n        for (i = 0; i < colorAttachments.length; ++i) {\n          incRefAndCheckShape(colorAttachments[i], width, height);\n\n          if (colorAttachments[i] && colorAttachments[i].texture) {\n            var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];\n\n            if (commonColorAttachmentSize === null) {\n              commonColorAttachmentSize = colorAttachmentSize;\n            } else {// We need to make sure that all color attachments have the same number of bitplanes\n              // (that is, the same numer of bits per pixel)\n              // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.\n            }\n          }\n        }\n\n        incRefAndCheckShape(depthAttachment, width, height);\n        incRefAndCheckShape(stencilAttachment, width, height);\n        incRefAndCheckShape(depthStencilAttachment, width, height); // decrement references\n\n        decFBORefs(framebuffer);\n        framebuffer.width = width;\n        framebuffer.height = height;\n        framebuffer.colorAttachments = colorAttachments;\n        framebuffer.depthAttachment = depthAttachment;\n        framebuffer.stencilAttachment = stencilAttachment;\n        framebuffer.depthStencilAttachment = depthStencilAttachment;\n        reglFramebuffer.color = colorAttachments.map(unwrapAttachment);\n        reglFramebuffer.depth = unwrapAttachment(depthAttachment);\n        reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);\n        reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);\n        reglFramebuffer.width = framebuffer.width;\n        reglFramebuffer.height = framebuffer.height;\n        updateFramebuffer(framebuffer);\n        return reglFramebuffer;\n      }\n\n      function resize(w_, h_) {\n        var w = Math.max(w_ | 0, 1);\n        var h = Math.max(h_ | 0 || w, 1);\n\n        if (w === framebuffer.width && h === framebuffer.height) {\n          return reglFramebuffer;\n        } // resize all buffers\n\n\n        var colorAttachments = framebuffer.colorAttachments;\n\n        for (var i = 0; i < colorAttachments.length; ++i) {\n          resizeAttachment(colorAttachments[i], w, h);\n        }\n\n        resizeAttachment(framebuffer.depthAttachment, w, h);\n        resizeAttachment(framebuffer.stencilAttachment, w, h);\n        resizeAttachment(framebuffer.depthStencilAttachment, w, h);\n        framebuffer.width = reglFramebuffer.width = w;\n        framebuffer.height = reglFramebuffer.height = h;\n        updateFramebuffer(framebuffer);\n        return reglFramebuffer;\n      }\n\n      reglFramebuffer(a0, a1);\n      return extend(reglFramebuffer, {\n        resize: resize,\n        _reglType: 'framebuffer',\n        _framebuffer: framebuffer,\n        destroy: function destroy() {\n          _destroy(framebuffer);\n\n          decFBORefs(framebuffer);\n        },\n        use: function use(block) {\n          framebufferState.setFBO({\n            framebuffer: reglFramebuffer\n          }, block);\n        }\n      });\n    }\n\n    function createCubeFBO(options) {\n      var faces = Array(6);\n\n      function reglFramebufferCube(a) {\n        var i;\n        var params = {\n          color: null\n        };\n        var radius = 0;\n        var colorBuffer = null;\n        var colorFormat = 'rgba';\n        var colorType = 'uint8';\n        var colorCount = 1;\n\n        if (typeof a === 'number') {\n          radius = a | 0;\n        } else if (!a) {\n          radius = 1;\n        } else {\n          var options = a;\n\n          if ('shape' in options) {\n            var shape = options.shape;\n            radius = shape[0];\n          } else {\n            if ('radius' in options) {\n              radius = options.radius | 0;\n            }\n\n            if ('width' in options) {\n              radius = options.width | 0;\n\n              if ('height' in options) {}\n            } else if ('height' in options) {\n              radius = options.height | 0;\n            }\n          }\n\n          if ('color' in options || 'colors' in options) {\n            colorBuffer = options.color || options.colors;\n\n            if (Array.isArray(colorBuffer)) {}\n          }\n\n          if (!colorBuffer) {\n            if ('colorCount' in options) {\n              colorCount = options.colorCount | 0;\n            }\n\n            if ('colorType' in options) {\n              colorType = options.colorType;\n            }\n\n            if ('colorFormat' in options) {\n              colorFormat = options.colorFormat;\n            }\n          }\n\n          if ('depth' in options) {\n            params.depth = options.depth;\n          }\n\n          if ('stencil' in options) {\n            params.stencil = options.stencil;\n          }\n\n          if ('depthStencil' in options) {\n            params.depthStencil = options.depthStencil;\n          }\n        }\n\n        var colorCubes;\n\n        if (colorBuffer) {\n          if (Array.isArray(colorBuffer)) {\n            colorCubes = [];\n\n            for (i = 0; i < colorBuffer.length; ++i) {\n              colorCubes[i] = colorBuffer[i];\n            }\n          } else {\n            colorCubes = [colorBuffer];\n          }\n        } else {\n          colorCubes = Array(colorCount);\n          var cubeMapParams = {\n            radius: radius,\n            format: colorFormat,\n            type: colorType\n          };\n\n          for (i = 0; i < colorCount; ++i) {\n            colorCubes[i] = textureState.createCube(cubeMapParams);\n          }\n        } // Check color cubes\n\n\n        params.color = Array(colorCubes.length);\n\n        for (i = 0; i < colorCubes.length; ++i) {\n          var cube = colorCubes[i];\n          radius = radius || cube.width;\n          params.color[i] = {\n            target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,\n            data: colorCubes[i]\n          };\n        }\n\n        for (i = 0; i < 6; ++i) {\n          for (var j = 0; j < colorCubes.length; ++j) {\n            params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;\n          } // reuse depth-stencil attachments across all cube maps\n\n\n          if (i > 0) {\n            params.depth = faces[0].depth;\n            params.stencil = faces[0].stencil;\n            params.depthStencil = faces[0].depthStencil;\n          }\n\n          if (faces[i]) {\n            faces[i](params);\n          } else {\n            faces[i] = createFBO(params);\n          }\n        }\n\n        return extend(reglFramebufferCube, {\n          width: radius,\n          height: radius,\n          color: colorCubes\n        });\n      }\n\n      function resize(radius_) {\n        var i;\n        var radius = radius_ | 0;\n\n        if (radius === reglFramebufferCube.width) {\n          return reglFramebufferCube;\n        }\n\n        var colors = reglFramebufferCube.color;\n\n        for (i = 0; i < colors.length; ++i) {\n          colors[i].resize(radius);\n        }\n\n        for (i = 0; i < 6; ++i) {\n          faces[i].resize(radius);\n        }\n\n        reglFramebufferCube.width = reglFramebufferCube.height = radius;\n        return reglFramebufferCube;\n      }\n\n      reglFramebufferCube(options);\n      return extend(reglFramebufferCube, {\n        faces: faces,\n        resize: resize,\n        _reglType: 'framebufferCube',\n        destroy: function destroy() {\n          faces.forEach(function (f) {\n            f.destroy();\n          });\n        }\n      });\n    }\n\n    function restoreFramebuffers() {\n      framebufferState.cur = null;\n      framebufferState.next = null;\n      framebufferState.dirty = true;\n      values(framebufferSet).forEach(function (fb) {\n        fb.framebuffer = gl.createFramebuffer();\n        updateFramebuffer(fb);\n      });\n    }\n\n    return extend(framebufferState, {\n      getFramebuffer: function getFramebuffer(object) {\n        if (typeof object === 'function' && object._reglType === 'framebuffer') {\n          var fbo = object._framebuffer;\n\n          if (fbo instanceof REGLFramebuffer) {\n            return fbo;\n          }\n        }\n\n        return null;\n      },\n      create: createFBO,\n      createCube: createCubeFBO,\n      clear: function clear() {\n        values(framebufferSet).forEach(_destroy);\n      },\n      restore: restoreFramebuffers\n    });\n  }\n\n  var GL_FLOAT$5 = 5126;\n  var GL_ARRAY_BUFFER$1 = 34962;\n  var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;\n\n  function AttributeRecord() {\n    this.state = 0;\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    this.w = 0.0;\n    this.buffer = null;\n    this.size = 0;\n    this.normalized = false;\n    this.type = GL_FLOAT$5;\n    this.offset = 0;\n    this.stride = 0;\n    this.divisor = 0;\n  }\n\n  function wrapAttributeState(gl, extensions, limits, stats, bufferState, elementState, drawState) {\n    var NUM_ATTRIBUTES = limits.maxAttributes;\n    var attributeBindings = new Array(NUM_ATTRIBUTES);\n\n    for (var i = 0; i < NUM_ATTRIBUTES; ++i) {\n      attributeBindings[i] = new AttributeRecord();\n    }\n\n    var vaoCount = 0;\n    var vaoSet = {};\n    var state = {\n      Record: AttributeRecord,\n      scope: {},\n      state: attributeBindings,\n      currentVAO: null,\n      targetVAO: null,\n      restore: extVAO() ? restoreVAO : function () {},\n      createVAO: createVAO,\n      getVAO: getVAO,\n      destroyBuffer: destroyBuffer,\n      setVAO: extVAO() ? setVAOEXT : setVAOEmulated,\n      clear: extVAO() ? destroyVAOEXT : function () {}\n    };\n\n    function destroyBuffer(buffer) {\n      for (var i = 0; i < attributeBindings.length; ++i) {\n        var record = attributeBindings[i];\n\n        if (record.buffer === buffer) {\n          gl.disableVertexAttribArray(i);\n          record.buffer = null;\n        }\n      }\n    }\n\n    function extVAO() {\n      return extensions.oes_vertex_array_object;\n    }\n\n    function extInstanced() {\n      return extensions.angle_instanced_arrays;\n    }\n\n    function getVAO(vao) {\n      if (typeof vao === 'function' && vao._vao) {\n        return vao._vao;\n      }\n\n      return null;\n    }\n\n    function setVAOEXT(vao) {\n      if (vao === state.currentVAO) {\n        return;\n      }\n\n      var ext = extVAO();\n\n      if (vao) {\n        ext.bindVertexArrayOES(vao.vao);\n      } else {\n        ext.bindVertexArrayOES(null);\n      }\n\n      state.currentVAO = vao;\n    }\n\n    function setVAOEmulated(vao) {\n      if (vao === state.currentVAO) {\n        return;\n      }\n\n      if (vao) {\n        vao.bindAttrs();\n      } else {\n        var exti = extInstanced();\n\n        for (var i = 0; i < attributeBindings.length; ++i) {\n          var binding = attributeBindings[i];\n\n          if (binding.buffer) {\n            gl.enableVertexAttribArray(i);\n            binding.buffer.bind();\n            gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);\n\n            if (exti && binding.divisor) {\n              exti.vertexAttribDivisorANGLE(i, binding.divisor);\n            }\n          } else {\n            gl.disableVertexAttribArray(i);\n            gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w);\n          }\n        }\n\n        if (drawState.elements) {\n          gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer);\n        } else {\n          gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);\n        }\n      }\n\n      state.currentVAO = vao;\n    }\n\n    function destroyVAOEXT() {\n      values(vaoSet).forEach(function (vao) {\n        vao.destroy();\n      });\n    }\n\n    function REGLVAO() {\n      this.id = ++vaoCount;\n      this.attributes = [];\n      this.elements = null;\n      this.ownsElements = false;\n      this.count = 0;\n      this.offset = 0;\n      this.instances = -1;\n      this.primitive = 4;\n      var extension = extVAO();\n\n      if (extension) {\n        this.vao = extension.createVertexArrayOES();\n      } else {\n        this.vao = null;\n      }\n\n      vaoSet[this.id] = this;\n      this.buffers = [];\n    }\n\n    REGLVAO.prototype.bindAttrs = function () {\n      var exti = extInstanced();\n      var attributes = this.attributes;\n\n      for (var i = 0; i < attributes.length; ++i) {\n        var attr = attributes[i];\n\n        if (attr.buffer) {\n          gl.enableVertexAttribArray(i);\n          gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);\n          gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);\n\n          if (exti && attr.divisor) {\n            exti.vertexAttribDivisorANGLE(i, attr.divisor);\n          }\n        } else {\n          gl.disableVertexAttribArray(i);\n          gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w);\n        }\n      }\n\n      for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {\n        gl.disableVertexAttribArray(j);\n      }\n\n      var elements = elementState.getElements(this.elements);\n\n      if (elements) {\n        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer);\n      } else {\n        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);\n      }\n    };\n\n    REGLVAO.prototype.refresh = function () {\n      var ext = extVAO();\n\n      if (ext) {\n        ext.bindVertexArrayOES(this.vao);\n        this.bindAttrs();\n        state.currentVAO = null;\n        ext.bindVertexArrayOES(null);\n      }\n    };\n\n    REGLVAO.prototype.destroy = function () {\n      if (this.vao) {\n        var extension = extVAO();\n\n        if (this === state.currentVAO) {\n          state.currentVAO = null;\n          extension.bindVertexArrayOES(null);\n        }\n\n        extension.deleteVertexArrayOES(this.vao);\n        this.vao = null;\n      }\n\n      if (this.ownsElements) {\n        this.elements.destroy();\n        this.elements = null;\n        this.ownsElements = false;\n      }\n\n      if (vaoSet[this.id]) {\n        delete vaoSet[this.id];\n        stats.vaoCount -= 1;\n      }\n    };\n\n    function restoreVAO() {\n      var ext = extVAO();\n\n      if (ext) {\n        values(vaoSet).forEach(function (vao) {\n          vao.refresh();\n        });\n      }\n    }\n\n    function createVAO(_attr) {\n      var vao = new REGLVAO();\n      stats.vaoCount += 1;\n\n      function updateVAO(options) {\n        var attributes;\n\n        if (Array.isArray(options)) {\n          attributes = options;\n\n          if (vao.elements && vao.ownsElements) {\n            vao.elements.destroy();\n          }\n\n          vao.elements = null;\n          vao.ownsElements = false;\n          vao.offset = 0;\n          vao.count = 0;\n          vao.instances = -1;\n          vao.primitive = 4;\n        } else {\n          if (options.elements) {\n            var elements = options.elements;\n\n            if (vao.ownsElements) {\n              if (typeof elements === 'function' && elements._reglType === 'elements') {\n                vao.elements.destroy();\n                vao.ownsElements = false;\n              } else {\n                vao.elements(elements);\n                vao.ownsElements = false;\n              }\n            } else if (elementState.getElements(options.elements)) {\n              vao.elements = options.elements;\n              vao.ownsElements = false;\n            } else {\n              vao.elements = elementState.create(options.elements);\n              vao.ownsElements = true;\n            }\n          } else {\n            vao.elements = null;\n            vao.ownsElements = false;\n          }\n\n          attributes = options.attributes; // set default vao\n\n          vao.offset = 0;\n          vao.count = -1;\n          vao.instances = -1;\n          vao.primitive = 4; // copy element properties\n\n          if (vao.elements) {\n            vao.count = vao.elements._elements.vertCount;\n            vao.primitive = vao.elements._elements.primType;\n          }\n\n          if ('offset' in options) {\n            vao.offset = options.offset | 0;\n          }\n\n          if ('count' in options) {\n            vao.count = options.count | 0;\n          }\n\n          if ('instances' in options) {\n            vao.instances = options.instances | 0;\n          }\n\n          if ('primitive' in options) {\n            vao.primitive = primTypes[options.primitive];\n          }\n        }\n\n        var bufUpdated = {};\n        var nattributes = vao.attributes;\n        nattributes.length = attributes.length;\n\n        for (var i = 0; i < attributes.length; ++i) {\n          var spec = attributes[i];\n          var rec = nattributes[i] = new AttributeRecord();\n          var data = spec.data || spec;\n\n          if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {\n            var buf;\n\n            if (vao.buffers[i]) {\n              buf = vao.buffers[i];\n\n              if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {\n                buf.subdata(data);\n              } else {\n                buf.destroy();\n                vao.buffers[i] = null;\n              }\n            }\n\n            if (!vao.buffers[i]) {\n              buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);\n            }\n\n            rec.buffer = bufferState.getBuffer(buf);\n            rec.size = rec.buffer.dimension | 0;\n            rec.normalized = false;\n            rec.type = rec.buffer.dtype;\n            rec.offset = 0;\n            rec.stride = 0;\n            rec.divisor = 0;\n            rec.state = 1;\n            bufUpdated[i] = 1;\n          } else if (bufferState.getBuffer(spec)) {\n            rec.buffer = bufferState.getBuffer(spec);\n            rec.size = rec.buffer.dimension | 0;\n            rec.normalized = false;\n            rec.type = rec.buffer.dtype;\n            rec.offset = 0;\n            rec.stride = 0;\n            rec.divisor = 0;\n            rec.state = 1;\n          } else if (bufferState.getBuffer(spec.buffer)) {\n            rec.buffer = bufferState.getBuffer(spec.buffer);\n            rec.size = (+spec.size || rec.buffer.dimension) | 0;\n            rec.normalized = !!spec.normalized || false;\n\n            if ('type' in spec) {\n              rec.type = glTypes[spec.type];\n            } else {\n              rec.type = rec.buffer.dtype;\n            }\n\n            rec.offset = (spec.offset || 0) | 0;\n            rec.stride = (spec.stride || 0) | 0;\n            rec.divisor = (spec.divisor || 0) | 0;\n            rec.state = 1;\n          } else if ('x' in spec) {\n            rec.x = +spec.x || 0;\n            rec.y = +spec.y || 0;\n            rec.z = +spec.z || 0;\n            rec.w = +spec.w || 0;\n            rec.state = 2;\n          } else {}\n        } // retire unused buffers\n\n\n        for (var j = 0; j < vao.buffers.length; ++j) {\n          if (!bufUpdated[j] && vao.buffers[j]) {\n            vao.buffers[j].destroy();\n            vao.buffers[j] = null;\n          }\n        }\n\n        vao.refresh();\n        return updateVAO;\n      }\n\n      updateVAO.destroy = function () {\n        for (var j = 0; j < vao.buffers.length; ++j) {\n          if (vao.buffers[j]) {\n            vao.buffers[j].destroy();\n          }\n        }\n\n        vao.buffers.length = 0;\n\n        if (vao.ownsElements) {\n          vao.elements.destroy();\n          vao.elements = null;\n          vao.ownsElements = false;\n        }\n\n        vao.destroy();\n      };\n\n      updateVAO._vao = vao;\n      updateVAO._reglType = 'vao';\n      return updateVAO(_attr);\n    }\n\n    return state;\n  }\n\n  var GL_FRAGMENT_SHADER = 35632;\n  var GL_VERTEX_SHADER = 35633;\n  var GL_ACTIVE_UNIFORMS = 0x8B86;\n  var GL_ACTIVE_ATTRIBUTES = 0x8B89;\n\n  function wrapShaderState(gl, stringStore, stats, config) {\n    // ===================================================\n    // glsl compilation and linking\n    // ===================================================\n    var fragShaders = {};\n    var vertShaders = {};\n\n    function ActiveInfo(name, id, location, info) {\n      this.name = name;\n      this.id = id;\n      this.location = location;\n      this.info = info;\n    }\n\n    function insertActiveInfo(list, info) {\n      for (var i = 0; i < list.length; ++i) {\n        if (list[i].id === info.id) {\n          list[i].location = info.location;\n          return;\n        }\n      }\n\n      list.push(info);\n    }\n\n    function getShader(type, id, command) {\n      var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;\n      var shader = cache[id];\n\n      if (!shader) {\n        var source = stringStore.str(id);\n        shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        cache[id] = shader;\n      }\n\n      return shader;\n    } // ===================================================\n    // program linking\n    // ===================================================\n\n\n    var programCache = {};\n    var programList = [];\n    var PROGRAM_COUNTER = 0;\n\n    function REGLProgram(fragId, vertId) {\n      this.id = PROGRAM_COUNTER++;\n      this.fragId = fragId;\n      this.vertId = vertId;\n      this.program = null;\n      this.uniforms = [];\n      this.attributes = [];\n      this.refCount = 1;\n\n      if (config.profile) {\n        this.stats = {\n          uniformsCount: 0,\n          attributesCount: 0\n        };\n      }\n    }\n\n    function linkProgram(desc, command, attributeLocations) {\n      var i, info; // -------------------------------\n      // compile & link\n      // -------------------------------\n\n      var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);\n      var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);\n      var program = desc.program = gl.createProgram();\n      gl.attachShader(program, fragShader);\n      gl.attachShader(program, vertShader);\n\n      if (attributeLocations) {\n        for (i = 0; i < attributeLocations.length; ++i) {\n          var binding = attributeLocations[i];\n          gl.bindAttribLocation(program, binding[0], binding[1]);\n        }\n      }\n\n      gl.linkProgram(program); // -------------------------------\n      // grab uniforms\n      // -------------------------------\n\n      var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);\n\n      if (config.profile) {\n        desc.stats.uniformsCount = numUniforms;\n      }\n\n      var uniforms = desc.uniforms;\n\n      for (i = 0; i < numUniforms; ++i) {\n        info = gl.getActiveUniform(program, i);\n\n        if (info) {\n          if (info.size > 1) {\n            for (var j = 0; j < info.size; ++j) {\n              var name = info.name.replace('[0]', '[' + j + ']');\n              insertActiveInfo(uniforms, new ActiveInfo(name, stringStore.id(name), gl.getUniformLocation(program, name), info));\n            }\n          } else {\n            insertActiveInfo(uniforms, new ActiveInfo(info.name, stringStore.id(info.name), gl.getUniformLocation(program, info.name), info));\n          }\n        }\n      } // -------------------------------\n      // grab attributes\n      // -------------------------------\n\n\n      var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);\n\n      if (config.profile) {\n        desc.stats.attributesCount = numAttributes;\n      }\n\n      var attributes = desc.attributes;\n\n      for (i = 0; i < numAttributes; ++i) {\n        info = gl.getActiveAttrib(program, i);\n\n        if (info) {\n          insertActiveInfo(attributes, new ActiveInfo(info.name, stringStore.id(info.name), gl.getAttribLocation(program, info.name), info));\n        }\n      }\n    }\n\n    if (config.profile) {\n      stats.getMaxUniformsCount = function () {\n        var m = 0;\n        programList.forEach(function (desc) {\n          if (desc.stats.uniformsCount > m) {\n            m = desc.stats.uniformsCount;\n          }\n        });\n        return m;\n      };\n\n      stats.getMaxAttributesCount = function () {\n        var m = 0;\n        programList.forEach(function (desc) {\n          if (desc.stats.attributesCount > m) {\n            m = desc.stats.attributesCount;\n          }\n        });\n        return m;\n      };\n    }\n\n    function restoreShaders() {\n      fragShaders = {};\n      vertShaders = {};\n\n      for (var i = 0; i < programList.length; ++i) {\n        linkProgram(programList[i], null, programList[i].attributes.map(function (info) {\n          return [info.location, info.name];\n        }));\n      }\n    }\n\n    return {\n      clear: function clear() {\n        var deleteShader = gl.deleteShader.bind(gl);\n        values(fragShaders).forEach(deleteShader);\n        fragShaders = {};\n        values(vertShaders).forEach(deleteShader);\n        vertShaders = {};\n        programList.forEach(function (desc) {\n          gl.deleteProgram(desc.program);\n        });\n        programList.length = 0;\n        programCache = {};\n        stats.shaderCount = 0;\n      },\n      program: function program(vertId, fragId, command, attribLocations) {\n        var cache = programCache[fragId];\n\n        if (!cache) {\n          cache = programCache[fragId] = {};\n        }\n\n        var prevProgram = cache[vertId];\n\n        if (prevProgram) {\n          prevProgram.refCount++;\n\n          if (!attribLocations) {\n            return prevProgram;\n          }\n        }\n\n        var program = new REGLProgram(fragId, vertId);\n        stats.shaderCount++;\n        linkProgram(program, command, attribLocations);\n\n        if (!prevProgram) {\n          cache[vertId] = program;\n        }\n\n        programList.push(program);\n        return extend(program, {\n          destroy: function destroy() {\n            program.refCount--;\n\n            if (program.refCount <= 0) {\n              gl.deleteProgram(program.program);\n              var idx = programList.indexOf(program);\n              programList.splice(idx, 1);\n              stats.shaderCount--;\n            } // no program is linked to this vert anymore\n\n\n            if (cache[program.vertId].refCount <= 0) {\n              gl.deleteShader(vertShaders[program.vertId]);\n              delete vertShaders[program.vertId];\n              delete programCache[program.fragId][program.vertId];\n            } // no program is linked to this frag anymore\n\n\n            if (!Object.keys(programCache[program.fragId]).length) {\n              gl.deleteShader(fragShaders[program.fragId]);\n              delete fragShaders[program.fragId];\n              delete programCache[program.fragId];\n            }\n          }\n        });\n      },\n      restore: restoreShaders,\n      shader: getShader,\n      frag: -1,\n      vert: -1\n    };\n  }\n\n  var GL_RGBA$3 = 6408;\n  var GL_UNSIGNED_BYTE$6 = 5121;\n  var GL_PACK_ALIGNMENT = 0x0D05;\n  var GL_FLOAT$6 = 0x1406; // 5126\n\n  function wrapReadPixels(gl, framebufferState, reglPoll, context, glAttributes, extensions, limits) {\n    function readPixelsImpl(input) {\n      var type;\n\n      if (framebufferState.next === null) {\n        type = GL_UNSIGNED_BYTE$6;\n      } else {\n        type = framebufferState.next.colorAttachments[0].texture._texture.type;\n      }\n\n      var x = 0;\n      var y = 0;\n      var width = context.framebufferWidth;\n      var height = context.framebufferHeight;\n      var data = null;\n\n      if (isTypedArray(input)) {\n        data = input;\n      } else if (input) {\n        x = input.x | 0;\n        y = input.y | 0;\n        width = (input.width || context.framebufferWidth - x) | 0;\n        height = (input.height || context.framebufferHeight - y) | 0;\n        data = input.data || null;\n      } // sanity check input.data\n\n\n      if (data) {\n        if (type === GL_UNSIGNED_BYTE$6) {} else if (type === GL_FLOAT$6) {}\n      } // Update WebGL state\n\n\n      reglPoll(); // Compute size\n\n      var size = width * height * 4; // Allocate data\n\n      if (!data) {\n        if (type === GL_UNSIGNED_BYTE$6) {\n          data = new Uint8Array(size);\n        } else if (type === GL_FLOAT$6) {\n          data = data || new Float32Array(size);\n        }\n      } // Type check\n      // Run read pixels\n\n\n      gl.pixelStorei(GL_PACK_ALIGNMENT, 4);\n      gl.readPixels(x, y, width, height, GL_RGBA$3, type, data);\n      return data;\n    }\n\n    function readPixelsFBO(options) {\n      var result;\n      framebufferState.setFBO({\n        framebuffer: options.framebuffer\n      }, function () {\n        result = readPixelsImpl(options);\n      });\n      return result;\n    }\n\n    function readPixels(options) {\n      if (!options || !('framebuffer' in options)) {\n        return readPixelsImpl(options);\n      } else {\n        return readPixelsFBO(options);\n      }\n    }\n\n    return readPixels;\n  }\n  /*\n   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined\n   * in FIPS 180-2\n   * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.\n   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n   * Distributed under the BSD License\n   * See http://pajhome.org.uk/crypt/md5 for details.\n   * Also http://anmar.eu.org/projects/jssha2/\n   */\n\n  /*\n   * Configurable variables. You may need to tweak these to be compatible with\n   * the server-side, but the defaults work in most cases.\n   */\n\n\n  var hexcase = 0;\n  /* hex output format. 0 - lowercase; 1 - uppercase        */\n\n  var b64pad = \"\";\n  /* base-64 pad character. \"=\" for strict RFC compliance   */\n\n  /*\n   * These are the functions you'll usually want to call\n   * They take string arguments and return either hex or base-64 encoded strings\n   */\n\n  function hex_sha256(s) {\n    return rstr2hex(rstr_sha256(str2rstr_utf8(s)));\n  }\n  /*\n   * Calculate the sha256 of a raw string\n   */\n\n\n  function rstr_sha256(s) {\n    return binb2rstr(binb_sha256(rstr2binb(s), s.length * 8));\n  }\n  /*\n   * Calculate the HMAC-sha256 of a key and some data (raw strings)\n   */\n\n\n  function rstr_hmac_sha256(key, data) {\n    var bkey = rstr2binb(key);\n    if (bkey.length > 16) bkey = binb_sha256(bkey, key.length * 8);\n    var ipad = Array(16),\n        opad = Array(16);\n\n    for (var i = 0; i < 16; i++) {\n      ipad[i] = bkey[i] ^ 0x36363636;\n      opad[i] = bkey[i] ^ 0x5C5C5C5C;\n    }\n\n    var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\n    return binb2rstr(binb_sha256(opad.concat(hash), 512 + 256));\n  }\n  /*\n   * Convert a raw string to a hex string\n   */\n\n\n  function rstr2hex(input) {\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n    var output = \"\";\n    var x;\n\n    for (var i = 0; i < input.length; i++) {\n      x = input.charCodeAt(i);\n      output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);\n    }\n\n    return output;\n  }\n  /*\n   * Convert a raw string to a base-64 string\n   */\n\n\n  function rstr2b64(input) {\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    var output = \"\";\n    var len = input.length;\n\n    for (var i = 0; i < len; i += 3) {\n      var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);\n\n      for (var j = 0; j < 4; j++) {\n        if (i * 8 + j * 6 > input.length * 8) output += b64pad;else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);\n      }\n    }\n\n    return output;\n  }\n  /*\n   * Convert a raw string to an arbitrary string encoding\n   */\n\n\n  function rstr2any(input, encoding) {\n    var divisor = encoding.length;\n    var remainders = Array();\n    var i, q, x, quotient;\n    /* Convert to an array of 16-bit big-endian values, forming the dividend */\n\n    var dividend = Array(Math.ceil(input.length / 2));\n\n    for (i = 0; i < dividend.length; i++) {\n      dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);\n    }\n    /*\n     * Repeatedly perform a long division. The binary array forms the dividend,\n     * the length of the encoding is the divisor. Once computed, the quotient\n     * forms the dividend for the next step. We stop when the dividend is zero.\n     * All remainders are stored for later use.\n     */\n\n\n    while (dividend.length > 0) {\n      quotient = Array();\n      x = 0;\n\n      for (i = 0; i < dividend.length; i++) {\n        x = (x << 16) + dividend[i];\n        q = Math.floor(x / divisor);\n        x -= q * divisor;\n        if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;\n      }\n\n      remainders[remainders.length] = x;\n      dividend = quotient;\n    }\n    /* Convert the remainders to the output string */\n\n\n    var output = \"\";\n\n    for (i = remainders.length - 1; i >= 0; i--) {\n      output += encoding.charAt(remainders[i]);\n    }\n    /* Append leading zero equivalents */\n\n\n    var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));\n\n    for (i = output.length; i < full_length; i++) {\n      output = encoding[0] + output;\n    }\n\n    return output;\n  }\n  /*\n   * Encode a string as utf-8.\n   * For efficiency, this assumes the input is valid utf-16.\n   */\n\n\n  function str2rstr_utf8(input) {\n    var output = \"\";\n    var i = -1;\n    var x, y;\n\n    while (++i < input.length) {\n      /* Decode utf-16 surrogate pairs */\n      x = input.charCodeAt(i);\n      y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\n\n      if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {\n        x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\n        i++;\n      }\n      /* Encode output as utf-8 */\n\n\n      if (x <= 0x7F) output += String.fromCharCode(x);else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);\n    }\n\n    return output;\n  }\n  /*\n   * Convert a raw string to an array of big-endian words\n   * Characters >255 have their high-byte silently ignored.\n   */\n\n\n  function rstr2binb(input) {\n    var output = Array(input.length >> 2);\n\n    for (var i = 0; i < output.length; i++) {\n      output[i] = 0;\n    }\n\n    for (var i = 0; i < input.length * 8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;\n    }\n\n    return output;\n  }\n  /*\n   * Convert an array of big-endian words to a string\n   */\n\n\n  function binb2rstr(input) {\n    var output = \"\";\n\n    for (var i = 0; i < input.length * 32; i += 8) {\n      output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);\n    }\n\n    return output;\n  }\n  /*\n   * Main sha256 function, with its support functions\n   */\n\n\n  function sha256_S(X, n) {\n    return X >>> n | X << 32 - n;\n  }\n\n  function sha256_R(X, n) {\n    return X >>> n;\n  }\n\n  function sha256_Ch(x, y, z) {\n    return x & y ^ ~x & z;\n  }\n\n  function sha256_Maj(x, y, z) {\n    return x & y ^ x & z ^ y & z;\n  }\n\n  function sha256_Sigma0256(x) {\n    return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);\n  }\n\n  function sha256_Sigma1256(x) {\n    return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);\n  }\n\n  function sha256_Gamma0256(x) {\n    return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);\n  }\n\n  function sha256_Gamma1256(x) {\n    return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);\n  }\n\n  var sha256_K = new Array(1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998);\n\n  function binb_sha256(m, l) {\n    var HASH = new Array(1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, 528734635, 1541459225);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h;\n    var i, j, T1, T2;\n    /* append padding */\n\n    m[l >> 5] |= 0x80 << 24 - l % 32;\n    m[(l + 64 >> 9 << 4) + 15] = l;\n\n    for (i = 0; i < m.length; i += 16) {\n      a = HASH[0];\n      b = HASH[1];\n      c = HASH[2];\n      d = HASH[3];\n      e = HASH[4];\n      f = HASH[5];\n      g = HASH[6];\n      h = HASH[7];\n\n      for (j = 0; j < 64; j++) {\n        if (j < 16) W[j] = m[j + i];else W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]), sha256_Gamma0256(W[j - 15])), W[j - 16]);\n        T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)), sha256_K[j]), W[j]);\n        T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));\n        h = g;\n        g = f;\n        f = e;\n        e = safe_add(d, T1);\n        d = c;\n        c = b;\n        b = a;\n        a = safe_add(T1, T2);\n      }\n\n      HASH[0] = safe_add(a, HASH[0]);\n      HASH[1] = safe_add(b, HASH[1]);\n      HASH[2] = safe_add(c, HASH[2]);\n      HASH[3] = safe_add(d, HASH[3]);\n      HASH[4] = safe_add(e, HASH[4]);\n      HASH[5] = safe_add(f, HASH[5]);\n      HASH[6] = safe_add(g, HASH[6]);\n      HASH[7] = safe_add(h, HASH[7]);\n    }\n\n    return HASH;\n  }\n\n  function safe_add(x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return msw << 16 | lsw & 0xFFFF;\n  }\n\n  function slice(x) {\n    return Array.prototype.slice.call(x);\n  }\n\n  function join(x) {\n    return slice(x).join('');\n  }\n\n  function createEnvironment(options) {\n    var cache = options && options.cache; // Unique variable id counter\n\n    var varCounter = 0; // Linked values are passed from this scope into the generated code block\n    // Calling link() passes a value into the generated scope and returns\n    // the variable name which it is bound to\n\n    var linkedNames = [];\n    var linkedValues = [];\n    var isStable = [];\n\n    function link(value, options) {\n      var stable = options && options.stable;\n\n      if (!stable) {\n        for (var i = 0; i < linkedValues.length; ++i) {\n          if (linkedValues[i] === value && !isStable[i]) {\n            return linkedNames[i];\n          }\n        }\n      }\n\n      var name = 'g' + varCounter++;\n      linkedNames.push(name);\n      linkedValues.push(value);\n      isStable.push(stable);\n      return name;\n    } // create a code block\n\n\n    function block() {\n      var code = [];\n\n      function push() {\n        code.push.apply(code, slice(arguments));\n      }\n\n      var vars = [];\n\n      function def() {\n        var name = 'v' + varCounter++;\n        vars.push(name);\n\n        if (arguments.length > 0) {\n          code.push(name, '=');\n          code.push.apply(code, slice(arguments));\n          code.push(';');\n        }\n\n        return name;\n      }\n\n      return extend(push, {\n        def: def,\n        toString: function toString() {\n          return join([vars.length > 0 ? 'var ' + vars.join(',') + ';' : '', join(code)]);\n        }\n      });\n    }\n\n    function scope() {\n      var entry = block();\n      var exit = block();\n      var entryToString = entry.toString;\n      var exitToString = exit.toString;\n\n      function save(object, prop) {\n        exit(object, prop, '=', entry.def(object, prop), ';');\n      }\n\n      return extend(function () {\n        entry.apply(entry, slice(arguments));\n      }, {\n        def: entry.def,\n        entry: entry,\n        exit: exit,\n        save: save,\n        set: function set(object, prop, value) {\n          save(object, prop);\n          entry(object, prop, '=', value, ';');\n        },\n        toString: function toString() {\n          return entryToString() + exitToString();\n        }\n      });\n    }\n\n    function conditional() {\n      var pred = join(arguments);\n      var thenBlock = scope();\n      var elseBlock = scope();\n      var thenToString = thenBlock.toString;\n      var elseToString = elseBlock.toString;\n      return extend(thenBlock, {\n        then: function then() {\n          thenBlock.apply(thenBlock, slice(arguments));\n          return this;\n        },\n        else: function _else() {\n          elseBlock.apply(elseBlock, slice(arguments));\n          return this;\n        },\n        toString: function toString() {\n          var elseClause = elseToString();\n\n          if (elseClause) {\n            elseClause = 'else{' + elseClause + '}';\n          }\n\n          return join(['if(', pred, '){', thenToString(), '}', elseClause]);\n        }\n      });\n    } // procedure list\n\n\n    var globalBlock = block();\n    var procedures = {};\n\n    function proc(name, count) {\n      var args = [];\n\n      function arg() {\n        var name = 'a' + args.length;\n        args.push(name);\n        return name;\n      }\n\n      count = count || 0;\n\n      for (var i = 0; i < count; ++i) {\n        arg();\n      }\n\n      var body = scope();\n      var bodyToString = body.toString;\n      var result = procedures[name] = extend(body, {\n        arg: arg,\n        toString: function toString() {\n          return join(['function(', args.join(), '){', bodyToString(), '}']);\n        }\n      });\n      return result;\n    }\n\n    function compile() {\n      var code = ['\"use strict\";', globalBlock, 'return {'];\n      Object.keys(procedures).forEach(function (name) {\n        code.push('\"', name, '\":', procedures[name].toString(), ',');\n      });\n      code.push('}');\n      var src = join(code).replace(/;/g, ';\\n').replace(/}/g, '}\\n').replace(/{/g, '{\\n');\n      var key;\n\n      if (cache) {\n        key = hex_sha256(src);\n\n        if (cache[key]) {\n          return cache[key].apply(null, linkedValues);\n        }\n      }\n\n      var proc = Function.apply(null, linkedNames.concat(src));\n\n      if (cache) {\n        cache[key] = proc;\n      }\n\n      return proc.apply(null, linkedValues);\n    }\n\n    return {\n      global: globalBlock,\n      link: link,\n      block: block,\n      proc: proc,\n      scope: scope,\n      cond: conditional,\n      compile: compile\n    };\n  } // \"cute\" names for vector components\n\n\n  var CUTE_COMPONENTS = 'xyzw'.split('');\n  var GL_UNSIGNED_BYTE$7 = 5121;\n  var ATTRIB_STATE_POINTER = 1;\n  var ATTRIB_STATE_CONSTANT = 2;\n  var DYN_FUNC$1 = 0;\n  var DYN_PROP$1 = 1;\n  var DYN_CONTEXT$1 = 2;\n  var DYN_STATE$1 = 3;\n  var DYN_THUNK = 4;\n  var DYN_CONSTANT$1 = 5;\n  var DYN_ARRAY$1 = 6;\n  var S_DITHER = 'dither';\n  var S_BLEND_ENABLE = 'blend.enable';\n  var S_BLEND_COLOR = 'blend.color';\n  var S_BLEND_EQUATION = 'blend.equation';\n  var S_BLEND_FUNC = 'blend.func';\n  var S_DEPTH_ENABLE = 'depth.enable';\n  var S_DEPTH_FUNC = 'depth.func';\n  var S_DEPTH_RANGE = 'depth.range';\n  var S_DEPTH_MASK = 'depth.mask';\n  var S_COLOR_MASK = 'colorMask';\n  var S_CULL_ENABLE = 'cull.enable';\n  var S_CULL_FACE = 'cull.face';\n  var S_FRONT_FACE = 'frontFace';\n  var S_LINE_WIDTH = 'lineWidth';\n  var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';\n  var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';\n  var S_SAMPLE_ALPHA = 'sample.alpha';\n  var S_SAMPLE_ENABLE = 'sample.enable';\n  var S_SAMPLE_COVERAGE = 'sample.coverage';\n  var S_STENCIL_ENABLE = 'stencil.enable';\n  var S_STENCIL_MASK = 'stencil.mask';\n  var S_STENCIL_FUNC = 'stencil.func';\n  var S_STENCIL_OPFRONT = 'stencil.opFront';\n  var S_STENCIL_OPBACK = 'stencil.opBack';\n  var S_SCISSOR_ENABLE = 'scissor.enable';\n  var S_SCISSOR_BOX = 'scissor.box';\n  var S_VIEWPORT = 'viewport';\n  var S_PROFILE = 'profile';\n  var S_FRAMEBUFFER = 'framebuffer';\n  var S_VERT = 'vert';\n  var S_FRAG = 'frag';\n  var S_ELEMENTS = 'elements';\n  var S_PRIMITIVE = 'primitive';\n  var S_COUNT = 'count';\n  var S_OFFSET = 'offset';\n  var S_INSTANCES = 'instances';\n  var S_VAO = 'vao';\n  var SUFFIX_WIDTH = 'Width';\n  var SUFFIX_HEIGHT = 'Height';\n  var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;\n  var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;\n  var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;\n  var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;\n  var S_DRAWINGBUFFER = 'drawingBuffer';\n  var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;\n  var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;\n  var NESTED_OPTIONS = [S_BLEND_FUNC, S_BLEND_EQUATION, S_STENCIL_FUNC, S_STENCIL_OPFRONT, S_STENCIL_OPBACK, S_SAMPLE_COVERAGE, S_VIEWPORT, S_SCISSOR_BOX, S_POLYGON_OFFSET_OFFSET];\n  var GL_ARRAY_BUFFER$2 = 34962;\n  var GL_ELEMENT_ARRAY_BUFFER$2 = 34963;\n  var GL_CULL_FACE = 0x0B44;\n  var GL_BLEND = 0x0BE2;\n  var GL_DITHER = 0x0BD0;\n  var GL_STENCIL_TEST = 0x0B90;\n  var GL_DEPTH_TEST = 0x0B71;\n  var GL_SCISSOR_TEST = 0x0C11;\n  var GL_POLYGON_OFFSET_FILL = 0x8037;\n  var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;\n  var GL_SAMPLE_COVERAGE = 0x80A0;\n  var GL_FLOAT$7 = 5126;\n  var GL_FLOAT_VEC2 = 35664;\n  var GL_FLOAT_VEC3 = 35665;\n  var GL_FLOAT_VEC4 = 35666;\n  var GL_INT$2 = 5124;\n  var GL_INT_VEC2 = 35667;\n  var GL_INT_VEC3 = 35668;\n  var GL_INT_VEC4 = 35669;\n  var GL_BOOL = 35670;\n  var GL_BOOL_VEC2 = 35671;\n  var GL_BOOL_VEC3 = 35672;\n  var GL_BOOL_VEC4 = 35673;\n  var GL_FLOAT_MAT2 = 35674;\n  var GL_FLOAT_MAT3 = 35675;\n  var GL_FLOAT_MAT4 = 35676;\n  var GL_SAMPLER_2D = 35678;\n  var GL_SAMPLER_CUBE = 35680;\n  var GL_TRIANGLES$1 = 4;\n  var GL_FRONT = 1028;\n  var GL_BACK = 1029;\n  var GL_CW = 0x0900;\n  var GL_CCW = 0x0901;\n  var GL_MIN_EXT = 0x8007;\n  var GL_MAX_EXT = 0x8008;\n  var GL_ALWAYS = 519;\n  var GL_KEEP = 7680;\n  var GL_ZERO = 0;\n  var GL_ONE = 1;\n  var GL_FUNC_ADD = 0x8006;\n  var GL_LESS = 513;\n  var GL_FRAMEBUFFER$2 = 0x8D40;\n  var GL_COLOR_ATTACHMENT0$2 = 0x8CE0;\n  var blendFuncs = {\n    '0': 0,\n    '1': 1,\n    'zero': 0,\n    'one': 1,\n    'src color': 768,\n    'one minus src color': 769,\n    'src alpha': 770,\n    'one minus src alpha': 771,\n    'dst color': 774,\n    'one minus dst color': 775,\n    'dst alpha': 772,\n    'one minus dst alpha': 773,\n    'constant color': 32769,\n    'one minus constant color': 32770,\n    'constant alpha': 32771,\n    'one minus constant alpha': 32772,\n    'src alpha saturate': 776\n  };\n  var compareFuncs = {\n    'never': 512,\n    'less': 513,\n    '<': 513,\n    'equal': 514,\n    '=': 514,\n    '==': 514,\n    '===': 514,\n    'lequal': 515,\n    '<=': 515,\n    'greater': 516,\n    '>': 516,\n    'notequal': 517,\n    '!=': 517,\n    '!==': 517,\n    'gequal': 518,\n    '>=': 518,\n    'always': 519\n  };\n  var stencilOps = {\n    '0': 0,\n    'zero': 0,\n    'keep': 7680,\n    'replace': 7681,\n    'increment': 7682,\n    'decrement': 7683,\n    'increment wrap': 34055,\n    'decrement wrap': 34056,\n    'invert': 5386\n  };\n  var orientationType = {\n    'cw': GL_CW,\n    'ccw': GL_CCW\n  };\n\n  function isBufferArgs(x) {\n    return Array.isArray(x) || isTypedArray(x) || isNDArrayLike(x);\n  } // Make sure viewport is processed first\n\n\n  function sortState(state) {\n    return state.sort(function (a, b) {\n      if (a === S_VIEWPORT) {\n        return -1;\n      } else if (b === S_VIEWPORT) {\n        return 1;\n      }\n\n      return a < b ? -1 : 1;\n    });\n  }\n\n  function Declaration(thisDep, contextDep, propDep, append) {\n    this.thisDep = thisDep;\n    this.contextDep = contextDep;\n    this.propDep = propDep;\n    this.append = append;\n  }\n\n  function isStatic(decl) {\n    return decl && !(decl.thisDep || decl.contextDep || decl.propDep);\n  }\n\n  function createStaticDecl(append) {\n    return new Declaration(false, false, false, append);\n  }\n\n  function createDynamicDecl(dyn, append) {\n    var type = dyn.type;\n\n    if (type === DYN_FUNC$1) {\n      var numArgs = dyn.data.length;\n      return new Declaration(true, numArgs >= 1, numArgs >= 2, append);\n    } else if (type === DYN_THUNK) {\n      var data = dyn.data;\n      return new Declaration(data.thisDep, data.contextDep, data.propDep, append);\n    } else if (type === DYN_CONSTANT$1) {\n      return new Declaration(false, false, false, append);\n    } else if (type === DYN_ARRAY$1) {\n      var thisDep = false;\n      var contextDep = false;\n      var propDep = false;\n\n      for (var i = 0; i < dyn.data.length; ++i) {\n        var subDyn = dyn.data[i];\n\n        if (subDyn.type === DYN_PROP$1) {\n          propDep = true;\n        } else if (subDyn.type === DYN_CONTEXT$1) {\n          contextDep = true;\n        } else if (subDyn.type === DYN_STATE$1) {\n          thisDep = true;\n        } else if (subDyn.type === DYN_FUNC$1) {\n          thisDep = true;\n          var subArgs = subDyn.data;\n\n          if (subArgs >= 1) {\n            contextDep = true;\n          }\n\n          if (subArgs >= 2) {\n            propDep = true;\n          }\n        } else if (subDyn.type === DYN_THUNK) {\n          thisDep = thisDep || subDyn.data.thisDep;\n          contextDep = contextDep || subDyn.data.contextDep;\n          propDep = propDep || subDyn.data.propDep;\n        }\n      }\n\n      return new Declaration(thisDep, contextDep, propDep, append);\n    } else {\n      return new Declaration(type === DYN_STATE$1, type === DYN_CONTEXT$1, type === DYN_PROP$1, append);\n    }\n  }\n\n  var SCOPE_DECL = new Declaration(false, false, false, function () {});\n\n  function reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, cachedCode, config) {\n    var AttributeRecord = attributeState.Record;\n    var blendEquations = {\n      'add': 32774,\n      'subtract': 32778,\n      'reverse subtract': 32779\n    };\n\n    if (extensions.ext_blend_minmax) {\n      blendEquations.min = GL_MIN_EXT;\n      blendEquations.max = GL_MAX_EXT;\n    }\n\n    var extInstancing = extensions.angle_instanced_arrays;\n    var extDrawBuffers = extensions.webgl_draw_buffers;\n    var extVertexArrays = extensions.oes_vertex_array_object; // ===================================================\n    // ===================================================\n    // WEBGL STATE\n    // ===================================================\n    // ===================================================\n\n    var currentState = {\n      dirty: true,\n      profile: config.profile\n    };\n    var nextState = {};\n    var GL_STATE_NAMES = [];\n    var GL_FLAGS = {};\n    var GL_VARIABLES = {};\n\n    function propName(name) {\n      return name.replace('.', '_');\n    }\n\n    function stateFlag(sname, cap, init) {\n      var name = propName(sname);\n      GL_STATE_NAMES.push(sname);\n      nextState[name] = currentState[name] = !!init;\n      GL_FLAGS[name] = cap;\n    }\n\n    function stateVariable(sname, func, init) {\n      var name = propName(sname);\n      GL_STATE_NAMES.push(sname);\n\n      if (Array.isArray(init)) {\n        currentState[name] = init.slice();\n        nextState[name] = init.slice();\n      } else {\n        currentState[name] = nextState[name] = init;\n      }\n\n      GL_VARIABLES[name] = func;\n    }\n\n    function hasVariableReference(exp) {\n      if (!isNaN(exp)) {\n        return false;\n      } // strengthen this function if variable values can be non-(null/number) literals.\n\n\n      return true;\n    } // Dithering\n\n\n    stateFlag(S_DITHER, GL_DITHER); // Blending\n\n    stateFlag(S_BLEND_ENABLE, GL_BLEND);\n    stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);\n    stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate', [GL_FUNC_ADD, GL_FUNC_ADD]);\n    stateVariable(S_BLEND_FUNC, 'blendFuncSeparate', [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]); // Depth\n\n    stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);\n    stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);\n    stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);\n    stateVariable(S_DEPTH_MASK, 'depthMask', true); // Color mask\n\n    stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]); // Face culling\n\n    stateFlag(S_CULL_ENABLE, GL_CULL_FACE);\n    stateVariable(S_CULL_FACE, 'cullFace', GL_BACK); // Front face orientation\n\n    stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW); // Line width\n\n    stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1); // Polygon offset\n\n    stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);\n    stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]); // Sample coverage\n\n    stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);\n    stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);\n    stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]); // Stencil\n\n    stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);\n    stateVariable(S_STENCIL_MASK, 'stencilMask', -1);\n    stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);\n    stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate', [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);\n    stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate', [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]); // Scissor\n\n    stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);\n    stateVariable(S_SCISSOR_BOX, 'scissor', [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]); // Viewport\n\n    stateVariable(S_VIEWPORT, S_VIEWPORT, [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]); // ===================================================\n    // ===================================================\n    // ENVIRONMENT\n    // ===================================================\n    // ===================================================\n\n    var sharedState = {\n      gl: gl,\n      context: contextState,\n      strings: stringStore,\n      next: nextState,\n      current: currentState,\n      draw: drawState,\n      elements: elementState,\n      buffer: bufferState,\n      shader: shaderState,\n      attributes: attributeState.state,\n      vao: attributeState,\n      uniforms: uniformState,\n      framebuffer: framebufferState,\n      extensions: extensions,\n      timer: timer,\n      isBufferArgs: isBufferArgs\n    };\n    var sharedConstants = {\n      primTypes: primTypes,\n      compareFuncs: compareFuncs,\n      blendFuncs: blendFuncs,\n      blendEquations: blendEquations,\n      stencilOps: stencilOps,\n      glTypes: glTypes,\n      orientationType: orientationType\n    };\n\n    if (extDrawBuffers) {\n      sharedConstants.backBuffer = [GL_BACK];\n      sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {\n        if (i === 0) {\n          return [0];\n        }\n\n        return loop(i, function (j) {\n          return GL_COLOR_ATTACHMENT0$2 + j;\n        });\n      });\n    }\n\n    var drawCallCounter = 0;\n\n    function createREGLEnvironment() {\n      var env = createEnvironment({\n        cache: cachedCode\n      });\n      var link = env.link;\n      var global = env.global;\n      env.id = drawCallCounter++;\n      env.batchId = '0'; // link shared state\n\n      var SHARED = link(sharedState);\n      var shared = env.shared = {\n        props: 'a0'\n      };\n      Object.keys(sharedState).forEach(function (prop) {\n        shared[prop] = global.def(SHARED, '.', prop);\n      }); // Inject runtime assertion stuff for debug builds\n      // Copy GL state variables over\n\n      var nextVars = env.next = {};\n      var currentVars = env.current = {};\n      Object.keys(GL_VARIABLES).forEach(function (variable) {\n        if (Array.isArray(currentState[variable])) {\n          nextVars[variable] = global.def(shared.next, '.', variable);\n          currentVars[variable] = global.def(shared.current, '.', variable);\n        }\n      }); // Initialize shared constants\n\n      var constants = env.constants = {};\n      Object.keys(sharedConstants).forEach(function (name) {\n        constants[name] = global.def(JSON.stringify(sharedConstants[name]));\n      }); // Helper function for calling a block\n\n      env.invoke = function (block, x) {\n        switch (x.type) {\n          case DYN_FUNC$1:\n            var argList = ['this', shared.context, shared.props, env.batchId];\n            return block.def(link(x.data), '.call(', argList.slice(0, Math.max(x.data.length + 1, 4)), ')');\n\n          case DYN_PROP$1:\n            return block.def(shared.props, x.data);\n\n          case DYN_CONTEXT$1:\n            return block.def(shared.context, x.data);\n\n          case DYN_STATE$1:\n            return block.def('this', x.data);\n\n          case DYN_THUNK:\n            x.data.append(env, block);\n            return x.data.ref;\n\n          case DYN_CONSTANT$1:\n            return x.data.toString();\n\n          case DYN_ARRAY$1:\n            return x.data.map(function (y) {\n              return env.invoke(block, y);\n            });\n        }\n      };\n\n      env.attribCache = {};\n      var scopeAttribs = {};\n\n      env.scopeAttrib = function (name) {\n        var id = stringStore.id(name);\n\n        if (id in scopeAttribs) {\n          return scopeAttribs[id];\n        }\n\n        var binding = attributeState.scope[id];\n\n        if (!binding) {\n          binding = attributeState.scope[id] = new AttributeRecord();\n        }\n\n        var result = scopeAttribs[id] = link(binding);\n        return result;\n      };\n\n      return env;\n    } // ===================================================\n    // ===================================================\n    // PARSING\n    // ===================================================\n    // ===================================================\n\n\n    function parseProfile(options) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n      var profileEnable;\n\n      if (S_PROFILE in staticOptions) {\n        var value = !!staticOptions[S_PROFILE];\n        profileEnable = createStaticDecl(function (env, scope) {\n          return value;\n        });\n        profileEnable.enable = value;\n      } else if (S_PROFILE in dynamicOptions) {\n        var dyn = dynamicOptions[S_PROFILE];\n        profileEnable = createDynamicDecl(dyn, function (env, scope) {\n          return env.invoke(scope, dyn);\n        });\n      }\n\n      return profileEnable;\n    }\n\n    function parseFramebuffer(options, env) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n\n      if (S_FRAMEBUFFER in staticOptions) {\n        var framebuffer = staticOptions[S_FRAMEBUFFER];\n\n        if (framebuffer) {\n          framebuffer = framebufferState.getFramebuffer(framebuffer);\n          return createStaticDecl(function (env, block) {\n            var FRAMEBUFFER = env.link(framebuffer);\n            var shared = env.shared;\n            block.set(shared.framebuffer, '.next', FRAMEBUFFER);\n            var CONTEXT = shared.context;\n            block.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '.width');\n            block.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '.height');\n            return FRAMEBUFFER;\n          });\n        } else {\n          return createStaticDecl(function (env, scope) {\n            var shared = env.shared;\n            scope.set(shared.framebuffer, '.next', 'null');\n            var CONTEXT = shared.context;\n            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);\n            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);\n            return 'null';\n          });\n        }\n      } else if (S_FRAMEBUFFER in dynamicOptions) {\n        var dyn = dynamicOptions[S_FRAMEBUFFER];\n        return createDynamicDecl(dyn, function (env, scope) {\n          var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);\n          var shared = env.shared;\n          var FRAMEBUFFER_STATE = shared.framebuffer;\n          var FRAMEBUFFER = scope.def(FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');\n          scope.set(FRAMEBUFFER_STATE, '.next', FRAMEBUFFER);\n          var CONTEXT = shared.context;\n          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' + CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);\n          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '?' + FRAMEBUFFER + '.height:' + CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);\n          return FRAMEBUFFER;\n        });\n      } else {\n        return null;\n      }\n    }\n\n    function parseViewportScissor(options, framebuffer, env) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n\n      function parseBox(param) {\n        if (param in staticOptions) {\n          var box = staticOptions[param];\n          var isStatic = true;\n          var x = box.x | 0;\n          var y = box.y | 0;\n          var w, h;\n\n          if ('width' in box) {\n            w = box.width | 0;\n          } else {\n            isStatic = false;\n          }\n\n          if ('height' in box) {\n            h = box.height | 0;\n          } else {\n            isStatic = false;\n          }\n\n          return new Declaration(!isStatic && framebuffer && framebuffer.thisDep, !isStatic && framebuffer && framebuffer.contextDep, !isStatic && framebuffer && framebuffer.propDep, function (env, scope) {\n            var CONTEXT = env.shared.context;\n            var BOX_W = w;\n\n            if (!('width' in box)) {\n              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);\n            }\n\n            var BOX_H = h;\n\n            if (!('height' in box)) {\n              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);\n            }\n\n            return [x, y, BOX_W, BOX_H];\n          });\n        } else if (param in dynamicOptions) {\n          var dynBox = dynamicOptions[param];\n          var result = createDynamicDecl(dynBox, function (env, scope) {\n            var BOX = env.invoke(scope, dynBox);\n            var CONTEXT = env.shared.context;\n            var BOX_X = scope.def(BOX, '.x|0');\n            var BOX_Y = scope.def(BOX, '.y|0');\n            var BOX_W = scope.def('\"width\" in ', BOX, '?', BOX, '.width|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');\n            var BOX_H = scope.def('\"height\" in ', BOX, '?', BOX, '.height|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');\n            return [BOX_X, BOX_Y, BOX_W, BOX_H];\n          });\n\n          if (framebuffer) {\n            result.thisDep = result.thisDep || framebuffer.thisDep;\n            result.contextDep = result.contextDep || framebuffer.contextDep;\n            result.propDep = result.propDep || framebuffer.propDep;\n          }\n\n          return result;\n        } else if (framebuffer) {\n          return new Declaration(framebuffer.thisDep, framebuffer.contextDep, framebuffer.propDep, function (env, scope) {\n            var CONTEXT = env.shared.context;\n            return [0, 0, scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH), scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)];\n          });\n        } else {\n          return null;\n        }\n      }\n\n      var viewport = parseBox(S_VIEWPORT);\n\n      if (viewport) {\n        var prevViewport = viewport;\n        viewport = new Declaration(viewport.thisDep, viewport.contextDep, viewport.propDep, function (env, scope) {\n          var VIEWPORT = prevViewport.append(env, scope);\n          var CONTEXT = env.shared.context;\n          scope.set(CONTEXT, '.' + S_VIEWPORT_WIDTH, VIEWPORT[2]);\n          scope.set(CONTEXT, '.' + S_VIEWPORT_HEIGHT, VIEWPORT[3]);\n          return VIEWPORT;\n        });\n      }\n\n      return {\n        viewport: viewport,\n        scissor_box: parseBox(S_SCISSOR_BOX)\n      };\n    }\n\n    function parseAttribLocations(options, attributes) {\n      var staticOptions = options.static;\n      var staticProgram = typeof staticOptions[S_FRAG] === 'string' && typeof staticOptions[S_VERT] === 'string';\n\n      if (staticProgram) {\n        if (Object.keys(attributes.dynamic).length > 0) {\n          return null;\n        }\n\n        var staticAttributes = attributes.static;\n        var sAttributes = Object.keys(staticAttributes);\n\n        if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {\n          var bindings = [];\n\n          for (var i = 0; i < sAttributes.length; ++i) {\n            bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]]);\n          }\n\n          return bindings;\n        }\n      }\n\n      return null;\n    }\n\n    function parseProgram(options, env, attribLocations) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n\n      function parseShader(name) {\n        if (name in staticOptions) {\n          var id = stringStore.id(staticOptions[name]);\n          var result = createStaticDecl(function () {\n            return id;\n          });\n          result.id = id;\n          return result;\n        } else if (name in dynamicOptions) {\n          var dyn = dynamicOptions[name];\n          return createDynamicDecl(dyn, function (env, scope) {\n            var str = env.invoke(scope, dyn);\n            var id = scope.def(env.shared.strings, '.id(', str, ')');\n            return id;\n          });\n        }\n\n        return null;\n      }\n\n      var frag = parseShader(S_FRAG);\n      var vert = parseShader(S_VERT);\n      var program = null;\n      var progVar;\n\n      if (isStatic(frag) && isStatic(vert)) {\n        program = shaderState.program(vert.id, frag.id, null, attribLocations);\n        progVar = createStaticDecl(function (env, scope) {\n          return env.link(program);\n        });\n      } else {\n        progVar = new Declaration(frag && frag.thisDep || vert && vert.thisDep, frag && frag.contextDep || vert && vert.contextDep, frag && frag.propDep || vert && vert.propDep, function (env, scope) {\n          var SHADER_STATE = env.shared.shader;\n          var fragId;\n\n          if (frag) {\n            fragId = frag.append(env, scope);\n          } else {\n            fragId = scope.def(SHADER_STATE, '.', S_FRAG);\n          }\n\n          var vertId;\n\n          if (vert) {\n            vertId = vert.append(env, scope);\n          } else {\n            vertId = scope.def(SHADER_STATE, '.', S_VERT);\n          }\n\n          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;\n          return scope.def(progDef + ')');\n        });\n      }\n\n      return {\n        frag: frag,\n        vert: vert,\n        progVar: progVar,\n        program: program\n      };\n    }\n\n    function parseDraw(options, env) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic; // TODO: should use VAO to get default values for offset properties\n      // should move vao parse into here and out of the old stuff\n\n      var staticDraw = {};\n      var vaoActive = false;\n\n      function parseVAO() {\n        if (S_VAO in staticOptions) {\n          var vao = staticOptions[S_VAO];\n\n          if (vao !== null && attributeState.getVAO(vao) === null) {\n            vao = attributeState.createVAO(vao);\n          }\n\n          vaoActive = true;\n          staticDraw.vao = vao;\n          return createStaticDecl(function (env) {\n            var vaoRef = attributeState.getVAO(vao);\n\n            if (vaoRef) {\n              return env.link(vaoRef);\n            } else {\n              return 'null';\n            }\n          });\n        } else if (S_VAO in dynamicOptions) {\n          vaoActive = true;\n          var dyn = dynamicOptions[S_VAO];\n          return createDynamicDecl(dyn, function (env, scope) {\n            var vaoRef = env.invoke(scope, dyn);\n            return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')');\n          });\n        }\n\n        return null;\n      }\n\n      var vao = parseVAO();\n      var elementsActive = false;\n\n      function parseElements() {\n        if (S_ELEMENTS in staticOptions) {\n          var elements = staticOptions[S_ELEMENTS];\n          staticDraw.elements = elements;\n\n          if (isBufferArgs(elements)) {\n            var e = staticDraw.elements = elementState.create(elements, true);\n            elements = elementState.getElements(e);\n            elementsActive = true;\n          } else if (elements) {\n            elements = elementState.getElements(elements);\n            elementsActive = true;\n          }\n\n          var result = createStaticDecl(function (env, scope) {\n            if (elements) {\n              var result = env.link(elements);\n              env.ELEMENTS = result;\n              return result;\n            }\n\n            env.ELEMENTS = null;\n            return null;\n          });\n          result.value = elements;\n          return result;\n        } else if (S_ELEMENTS in dynamicOptions) {\n          elementsActive = true;\n          var dyn = dynamicOptions[S_ELEMENTS];\n          return createDynamicDecl(dyn, function (env, scope) {\n            var shared = env.shared;\n            var IS_BUFFER_ARGS = shared.isBufferArgs;\n            var ELEMENT_STATE = shared.elements;\n            var elementDefn = env.invoke(scope, dyn);\n            var elements = scope.def('null');\n            var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');\n            var ifte = env.cond(elementStream).then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');').else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');\n            scope.entry(ifte);\n            scope.exit(env.cond(elementStream).then(ELEMENT_STATE, '.destroyStream(', elements, ');'));\n            env.ELEMENTS = elements;\n            return elements;\n          });\n        } else if (vaoActive) {\n          return new Declaration(vao.thisDep, vao.contextDep, vao.propDep, function (env, scope) {\n            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.elements + '.getElements(' + env.shared.vao + '.currentVAO.elements):null');\n          });\n        }\n\n        return null;\n      }\n\n      var elements = parseElements();\n\n      function parsePrimitive() {\n        if (S_PRIMITIVE in staticOptions) {\n          var primitive = staticOptions[S_PRIMITIVE];\n          staticDraw.primitive = primitive;\n          return createStaticDecl(function (env, scope) {\n            return primTypes[primitive];\n          });\n        } else if (S_PRIMITIVE in dynamicOptions) {\n          var dynPrimitive = dynamicOptions[S_PRIMITIVE];\n          return createDynamicDecl(dynPrimitive, function (env, scope) {\n            var PRIM_TYPES = env.constants.primTypes;\n            var prim = env.invoke(scope, dynPrimitive);\n            return scope.def(PRIM_TYPES, '[', prim, ']');\n          });\n        } else if (elementsActive) {\n          if (isStatic(elements)) {\n            if (elements.value) {\n              return createStaticDecl(function (env, scope) {\n                return scope.def(env.ELEMENTS, '.primType');\n              });\n            } else {\n              return createStaticDecl(function () {\n                return GL_TRIANGLES$1;\n              });\n            }\n          } else {\n            return new Declaration(elements.thisDep, elements.contextDep, elements.propDep, function (env, scope) {\n              var elements = env.ELEMENTS;\n              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1);\n            });\n          }\n        } else if (vaoActive) {\n          return new Declaration(vao.thisDep, vao.contextDep, vao.propDep, function (env, scope) {\n            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.primitive:' + GL_TRIANGLES$1);\n          });\n        }\n\n        return null;\n      }\n\n      function parseParam(param, isOffset) {\n        if (param in staticOptions) {\n          var value = staticOptions[param] | 0;\n\n          if (isOffset) {\n            staticDraw.offset = value;\n          } else {\n            staticDraw.instances = value;\n          }\n\n          return createStaticDecl(function (env, scope) {\n            if (isOffset) {\n              env.OFFSET = value;\n            }\n\n            return value;\n          });\n        } else if (param in dynamicOptions) {\n          var dynValue = dynamicOptions[param];\n          return createDynamicDecl(dynValue, function (env, scope) {\n            var result = env.invoke(scope, dynValue);\n\n            if (isOffset) {\n              env.OFFSET = result;\n            }\n\n            return result;\n          });\n        } else if (isOffset) {\n          if (elementsActive) {\n            return createStaticDecl(function (env, scope) {\n              env.OFFSET = 0;\n              return 0;\n            });\n          } else if (vaoActive) {\n            return new Declaration(vao.thisDep, vao.contextDep, vao.propDep, function (env, scope) {\n              return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.offset:0');\n            });\n          }\n        } else if (vaoActive) {\n          return new Declaration(vao.thisDep, vao.contextDep, vao.propDep, function (env, scope) {\n            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.instances:-1');\n          });\n        }\n\n        return null;\n      }\n\n      var OFFSET = parseParam(S_OFFSET, true);\n\n      function parseVertCount() {\n        if (S_COUNT in staticOptions) {\n          var count = staticOptions[S_COUNT] | 0;\n          staticDraw.count = count;\n          return createStaticDecl(function () {\n            return count;\n          });\n        } else if (S_COUNT in dynamicOptions) {\n          var dynCount = dynamicOptions[S_COUNT];\n          return createDynamicDecl(dynCount, function (env, scope) {\n            var result = env.invoke(scope, dynCount);\n            return result;\n          });\n        } else if (elementsActive) {\n          if (isStatic(elements)) {\n            if (elements) {\n              if (OFFSET) {\n                return new Declaration(OFFSET.thisDep, OFFSET.contextDep, OFFSET.propDep, function (env, scope) {\n                  var result = scope.def(env.ELEMENTS, '.vertCount-', env.OFFSET);\n                  return result;\n                });\n              } else {\n                return createStaticDecl(function (env, scope) {\n                  return scope.def(env.ELEMENTS, '.vertCount');\n                });\n              }\n            } else {\n              var result = createStaticDecl(function () {\n                return -1;\n              });\n              return result;\n            }\n          } else {\n            var variable = new Declaration(elements.thisDep || OFFSET.thisDep, elements.contextDep || OFFSET.contextDep, elements.propDep || OFFSET.propDep, function (env, scope) {\n              var elements = env.ELEMENTS;\n\n              if (env.OFFSET) {\n                return scope.def(elements, '?', elements, '.vertCount-', env.OFFSET, ':-1');\n              }\n\n              return scope.def(elements, '?', elements, '.vertCount:-1');\n            });\n            return variable;\n          }\n        } else if (vaoActive) {\n          var countVariable = new Declaration(vao.thisDep, vao.contextDep, vao.propDep, function (env, scope) {\n            return scope.def(env.shared.vao, '.currentVAO?', env.shared.vao, '.currentVAO.count:-1');\n          });\n          return countVariable;\n        }\n\n        return null;\n      }\n\n      var primitive = parsePrimitive();\n      var count = parseVertCount();\n      var instances = parseParam(S_INSTANCES, false);\n      return {\n        elements: elements,\n        primitive: primitive,\n        count: count,\n        instances: instances,\n        offset: OFFSET,\n        vao: vao,\n        vaoActive: vaoActive,\n        elementsActive: elementsActive,\n        // static draw props\n        static: staticDraw\n      };\n    }\n\n    function parseGLState(options, env) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n      var STATE = {};\n      GL_STATE_NAMES.forEach(function (prop) {\n        var param = propName(prop);\n\n        function parseParam(parseStatic, parseDynamic) {\n          if (prop in staticOptions) {\n            var value = parseStatic(staticOptions[prop]);\n            STATE[param] = createStaticDecl(function () {\n              return value;\n            });\n          } else if (prop in dynamicOptions) {\n            var dyn = dynamicOptions[prop];\n            STATE[param] = createDynamicDecl(dyn, function (env, scope) {\n              return parseDynamic(env, scope, env.invoke(scope, dyn));\n            });\n          }\n        }\n\n        switch (prop) {\n          case S_CULL_ENABLE:\n          case S_BLEND_ENABLE:\n          case S_DITHER:\n          case S_STENCIL_ENABLE:\n          case S_DEPTH_ENABLE:\n          case S_SCISSOR_ENABLE:\n          case S_POLYGON_OFFSET_ENABLE:\n          case S_SAMPLE_ALPHA:\n          case S_SAMPLE_ENABLE:\n          case S_DEPTH_MASK:\n            return parseParam(function (value) {\n              return value;\n            }, function (env, scope, value) {\n              return value;\n            });\n\n          case S_DEPTH_FUNC:\n            return parseParam(function (value) {\n              return compareFuncs[value];\n            }, function (env, scope, value) {\n              var COMPARE_FUNCS = env.constants.compareFuncs;\n              return scope.def(COMPARE_FUNCS, '[', value, ']');\n            });\n\n          case S_DEPTH_RANGE:\n            return parseParam(function (value) {\n              return value;\n            }, function (env, scope, value) {\n              var Z_NEAR = scope.def('+', value, '[0]');\n              var Z_FAR = scope.def('+', value, '[1]');\n              return [Z_NEAR, Z_FAR];\n            });\n\n          case S_BLEND_FUNC:\n            return parseParam(function (value) {\n              var srcRGB = 'srcRGB' in value ? value.srcRGB : value.src;\n              var srcAlpha = 'srcAlpha' in value ? value.srcAlpha : value.src;\n              var dstRGB = 'dstRGB' in value ? value.dstRGB : value.dst;\n              var dstAlpha = 'dstAlpha' in value ? value.dstAlpha : value.dst;\n              return [blendFuncs[srcRGB], blendFuncs[dstRGB], blendFuncs[srcAlpha], blendFuncs[dstAlpha]];\n            }, function (env, scope, value) {\n              var BLEND_FUNCS = env.constants.blendFuncs;\n\n              function read(prefix, suffix) {\n                var func = scope.def('\"', prefix, suffix, '\" in ', value, '?', value, '.', prefix, suffix, ':', value, '.', prefix);\n                return func;\n              }\n\n              var srcRGB = read('src', 'RGB');\n              var dstRGB = read('dst', 'RGB');\n              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');\n              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');\n              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');\n              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');\n              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];\n            });\n\n          case S_BLEND_EQUATION:\n            return parseParam(function (value) {\n              if (typeof value === 'string') {\n                return [blendEquations[value], blendEquations[value]];\n              } else if (typeof value === 'object') {\n                return [blendEquations[value.rgb], blendEquations[value.alpha]];\n              } else {}\n            }, function (env, scope, value) {\n              var BLEND_EQUATIONS = env.constants.blendEquations;\n              var RGB = scope.def();\n              var ALPHA = scope.def();\n              var ifte = env.cond('typeof ', value, '===\"string\"');\n              ifte.then(RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');\n              ifte.else(RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];', ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');\n              scope(ifte);\n              return [RGB, ALPHA];\n            });\n\n          case S_BLEND_COLOR:\n            return parseParam(function (value) {\n              return loop(4, function (i) {\n                return +value[i];\n              });\n            }, function (env, scope, value) {\n              return loop(4, function (i) {\n                return scope.def('+', value, '[', i, ']');\n              });\n            });\n\n          case S_STENCIL_MASK:\n            return parseParam(function (value) {\n              return value | 0;\n            }, function (env, scope, value) {\n              return scope.def(value, '|0');\n            });\n\n          case S_STENCIL_FUNC:\n            return parseParam(function (value) {\n              var cmp = value.cmp || 'keep';\n              var ref = value.ref || 0;\n              var mask = 'mask' in value ? value.mask : -1;\n              return [compareFuncs[cmp], ref, mask];\n            }, function (env, scope, value) {\n              var COMPARE_FUNCS = env.constants.compareFuncs;\n              var cmp = scope.def('\"cmp\" in ', value, '?', COMPARE_FUNCS, '[', value, '.cmp]', ':', GL_KEEP);\n              var ref = scope.def(value, '.ref|0');\n              var mask = scope.def('\"mask\" in ', value, '?', value, '.mask|0:-1');\n              return [cmp, ref, mask];\n            });\n\n          case S_STENCIL_OPFRONT:\n          case S_STENCIL_OPBACK:\n            return parseParam(function (value) {\n              var fail = value.fail || 'keep';\n              var zfail = value.zfail || 'keep';\n              var zpass = value.zpass || 'keep';\n              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, stencilOps[fail], stencilOps[zfail], stencilOps[zpass]];\n            }, function (env, scope, value) {\n              var STENCIL_OPS = env.constants.stencilOps;\n\n              function read(name) {\n                return scope.def('\"', name, '\" in ', value, '?', STENCIL_OPS, '[', value, '.', name, ']:', GL_KEEP);\n              }\n\n              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, read('fail'), read('zfail'), read('zpass')];\n            });\n\n          case S_POLYGON_OFFSET_OFFSET:\n            return parseParam(function (value) {\n              var factor = value.factor | 0;\n              var units = value.units | 0;\n              return [factor, units];\n            }, function (env, scope, value) {\n              var FACTOR = scope.def(value, '.factor|0');\n              var UNITS = scope.def(value, '.units|0');\n              return [FACTOR, UNITS];\n            });\n\n          case S_CULL_FACE:\n            return parseParam(function (value) {\n              var face = 0;\n\n              if (value === 'front') {\n                face = GL_FRONT;\n              } else if (value === 'back') {\n                face = GL_BACK;\n              }\n\n              return face;\n            }, function (env, scope, value) {\n              return scope.def(value, '===\"front\"?', GL_FRONT, ':', GL_BACK);\n            });\n\n          case S_LINE_WIDTH:\n            return parseParam(function (value) {\n              return value;\n            }, function (env, scope, value) {\n              return value;\n            });\n\n          case S_FRONT_FACE:\n            return parseParam(function (value) {\n              return orientationType[value];\n            }, function (env, scope, value) {\n              return scope.def(value + '===\"cw\"?' + GL_CW + ':' + GL_CCW);\n            });\n\n          case S_COLOR_MASK:\n            return parseParam(function (value) {\n              return value.map(function (v) {\n                return !!v;\n              });\n            }, function (env, scope, value) {\n              return loop(4, function (i) {\n                return '!!' + value + '[' + i + ']';\n              });\n            });\n\n          case S_SAMPLE_COVERAGE:\n            return parseParam(function (value) {\n              var sampleValue = 'value' in value ? value.value : 1;\n              var sampleInvert = !!value.invert;\n              return [sampleValue, sampleInvert];\n            }, function (env, scope, value) {\n              var VALUE = scope.def('\"value\" in ', value, '?+', value, '.value:1');\n              var INVERT = scope.def('!!', value, '.invert');\n              return [VALUE, INVERT];\n            });\n        }\n      });\n      return STATE;\n    }\n\n    function parseUniforms(uniforms, env) {\n      var staticUniforms = uniforms.static;\n      var dynamicUniforms = uniforms.dynamic;\n      var UNIFORMS = {};\n      Object.keys(staticUniforms).forEach(function (name) {\n        var value = staticUniforms[name];\n        var result;\n\n        if (typeof value === 'number' || typeof value === 'boolean') {\n          result = createStaticDecl(function () {\n            return value;\n          });\n        } else if (typeof value === 'function') {\n          var reglType = value._reglType;\n\n          if (reglType === 'texture2d' || reglType === 'textureCube') {\n            result = createStaticDecl(function (env) {\n              return env.link(value);\n            });\n          } else if (reglType === 'framebuffer' || reglType === 'framebufferCube') {\n            result = createStaticDecl(function (env) {\n              return env.link(value.color[0]);\n            });\n          } else {}\n        } else if (isArrayLike(value)) {\n          result = createStaticDecl(function (env) {\n            var ITEM = env.global.def('[', loop(value.length, function (i) {\n              return value[i];\n            }), ']');\n            return ITEM;\n          });\n        } else {}\n\n        result.value = value;\n        UNIFORMS[name] = result;\n      });\n      Object.keys(dynamicUniforms).forEach(function (key) {\n        var dyn = dynamicUniforms[key];\n        UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {\n          return env.invoke(scope, dyn);\n        });\n      });\n      return UNIFORMS;\n    }\n\n    function parseAttributes(attributes, env) {\n      var staticAttributes = attributes.static;\n      var dynamicAttributes = attributes.dynamic;\n      var attributeDefs = {};\n      Object.keys(staticAttributes).forEach(function (attribute) {\n        var value = staticAttributes[attribute];\n        var id = stringStore.id(attribute);\n        var record = new AttributeRecord();\n\n        if (isBufferArgs(value)) {\n          record.state = ATTRIB_STATE_POINTER;\n          record.buffer = bufferState.getBuffer(bufferState.create(value, GL_ARRAY_BUFFER$2, false, true));\n          record.type = 0;\n        } else {\n          var buffer = bufferState.getBuffer(value);\n\n          if (buffer) {\n            record.state = ATTRIB_STATE_POINTER;\n            record.buffer = buffer;\n            record.type = 0;\n          } else {\n            if ('constant' in value) {\n              var constant = value.constant;\n              record.buffer = 'null';\n              record.state = ATTRIB_STATE_CONSTANT;\n\n              if (typeof constant === 'number') {\n                record.x = constant;\n              } else {\n                CUTE_COMPONENTS.forEach(function (c, i) {\n                  if (i < constant.length) {\n                    record[c] = constant[i];\n                  }\n                });\n              }\n            } else {\n              if (isBufferArgs(value.buffer)) {\n                buffer = bufferState.getBuffer(bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true));\n              } else {\n                buffer = bufferState.getBuffer(value.buffer);\n              }\n\n              var offset = value.offset | 0;\n              var stride = value.stride | 0;\n              var size = value.size | 0;\n              var normalized = !!value.normalized;\n              var type = 0;\n\n              if ('type' in value) {\n                type = glTypes[value.type];\n              }\n\n              var divisor = value.divisor | 0;\n              record.buffer = buffer;\n              record.state = ATTRIB_STATE_POINTER;\n              record.size = size;\n              record.normalized = normalized;\n              record.type = type || buffer.dtype;\n              record.offset = offset;\n              record.stride = stride;\n              record.divisor = divisor;\n            }\n          }\n        }\n\n        attributeDefs[attribute] = createStaticDecl(function (env, scope) {\n          var cache = env.attribCache;\n\n          if (id in cache) {\n            return cache[id];\n          }\n\n          var result = {\n            isStream: false\n          };\n          Object.keys(record).forEach(function (key) {\n            result[key] = record[key];\n          });\n\n          if (record.buffer) {\n            result.buffer = env.link(record.buffer);\n            result.type = result.type || result.buffer + '.dtype';\n          }\n\n          cache[id] = result;\n          return result;\n        });\n      });\n      Object.keys(dynamicAttributes).forEach(function (attribute) {\n        var dyn = dynamicAttributes[attribute];\n\n        function appendAttributeCode(env, block) {\n          var VALUE = env.invoke(block, dyn);\n          var shared = env.shared;\n          var constants = env.constants;\n          var IS_BUFFER_ARGS = shared.isBufferArgs;\n          var BUFFER_STATE = shared.buffer; // Perform validation on attribute\n          // allocate names for result\n\n          var result = {\n            isStream: block.def(false)\n          };\n          var defaultRecord = new AttributeRecord();\n          defaultRecord.state = ATTRIB_STATE_POINTER;\n          Object.keys(defaultRecord).forEach(function (key) {\n            result[key] = block.def('' + defaultRecord[key]);\n          });\n          var BUFFER = result.buffer;\n          var TYPE = result.type;\n          block('if(', IS_BUFFER_ARGS, '(', VALUE, ')){', result.isStream, '=true;', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');', TYPE, '=', BUFFER, '.dtype;', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');', 'if(', BUFFER, '){', TYPE, '=', BUFFER, '.dtype;', '}else if(\"constant\" in ', VALUE, '){', result.state, '=', ATTRIB_STATE_CONSTANT, ';', 'if(typeof ' + VALUE + '.constant === \"number\"){', result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;', CUTE_COMPONENTS.slice(1).map(function (n) {\n            return result[n];\n          }).join('='), '=0;', '}else{', CUTE_COMPONENTS.map(function (name, i) {\n            return result[name] + '=' + VALUE + '.constant.length>' + i + '?' + VALUE + '.constant[' + i + ']:0;';\n          }).join(''), '}}else{', 'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);', '}', TYPE, '=\"type\" in ', VALUE, '?', constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;', result.normalized, '=!!', VALUE, '.normalized;');\n\n          function emitReadRecord(name) {\n            block(result[name], '=', VALUE, '.', name, '|0;');\n          }\n\n          emitReadRecord('size');\n          emitReadRecord('offset');\n          emitReadRecord('stride');\n          emitReadRecord('divisor');\n          block('}}');\n          block.exit('if(', result.isStream, '){', BUFFER_STATE, '.destroyStream(', BUFFER, ');', '}');\n          return result;\n        }\n\n        attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);\n      });\n      return attributeDefs;\n    }\n\n    function parseContext(context) {\n      var staticContext = context.static;\n      var dynamicContext = context.dynamic;\n      var result = {};\n      Object.keys(staticContext).forEach(function (name) {\n        var value = staticContext[name];\n        result[name] = createStaticDecl(function (env, scope) {\n          if (typeof value === 'number' || typeof value === 'boolean') {\n            return '' + value;\n          } else {\n            return env.link(value);\n          }\n        });\n      });\n      Object.keys(dynamicContext).forEach(function (name) {\n        var dyn = dynamicContext[name];\n        result[name] = createDynamicDecl(dyn, function (env, scope) {\n          return env.invoke(scope, dyn);\n        });\n      });\n      return result;\n    }\n\n    function parseArguments(options, attributes, uniforms, context, env) {\n      var staticOptions = options.static;\n      var dynamicOptions = options.dynamic;\n      var attribLocations = parseAttribLocations(options, attributes);\n      var framebuffer = parseFramebuffer(options, env);\n      var viewportAndScissor = parseViewportScissor(options, framebuffer, env);\n      var draw = parseDraw(options, env);\n      var state = parseGLState(options, env);\n      var shader = parseProgram(options, env, attribLocations);\n\n      function copyBox(name) {\n        var defn = viewportAndScissor[name];\n\n        if (defn) {\n          state[name] = defn;\n        }\n      }\n\n      copyBox(S_VIEWPORT);\n      copyBox(propName(S_SCISSOR_BOX));\n      var dirty = Object.keys(state).length > 0;\n      var result = {\n        framebuffer: framebuffer,\n        draw: draw,\n        shader: shader,\n        state: state,\n        dirty: dirty,\n        scopeVAO: null,\n        drawVAO: null,\n        useVAO: false,\n        attributes: {}\n      };\n      result.profile = parseProfile(options, env);\n      result.uniforms = parseUniforms(uniforms, env);\n      result.drawVAO = result.scopeVAO = draw.vao; // special case: check if we can statically allocate a vertex array object for this program\n\n      if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays && draw.static.elements) {\n        var useVAO = true;\n        var staticBindings = shader.program.attributes.map(function (attr) {\n          var binding = attributes.static[attr];\n          useVAO = useVAO && !!binding;\n          return binding;\n        });\n\n        if (useVAO && staticBindings.length > 0) {\n          var vao = attributeState.getVAO(attributeState.createVAO({\n            attributes: staticBindings,\n            elements: draw.static.elements\n          }));\n          result.drawVAO = new Declaration(null, null, null, function (env, scope) {\n            return env.link(vao);\n          });\n          result.useVAO = true;\n        }\n      }\n\n      if (attribLocations) {\n        result.useVAO = true;\n      } else {\n        result.attributes = parseAttributes(attributes, env);\n      }\n\n      result.context = parseContext(context, env);\n      return result;\n    } // ===================================================\n    // ===================================================\n    // COMMON UPDATE FUNCTIONS\n    // ===================================================\n    // ===================================================\n\n\n    function emitContext(env, scope, context) {\n      var shared = env.shared;\n      var CONTEXT = shared.context;\n      var contextEnter = env.scope();\n      Object.keys(context).forEach(function (name) {\n        scope.save(CONTEXT, '.' + name);\n        var defn = context[name];\n        var value = defn.append(env, scope);\n\n        if (Array.isArray(value)) {\n          contextEnter(CONTEXT, '.', name, '=[', value.join(), '];');\n        } else {\n          contextEnter(CONTEXT, '.', name, '=', value, ';');\n        }\n      });\n      scope(contextEnter);\n    } // ===================================================\n    // ===================================================\n    // COMMON DRAWING FUNCTIONS\n    // ===================================================\n    // ===================================================\n\n\n    function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {\n      var shared = env.shared;\n      var GL = shared.gl;\n      var FRAMEBUFFER_STATE = shared.framebuffer;\n      var EXT_DRAW_BUFFERS;\n\n      if (extDrawBuffers) {\n        EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');\n      }\n\n      var constants = env.constants;\n      var DRAW_BUFFERS = constants.drawBuffer;\n      var BACK_BUFFER = constants.backBuffer;\n      var NEXT;\n\n      if (framebuffer) {\n        NEXT = framebuffer.append(env, scope);\n      } else {\n        NEXT = scope.def(FRAMEBUFFER_STATE, '.next');\n      }\n\n      if (!skipCheck) {\n        scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');\n      }\n\n      scope('if(', NEXT, '){', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);');\n\n      if (extDrawBuffers) {\n        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');\n      }\n\n      scope('}else{', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);');\n\n      if (extDrawBuffers) {\n        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');\n      }\n\n      scope('}', FRAMEBUFFER_STATE, '.cur=', NEXT, ';');\n\n      if (!skipCheck) {\n        scope('}');\n      }\n    }\n\n    function emitPollState(env, scope, args) {\n      var shared = env.shared;\n      var GL = shared.gl;\n      var CURRENT_VARS = env.current;\n      var NEXT_VARS = env.next;\n      var CURRENT_STATE = shared.current;\n      var NEXT_STATE = shared.next;\n      var block = env.cond(CURRENT_STATE, '.dirty');\n      GL_STATE_NAMES.forEach(function (prop) {\n        var param = propName(prop);\n\n        if (param in args.state) {\n          return;\n        }\n\n        var NEXT, CURRENT;\n\n        if (param in NEXT_VARS) {\n          NEXT = NEXT_VARS[param];\n          CURRENT = CURRENT_VARS[param];\n          var parts = loop(currentState[param].length, function (i) {\n            return block.def(NEXT, '[', i, ']');\n          });\n          block(env.cond(parts.map(function (p, i) {\n            return p + '!==' + CURRENT + '[' + i + ']';\n          }).join('||')).then(GL, '.', GL_VARIABLES[param], '(', parts, ');', parts.map(function (p, i) {\n            return CURRENT + '[' + i + ']=' + p;\n          }).join(';'), ';'));\n        } else {\n          NEXT = block.def(NEXT_STATE, '.', param);\n          var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);\n          block(ifte);\n\n          if (param in GL_FLAGS) {\n            ifte(env.cond(NEXT).then(GL, '.enable(', GL_FLAGS[param], ');').else(GL, '.disable(', GL_FLAGS[param], ');'), CURRENT_STATE, '.', param, '=', NEXT, ';');\n          } else {\n            ifte(GL, '.', GL_VARIABLES[param], '(', NEXT, ');', CURRENT_STATE, '.', param, '=', NEXT, ';');\n          }\n        }\n      });\n\n      if (Object.keys(args.state).length === 0) {\n        block(CURRENT_STATE, '.dirty=false;');\n      }\n\n      scope(block);\n    }\n\n    function emitSetOptions(env, scope, options, filter) {\n      var shared = env.shared;\n      var CURRENT_VARS = env.current;\n      var CURRENT_STATE = shared.current;\n      var GL = shared.gl;\n      var VALUE;\n      sortState(Object.keys(options)).forEach(function (param) {\n        var defn = options[param];\n\n        if (filter && !filter(defn)) {\n          return;\n        }\n\n        var variable = defn.append(env, scope);\n\n        if (GL_FLAGS[param]) {\n          var flag = GL_FLAGS[param];\n\n          if (isStatic(defn)) {\n            VALUE = env.link(variable, {\n              stable: true\n            });\n            scope(env.cond(VALUE).then(GL, '.enable(', flag, ');').else(GL, '.disable(', flag, ');'));\n            scope(CURRENT_STATE, '.', param, '=', VALUE, ';');\n          } else {\n            scope(env.cond(variable).then(GL, '.enable(', flag, ');').else(GL, '.disable(', flag, ');'));\n            scope(CURRENT_STATE, '.', param, '=', variable, ';');\n          }\n        } else if (isArrayLike(variable)) {\n          var CURRENT = CURRENT_VARS[param];\n          scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', variable.map(function (v, i) {\n            return CURRENT + '[' + i + ']=' + v;\n          }).join(';'), ';');\n        } else {\n          if (isStatic(defn)) {\n            VALUE = env.link(variable, {\n              stable: true\n            });\n            scope(GL, '.', GL_VARIABLES[param], '(', VALUE, ');', CURRENT_STATE, '.', param, '=', VALUE, ';');\n          } else {\n            scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', CURRENT_STATE, '.', param, '=', variable, ';');\n          }\n        }\n      });\n    }\n\n    function injectExtensions(env, scope) {\n      if (extInstancing) {\n        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');\n      }\n    }\n\n    function emitProfile(env, scope, args, useScope, incrementCounter) {\n      var shared = env.shared;\n      var STATS = env.stats;\n      var CURRENT_STATE = shared.current;\n      var TIMER = shared.timer;\n      var profileArg = args.profile;\n\n      function perfCounter() {\n        if (typeof performance === 'undefined') {\n          return 'Date.now()';\n        } else {\n          return 'performance.now()';\n        }\n      }\n\n      var CPU_START, QUERY_COUNTER;\n\n      function emitProfileStart(block) {\n        CPU_START = scope.def();\n        block(CPU_START, '=', perfCounter(), ';');\n\n        if (typeof incrementCounter === 'string') {\n          block(STATS, '.count+=', incrementCounter, ';');\n        } else {\n          block(STATS, '.count++;');\n        }\n\n        if (timer) {\n          if (useScope) {\n            QUERY_COUNTER = scope.def();\n            block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');\n          } else {\n            block(TIMER, '.beginQuery(', STATS, ');');\n          }\n        }\n      }\n\n      function emitProfileEnd(block) {\n        block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');\n\n        if (timer) {\n          if (useScope) {\n            block(TIMER, '.pushScopeStats(', QUERY_COUNTER, ',', TIMER, '.getNumPendingQueries(),', STATS, ');');\n          } else {\n            block(TIMER, '.endQuery();');\n          }\n        }\n      }\n\n      function scopeProfile(value) {\n        var prev = scope.def(CURRENT_STATE, '.profile');\n        scope(CURRENT_STATE, '.profile=', value, ';');\n        scope.exit(CURRENT_STATE, '.profile=', prev, ';');\n      }\n\n      var USE_PROFILE;\n\n      if (profileArg) {\n        if (isStatic(profileArg)) {\n          if (profileArg.enable) {\n            emitProfileStart(scope);\n            emitProfileEnd(scope.exit);\n            scopeProfile('true');\n          } else {\n            scopeProfile('false');\n          }\n\n          return;\n        }\n\n        USE_PROFILE = profileArg.append(env, scope);\n        scopeProfile(USE_PROFILE);\n      } else {\n        USE_PROFILE = scope.def(CURRENT_STATE, '.profile');\n      }\n\n      var start = env.block();\n      emitProfileStart(start);\n      scope('if(', USE_PROFILE, '){', start, '}');\n      var end = env.block();\n      emitProfileEnd(end);\n      scope.exit('if(', USE_PROFILE, '){', end, '}');\n    }\n\n    function emitAttributes(env, scope, args, attributes, filter) {\n      var shared = env.shared;\n\n      function typeLength(x) {\n        switch (x) {\n          case GL_FLOAT_VEC2:\n          case GL_INT_VEC2:\n          case GL_BOOL_VEC2:\n            return 2;\n\n          case GL_FLOAT_VEC3:\n          case GL_INT_VEC3:\n          case GL_BOOL_VEC3:\n            return 3;\n\n          case GL_FLOAT_VEC4:\n          case GL_INT_VEC4:\n          case GL_BOOL_VEC4:\n            return 4;\n\n          default:\n            return 1;\n        }\n      }\n\n      function emitBindAttribute(ATTRIBUTE, size, record) {\n        var GL = shared.gl;\n        var LOCATION = scope.def(ATTRIBUTE, '.location');\n        var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');\n        var STATE = record.state;\n        var BUFFER = record.buffer;\n        var CONST_COMPONENTS = [record.x, record.y, record.z, record.w];\n        var COMMON_KEYS = ['buffer', 'normalized', 'offset', 'stride'];\n\n        function emitBuffer() {\n          scope('if(!', BINDING, '.buffer){', GL, '.enableVertexAttribArray(', LOCATION, ');}');\n          var TYPE = record.type;\n          var SIZE;\n\n          if (!record.size) {\n            SIZE = size;\n          } else {\n            SIZE = scope.def(record.size, '||', size);\n          }\n\n          scope('if(', BINDING, '.type!==', TYPE, '||', BINDING, '.size!==', SIZE, '||', COMMON_KEYS.map(function (key) {\n            return BINDING + '.' + key + '!==' + record[key];\n          }).join('||'), '){', GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);', GL, '.vertexAttribPointer(', [LOCATION, SIZE, TYPE, record.normalized, record.stride, record.offset], ');', BINDING, '.type=', TYPE, ';', BINDING, '.size=', SIZE, ';', COMMON_KEYS.map(function (key) {\n            return BINDING + '.' + key + '=' + record[key] + ';';\n          }).join(''), '}');\n\n          if (extInstancing) {\n            var DIVISOR = record.divisor;\n            scope('if(', BINDING, '.divisor!==', DIVISOR, '){', env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');', BINDING, '.divisor=', DIVISOR, ';}');\n          }\n        }\n\n        function emitConstant() {\n          scope('if(', BINDING, '.buffer){', GL, '.disableVertexAttribArray(', LOCATION, ');', BINDING, '.buffer=null;', '}if(', CUTE_COMPONENTS.map(function (c, i) {\n            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i];\n          }).join('||'), '){', GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');', CUTE_COMPONENTS.map(function (c, i) {\n            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';';\n          }).join(''), '}');\n        }\n\n        if (STATE === ATTRIB_STATE_POINTER) {\n          emitBuffer();\n        } else if (STATE === ATTRIB_STATE_CONSTANT) {\n          emitConstant();\n        } else {\n          scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');\n          emitBuffer();\n          scope('}else{');\n          emitConstant();\n          scope('}');\n        }\n      }\n\n      attributes.forEach(function (attribute) {\n        var name = attribute.name;\n        var arg = args.attributes[name];\n        var record;\n\n        if (arg) {\n          if (!filter(arg)) {\n            return;\n          }\n\n          record = arg.append(env, scope);\n        } else {\n          if (!filter(SCOPE_DECL)) {\n            return;\n          }\n\n          var scopeAttrib = env.scopeAttrib(name);\n          record = {};\n          Object.keys(new AttributeRecord()).forEach(function (key) {\n            record[key] = scope.def(scopeAttrib, '.', key);\n          });\n        }\n\n        emitBindAttribute(env.link(attribute), typeLength(attribute.info.type), record);\n      });\n    }\n\n    function emitUniforms(env, scope, args, uniforms, filter, isBatchInnerLoop) {\n      var shared = env.shared;\n      var GL = shared.gl;\n      var infix;\n\n      for (var i = 0; i < uniforms.length; ++i) {\n        var uniform = uniforms[i];\n        var name = uniform.name;\n        var type = uniform.info.type;\n        var arg = args.uniforms[name];\n        var UNIFORM = env.link(uniform);\n        var LOCATION = UNIFORM + '.location';\n        var VALUE;\n\n        if (arg) {\n          if (!filter(arg)) {\n            continue;\n          }\n\n          if (isStatic(arg)) {\n            var value = arg.value;\n\n            if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {\n              var TEX_VALUE = env.link(value._texture || value.color[0]._texture);\n              scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');\n              scope.exit(TEX_VALUE, '.unbind();');\n            } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {\n              var MAT_VALUE = env.global.def('new Float32Array([' + Array.prototype.slice.call(value) + '])');\n              var dim = 2;\n\n              if (type === GL_FLOAT_MAT3) {\n                dim = 3;\n              } else if (type === GL_FLOAT_MAT4) {\n                dim = 4;\n              }\n\n              scope(GL, '.uniformMatrix', dim, 'fv(', LOCATION, ',false,', MAT_VALUE, ');');\n            } else {\n              switch (type) {\n                case GL_FLOAT$7:\n                  infix = '1f';\n                  break;\n\n                case GL_FLOAT_VEC2:\n                  infix = '2f';\n                  break;\n\n                case GL_FLOAT_VEC3:\n                  infix = '3f';\n                  break;\n\n                case GL_FLOAT_VEC4:\n                  infix = '4f';\n                  break;\n\n                case GL_BOOL:\n                  infix = '1i';\n                  break;\n\n                case GL_INT$2:\n                  infix = '1i';\n                  break;\n\n                case GL_BOOL_VEC2:\n                  infix = '2i';\n                  break;\n\n                case GL_INT_VEC2:\n                  infix = '2i';\n                  break;\n\n                case GL_BOOL_VEC3:\n                  infix = '3i';\n                  break;\n\n                case GL_INT_VEC3:\n                  infix = '3i';\n                  break;\n\n                case GL_BOOL_VEC4:\n                  infix = '4i';\n                  break;\n\n                case GL_INT_VEC4:\n                  infix = '4i';\n                  break;\n              }\n\n              scope(GL, '.uniform', infix, '(', LOCATION, ',', isArrayLike(value) ? Array.prototype.slice.call(value) : value, ');');\n            }\n\n            continue;\n          } else {\n            VALUE = arg.append(env, scope);\n          }\n        } else {\n          if (!filter(SCOPE_DECL)) {\n            continue;\n          }\n\n          VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');\n        }\n\n        if (type === GL_SAMPLER_2D) {\n          scope('if(', VALUE, '&&', VALUE, '._reglType===\"framebuffer\"){', VALUE, '=', VALUE, '.color[0];', '}');\n        } else if (type === GL_SAMPLER_CUBE) {\n          scope('if(', VALUE, '&&', VALUE, '._reglType===\"framebufferCube\"){', VALUE, '=', VALUE, '.color[0];', '}');\n        } // perform type validation\n\n\n        var unroll = 1;\n\n        switch (type) {\n          case GL_SAMPLER_2D:\n          case GL_SAMPLER_CUBE:\n            var TEX = scope.def(VALUE, '._texture');\n            scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');\n            scope.exit(TEX, '.unbind();');\n            continue;\n\n          case GL_INT$2:\n          case GL_BOOL:\n            infix = '1i';\n            break;\n\n          case GL_INT_VEC2:\n          case GL_BOOL_VEC2:\n            infix = '2i';\n            unroll = 2;\n            break;\n\n          case GL_INT_VEC3:\n          case GL_BOOL_VEC3:\n            infix = '3i';\n            unroll = 3;\n            break;\n\n          case GL_INT_VEC4:\n          case GL_BOOL_VEC4:\n            infix = '4i';\n            unroll = 4;\n            break;\n\n          case GL_FLOAT$7:\n            infix = '1f';\n            break;\n\n          case GL_FLOAT_VEC2:\n            infix = '2f';\n            unroll = 2;\n            break;\n\n          case GL_FLOAT_VEC3:\n            infix = '3f';\n            unroll = 3;\n            break;\n\n          case GL_FLOAT_VEC4:\n            infix = '4f';\n            unroll = 4;\n            break;\n\n          case GL_FLOAT_MAT2:\n            infix = 'Matrix2fv';\n            break;\n\n          case GL_FLOAT_MAT3:\n            infix = 'Matrix3fv';\n            break;\n\n          case GL_FLOAT_MAT4:\n            infix = 'Matrix4fv';\n            break;\n        }\n\n        if (infix.charAt(0) === 'M') {\n          scope(GL, '.uniform', infix, '(', LOCATION, ',');\n          var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);\n          var STORAGE = env.global.def('new Float32Array(', matSize, ')');\n\n          if (Array.isArray(VALUE)) {\n            scope('false,(', loop(matSize, function (i) {\n              return STORAGE + '[' + i + ']=' + VALUE[i];\n            }), ',', STORAGE, ')');\n          } else {\n            scope('false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(', loop(matSize, function (i) {\n              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']';\n            }), ',', STORAGE, ')');\n          }\n\n          scope(');');\n        } else if (unroll > 1) {\n          var prev = [];\n          var cur = [];\n\n          for (var j = 0; j < unroll; ++j) {\n            if (Array.isArray(VALUE)) {\n              cur.push(VALUE[j]);\n            } else {\n              cur.push(scope.def(VALUE + '[' + j + ']'));\n            }\n\n            if (isBatchInnerLoop) {\n              prev.push(scope.def());\n            }\n          }\n\n          if (isBatchInnerLoop) {\n            scope('if(!', env.batchId, '||', prev.map(function (p, i) {\n              return p + '!==' + cur[i];\n            }).join('||'), '){', prev.map(function (p, i) {\n              return p + '=' + cur[i] + ';';\n            }).join(''));\n          }\n\n          scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');');\n\n          if (isBatchInnerLoop) {\n            scope('}');\n          }\n        } else {\n          if (isBatchInnerLoop) {\n            var prevS = scope.def();\n            scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){', prevS, '=', VALUE, ';');\n          }\n\n          scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');');\n\n          if (isBatchInnerLoop) {\n            scope('}');\n          }\n        }\n      }\n    }\n\n    function emitDraw(env, outer, inner, args) {\n      var shared = env.shared;\n      var GL = shared.gl;\n      var DRAW_STATE = shared.draw;\n      var drawOptions = args.draw;\n\n      function emitElements() {\n        var defn = drawOptions.elements;\n        var ELEMENTS;\n        var scope = outer;\n\n        if (defn) {\n          if (defn.contextDep && args.contextDynamic || defn.propDep) {\n            scope = inner;\n          }\n\n          ELEMENTS = defn.append(env, scope);\n\n          if (drawOptions.elementsActive) {\n            scope('if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);');\n          }\n        } else {\n          ELEMENTS = scope.def();\n          scope(ELEMENTS, '=', DRAW_STATE, '.', S_ELEMENTS, ';', 'if(', ELEMENTS, '){', GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER$2, ',', ELEMENTS, '.buffer.buffer);}', 'else if(', shared.vao, '.currentVAO){', ELEMENTS, '=', env.shared.elements + '.getElements(' + shared.vao, '.currentVAO.elements);', !extVertexArrays ? 'if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);' : '', '}');\n        }\n\n        return ELEMENTS;\n      }\n\n      function emitCount() {\n        var defn = drawOptions.count;\n        var COUNT;\n        var scope = outer;\n\n        if (defn) {\n          if (defn.contextDep && args.contextDynamic || defn.propDep) {\n            scope = inner;\n          }\n\n          COUNT = defn.append(env, scope);\n        } else {\n          COUNT = scope.def(DRAW_STATE, '.', S_COUNT);\n        }\n\n        return COUNT;\n      }\n\n      var ELEMENTS = emitElements();\n\n      function emitValue(name) {\n        var defn = drawOptions[name];\n\n        if (defn) {\n          if (defn.contextDep && args.contextDynamic || defn.propDep) {\n            return defn.append(env, inner);\n          } else {\n            return defn.append(env, outer);\n          }\n        } else {\n          return outer.def(DRAW_STATE, '.', name);\n        }\n      }\n\n      var PRIMITIVE = emitValue(S_PRIMITIVE);\n      var OFFSET = emitValue(S_OFFSET);\n      var COUNT = emitCount();\n\n      if (typeof COUNT === 'number') {\n        if (COUNT === 0) {\n          return;\n        }\n      } else {\n        inner('if(', COUNT, '){');\n        inner.exit('}');\n      }\n\n      var INSTANCES, EXT_INSTANCING;\n\n      if (extInstancing) {\n        INSTANCES = emitValue(S_INSTANCES);\n        EXT_INSTANCING = env.instancing;\n      }\n\n      var ELEMENT_TYPE = ELEMENTS + '.type';\n      var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive;\n\n      function emitInstancing() {\n        function drawElements() {\n          inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)', INSTANCES], ');');\n        }\n\n        function drawArrays() {\n          inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(', [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');\n        }\n\n        if (ELEMENTS && ELEMENTS !== 'null') {\n          if (!elementsStatic) {\n            inner('if(', ELEMENTS, '){');\n            drawElements();\n            inner('}else{');\n            drawArrays();\n            inner('}');\n          } else {\n            drawElements();\n          }\n        } else {\n          drawArrays();\n        }\n      }\n\n      function emitRegular() {\n        function drawElements() {\n          inner(GL + '.drawElements(' + [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)'] + ');');\n        }\n\n        function drawArrays() {\n          inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');\n        }\n\n        if (ELEMENTS && ELEMENTS !== 'null') {\n          if (!elementsStatic) {\n            inner('if(', ELEMENTS, '){');\n            drawElements();\n            inner('}else{');\n            drawArrays();\n            inner('}');\n          } else {\n            drawElements();\n          }\n        } else {\n          drawArrays();\n        }\n      }\n\n      if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {\n        if (typeof INSTANCES === 'string') {\n          inner('if(', INSTANCES, '>0){');\n          emitInstancing();\n          inner('}else if(', INSTANCES, '<0){');\n          emitRegular();\n          inner('}');\n        } else {\n          emitInstancing();\n        }\n      } else {\n        emitRegular();\n      }\n    }\n\n    function createBody(emitBody, parentEnv, args, program, count) {\n      var env = createREGLEnvironment();\n      var scope = env.proc('body', count);\n\n      if (extInstancing) {\n        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');\n      }\n\n      emitBody(env, scope, args, program);\n      return env.compile().body;\n    } // ===================================================\n    // ===================================================\n    // DRAW PROC\n    // ===================================================\n    // ===================================================\n\n\n    function emitDrawBody(env, draw, args, program) {\n      injectExtensions(env, draw);\n\n      if (args.useVAO) {\n        if (args.drawVAO) {\n          draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');');\n        } else {\n          draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');\n        }\n      } else {\n        draw(env.shared.vao, '.setVAO(null);');\n        emitAttributes(env, draw, args, program.attributes, function () {\n          return true;\n        });\n      }\n\n      emitUniforms(env, draw, args, program.uniforms, function () {\n        return true;\n      }, false);\n      emitDraw(env, draw, draw, args);\n    }\n\n    function emitDrawProc(env, args) {\n      var draw = env.proc('draw', 1);\n      injectExtensions(env, draw);\n      emitContext(env, draw, args.context);\n      emitPollFramebuffer(env, draw, args.framebuffer);\n      emitPollState(env, draw, args);\n      emitSetOptions(env, draw, args.state);\n      emitProfile(env, draw, args, false, true);\n      var program = args.shader.progVar.append(env, draw);\n      draw(env.shared.gl, '.useProgram(', program, '.program);');\n\n      if (args.shader.program) {\n        emitDrawBody(env, draw, args, args.shader.program);\n      } else {\n        draw(env.shared.vao, '.setVAO(null);');\n        var drawCache = env.global.def('{}');\n        var PROG_ID = draw.def(program, '.id');\n        var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');\n        draw(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0);').else(CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=', env.link(function (program) {\n          return createBody(emitDrawBody, env, args, program, 1);\n        }), '(', program, ');', CACHED_PROC, '.call(this,a0);'));\n      }\n\n      if (Object.keys(args.state).length > 0) {\n        draw(env.shared.current, '.dirty=true;');\n      }\n\n      if (env.shared.vao) {\n        draw(env.shared.vao, '.setVAO(null);');\n      }\n    } // ===================================================\n    // ===================================================\n    // BATCH PROC\n    // ===================================================\n    // ===================================================\n\n\n    function emitBatchDynamicShaderBody(env, scope, args, program) {\n      env.batchId = 'a1';\n      injectExtensions(env, scope);\n\n      function all() {\n        return true;\n      }\n\n      emitAttributes(env, scope, args, program.attributes, all);\n      emitUniforms(env, scope, args, program.uniforms, all, false);\n      emitDraw(env, scope, scope, args);\n    }\n\n    function emitBatchBody(env, scope, args, program) {\n      injectExtensions(env, scope);\n      var contextDynamic = args.contextDep;\n      var BATCH_ID = scope.def();\n      var PROP_LIST = 'a0';\n      var NUM_PROPS = 'a1';\n      var PROPS = scope.def();\n      env.shared.props = PROPS;\n      env.batchId = BATCH_ID;\n      var outer = env.scope();\n      var inner = env.scope();\n      scope(outer.entry, 'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){', PROPS, '=', PROP_LIST, '[', BATCH_ID, '];', inner, '}', outer.exit);\n\n      function isInnerDefn(defn) {\n        return defn.contextDep && contextDynamic || defn.propDep;\n      }\n\n      function isOuterDefn(defn) {\n        return !isInnerDefn(defn);\n      }\n\n      if (args.needsContext) {\n        emitContext(env, inner, args.context);\n      }\n\n      if (args.needsFramebuffer) {\n        emitPollFramebuffer(env, inner, args.framebuffer);\n      }\n\n      emitSetOptions(env, inner, args.state, isInnerDefn);\n\n      if (args.profile && isInnerDefn(args.profile)) {\n        emitProfile(env, inner, args, false, true);\n      }\n\n      if (!program) {\n        var progCache = env.global.def('{}');\n        var PROGRAM = args.shader.progVar.append(env, inner);\n        var PROG_ID = inner.def(PROGRAM, '.id');\n        var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');\n        inner(env.shared.gl, '.useProgram(', PROGRAM, '.program);', 'if(!', CACHED_PROC, '){', CACHED_PROC, '=', progCache, '[', PROG_ID, ']=', env.link(function (program) {\n          return createBody(emitBatchDynamicShaderBody, env, args, program, 2);\n        }), '(', PROGRAM, ');}', CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');\n      } else {\n        if (args.useVAO) {\n          if (args.drawVAO) {\n            if (isInnerDefn(args.drawVAO)) {\n              // vao is a prop\n              inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');');\n            } else {\n              // vao is invariant\n              outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');');\n            }\n          } else {\n            // scoped vao binding\n            outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');\n          }\n        } else {\n          outer(env.shared.vao, '.setVAO(null);');\n          emitAttributes(env, outer, args, program.attributes, isOuterDefn);\n          emitAttributes(env, inner, args, program.attributes, isInnerDefn);\n        }\n\n        emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false);\n        emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true);\n        emitDraw(env, outer, inner, args);\n      }\n    }\n\n    function emitBatchProc(env, args) {\n      var batch = env.proc('batch', 2);\n      env.batchId = '0';\n      injectExtensions(env, batch); // Check if any context variables depend on props\n\n      var contextDynamic = false;\n      var needsContext = true;\n      Object.keys(args.context).forEach(function (name) {\n        contextDynamic = contextDynamic || args.context[name].propDep;\n      });\n\n      if (!contextDynamic) {\n        emitContext(env, batch, args.context);\n        needsContext = false;\n      } // framebuffer state affects framebufferWidth/height context vars\n\n\n      var framebuffer = args.framebuffer;\n      var needsFramebuffer = false;\n\n      if (framebuffer) {\n        if (framebuffer.propDep) {\n          contextDynamic = needsFramebuffer = true;\n        } else if (framebuffer.contextDep && contextDynamic) {\n          needsFramebuffer = true;\n        }\n\n        if (!needsFramebuffer) {\n          emitPollFramebuffer(env, batch, framebuffer);\n        }\n      } else {\n        emitPollFramebuffer(env, batch, null);\n      } // viewport is weird because it can affect context vars\n\n\n      if (args.state.viewport && args.state.viewport.propDep) {\n        contextDynamic = true;\n      }\n\n      function isInnerDefn(defn) {\n        return defn.contextDep && contextDynamic || defn.propDep;\n      } // set webgl options\n\n\n      emitPollState(env, batch, args);\n      emitSetOptions(env, batch, args.state, function (defn) {\n        return !isInnerDefn(defn);\n      });\n\n      if (!args.profile || !isInnerDefn(args.profile)) {\n        emitProfile(env, batch, args, false, 'a1');\n      } // Save these values to args so that the batch body routine can use them\n\n\n      args.contextDep = contextDynamic;\n      args.needsContext = needsContext;\n      args.needsFramebuffer = needsFramebuffer; // determine if shader is dynamic\n\n      var progDefn = args.shader.progVar;\n\n      if (progDefn.contextDep && contextDynamic || progDefn.propDep) {\n        emitBatchBody(env, batch, args, null);\n      } else {\n        var PROGRAM = progDefn.append(env, batch);\n        batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');\n\n        if (args.shader.program) {\n          emitBatchBody(env, batch, args, args.shader.program);\n        } else {\n          batch(env.shared.vao, '.setVAO(null);');\n          var batchCache = env.global.def('{}');\n          var PROG_ID = batch.def(PROGRAM, '.id');\n          var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');\n          batch(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0,a1);').else(CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=', env.link(function (program) {\n            return createBody(emitBatchBody, env, args, program, 2);\n          }), '(', PROGRAM, ');', CACHED_PROC, '.call(this,a0,a1);'));\n        }\n      }\n\n      if (Object.keys(args.state).length > 0) {\n        batch(env.shared.current, '.dirty=true;');\n      }\n\n      if (env.shared.vao) {\n        batch(env.shared.vao, '.setVAO(null);');\n      }\n    } // ===================================================\n    // ===================================================\n    // SCOPE COMMAND\n    // ===================================================\n    // ===================================================\n\n\n    function emitScopeProc(env, args) {\n      var scope = env.proc('scope', 3);\n      env.batchId = 'a2';\n      var shared = env.shared;\n      var CURRENT_STATE = shared.current;\n      emitContext(env, scope, args.context);\n\n      if (args.framebuffer) {\n        args.framebuffer.append(env, scope);\n      }\n\n      sortState(Object.keys(args.state)).forEach(function (name) {\n        var defn = args.state[name];\n        var value = defn.append(env, scope);\n\n        if (isArrayLike(value)) {\n          value.forEach(function (v, i) {\n            if (hasVariableReference(v)) {\n              scope.set(env.next[name], '[' + i + ']', v);\n            } else {\n              scope.set(env.next[name], '[' + i + ']', env.link(v, {\n                stable: true\n              }));\n            }\n          });\n        } else {\n          if (isStatic(defn)) {\n            scope.set(shared.next, '.' + name, env.link(value, {\n              stable: true\n            }));\n          } else {\n            scope.set(shared.next, '.' + name, value);\n          }\n        }\n      });\n      emitProfile(env, scope, args, true, true);\n      [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(function (opt) {\n        var variable = args.draw[opt];\n\n        if (!variable) {\n          return;\n        }\n\n        var VARIABLE = variable.append(env, scope);\n\n        if (hasVariableReference(VARIABLE)) {\n          scope.set(shared.draw, '.' + opt, VARIABLE);\n        } else {\n          scope.set(shared.draw, '.' + opt, env.link(VARIABLE), {\n            stable: true\n          });\n        }\n      });\n      Object.keys(args.uniforms).forEach(function (opt) {\n        var value = args.uniforms[opt].append(env, scope);\n\n        if (Array.isArray(value)) {\n          value = '[' + value.map(function (v) {\n            if (hasVariableReference(v)) {\n              return v;\n            } else {\n              return env.link(v, {\n                stable: true\n              });\n            }\n          }) + ']';\n        }\n\n        scope.set(shared.uniforms, '[' + env.link(stringStore.id(opt), {\n          stable: true\n        }) + ']', value);\n      });\n      Object.keys(args.attributes).forEach(function (name) {\n        var record = args.attributes[name].append(env, scope);\n        var scopeAttrib = env.scopeAttrib(name);\n        Object.keys(new AttributeRecord()).forEach(function (prop) {\n          scope.set(scopeAttrib, '.' + prop, record[prop]);\n        });\n      });\n\n      if (args.scopeVAO) {\n        var VARIABLE = args.scopeVAO.append(env, scope);\n\n        if (hasVariableReference(VARIABLE)) {\n          scope.set(shared.vao, '.targetVAO', VARIABLE);\n        } else {\n          scope.set(shared.vao, '.targetVAO', env.link(VARIABLE, {\n            stable: true\n          }));\n        }\n      }\n\n      function saveShader(name) {\n        var shader = args.shader[name];\n\n        if (shader) {\n          var VARIABLE = shader.append(env, scope);\n\n          if (hasVariableReference(VARIABLE)) {\n            scope.set(shared.shader, '.' + name, VARIABLE);\n          } else {\n            scope.set(shared.shader, '.' + name, env.link(VARIABLE, {\n              stable: true\n            }));\n          }\n        }\n      }\n\n      saveShader(S_VERT);\n      saveShader(S_FRAG);\n\n      if (Object.keys(args.state).length > 0) {\n        scope(CURRENT_STATE, '.dirty=true;');\n        scope.exit(CURRENT_STATE, '.dirty=true;');\n      }\n\n      scope('a1(', env.shared.context, ',a0,', env.batchId, ');');\n    }\n\n    function isDynamicObject(object) {\n      if (typeof object !== 'object' || isArrayLike(object)) {\n        return;\n      }\n\n      var props = Object.keys(object);\n\n      for (var i = 0; i < props.length; ++i) {\n        if (dynamic.isDynamic(object[props[i]])) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function splatObject(env, options, name) {\n      var object = options.static[name];\n\n      if (!object || !isDynamicObject(object)) {\n        return;\n      }\n\n      var globals = env.global;\n      var keys = Object.keys(object);\n      var thisDep = false;\n      var contextDep = false;\n      var propDep = false;\n      var objectRef = env.global.def('{}');\n      keys.forEach(function (key) {\n        var value = object[key];\n\n        if (dynamic.isDynamic(value)) {\n          if (typeof value === 'function') {\n            value = object[key] = dynamic.unbox(value);\n          }\n\n          var deps = createDynamicDecl(value, null);\n          thisDep = thisDep || deps.thisDep;\n          propDep = propDep || deps.propDep;\n          contextDep = contextDep || deps.contextDep;\n        } else {\n          globals(objectRef, '.', key, '=');\n\n          switch (typeof value) {\n            case 'number':\n              globals(value);\n              break;\n\n            case 'string':\n              globals('\"', value, '\"');\n              break;\n\n            case 'object':\n              if (Array.isArray(value)) {\n                globals('[', value.join(), ']');\n              }\n\n              break;\n\n            default:\n              globals(env.link(value));\n              break;\n          }\n\n          globals(';');\n        }\n      });\n\n      function appendBlock(env, block) {\n        keys.forEach(function (key) {\n          var value = object[key];\n\n          if (!dynamic.isDynamic(value)) {\n            return;\n          }\n\n          var ref = env.invoke(block, value);\n          block(objectRef, '.', key, '=', ref, ';');\n        });\n      }\n\n      options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {\n        thisDep: thisDep,\n        contextDep: contextDep,\n        propDep: propDep,\n        ref: objectRef,\n        append: appendBlock\n      });\n      delete options.static[name];\n    } // ===========================================================================\n    // ===========================================================================\n    // MAIN DRAW COMMAND\n    // ===========================================================================\n    // ===========================================================================\n\n\n    function compileCommand(options, attributes, uniforms, context, stats) {\n      var env = createREGLEnvironment(); // link stats, so that we can easily access it in the program.\n\n      env.stats = env.link(stats); // splat options and attributes to allow for dynamic nested properties\n\n      Object.keys(attributes.static).forEach(function (key) {\n        splatObject(env, attributes, key);\n      });\n      NESTED_OPTIONS.forEach(function (name) {\n        splatObject(env, options, name);\n      });\n      var args = parseArguments(options, attributes, uniforms, context, env);\n\n      if (args.shader.program) {\n        args.shader.program.attributes.sort(function (a, b) {\n          return a.name < b.name ? -1 : 1;\n        });\n        args.shader.program.uniforms.sort(function (a, b) {\n          return a.name < b.name ? -1 : 1;\n        });\n      }\n\n      emitDrawProc(env, args);\n      emitScopeProc(env, args);\n      emitBatchProc(env, args);\n      return extend(env.compile(), {\n        destroy: function destroy() {\n          args.shader.program.destroy();\n        }\n      });\n    } // ===========================================================================\n    // ===========================================================================\n    // POLL / REFRESH\n    // ===========================================================================\n    // ===========================================================================\n\n\n    return {\n      next: nextState,\n      current: currentState,\n      procs: function () {\n        var env = createREGLEnvironment();\n        var poll = env.proc('poll');\n        var refresh = env.proc('refresh');\n        var common = env.block();\n        poll(common);\n        refresh(common);\n        var shared = env.shared;\n        var GL = shared.gl;\n        var NEXT_STATE = shared.next;\n        var CURRENT_STATE = shared.current;\n        common(CURRENT_STATE, '.dirty=false;');\n        emitPollFramebuffer(env, poll);\n        emitPollFramebuffer(env, refresh, null, true); // Refresh updates all attribute state changes\n\n        var INSTANCING;\n\n        if (extInstancing) {\n          INSTANCING = env.link(extInstancing);\n        } // update vertex array bindings\n\n\n        if (extensions.oes_vertex_array_object) {\n          refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);');\n        }\n\n        var BINDING = refresh.def(shared.attributes);\n        var TEMP_BINDING = refresh.def(0);\n        var ifte = env.cond(TEMP_BINDING, '.buffer');\n        ifte.then(GL, '.enableVertexAttribArray(i);', GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', TEMP_BINDING, '.buffer.buffer);', GL, '.vertexAttribPointer(i,', TEMP_BINDING, '.size,', TEMP_BINDING, '.type,', TEMP_BINDING, '.normalized,', TEMP_BINDING, '.stride,', TEMP_BINDING, '.offset);').else(GL, '.disableVertexAttribArray(i);', GL, '.vertexAttrib4f(i,', TEMP_BINDING, '.x,', TEMP_BINDING, '.y,', TEMP_BINDING, '.z,', TEMP_BINDING, '.w);', TEMP_BINDING, '.buffer=null;');\n        var MAX_ATTRIBUTES = env.link(limits.maxAttributes, {\n          stable: true\n        });\n        refresh('for(var i=0;i<', MAX_ATTRIBUTES, ';++i){', TEMP_BINDING, '=', BINDING, '[i];', ifte, '}');\n\n        if (extInstancing) {\n          refresh('for(var i=0;i<', MAX_ATTRIBUTES, ';++i){', INSTANCING, '.vertexAttribDivisorANGLE(i,', BINDING, '[i].divisor);', '}');\n        }\n\n        refresh(env.shared.vao, '.currentVAO=null;', env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');\n        Object.keys(GL_FLAGS).forEach(function (flag) {\n          var cap = GL_FLAGS[flag];\n          var NEXT = common.def(NEXT_STATE, '.', flag);\n          var block = env.block();\n          block('if(', NEXT, '){', GL, '.enable(', cap, ')}else{', GL, '.disable(', cap, ')}', CURRENT_STATE, '.', flag, '=', NEXT, ';');\n          refresh(block);\n          poll('if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){', block, '}');\n        });\n        Object.keys(GL_VARIABLES).forEach(function (name) {\n          var func = GL_VARIABLES[name];\n          var init = currentState[name];\n          var NEXT, CURRENT;\n          var block = env.block();\n          block(GL, '.', func, '(');\n\n          if (isArrayLike(init)) {\n            var n = init.length;\n            NEXT = env.global.def(NEXT_STATE, '.', name);\n            CURRENT = env.global.def(CURRENT_STATE, '.', name);\n            block(loop(n, function (i) {\n              return NEXT + '[' + i + ']';\n            }), ');', loop(n, function (i) {\n              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];';\n            }).join(''));\n            poll('if(', loop(n, function (i) {\n              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']';\n            }).join('||'), '){', block, '}');\n          } else {\n            NEXT = common.def(NEXT_STATE, '.', name);\n            CURRENT = common.def(CURRENT_STATE, '.', name);\n            block(NEXT, ');', CURRENT_STATE, '.', name, '=', NEXT, ';');\n            poll('if(', NEXT, '!==', CURRENT, '){', block, '}');\n          }\n\n          refresh(block);\n        });\n        return env.compile();\n      }(),\n      compile: compileCommand\n    };\n  }\n\n  function stats() {\n    return {\n      vaoCount: 0,\n      bufferCount: 0,\n      elementsCount: 0,\n      framebufferCount: 0,\n      shaderCount: 0,\n      textureCount: 0,\n      cubeCount: 0,\n      renderbufferCount: 0,\n      maxTextureUnits: 0\n    };\n  }\n\n  var GL_QUERY_RESULT_EXT = 0x8866;\n  var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;\n  var GL_TIME_ELAPSED_EXT = 0x88BF;\n\n  var createTimer = function createTimer(gl, extensions) {\n    if (!extensions.ext_disjoint_timer_query) {\n      return null;\n    } // QUERY POOL BEGIN\n\n\n    var queryPool = [];\n\n    function allocQuery() {\n      return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();\n    }\n\n    function freeQuery(query) {\n      queryPool.push(query);\n    } // QUERY POOL END\n\n\n    var pendingQueries = [];\n\n    function beginQuery(stats) {\n      var query = allocQuery();\n      extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);\n      pendingQueries.push(query);\n      pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);\n    }\n\n    function endQuery() {\n      extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);\n    } //\n    // Pending stats pool.\n    //\n\n\n    function PendingStats() {\n      this.startQueryIndex = -1;\n      this.endQueryIndex = -1;\n      this.sum = 0;\n      this.stats = null;\n    }\n\n    var pendingStatsPool = [];\n\n    function allocPendingStats() {\n      return pendingStatsPool.pop() || new PendingStats();\n    }\n\n    function freePendingStats(pendingStats) {\n      pendingStatsPool.push(pendingStats);\n    } // Pending stats pool end\n\n\n    var pendingStats = [];\n\n    function pushScopeStats(start, end, stats) {\n      var ps = allocPendingStats();\n      ps.startQueryIndex = start;\n      ps.endQueryIndex = end;\n      ps.sum = 0;\n      ps.stats = stats;\n      pendingStats.push(ps);\n    } // we should call this at the beginning of the frame,\n    // in order to update gpuTime\n\n\n    var timeSum = [];\n    var queryPtr = [];\n\n    function update() {\n      var ptr, i;\n      var n = pendingQueries.length;\n\n      if (n === 0) {\n        return;\n      } // Reserve space\n\n\n      queryPtr.length = Math.max(queryPtr.length, n + 1);\n      timeSum.length = Math.max(timeSum.length, n + 1);\n      timeSum[0] = 0;\n      queryPtr[0] = 0; // Update all pending timer queries\n\n      var queryTime = 0;\n      ptr = 0;\n\n      for (i = 0; i < pendingQueries.length; ++i) {\n        var query = pendingQueries[i];\n\n        if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {\n          queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);\n          freeQuery(query);\n        } else {\n          pendingQueries[ptr++] = query;\n        }\n\n        timeSum[i + 1] = queryTime;\n        queryPtr[i + 1] = ptr;\n      }\n\n      pendingQueries.length = ptr; // Update all pending stat queries\n\n      ptr = 0;\n\n      for (i = 0; i < pendingStats.length; ++i) {\n        var stats = pendingStats[i];\n        var start = stats.startQueryIndex;\n        var end = stats.endQueryIndex;\n        stats.sum += timeSum[end] - timeSum[start];\n        var startPtr = queryPtr[start];\n        var endPtr = queryPtr[end];\n\n        if (endPtr === startPtr) {\n          stats.stats.gpuTime += stats.sum / 1e6;\n          freePendingStats(stats);\n        } else {\n          stats.startQueryIndex = startPtr;\n          stats.endQueryIndex = endPtr;\n          pendingStats[ptr++] = stats;\n        }\n      }\n\n      pendingStats.length = ptr;\n    }\n\n    return {\n      beginQuery: beginQuery,\n      endQuery: endQuery,\n      pushScopeStats: pushScopeStats,\n      update: update,\n      getNumPendingQueries: function getNumPendingQueries() {\n        return pendingQueries.length;\n      },\n      clear: function clear() {\n        queryPool.push.apply(queryPool, pendingQueries);\n\n        for (var i = 0; i < queryPool.length; i++) {\n          extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i]);\n        }\n\n        pendingQueries.length = 0;\n        queryPool.length = 0;\n      },\n      restore: function restore() {\n        pendingQueries.length = 0;\n        queryPool.length = 0;\n      }\n    };\n  };\n\n  var GL_COLOR_BUFFER_BIT = 16384;\n  var GL_DEPTH_BUFFER_BIT = 256;\n  var GL_STENCIL_BUFFER_BIT = 1024;\n  var GL_ARRAY_BUFFER = 34962;\n  var CONTEXT_LOST_EVENT = 'webglcontextlost';\n  var CONTEXT_RESTORED_EVENT = 'webglcontextrestored';\n  var DYN_PROP = 1;\n  var DYN_CONTEXT = 2;\n  var DYN_STATE = 3;\n\n  function find(haystack, needle) {\n    for (var i = 0; i < haystack.length; ++i) {\n      if (haystack[i] === needle) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function wrapREGL(args) {\n    var config = parseArgs(args);\n\n    if (!config) {\n      return null;\n    }\n\n    var gl = config.gl;\n    var glAttributes = gl.getContextAttributes();\n    var contextLost = gl.isContextLost();\n    var extensionState = createExtensionCache(gl, config);\n\n    if (!extensionState) {\n      return null;\n    }\n\n    var stringStore = createStringStore();\n    var stats$$1 = stats();\n    var cachedCode = config.cachedCode || {};\n    var extensions = extensionState.extensions;\n    var timer = createTimer(gl, extensions);\n    var START_TIME = clock();\n    var WIDTH = gl.drawingBufferWidth;\n    var HEIGHT = gl.drawingBufferHeight;\n    var contextState = {\n      tick: 0,\n      time: 0,\n      viewportWidth: WIDTH,\n      viewportHeight: HEIGHT,\n      framebufferWidth: WIDTH,\n      framebufferHeight: HEIGHT,\n      drawingBufferWidth: WIDTH,\n      drawingBufferHeight: HEIGHT,\n      pixelRatio: config.pixelRatio\n    };\n    var uniformState = {};\n    var drawState = {\n      elements: null,\n      primitive: 4,\n      // GL_TRIANGLES\n      count: -1,\n      offset: 0,\n      instances: -1\n    };\n    var limits = wrapLimits(gl, extensions);\n    var bufferState = wrapBufferState(gl, stats$$1, config, destroyBuffer);\n    var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);\n    var attributeState = wrapAttributeState(gl, extensions, limits, stats$$1, bufferState, elementState, drawState);\n\n    function destroyBuffer(buffer) {\n      return attributeState.destroyBuffer(buffer);\n    }\n\n    var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);\n    var textureState = createTextureSet(gl, extensions, limits, function () {\n      core.procs.poll();\n    }, contextState, stats$$1, config);\n    var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);\n    var framebufferState = wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats$$1);\n    var core = reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, cachedCode, config);\n    var readPixels = wrapReadPixels(gl, framebufferState, core.procs.poll, contextState, glAttributes, extensions, limits);\n    var nextState = core.next;\n    var canvas = gl.canvas;\n    var rafCallbacks = [];\n    var lossCallbacks = [];\n    var restoreCallbacks = [];\n    var destroyCallbacks = [config.onDestroy];\n    var activeRAF = null;\n\n    function handleRAF() {\n      if (rafCallbacks.length === 0) {\n        if (timer) {\n          timer.update();\n        }\n\n        activeRAF = null;\n        return;\n      } // schedule next animation frame\n\n\n      activeRAF = raf.next(handleRAF); // poll for changes\n\n      _poll(); // fire a callback for all pending rafs\n\n\n      for (var i = rafCallbacks.length - 1; i >= 0; --i) {\n        var cb = rafCallbacks[i];\n\n        if (cb) {\n          cb(contextState, null, 0);\n        }\n      } // flush all pending webgl calls\n\n\n      gl.flush(); // poll GPU timers *after* gl.flush so we don't delay command dispatch\n\n      if (timer) {\n        timer.update();\n      }\n    }\n\n    function startRAF() {\n      if (!activeRAF && rafCallbacks.length > 0) {\n        activeRAF = raf.next(handleRAF);\n      }\n    }\n\n    function stopRAF() {\n      if (activeRAF) {\n        raf.cancel(handleRAF);\n        activeRAF = null;\n      }\n    }\n\n    function handleContextLoss(event) {\n      event.preventDefault(); // set context lost flag\n\n      contextLost = true; // pause request animation frame\n\n      stopRAF(); // lose context\n\n      lossCallbacks.forEach(function (cb) {\n        cb();\n      });\n    }\n\n    function handleContextRestored(event) {\n      // clear error code\n      gl.getError(); // clear context lost flag\n\n      contextLost = false; // refresh state\n\n      extensionState.restore();\n      shaderState.restore();\n      bufferState.restore();\n      textureState.restore();\n      renderbufferState.restore();\n      framebufferState.restore();\n      attributeState.restore();\n\n      if (timer) {\n        timer.restore();\n      } // refresh state\n\n\n      core.procs.refresh(); // restart RAF\n\n      startRAF(); // restore context\n\n      restoreCallbacks.forEach(function (cb) {\n        cb();\n      });\n    }\n\n    if (canvas) {\n      canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);\n      canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);\n    }\n\n    function destroy() {\n      rafCallbacks.length = 0;\n      stopRAF();\n\n      if (canvas) {\n        canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);\n        canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);\n      }\n\n      shaderState.clear();\n      framebufferState.clear();\n      renderbufferState.clear();\n      attributeState.clear();\n      textureState.clear();\n      elementState.clear();\n      bufferState.clear();\n\n      if (timer) {\n        timer.clear();\n      }\n\n      destroyCallbacks.forEach(function (cb) {\n        cb();\n      });\n    }\n\n    function compileProcedure(options) {\n      function flattenNestedOptions(options) {\n        var result = extend({}, options);\n        delete result.uniforms;\n        delete result.attributes;\n        delete result.context;\n        delete result.vao;\n\n        if ('stencil' in result && result.stencil.op) {\n          result.stencil.opBack = result.stencil.opFront = result.stencil.op;\n          delete result.stencil.op;\n        }\n\n        function merge(name) {\n          if (name in result) {\n            var child = result[name];\n            delete result[name];\n            Object.keys(child).forEach(function (prop) {\n              result[name + '.' + prop] = child[prop];\n            });\n          }\n        }\n\n        merge('blend');\n        merge('depth');\n        merge('cull');\n        merge('stencil');\n        merge('polygonOffset');\n        merge('scissor');\n        merge('sample');\n\n        if ('vao' in options) {\n          result.vao = options.vao;\n        }\n\n        return result;\n      }\n\n      function separateDynamic(object, useArrays) {\n        var staticItems = {};\n        var dynamicItems = {};\n        Object.keys(object).forEach(function (option) {\n          var value = object[option];\n\n          if (dynamic.isDynamic(value)) {\n            dynamicItems[option] = dynamic.unbox(value, option);\n            return;\n          } else if (useArrays && Array.isArray(value)) {\n            for (var i = 0; i < value.length; ++i) {\n              if (dynamic.isDynamic(value[i])) {\n                dynamicItems[option] = dynamic.unbox(value, option);\n                return;\n              }\n            }\n          }\n\n          staticItems[option] = value;\n        });\n        return {\n          dynamic: dynamicItems,\n          static: staticItems\n        };\n      } // Treat context variables separate from other dynamic variables\n\n\n      var context = separateDynamic(options.context || {}, true);\n      var uniforms = separateDynamic(options.uniforms || {}, true);\n      var attributes = separateDynamic(options.attributes || {}, false);\n      var opts = separateDynamic(flattenNestedOptions(options), false);\n      var stats$$1 = {\n        gpuTime: 0.0,\n        cpuTime: 0.0,\n        count: 0\n      };\n      var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);\n      var draw = compiled.draw;\n      var batch = compiled.batch;\n      var scope = compiled.scope; // FIXME: we should modify code generation for batch commands so this\n      // isn't necessary\n\n      var EMPTY_ARRAY = [];\n\n      function reserve(count) {\n        while (EMPTY_ARRAY.length < count) {\n          EMPTY_ARRAY.push(null);\n        }\n\n        return EMPTY_ARRAY;\n      }\n\n      function REGLCommand(args, body) {\n        var i;\n\n        if (contextLost) {}\n\n        if (typeof args === 'function') {\n          return scope.call(this, null, args, 0);\n        } else if (typeof body === 'function') {\n          if (typeof args === 'number') {\n            for (i = 0; i < args; ++i) {\n              scope.call(this, null, body, i);\n            }\n          } else if (Array.isArray(args)) {\n            for (i = 0; i < args.length; ++i) {\n              scope.call(this, args[i], body, i);\n            }\n          } else {\n            return scope.call(this, args, body, 0);\n          }\n        } else if (typeof args === 'number') {\n          if (args > 0) {\n            return batch.call(this, reserve(args | 0), args | 0);\n          }\n        } else if (Array.isArray(args)) {\n          if (args.length) {\n            return batch.call(this, args, args.length);\n          }\n        } else {\n          return draw.call(this, args);\n        }\n      }\n\n      return extend(REGLCommand, {\n        stats: stats$$1,\n        destroy: function destroy() {\n          compiled.destroy();\n        }\n      });\n    }\n\n    var setFBO = framebufferState.setFBO = compileProcedure({\n      framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')\n    });\n\n    function clearImpl(_, options) {\n      var clearFlags = 0;\n      core.procs.poll();\n      var c = options.color;\n\n      if (c) {\n        gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);\n        clearFlags |= GL_COLOR_BUFFER_BIT;\n      }\n\n      if ('depth' in options) {\n        gl.clearDepth(+options.depth);\n        clearFlags |= GL_DEPTH_BUFFER_BIT;\n      }\n\n      if ('stencil' in options) {\n        gl.clearStencil(options.stencil | 0);\n        clearFlags |= GL_STENCIL_BUFFER_BIT;\n      }\n\n      gl.clear(clearFlags);\n    }\n\n    function clear(options) {\n      if ('framebuffer' in options) {\n        if (options.framebuffer && options.framebuffer_reglType === 'framebufferCube') {\n          for (var i = 0; i < 6; ++i) {\n            setFBO(extend({\n              framebuffer: options.framebuffer.faces[i]\n            }, options), clearImpl);\n          }\n        } else {\n          setFBO(options, clearImpl);\n        }\n      } else {\n        clearImpl(null, options);\n      }\n    }\n\n    function frame(cb) {\n      rafCallbacks.push(cb);\n\n      function cancel() {\n        // FIXME:  should we check something other than equals cb here?\n        // what if a user calls frame twice with the same callback...\n        //\n        var i = find(rafCallbacks, cb);\n\n        function pendingCancel() {\n          var index = find(rafCallbacks, pendingCancel);\n          rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];\n          rafCallbacks.length -= 1;\n\n          if (rafCallbacks.length <= 0) {\n            stopRAF();\n          }\n        }\n\n        rafCallbacks[i] = pendingCancel;\n      }\n\n      startRAF();\n      return {\n        cancel: cancel\n      };\n    } // poll viewport\n\n\n    function pollViewport() {\n      var viewport = nextState.viewport;\n      var scissorBox = nextState.scissor_box;\n      viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;\n      contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl.drawingBufferWidth;\n      contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl.drawingBufferHeight;\n    }\n\n    function _poll() {\n      contextState.tick += 1;\n      contextState.time = now();\n      pollViewport();\n      core.procs.poll();\n    }\n\n    function refresh() {\n      textureState.refresh();\n      pollViewport();\n      core.procs.refresh();\n\n      if (timer) {\n        timer.update();\n      }\n    }\n\n    function now() {\n      return (clock() - START_TIME) / 1000.0;\n    }\n\n    refresh();\n\n    function addListener(event, callback) {\n      var callbacks;\n\n      switch (event) {\n        case 'frame':\n          return frame(callback);\n\n        case 'lost':\n          callbacks = lossCallbacks;\n          break;\n\n        case 'restore':\n          callbacks = restoreCallbacks;\n          break;\n\n        case 'destroy':\n          callbacks = destroyCallbacks;\n          break;\n\n        default:\n      }\n\n      callbacks.push(callback);\n      return {\n        cancel: function cancel() {\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i] === callback) {\n              callbacks[i] = callbacks[callbacks.length - 1];\n              callbacks.pop();\n              return;\n            }\n          }\n        }\n      };\n    }\n\n    function getCachedCode() {\n      return cachedCode;\n    }\n\n    function preloadCachedCode(moreCache) {\n      Object.entries(moreCache).forEach(function (kv) {\n        cachedCode[kv[0]] = kv[1];\n      });\n    }\n\n    var regl = extend(compileProcedure, {\n      // Clear current FBO\n      clear: clear,\n      // Short cuts for dynamic variables\n      prop: dynamic.define.bind(null, DYN_PROP),\n      context: dynamic.define.bind(null, DYN_CONTEXT),\n      this: dynamic.define.bind(null, DYN_STATE),\n      // executes an empty draw command\n      draw: compileProcedure({}),\n      // Resources\n      buffer: function buffer(options) {\n        return bufferState.create(options, GL_ARRAY_BUFFER, false, false);\n      },\n      elements: function elements(options) {\n        return elementState.create(options, false);\n      },\n      texture: textureState.create2D,\n      cube: textureState.createCube,\n      renderbuffer: renderbufferState.create,\n      framebuffer: framebufferState.create,\n      framebufferCube: framebufferState.createCube,\n      vao: attributeState.createVAO,\n      // Expose context attributes\n      attributes: glAttributes,\n      // Frame rendering\n      frame: frame,\n      on: addListener,\n      // System limits\n      limits: limits,\n      hasExtension: function hasExtension(name) {\n        return limits.extensions.indexOf(name.toLowerCase()) >= 0;\n      },\n      // Read pixels\n      read: readPixels,\n      // Destroy regl and all associated resources\n      destroy: destroy,\n      // Direct GL state manipulation\n      _gl: gl,\n      _refresh: refresh,\n      poll: function poll() {\n        _poll();\n\n        if (timer) {\n          timer.update();\n        }\n      },\n      // Current time\n      now: now,\n      // regl Statistics Information\n      stats: stats$$1,\n      // cache generated code\n      getCachedCode: getCachedCode,\n      preloadCachedCode: preloadCachedCode\n    });\n    config.onDone(null, regl);\n    return regl;\n  }\n\n  return wrapREGL;\n});","map":null,"metadata":{},"sourceType":"script"}