{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n  var inHover = opts._inHover;\n  var grouped = helpers.isGrouped(opts);\n  var reversed = helpers.isReversed(opts);\n  var lgroupToTraces = {};\n  var lgroups = [];\n  var hasOneNonBlankGroup = false;\n  var slicesShown = {};\n  var lgroupi = 0;\n  var maxNameLength = 0;\n  var i, j;\n\n  function addOneItem(legendGroup, legendItem) {\n    // each '' legend group is treated as a separate group\n    if (legendGroup === '' || !helpers.isGrouped(opts)) {\n      // TODO: check this against fullData legendgroups?\n      var uniqueGroup = '~~i' + lgroupi;\n      lgroups.push(uniqueGroup);\n      lgroupToTraces[uniqueGroup] = [legendItem];\n      lgroupi++;\n    } else if (lgroups.indexOf(legendGroup) === -1) {\n      lgroups.push(legendGroup);\n      hasOneNonBlankGroup = true;\n      lgroupToTraces[legendGroup] = [legendItem];\n    } else {\n      lgroupToTraces[legendGroup].push(legendItem);\n    }\n  } // build an { legendgroup: [cd0, cd0], ... } object\n\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var lgroup = trace.legendgroup;\n    if (!inHover && (!trace.visible || !trace.showlegend)) continue;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n      for (j = 0; j < cd.length; j++) {\n        var labelj = cd[j].label;\n\n        if (!slicesShown[lgroup][labelj]) {\n          addOneItem(lgroup, {\n            label: labelj,\n            color: cd[j].color,\n            i: cd[j].i,\n            trace: trace,\n            pts: cd[j].pts\n          });\n          slicesShown[lgroup][labelj] = true;\n          maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n        }\n      }\n    } else {\n      addOneItem(lgroup, cd0);\n      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n    }\n  } // won't draw a legend in this case\n\n\n  if (!lgroups.length) return []; // collapse all groups into one if all groups are blank\n\n  var shouldCollapse = !hasOneNonBlankGroup || !grouped;\n  var legendData = [];\n\n  for (i = 0; i < lgroups.length; i++) {\n    var t = lgroupToTraces[lgroups[i]];\n\n    if (shouldCollapse) {\n      legendData.push(t[0]);\n    } else {\n      legendData.push(t);\n    }\n  }\n\n  if (shouldCollapse) legendData = [legendData];\n\n  for (i = 0; i < legendData.length; i++) {\n    // find minimum rank within group\n    var groupMinRank = Infinity;\n\n    for (j = 0; j < legendData[i].length; j++) {\n      var rank = legendData[i][j].trace.legendrank;\n      if (groupMinRank > rank) groupMinRank = rank;\n    } // record on first group element\n\n\n    legendData[i][0]._groupMinRank = groupMinRank;\n    legendData[i][0]._preGroupSort = i;\n  }\n\n  var orderFn1 = function orderFn1(a, b) {\n    return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  };\n\n  var orderFn2 = function orderFn2(a, b) {\n    return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  }; // sort considering minimum group legendrank\n\n\n  legendData.forEach(function (a, k) {\n    a[0]._preGroupSort = k;\n  });\n  legendData.sort(orderFn1);\n\n  for (i = 0; i < legendData.length; i++) {\n    // sort considering trace.legendrank and legend.traceorder\n    legendData[i].forEach(function (a, k) {\n      a._preSort = k;\n    });\n    legendData[i].sort(orderFn2);\n    var firstItemTrace = legendData[i][0].trace;\n    var groupTitle = null; // get group title text\n\n    for (j = 0; j < legendData[i].length; j++) {\n      var gt = legendData[i][j].trace.legendgrouptitle;\n\n      if (gt && gt.text) {\n        groupTitle = gt;\n        if (inHover) gt.font = opts._groupTitleFont;\n        break;\n      }\n    } // reverse order\n\n\n    if (reversed) legendData[i].reverse();\n\n    if (groupTitle) {\n      var hasPieLike = false;\n\n      for (j = 0; j < legendData[i].length; j++) {\n        if (Registry.traceIs(legendData[i][j].trace, 'pie-like')) {\n          hasPieLike = true;\n          break;\n        }\n      } // set group title text\n\n\n      legendData[i].unshift({\n        i: -1,\n        groupTitle: groupTitle,\n        noClick: hasPieLike,\n        trace: {\n          showlegend: firstItemTrace.showlegend,\n          legendgroup: firstItemTrace.legendgroup,\n          visible: opts.groupclick === 'toggleitem' ? true : firstItemTrace.visible\n        }\n      });\n    } // rearrange lgroupToTraces into a d3-friendly array of arrays\n\n\n    for (j = 0; j < legendData[i].length; j++) {\n      legendData[i][j] = [legendData[i][j]];\n    }\n  } // number of legend groups - needed in legend/draw.js\n\n\n  opts._lgroupsLength = legendData.length; // maximum name/label length - needed in legend/draw.js\n\n  opts._maxNameLength = maxNameLength;\n  return legendData;\n};","map":null,"metadata":{},"sourceType":"script"}