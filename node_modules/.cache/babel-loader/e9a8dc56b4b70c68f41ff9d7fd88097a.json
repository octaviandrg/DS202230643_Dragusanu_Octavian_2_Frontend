{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\nvar _ = Lib._;\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar setConvert = require('../cartesian/set_convert');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar Plots = require('../plots');\n\nvar Axes = require('../cartesian/axes');\n\nvar dragElement = require('../../components/dragelement');\n\nvar Fx = require('../../components/fx');\n\nvar dragHelpers = require('../../components/dragelement/helpers');\n\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\n\nvar Titles = require('../../components/titles');\n\nvar prepSelect = require('../../components/selections').prepSelect;\n\nvar selectOnClick = require('../../components/selections').selectOnClick;\n\nvar clearOutline = require('../../components/selections').clearOutline;\n\nvar clearSelectionsCache = require('../../components/selections').clearSelectionsCache;\n\nvar constants = require('../cartesian/constants');\n\nfunction Ternary(options, fullLayout) {\n  this.id = options.id;\n  this.graphDiv = options.graphDiv;\n  this.init(fullLayout);\n  this.makeFramework(fullLayout); // unfortunately, we have to keep track of some axis tick settings\n  // as ternary subplots do not implement the 'ticks' editType\n\n  this.aTickLayout = null;\n  this.bTickLayout = null;\n  this.cTickLayout = null;\n}\n\nmodule.exports = Ternary;\nvar proto = Ternary.prototype;\n\nproto.init = function (fullLayout) {\n  this.container = fullLayout._ternarylayer;\n  this.defs = fullLayout._defs;\n  this.layoutId = fullLayout._uid;\n  this.traceHash = {};\n  this.layers = {};\n};\n\nproto.plot = function (ternaryCalcData, fullLayout) {\n  var _this = this;\n\n  var ternaryLayout = fullLayout[_this.id];\n  var graphSize = fullLayout._size;\n  _this._hasClipOnAxisFalse = false;\n\n  for (var i = 0; i < ternaryCalcData.length; i++) {\n    var trace = ternaryCalcData[i][0].trace;\n\n    if (trace.cliponaxis === false) {\n      _this._hasClipOnAxisFalse = true;\n      break;\n    }\n  }\n\n  _this.updateLayers(ternaryLayout);\n\n  _this.adjustLayout(ternaryLayout, graphSize);\n\n  Plots.generalUpdatePerTraceModule(_this.graphDiv, _this, ternaryCalcData, ternaryLayout);\n\n  _this.layers.plotbg.select('path').call(Color.fill, ternaryLayout.bgcolor);\n};\n\nproto.makeFramework = function (fullLayout) {\n  var _this = this;\n\n  var gd = _this.graphDiv;\n  var ternaryLayout = fullLayout[_this.id];\n  var clipId = _this.clipId = 'clip' + _this.layoutId + _this.id;\n  var clipIdRelative = _this.clipIdRelative = 'clip-relative' + _this.layoutId + _this.id; // clippath for this ternary subplot\n\n  _this.clipDef = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipId, function (s) {\n    s.append('path').attr('d', 'M0,0Z');\n  }); // 'relative' clippath (i.e. no translation) for this ternary subplot\n\n  _this.clipDefRelative = Lib.ensureSingleById(fullLayout._clips, 'clipPath', clipIdRelative, function (s) {\n    s.append('path').attr('d', 'M0,0Z');\n  }); // container for everything in this ternary subplot\n\n  _this.plotContainer = Lib.ensureSingle(_this.container, 'g', _this.id);\n\n  _this.updateLayers(ternaryLayout);\n\n  Drawing.setClipUrl(_this.layers.backplot, clipId, gd);\n  Drawing.setClipUrl(_this.layers.grids, clipId, gd);\n};\n\nproto.updateLayers = function (ternaryLayout) {\n  var _this = this;\n\n  var layers = _this.layers; // inside that container, we have one container for the data, and\n  // one each for the three axes around it.\n\n  var plotLayers = ['draglayer', 'plotbg', 'backplot', 'grids'];\n\n  if (ternaryLayout.aaxis.layer === 'below traces') {\n    plotLayers.push('aaxis', 'aline');\n  }\n\n  if (ternaryLayout.baxis.layer === 'below traces') {\n    plotLayers.push('baxis', 'bline');\n  }\n\n  if (ternaryLayout.caxis.layer === 'below traces') {\n    plotLayers.push('caxis', 'cline');\n  }\n\n  plotLayers.push('frontplot');\n\n  if (ternaryLayout.aaxis.layer === 'above traces') {\n    plotLayers.push('aaxis', 'aline');\n  }\n\n  if (ternaryLayout.baxis.layer === 'above traces') {\n    plotLayers.push('baxis', 'bline');\n  }\n\n  if (ternaryLayout.caxis.layer === 'above traces') {\n    plotLayers.push('caxis', 'cline');\n  }\n\n  var toplevel = _this.plotContainer.selectAll('g.toplevel').data(plotLayers, String);\n\n  var grids = ['agrid', 'bgrid', 'cgrid'];\n  toplevel.enter().append('g').attr('class', function (d) {\n    return 'toplevel ' + d;\n  }).each(function (d) {\n    var s = d3.select(this);\n    layers[d] = s; // containers for different trace types.\n    // NOTE - this is different from cartesian, where all traces\n    // are in front of grids. Here I'm putting maps behind the grids\n    // so the grids will always be visible if they're requested.\n    // Perhaps we want that for cartesian too?\n\n    if (d === 'frontplot') {\n      s.append('g').classed('scatterlayer', true);\n    } else if (d === 'backplot') {\n      s.append('g').classed('maplayer', true);\n    } else if (d === 'plotbg') {\n      s.append('path').attr('d', 'M0,0Z');\n    } else if (d === 'aline' || d === 'bline' || d === 'cline') {\n      s.append('path');\n    } else if (d === 'grids') {\n      grids.forEach(function (d) {\n        layers[d] = s.append('g').classed('grid ' + d, true);\n      });\n    }\n  });\n  toplevel.order();\n};\n\nvar whRatio = Math.sqrt(4 / 3);\n\nproto.adjustLayout = function (ternaryLayout, graphSize) {\n  var _this = this;\n\n  var domain = ternaryLayout.domain;\n  var xDomainCenter = (domain.x[0] + domain.x[1]) / 2;\n  var yDomainCenter = (domain.y[0] + domain.y[1]) / 2;\n  var xDomain = domain.x[1] - domain.x[0];\n  var yDomain = domain.y[1] - domain.y[0];\n  var wmax = xDomain * graphSize.w;\n  var hmax = yDomain * graphSize.h;\n  var sum = ternaryLayout.sum;\n  var amin = ternaryLayout.aaxis.min;\n  var bmin = ternaryLayout.baxis.min;\n  var cmin = ternaryLayout.caxis.min;\n  var x0, y0, w, h, xDomainFinal, yDomainFinal;\n\n  if (wmax > whRatio * hmax) {\n    h = hmax;\n    w = h * whRatio;\n  } else {\n    w = wmax;\n    h = w / whRatio;\n  }\n\n  xDomainFinal = xDomain * w / wmax;\n  yDomainFinal = yDomain * h / hmax;\n  x0 = graphSize.l + graphSize.w * xDomainCenter - w / 2;\n  y0 = graphSize.t + graphSize.h * (1 - yDomainCenter) - h / 2;\n  _this.x0 = x0;\n  _this.y0 = y0;\n  _this.w = w;\n  _this.h = h;\n  _this.sum = sum; // set up the x and y axis objects we'll use to lay out the points\n\n  _this.xaxis = {\n    type: 'linear',\n    range: [amin + 2 * cmin - sum, sum - amin - 2 * bmin],\n    domain: [xDomainCenter - xDomainFinal / 2, xDomainCenter + xDomainFinal / 2],\n    _id: 'x'\n  };\n  setConvert(_this.xaxis, _this.graphDiv._fullLayout);\n\n  _this.xaxis.setScale();\n\n  _this.xaxis.isPtWithinRange = function (d) {\n    return d.a >= _this.aaxis.range[0] && d.a <= _this.aaxis.range[1] && d.b >= _this.baxis.range[1] && d.b <= _this.baxis.range[0] && d.c >= _this.caxis.range[1] && d.c <= _this.caxis.range[0];\n  };\n\n  _this.yaxis = {\n    type: 'linear',\n    range: [amin, sum - bmin - cmin],\n    domain: [yDomainCenter - yDomainFinal / 2, yDomainCenter + yDomainFinal / 2],\n    _id: 'y'\n  };\n  setConvert(_this.yaxis, _this.graphDiv._fullLayout);\n\n  _this.yaxis.setScale();\n\n  _this.yaxis.isPtWithinRange = function () {\n    return true;\n  }; // set up the modified axes for tick drawing\n\n\n  var yDomain0 = _this.yaxis.domain[0]; // aaxis goes up the left side. Set it up as a y axis, but with\n  // fictitious angles and domain, but then rotate and translate\n  // it into place at the end\n\n  var aaxis = _this.aaxis = extendFlat({}, ternaryLayout.aaxis, {\n    range: [amin, sum - bmin - cmin],\n    side: 'left',\n    // tickangle = 'auto' means 0 anyway for a y axis, need to coerce to 0 here\n    // so we can shift by 30.\n    tickangle: (+ternaryLayout.aaxis.tickangle || 0) - 30,\n    domain: [yDomain0, yDomain0 + yDomainFinal * whRatio],\n    anchor: 'free',\n    position: 0,\n    _id: 'y',\n    _length: w\n  });\n  setConvert(aaxis, _this.graphDiv._fullLayout);\n  aaxis.setScale(); // baxis goes across the bottom (backward). We can set it up as an x axis\n  // without any enclosing transformation.\n\n  var baxis = _this.baxis = extendFlat({}, ternaryLayout.baxis, {\n    range: [sum - amin - cmin, bmin],\n    side: 'bottom',\n    domain: _this.xaxis.domain,\n    anchor: 'free',\n    position: 0,\n    _id: 'x',\n    _length: w\n  });\n  setConvert(baxis, _this.graphDiv._fullLayout);\n  baxis.setScale(); // caxis goes down the right side. Set it up as a y axis, with\n  // post-transformation similar to aaxis\n\n  var caxis = _this.caxis = extendFlat({}, ternaryLayout.caxis, {\n    range: [sum - amin - bmin, cmin],\n    side: 'right',\n    tickangle: (+ternaryLayout.caxis.tickangle || 0) + 30,\n    domain: [yDomain0, yDomain0 + yDomainFinal * whRatio],\n    anchor: 'free',\n    position: 0,\n    _id: 'y',\n    _length: w\n  });\n  setConvert(caxis, _this.graphDiv._fullLayout);\n  caxis.setScale();\n  var triangleClip = 'M' + x0 + ',' + (y0 + h) + 'h' + w + 'l-' + w / 2 + ',-' + h + 'Z';\n\n  _this.clipDef.select('path').attr('d', triangleClip);\n\n  _this.layers.plotbg.select('path').attr('d', triangleClip);\n\n  var triangleClipRelative = 'M0,' + h + 'h' + w + 'l-' + w / 2 + ',-' + h + 'Z';\n\n  _this.clipDefRelative.select('path').attr('d', triangleClipRelative);\n\n  var plotTransform = strTranslate(x0, y0);\n\n  _this.plotContainer.selectAll('.scatterlayer,.maplayer').attr('transform', plotTransform);\n\n  _this.clipDefRelative.select('path').attr('transform', null); // TODO: shift axes to accommodate linewidth*sin(30) tick mark angle\n  // TODO: there's probably an easier way to handle these translations/offsets now...\n\n\n  var bTransform = strTranslate(x0 - baxis._offset, y0 + h);\n\n  _this.layers.baxis.attr('transform', bTransform);\n\n  _this.layers.bgrid.attr('transform', bTransform);\n\n  var aTransform = strTranslate(x0 + w / 2, y0) + 'rotate(30)' + strTranslate(0, -aaxis._offset);\n\n  _this.layers.aaxis.attr('transform', aTransform);\n\n  _this.layers.agrid.attr('transform', aTransform);\n\n  var cTransform = strTranslate(x0 + w / 2, y0) + 'rotate(-30)' + strTranslate(0, -caxis._offset);\n\n  _this.layers.caxis.attr('transform', cTransform);\n\n  _this.layers.cgrid.attr('transform', cTransform);\n\n  _this.drawAxes(true);\n\n  _this.layers.aline.select('path').attr('d', aaxis.showline ? 'M' + x0 + ',' + (y0 + h) + 'l' + w / 2 + ',-' + h : 'M0,0').call(Color.stroke, aaxis.linecolor || '#000').style('stroke-width', (aaxis.linewidth || 0) + 'px');\n\n  _this.layers.bline.select('path').attr('d', baxis.showline ? 'M' + x0 + ',' + (y0 + h) + 'h' + w : 'M0,0').call(Color.stroke, baxis.linecolor || '#000').style('stroke-width', (baxis.linewidth || 0) + 'px');\n\n  _this.layers.cline.select('path').attr('d', caxis.showline ? 'M' + (x0 + w / 2) + ',' + y0 + 'l' + w / 2 + ',' + h : 'M0,0').call(Color.stroke, caxis.linecolor || '#000').style('stroke-width', (caxis.linewidth || 0) + 'px');\n\n  if (!_this.graphDiv._context.staticPlot) {\n    _this.initInteractions();\n  }\n\n  Drawing.setClipUrl(_this.layers.frontplot, _this._hasClipOnAxisFalse ? null : _this.clipId, _this.graphDiv);\n};\n\nproto.drawAxes = function (doTitles) {\n  var _this = this;\n\n  var gd = _this.graphDiv;\n  var titlesuffix = _this.id.substr(7) + 'title';\n  var layers = _this.layers;\n  var aaxis = _this.aaxis;\n  var baxis = _this.baxis;\n  var caxis = _this.caxis;\n\n  _this.drawAx(aaxis);\n\n  _this.drawAx(baxis);\n\n  _this.drawAx(caxis);\n\n  if (doTitles) {\n    var apad = Math.max(aaxis.showticklabels ? aaxis.tickfont.size / 2 : 0, (caxis.showticklabels ? caxis.tickfont.size * 0.75 : 0) + (caxis.ticks === 'outside' ? caxis.ticklen * 0.87 : 0));\n    var bpad = (baxis.showticklabels ? baxis.tickfont.size : 0) + (baxis.ticks === 'outside' ? baxis.ticklen : 0) + 3;\n    layers['a-title'] = Titles.draw(gd, 'a' + titlesuffix, {\n      propContainer: aaxis,\n      propName: _this.id + '.aaxis.title',\n      placeholder: _(gd, 'Click to enter Component A title'),\n      attributes: {\n        x: _this.x0 + _this.w / 2,\n        y: _this.y0 - aaxis.title.font.size / 3 - apad,\n        'text-anchor': 'middle'\n      }\n    });\n    layers['b-title'] = Titles.draw(gd, 'b' + titlesuffix, {\n      propContainer: baxis,\n      propName: _this.id + '.baxis.title',\n      placeholder: _(gd, 'Click to enter Component B title'),\n      attributes: {\n        x: _this.x0 - bpad,\n        y: _this.y0 + _this.h + baxis.title.font.size * 0.83 + bpad,\n        'text-anchor': 'middle'\n      }\n    });\n    layers['c-title'] = Titles.draw(gd, 'c' + titlesuffix, {\n      propContainer: caxis,\n      propName: _this.id + '.caxis.title',\n      placeholder: _(gd, 'Click to enter Component C title'),\n      attributes: {\n        x: _this.x0 + _this.w + bpad,\n        y: _this.y0 + _this.h + caxis.title.font.size * 0.83 + bpad,\n        'text-anchor': 'middle'\n      }\n    });\n  }\n};\n\nproto.drawAx = function (ax) {\n  var _this = this;\n\n  var gd = _this.graphDiv;\n  var axName = ax._name;\n  var axLetter = axName.charAt(0);\n  var axId = ax._id;\n  var axLayer = _this.layers[axName];\n  var counterAngle = 30;\n  var stashKey = axLetter + 'tickLayout';\n  var newTickLayout = strTickLayout(ax);\n\n  if (_this[stashKey] !== newTickLayout) {\n    axLayer.selectAll('.' + axId + 'tick').remove();\n    _this[stashKey] = newTickLayout;\n  }\n\n  ax.setScale();\n  var vals = Axes.calcTicks(ax);\n  var valsClipped = Axes.clipEnds(ax, vals);\n  var transFn = Axes.makeTransTickFn(ax);\n  var tickSign = Axes.getTickSigns(ax)[2];\n  var caRad = Lib.deg2rad(counterAngle);\n  var pad = tickSign * (ax.linewidth || 1) / 2;\n  var len = tickSign * ax.ticklen;\n  var w = _this.w;\n  var h = _this.h;\n  var tickPath = axLetter === 'b' ? 'M0,' + pad + 'l' + Math.sin(caRad) * len + ',' + Math.cos(caRad) * len : 'M' + pad + ',0l' + Math.cos(caRad) * len + ',' + -Math.sin(caRad) * len;\n  var gridPath = {\n    a: 'M0,0l' + h + ',-' + w / 2,\n    b: 'M0,0l-' + w / 2 + ',-' + h,\n    c: 'M0,0l-' + h + ',' + w / 2\n  }[axLetter];\n  Axes.drawTicks(gd, ax, {\n    vals: ax.ticks === 'inside' ? valsClipped : vals,\n    layer: axLayer,\n    path: tickPath,\n    transFn: transFn,\n    crisp: false\n  });\n  Axes.drawGrid(gd, ax, {\n    vals: valsClipped,\n    layer: _this.layers[axLetter + 'grid'],\n    path: gridPath,\n    transFn: transFn,\n    crisp: false\n  });\n  Axes.drawLabels(gd, ax, {\n    vals: vals,\n    layer: axLayer,\n    transFn: transFn,\n    labelFns: Axes.makeLabelFns(ax, 0, counterAngle)\n  });\n};\n\nfunction strTickLayout(axLayout) {\n  return axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n} // hard coded paths for zoom corners\n// uses the same sizing as cartesian, length is MINZOOM/2, width is 3px\n\n\nvar CLEN = constants.MINZOOM / 2 + 0.87;\nvar BLPATH = 'm-0.87,.5h' + CLEN + 'v3h-' + (CLEN + 5.2) + 'l' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) + 'l2.6,1.5l-' + CLEN / 2 + ',' + CLEN * 0.87 + 'Z';\nvar BRPATH = 'm0.87,.5h-' + CLEN + 'v3h' + (CLEN + 5.2) + 'l-' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) + 'l-2.6,1.5l' + CLEN / 2 + ',' + CLEN * 0.87 + 'Z';\nvar TOPPATH = 'm0,1l' + CLEN / 2 + ',' + CLEN * 0.87 + 'l2.6,-1.5l-' + (CLEN / 2 + 2.6) + ',-' + (CLEN * 0.87 + 4.5) + 'l-' + (CLEN / 2 + 2.6) + ',' + (CLEN * 0.87 + 4.5) + 'l2.6,1.5l' + CLEN / 2 + ',-' + CLEN * 0.87 + 'Z';\nvar STARTMARKER = 'm0.5,0.5h5v-2h-5v-5h-2v5h-5v2h5v5h2Z'; // I guess this could be shared with cartesian... but for now it's separate.\n\nvar SHOWZOOMOUTTIP = true;\n\nproto.clearOutline = function () {\n  clearSelectionsCache(this.dragOptions);\n  clearOutline(this.dragOptions.gd);\n};\n\nproto.initInteractions = function () {\n  var _this = this;\n\n  var dragger = _this.layers.plotbg.select('path').node();\n\n  var gd = _this.graphDiv;\n  var zoomLayer = gd._fullLayout._zoomlayer;\n  var scaleX;\n  var scaleY; // use plotbg for the main interactions\n\n  this.dragOptions = {\n    element: dragger,\n    gd: gd,\n    plotinfo: {\n      id: _this.id,\n      domain: gd._fullLayout[_this.id].domain,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis\n    },\n    subplot: _this.id,\n    prepFn: function prepFn(e, startX, startY) {\n      // these aren't available yet when initInteractions\n      // is called\n      _this.dragOptions.xaxes = [_this.xaxis];\n      _this.dragOptions.yaxes = [_this.yaxis];\n      scaleX = gd._fullLayout._invScaleX;\n      scaleY = gd._fullLayout._invScaleY;\n      var dragModeNow = _this.dragOptions.dragmode = gd._fullLayout.dragmode;\n      if (freeMode(dragModeNow)) _this.dragOptions.minDrag = 1;else _this.dragOptions.minDrag = undefined;\n\n      if (dragModeNow === 'zoom') {\n        _this.dragOptions.moveFn = zoomMove;\n        _this.dragOptions.clickFn = clickZoomPan;\n        _this.dragOptions.doneFn = zoomDone;\n        zoomPrep(e, startX, startY);\n      } else if (dragModeNow === 'pan') {\n        _this.dragOptions.moveFn = plotDrag;\n        _this.dragOptions.clickFn = clickZoomPan;\n        _this.dragOptions.doneFn = dragDone;\n        panPrep();\n\n        _this.clearOutline(gd);\n      } else if (rectMode(dragModeNow) || freeMode(dragModeNow)) {\n        prepSelect(e, startX, startY, _this.dragOptions, dragModeNow);\n      }\n    }\n  };\n  var x0, y0, mins0, span0, mins, lum, path0, dimmed, zb, corners;\n\n  function makeUpdate(_mins) {\n    var attrs = {};\n    attrs[_this.id + '.aaxis.min'] = _mins.a;\n    attrs[_this.id + '.baxis.min'] = _mins.b;\n    attrs[_this.id + '.caxis.min'] = _mins.c;\n    return attrs;\n  }\n\n  function clickZoomPan(numClicks, evt) {\n    var clickMode = gd._fullLayout.clickmode;\n    removeZoombox(gd);\n\n    if (numClicks === 2) {\n      gd.emit('plotly_doubleclick', null);\n      Registry.call('_guiRelayout', gd, makeUpdate({\n        a: 0,\n        b: 0,\n        c: 0\n      }));\n    }\n\n    if (clickMode.indexOf('select') > -1 && numClicks === 1) {\n      selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, _this.dragOptions);\n    }\n\n    if (clickMode.indexOf('event') > -1) {\n      Fx.click(gd, evt, _this.id);\n    }\n  }\n\n  function zoomPrep(e, startX, startY) {\n    var dragBBox = dragger.getBoundingClientRect();\n    x0 = startX - dragBBox.left;\n    y0 = startY - dragBBox.top;\n\n    gd._fullLayout._calcInverseTransform(gd);\n\n    var inverse = gd._fullLayout._invTransform;\n    var transformedCoords = Lib.apply3DTransform(inverse)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    mins0 = {\n      a: _this.aaxis.range[0],\n      b: _this.baxis.range[1],\n      c: _this.caxis.range[1]\n    };\n    mins = mins0;\n    span0 = _this.aaxis.range[1] - mins0.a;\n    lum = tinycolor(_this.graphDiv._fullLayout[_this.id].bgcolor).getLuminance();\n    path0 = 'M0,' + _this.h + 'L' + _this.w / 2 + ', 0L' + _this.w + ',' + _this.h + 'Z';\n    dimmed = false;\n    zb = zoomLayer.append('path').attr('class', 'zoombox').attr('transform', strTranslate(_this.x0, _this.y0)).style({\n      'fill': lum > 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',\n      'stroke-width': 0\n    }).attr('d', path0);\n    corners = zoomLayer.append('path').attr('class', 'zoombox-corners').attr('transform', strTranslate(_this.x0, _this.y0)).style({\n      fill: Color.background,\n      stroke: Color.defaultLine,\n      'stroke-width': 1,\n      opacity: 0\n    }).attr('d', 'M0,0Z');\n\n    _this.clearOutline(gd);\n  }\n\n  function getAFrac(x, y) {\n    return 1 - y / _this.h;\n  }\n\n  function getBFrac(x, y) {\n    return 1 - (x + (_this.h - y) / Math.sqrt(3)) / _this.w;\n  }\n\n  function getCFrac(x, y) {\n    return (x - (_this.h - y) / Math.sqrt(3)) / _this.w;\n  }\n\n  function zoomMove(dx0, dy0) {\n    var x1 = x0 + dx0 * scaleX;\n    var y1 = y0 + dy0 * scaleY;\n    var afrac = Math.max(0, Math.min(1, getAFrac(x0, y0), getAFrac(x1, y1)));\n    var bfrac = Math.max(0, Math.min(1, getBFrac(x0, y0), getBFrac(x1, y1)));\n    var cfrac = Math.max(0, Math.min(1, getCFrac(x0, y0), getCFrac(x1, y1)));\n    var xLeft = (afrac / 2 + cfrac) * _this.w;\n    var xRight = (1 - afrac / 2 - bfrac) * _this.w;\n    var xCenter = (xLeft + xRight) / 2;\n    var xSpan = xRight - xLeft;\n    var yBottom = (1 - afrac) * _this.h;\n    var yTop = yBottom - xSpan / whRatio;\n\n    if (xSpan < constants.MINZOOM) {\n      mins = mins0;\n      zb.attr('d', path0);\n      corners.attr('d', 'M0,0Z');\n    } else {\n      mins = {\n        a: mins0.a + afrac * span0,\n        b: mins0.b + bfrac * span0,\n        c: mins0.c + cfrac * span0\n      };\n      zb.attr('d', path0 + 'M' + xLeft + ',' + yBottom + 'H' + xRight + 'L' + xCenter + ',' + yTop + 'L' + xLeft + ',' + yBottom + 'Z');\n      corners.attr('d', 'M' + x0 + ',' + y0 + STARTMARKER + 'M' + xLeft + ',' + yBottom + BLPATH + 'M' + xRight + ',' + yBottom + BRPATH + 'M' + xCenter + ',' + yTop + TOPPATH);\n    }\n\n    if (!dimmed) {\n      zb.transition().style('fill', lum > 0.2 ? 'rgba(0,0,0,0.4)' : 'rgba(255,255,255,0.3)').duration(200);\n      corners.transition().style('opacity', 1).duration(200);\n      dimmed = true;\n    }\n\n    gd.emit('plotly_relayouting', makeUpdate(mins));\n  }\n\n  function zoomDone() {\n    removeZoombox(gd);\n    if (mins === mins0) return;\n    Registry.call('_guiRelayout', gd, makeUpdate(mins));\n\n    if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {\n      Lib.notifier(_(gd, 'Double-click to zoom back out'), 'long');\n      SHOWZOOMOUTTIP = false;\n    }\n  }\n\n  function panPrep() {\n    mins0 = {\n      a: _this.aaxis.range[0],\n      b: _this.baxis.range[1],\n      c: _this.caxis.range[1]\n    };\n    mins = mins0;\n  }\n\n  function plotDrag(dx, dy) {\n    var dxScaled = dx / _this.xaxis._m;\n    var dyScaled = dy / _this.yaxis._m;\n    mins = {\n      a: mins0.a - dyScaled,\n      b: mins0.b + (dxScaled + dyScaled) / 2,\n      c: mins0.c - (dxScaled - dyScaled) / 2\n    };\n    var minsorted = [mins.a, mins.b, mins.c].sort(Lib.sorterAsc);\n    var minindices = {\n      a: minsorted.indexOf(mins.a),\n      b: minsorted.indexOf(mins.b),\n      c: minsorted.indexOf(mins.c)\n    };\n\n    if (minsorted[0] < 0) {\n      if (minsorted[1] + minsorted[0] / 2 < 0) {\n        minsorted[2] += minsorted[0] + minsorted[1];\n        minsorted[0] = minsorted[1] = 0;\n      } else {\n        minsorted[2] += minsorted[0] / 2;\n        minsorted[1] += minsorted[0] / 2;\n        minsorted[0] = 0;\n      }\n\n      mins = {\n        a: minsorted[minindices.a],\n        b: minsorted[minindices.b],\n        c: minsorted[minindices.c]\n      };\n      dy = (mins0.a - mins.a) * _this.yaxis._m;\n      dx = (mins0.c - mins.c - mins0.b + mins.b) * _this.xaxis._m;\n    } // move the data (translate, don't redraw)\n\n\n    var plotTransform = strTranslate(_this.x0 + dx, _this.y0 + dy);\n\n    _this.plotContainer.selectAll('.scatterlayer,.maplayer').attr('transform', plotTransform);\n\n    var plotTransform2 = strTranslate(-dx, -dy);\n\n    _this.clipDefRelative.select('path').attr('transform', plotTransform2); // move the ticks\n\n\n    _this.aaxis.range = [mins.a, _this.sum - mins.b - mins.c];\n    _this.baxis.range = [_this.sum - mins.a - mins.c, mins.b];\n    _this.caxis.range = [_this.sum - mins.a - mins.b, mins.c];\n\n    _this.drawAxes(false);\n\n    if (_this._hasClipOnAxisFalse) {\n      _this.plotContainer.select('.scatterlayer').selectAll('.trace').call(Drawing.hideOutsideRangePoints, _this);\n    }\n\n    gd.emit('plotly_relayouting', makeUpdate(mins));\n  }\n\n  function dragDone() {\n    Registry.call('_guiRelayout', gd, makeUpdate(mins));\n  } // finally, set up hover and click\n  // these event handlers must already be set before dragElement.init\n  // so it can stash them and override them.\n\n\n  dragger.onmousemove = function (evt) {\n    Fx.hover(gd, evt, _this.id);\n    gd._fullLayout._lasthover = dragger;\n    gd._fullLayout._hoversubplot = _this.id;\n  };\n\n  dragger.onmouseout = function (evt) {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, evt);\n  };\n\n  dragElement.init(this.dragOptions);\n};\n\nfunction removeZoombox(gd) {\n  d3.select(gd).selectAll('.zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners').remove();\n}","map":null,"metadata":{},"sourceType":"script"}