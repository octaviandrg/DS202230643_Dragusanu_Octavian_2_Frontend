{"ast":null,"code":"'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes'); // special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V3.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\n\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\n\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\n\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\n\nexports.extractPathCoords = function (path, paramsToUse, isRaw) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    var str = params[relevantParamIdx];\n    var pos = isRaw ? str : Lib.cleanNumber(str);\n    extractedCoordinates.push(pos);\n  });\n  return extractedCoordinates;\n};\n\nexports.getDataToPixel = function (gd, axis, isVertical, refType) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n\n  if (axis) {\n    if (refType === 'domain') {\n      dataToPixel = function dataToPixel(v) {\n        return axis._length * (isVertical ? 1 - v : v) + axis._offset;\n      };\n    } else {\n      var d2r = exports.shapePositionToRange(axis);\n\n      dataToPixel = function dataToPixel(v) {\n        return axis._offset + axis.r2p(d2r(v, true));\n      };\n\n      if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n  } else if (isVertical) {\n    dataToPixel = function dataToPixel(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function dataToPixel(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  return dataToPixel;\n};\n\nexports.getPixelToData = function (gd, axis, isVertical, opt) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n\n  if (axis) {\n    if (opt === 'domain') {\n      pixelToData = function pixelToData(p) {\n        var q = (p - axis._offset) / axis._length;\n        return isVertical ? 1 - q : q;\n      };\n    } else {\n      var r2d = exports.rangeToShapePosition(axis);\n\n      pixelToData = function pixelToData(p) {\n        return r2d(axis.p2r(p - axis._offset));\n      };\n    }\n  } else if (isVertical) {\n    pixelToData = function pixelToData(p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function pixelToData(p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n\n  return pixelToData;\n};\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\n\n\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n\nexports.makeShapesOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.shapes[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref && options.xref !== 'paper') plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref && options.yref !== 'paper') plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n\n  plotinfo.xsizemode = options.xsizemode;\n  plotinfo.ysizemode = options.ysizemode;\n  plotinfo.xanchor = options.xanchor;\n  plotinfo.yanchor = options.yanchor;\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n}; // TODO: move to selections helpers?\n\n\nexports.makeSelectionsOptionsAndPlotinfo = function (gd, index) {\n  var options = gd._fullLayout.selections[index] || {};\n  var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n  var hasPlotinfo = !!plotinfo;\n\n  if (hasPlotinfo) {\n    plotinfo._hadPlotinfo = true;\n  } else {\n    plotinfo = {};\n    if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + 'axis'];\n    if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + 'axis'];\n  }\n\n  return {\n    options: options,\n    plotinfo: plotinfo\n  };\n};\n\nexports.getPathString = function (gd, options) {\n  var type = options.type;\n  var xRefType = Axes.getRefType(options.xref);\n  var yRefType = Axes.getRefType(options.yref);\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var x0, x1, y0, y1;\n\n  if (xa) {\n    if (xRefType === 'domain') {\n      x2p = function x2p(v) {\n        return xa._offset + xa._length * v;\n      };\n    } else {\n      x2r = exports.shapePositionToRange(xa);\n\n      x2p = function x2p(v) {\n        return xa._offset + xa.r2p(x2r(v, true));\n      };\n    }\n  } else {\n    x2p = function x2p(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n\n  if (ya) {\n    if (yRefType === 'domain') {\n      y2p = function y2p(v) {\n        return ya._offset + ya._length * (1 - v);\n      };\n    } else {\n      y2r = exports.shapePositionToRange(ya);\n\n      y2p = function y2p(v) {\n        return ya._offset + ya.r2p(y2r(v, true));\n      };\n    }\n  } else {\n    y2p = function y2p(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = exports.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = exports.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0;\n    x1 = xAnchorPos + options.x1;\n  } else {\n    x0 = x2p(options.x0);\n    x1 = x2p(options.x1);\n  }\n\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0;\n    y1 = yAnchorPos - options.y1;\n  } else {\n    y0 = y2p(options.y0);\n    y1 = y2p(options.y1);\n  }\n\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z'; // circle\n\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n};\n\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n\n    return segmentType + paramString;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}