{"ast":null,"code":"'use strict';\n\nvar dragHelpers = require('../../dragelement/helpers');\n\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\n\nvar constants = require('./constants');\n\nvar i000 = constants.i000;\nvar i090 = constants.i090;\nvar i180 = constants.i180;\nvar i270 = constants.i270;\nvar cos45 = constants.cos45;\nvar sin45 = constants.sin45;\n\nvar cartesianHelpers = require('../../selections/helpers');\n\nvar p2r = cartesianHelpers.p2r;\nvar r2p = cartesianHelpers.r2p;\n\nvar handleOutline = require('.././handle_outline');\n\nvar clearOutline = handleOutline.clearOutline;\n\nvar helpers = require('./helpers');\n\nvar readPaths = helpers.readPaths;\nvar writePaths = helpers.writePaths;\nvar ellipseOver = helpers.ellipseOver;\nvar fixDatesForPaths = helpers.fixDatesForPaths;\n\nmodule.exports = function newShapes(outlines, dragOptions) {\n  if (!outlines.length) return;\n  var e = outlines[0][0]; // pick first\n\n  if (!e) return;\n  var d = e.getAttribute('d');\n  var gd = dragOptions.gd;\n  var newStyle = gd._fullLayout.newshape;\n  var plotinfo = dragOptions.plotinfo;\n  var xaxis = plotinfo.xaxis;\n  var yaxis = plotinfo.yaxis;\n  var xPaper = !!plotinfo.domain || !plotinfo.xaxis;\n  var yPaper = !!plotinfo.domain || !plotinfo.yaxis;\n  var isActiveShape = dragOptions.isActiveShape;\n  var dragmode = dragOptions.dragmode;\n  var shapes = (gd.layout || {}).shapes || [];\n\n  if (!drawMode(dragmode) && isActiveShape !== undefined) {\n    var id = gd._fullLayout._activeShapeIndex;\n\n    if (id < shapes.length) {\n      switch (gd._fullLayout.shapes[id].type) {\n        case 'rect':\n          dragmode = 'drawrect';\n          break;\n\n        case 'circle':\n          dragmode = 'drawcircle';\n          break;\n\n        case 'line':\n          dragmode = 'drawline';\n          break;\n\n        case 'path':\n          var path = shapes[id].path || '';\n\n          if (path[path.length - 1] === 'Z') {\n            dragmode = 'drawclosedpath';\n          } else {\n            dragmode = 'drawopenpath';\n          }\n\n          break;\n      }\n    }\n  }\n\n  var isOpenMode = openMode(dragmode);\n  var polygons = readPaths(d, gd, plotinfo, isActiveShape);\n  var newShape = {\n    editable: true,\n    xref: xPaper ? 'paper' : xaxis._id,\n    yref: yPaper ? 'paper' : yaxis._id,\n    layer: newStyle.layer,\n    opacity: newStyle.opacity,\n    line: {\n      color: newStyle.line.color,\n      width: newStyle.line.width,\n      dash: newStyle.line.dash\n    }\n  };\n\n  if (!isOpenMode) {\n    newShape.fillcolor = newStyle.fillcolor;\n    newShape.fillrule = newStyle.fillrule;\n  }\n\n  var cell; // line, rect and circle can be in one cell\n  // only define cell if there is single cell\n\n  if (polygons.length === 1) cell = polygons[0];\n\n  if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect\n  dragmode === 'drawrect') {\n    newShape.type = 'rect';\n    newShape.x0 = cell[0][1];\n    newShape.y0 = cell[0][2];\n    newShape.x1 = cell[2][1];\n    newShape.y1 = cell[2][2];\n  } else if (cell && dragmode === 'drawline') {\n    newShape.type = 'line';\n    newShape.x0 = cell[0][1];\n    newShape.y0 = cell[0][2];\n    newShape.x1 = cell[1][1];\n    newShape.y1 = cell[1][2];\n  } else if (cell && dragmode === 'drawcircle') {\n    newShape.type = 'circle'; // an ellipse!\n\n    var xA = cell[i000][1];\n    var xB = cell[i090][1];\n    var xC = cell[i180][1];\n    var xD = cell[i270][1];\n    var yA = cell[i000][2];\n    var yB = cell[i090][2];\n    var yC = cell[i180][2];\n    var yD = cell[i270][2];\n    var xDateOrLog = plotinfo.xaxis && (plotinfo.xaxis.type === 'date' || plotinfo.xaxis.type === 'log');\n    var yDateOrLog = plotinfo.yaxis && (plotinfo.yaxis.type === 'date' || plotinfo.yaxis.type === 'log');\n\n    if (xDateOrLog) {\n      xA = r2p(plotinfo.xaxis, xA);\n      xB = r2p(plotinfo.xaxis, xB);\n      xC = r2p(plotinfo.xaxis, xC);\n      xD = r2p(plotinfo.xaxis, xD);\n    }\n\n    if (yDateOrLog) {\n      yA = r2p(plotinfo.yaxis, yA);\n      yB = r2p(plotinfo.yaxis, yB);\n      yC = r2p(plotinfo.yaxis, yC);\n      yD = r2p(plotinfo.yaxis, yD);\n    }\n\n    var x0 = (xB + xD) / 2;\n    var y0 = (yA + yC) / 2;\n    var rx = (xD - xB + xC - xA) / 2;\n    var ry = (yD - yB + yC - yA) / 2;\n    var pos = ellipseOver({\n      x0: x0,\n      y0: y0,\n      x1: x0 + rx * cos45,\n      y1: y0 + ry * sin45\n    });\n\n    if (xDateOrLog) {\n      pos.x0 = p2r(plotinfo.xaxis, pos.x0);\n      pos.x1 = p2r(plotinfo.xaxis, pos.x1);\n    }\n\n    if (yDateOrLog) {\n      pos.y0 = p2r(plotinfo.yaxis, pos.y0);\n      pos.y1 = p2r(plotinfo.yaxis, pos.y1);\n    }\n\n    newShape.x0 = pos.x0;\n    newShape.y0 = pos.y0;\n    newShape.x1 = pos.x1;\n    newShape.y1 = pos.y1;\n  } else {\n    newShape.type = 'path';\n    if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);\n    newShape.path = writePaths(polygons);\n    cell = null;\n  }\n\n  clearOutline(gd);\n  var editHelpers = dragOptions.editHelpers;\n  var modifyItem = (editHelpers || {}).modifyItem;\n  var allShapes = [];\n\n  for (var q = 0; q < shapes.length; q++) {\n    var beforeEdit = gd._fullLayout.shapes[q];\n    allShapes[q] = beforeEdit._input;\n\n    if (isActiveShape !== undefined && q === gd._fullLayout._activeShapeIndex) {\n      var afterEdit = newShape;\n\n      switch (beforeEdit.type) {\n        case 'line':\n        case 'rect':\n        case 'circle':\n          modifyItem('x0', afterEdit.x0);\n          modifyItem('x1', afterEdit.x1);\n          modifyItem('y0', afterEdit.y0);\n          modifyItem('y1', afterEdit.y1);\n          break;\n\n        case 'path':\n          modifyItem('path', afterEdit.path);\n          break;\n      }\n    }\n  }\n\n  if (isActiveShape === undefined) {\n    allShapes.push(newShape); // add new shape\n\n    return allShapes;\n  }\n\n  return editHelpers ? editHelpers.getUpdateObj() : {};\n};","map":null,"metadata":{},"sourceType":"script"}