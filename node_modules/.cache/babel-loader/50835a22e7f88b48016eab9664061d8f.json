{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nmodule.exports = function convert(scene) {\n  var fullSceneLayout = scene.fullSceneLayout;\n  var anns = fullSceneLayout.annotations;\n\n  for (var i = 0; i < anns.length; i++) {\n    mockAnnAxes(anns[i], scene);\n  }\n\n  scene.fullLayout._infolayer.selectAll('.annotation-' + scene.id).remove();\n};\n\nfunction mockAnnAxes(ann, scene) {\n  var fullSceneLayout = scene.fullSceneLayout;\n  var domain = fullSceneLayout.domain;\n  var size = scene.fullLayout._size;\n  var base = {\n    // this gets fill in on render\n    pdata: null,\n    // to get setConvert to not execute cleanly\n    type: 'linear',\n    // don't try to update them on `editable: true`\n    autorange: false,\n    // set infinite range so that annotation draw routine\n    // does not try to remove 'outside-range' annotations,\n    // this case is handled in the render loop\n    range: [-Infinity, Infinity]\n  };\n  ann._xa = {};\n  Lib.extendFlat(ann._xa, base);\n  Axes.setConvert(ann._xa);\n  ann._xa._offset = size.l + domain.x[0] * size.w;\n\n  ann._xa.l2p = function () {\n    return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);\n  };\n\n  ann._ya = {};\n  Lib.extendFlat(ann._ya, base);\n  Axes.setConvert(ann._ya);\n  ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;\n\n  ann._ya.l2p = function () {\n    return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}