{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n/**\n * setConvert for polar axes!\n *\n * @param {object} ax\n *   axis in question (works for both radial and angular axes)\n * @param {object} polarLayout\n *   full polar layout of the subplot associated with 'ax'\n * @param {object} fullLayout\n *   full layout\n *\n * Here, reuse some of the Cartesian setConvert logic,\n * but we must extend some of it, as both radial and angular axes\n * don't have domains and angular axes don't have _true_ ranges.\n *\n * Moreover, we introduce two new coordinate systems:\n * - 'g' for geometric coordinates and\n * - 't' for angular ticks\n *\n * Radial axis coordinate systems:\n * - d, c and l: same as for cartesian axes\n * - g: like calcdata but translated about `radialaxis.range[0]` & `polar.hole`\n *\n * Angular axis coordinate systems:\n * - d: data, in whatever form it's provided\n * - c: calcdata, turned into radians (for linear axes)\n *      or category indices (category axes)\n * - t: tick calcdata, just like 'c' but in degrees for linear axes\n * - g: geometric calcdata, radians coordinates that take into account\n *      axis rotation and direction\n *\n * Then, 'g'eometric data is ready to be converted to (x,y).\n */\n\nmodule.exports = function setConvert(ax, polarLayout, fullLayout) {\n  setConvertCartesian(ax, fullLayout);\n\n  switch (ax._id) {\n    case 'x':\n    case 'radialaxis':\n      setConvertRadial(ax, polarLayout);\n      break;\n\n    case 'angularaxis':\n      setConvertAngular(ax, polarLayout);\n      break;\n  }\n};\n\nfunction setConvertRadial(ax, polarLayout) {\n  var subplot = polarLayout._subplot;\n\n  ax.setGeometry = function () {\n    var rl0 = ax._rl[0];\n    var rl1 = ax._rl[1];\n    var b = subplot.innerRadius;\n    var m = (subplot.radius - b) / (rl1 - rl0);\n    var b2 = b / m;\n    var rFilter = rl0 > rl1 ? function (v) {\n      return v <= 0;\n    } : function (v) {\n      return v >= 0;\n    };\n\n    ax.c2g = function (v) {\n      var r = ax.c2l(v) - rl0;\n      return (rFilter(r) ? r : 0) + b2;\n    };\n\n    ax.g2c = function (v) {\n      return ax.l2c(v + rl0 - b2);\n    };\n\n    ax.g2p = function (v) {\n      return v * m;\n    };\n\n    ax.c2p = function (v) {\n      return ax.g2p(ax.c2g(v));\n    };\n  };\n}\n\nfunction toRadians(v, unit) {\n  return unit === 'degrees' ? deg2rad(v) : v;\n}\n\nfunction fromRadians(v, unit) {\n  return unit === 'degrees' ? rad2deg(v) : v;\n}\n\nfunction setConvertAngular(ax, polarLayout) {\n  var axType = ax.type;\n\n  if (axType === 'linear') {\n    var _d2c = ax.d2c;\n    var _c2d = ax.c2d;\n\n    ax.d2c = function (v, unit) {\n      return toRadians(_d2c(v), unit);\n    };\n\n    ax.c2d = function (v, unit) {\n      return _c2d(fromRadians(v, unit));\n    };\n  } // override makeCalcdata to handle thetaunit and special theta0/dtheta logic\n\n\n  ax.makeCalcdata = function (trace, coord) {\n    var arrayIn = trace[coord];\n    var len = trace._length;\n    var arrayOut, i;\n\n    var _d2c = function _d2c(v) {\n      return ax.d2c(v, trace.thetaunit);\n    };\n\n    if (arrayIn) {\n      if (Lib.isTypedArray(arrayIn) && axType === 'linear') {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = _d2c(arrayIn[i]);\n      }\n    } else {\n      var coord0 = coord + '0';\n      var dcoord = 'd' + coord;\n      var v0 = coord0 in trace ? _d2c(trace[coord0]) : 0;\n      var dv = trace[dcoord] ? _d2c(trace[dcoord]) : (ax.period || 2 * Math.PI) / len;\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    }\n\n    return arrayOut;\n  }; // N.B. we mock the axis 'range' here\n\n\n  ax.setGeometry = function () {\n    var sector = polarLayout.sector;\n    var sectorInRad = sector.map(deg2rad);\n    var dir = {\n      clockwise: -1,\n      counterclockwise: 1\n    }[ax.direction];\n    var rot = deg2rad(ax.rotation);\n\n    var rad2g = function rad2g(v) {\n      return dir * v + rot;\n    };\n\n    var g2rad = function g2rad(v) {\n      return (v - rot) / dir;\n    };\n\n    var rad2c, c2rad;\n    var rad2t, t2rad;\n\n    switch (axType) {\n      case 'linear':\n        c2rad = rad2c = Lib.identity;\n        t2rad = deg2rad;\n        rad2t = rad2deg; // Set the angular range in degrees to make auto-tick computation cleaner,\n        // changing rotation/direction should not affect the angular tick value.\n\n        ax.range = Lib.isFullCircle(sectorInRad) ? [sector[0], sector[0] + 360] : sectorInRad.map(g2rad).map(rad2deg);\n        break;\n\n      case 'category':\n        var catLen = ax._categories.length;\n\n        var _period = ax.period ? Math.max(ax.period, catLen) : catLen; // fallback in case all categories have been filtered out\n\n\n        if (_period === 0) _period = 1;\n\n        c2rad = t2rad = function t2rad(v) {\n          return v * 2 * Math.PI / _period;\n        };\n\n        rad2c = rad2t = function rad2t(v) {\n          return v * _period / Math.PI / 2;\n        };\n\n        ax.range = [0, _period];\n        break;\n    }\n\n    ax.c2g = function (v) {\n      return rad2g(c2rad(v));\n    };\n\n    ax.g2c = function (v) {\n      return rad2c(g2rad(v));\n    };\n\n    ax.t2g = function (v) {\n      return rad2g(t2rad(v));\n    };\n\n    ax.g2t = function (v) {\n      return rad2t(g2rad(v));\n    };\n  };\n}","map":null,"metadata":{},"sourceType":"script"}