{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar autorange = require('./autorange');\n\nvar id2name = require('./axis_ids').id2name;\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar scaleZoom = require('./scale_zoom');\n\nvar setConvert = require('./set_convert');\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\nexports.handleDefaults = function (layoutIn, layoutOut, opts) {\n  var axIds = opts.axIds;\n  var axHasImage = opts.axHasImage; // sets of axes linked by `scaleanchor` OR `matches` along with the\n  // scaleratios compounded together, populated in handleConstraintDefaults\n\n  var constraintGroups = layoutOut._axisConstraintGroups = []; // similar to _axisConstraintGroups, but only matching axes\n\n  var matchGroups = layoutOut._axisMatchGroups = [];\n  var i, group, axId, axName, axIn, axOut, attr, val;\n\n  for (i = 0; i < axIds.length; i++) {\n    axName = id2name(axIds[i]);\n    axIn = layoutIn[axName];\n    axOut = layoutOut[axName];\n    handleOneAxDefaults(axIn, axOut, {\n      axIds: axIds,\n      layoutOut: layoutOut,\n      hasImage: axHasImage[axName]\n    });\n  } // save matchGroup on each matching axis\n\n\n  function stash(groups, stashAttr) {\n    for (i = 0; i < groups.length; i++) {\n      group = groups[i];\n\n      for (axId in group) {\n        layoutOut[id2name(axId)][stashAttr] = group;\n      }\n    }\n  }\n\n  stash(matchGroups, '_matchGroup'); // If any axis in a constraint group is fixedrange, they all get fixed\n  // This covers matches axes, as they're now in the constraintgroup too\n  // and have not yet been removed (if the group is *only* matching)\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = constraintGroups[i];\n\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n\n      if (axOut.fixedrange) {\n        for (var axId2 in group) {\n          var axName2 = id2name(axId2);\n\n          if ((layoutIn[axName2] || {}).fixedrange === false) {\n            Lib.warn('fixedrange was specified as false for axis ' + axName2 + ' but was overridden because another ' + 'axis in its constraint group has fixedrange true');\n          }\n\n          layoutOut[axName2].fixedrange = true;\n        }\n\n        break;\n      }\n    }\n  } // remove constraint groups that simply duplicate match groups\n\n\n  i = 0;\n\n  while (i < constraintGroups.length) {\n    group = constraintGroups[i];\n\n    for (axId in group) {\n      axOut = layoutOut[id2name(axId)];\n\n      if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {\n        constraintGroups.splice(i, 1);\n        i--;\n      }\n\n      break;\n    }\n\n    i++;\n  } // save constraintGroup on each constrained axis\n\n\n  stash(constraintGroups, '_constraintGroup'); // make sure `matching` axes share values of necessary attributes\n  // Precedence (base axis is the one that doesn't list a `matches`, ie others\n  // all point to it):\n  // (1) explicitly defined value in the base axis\n  // (2) explicitly defined in another axis (arbitrary order)\n  // (3) default in the base axis\n\n  var matchAttrs = ['constrain', 'range', 'autorange', 'rangemode', 'rangebreaks', 'categoryorder', 'categoryarray'];\n  var hasRange = false;\n  var hasDayOfWeekBreaks = false;\n\n  function setAttrVal() {\n    val = axOut[attr];\n\n    if (attr === 'rangebreaks') {\n      hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;\n    }\n  }\n\n  for (i = 0; i < matchGroups.length; i++) {\n    group = matchGroups[i]; // find 'matching' range attrs\n\n    for (var j = 0; j < matchAttrs.length; j++) {\n      attr = matchAttrs[j];\n      val = null;\n      var baseAx;\n\n      for (axId in group) {\n        axName = id2name(axId);\n        axIn = layoutIn[axName];\n        axOut = layoutOut[axName];\n\n        if (!(attr in axOut)) {\n          continue;\n        }\n\n        if (!axOut.matches) {\n          baseAx = axOut; // top priority: explicit value in base axis\n\n          if (attr in axIn) {\n            setAttrVal();\n            break;\n          }\n        }\n\n        if (val === null && attr in axIn) {\n          // second priority: first explicit value in another axis\n          setAttrVal();\n        }\n      } // special logic for coupling of range and autorange\n      // if nobody explicitly specifies autorange, but someone does\n      // explicitly specify range, autorange must be disabled.\n\n\n      if (attr === 'range' && val) {\n        hasRange = true;\n      }\n\n      if (attr === 'autorange' && val === null && hasRange) {\n        val = false;\n      }\n\n      if (val === null && attr in baseAx) {\n        // fallback: default value in base axis\n        val = baseAx[attr];\n      } // but we still might not have a value, which is fine.\n\n\n      if (val !== null) {\n        for (axId in group) {\n          axOut = layoutOut[id2name(axId)];\n          axOut[attr] = attr === 'range' ? val.slice() : val;\n\n          if (attr === 'rangebreaks') {\n            axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;\n            setConvert(axOut, layoutOut);\n          }\n        }\n      }\n    }\n  }\n};\n\nfunction handleOneAxDefaults(axIn, axOut, opts) {\n  var axIds = opts.axIds;\n  var layoutOut = opts.layoutOut;\n  var hasImage = opts.hasImage;\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var matchGroups = layoutOut._axisMatchGroups;\n  var axId = axOut._id;\n  var axLetter = axId.charAt(0);\n  var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};\n  var thisID = axOut._id;\n  var isX = thisID.charAt(0) === 'x'; // Clear _matchGroup & _constraintGroup so relinkPrivateKeys doesn't keep\n  // an old one around. If this axis is in a group we'll set this again later\n\n  axOut._matchGroup = null;\n  axOut._constraintGroup = null;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);\n  } // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n\n\n  coerce('constrain', hasImage ? 'domain' : 'range');\n  Lib.coerce(axIn, axOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: isX ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: isX ? 'center' : 'middle'\n    }\n  }, 'constraintoward'); // If this axis is already part of a constraint group, we can't\n  // scaleanchor any other axis in that group, or we'd make a loop.\n  // Filter axIds to enforce this, also matching axis types.\n\n  var thisType = axOut.type;\n  var i, idi;\n  var linkableAxes = [];\n\n  for (i = 0; i < axIds.length; i++) {\n    idi = axIds[i];\n    if (idi === thisID) continue;\n    var axi = layoutOut[id2name(idi)];\n\n    if (axi.type === thisType) {\n      linkableAxes.push(idi);\n    }\n  }\n\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n  if (thisGroup) {\n    var linkableAxesNoLoops = [];\n\n    for (i = 0; i < linkableAxes.length; i++) {\n      idi = linkableAxes[i];\n      if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);\n    }\n\n    linkableAxes = linkableAxesNoLoops;\n  }\n\n  var canLink = linkableAxes.length;\n  var matches, scaleanchor;\n\n  if (canLink && (axIn.matches || splomStash.matches)) {\n    matches = Lib.coerce(axIn, axOut, {\n      matches: {\n        valType: 'enumerated',\n        values: linkableAxes,\n        dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : undefined\n      }\n    }, 'matches');\n  } // 'matches' wins over 'scaleanchor' - each axis can only specify one\n  // constraint, but you can chain matches and scaleanchor constraints by\n  // specifying them in separate axes.\n\n\n  var scaleanchorDflt = hasImage && !isX ? axOut.anchor : undefined;\n\n  if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {\n    scaleanchor = Lib.coerce(axIn, axOut, {\n      scaleanchor: {\n        valType: 'enumerated',\n        values: linkableAxes\n      }\n    }, 'scaleanchor', scaleanchorDflt);\n  }\n\n  if (matches) {\n    axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1); // Also include match constraints in the scale groups\n\n    var matchedAx = layoutOut[id2name(matches)];\n    var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);\n\n    if (isX !== (matches.charAt(0) === 'x')) {\n      // We don't yet know the actual scale ratio of x/y matches constraints,\n      // due to possible automargins, so just leave a placeholder for this:\n      // 'x' means \"x size over y size\", 'y' means the inverse.\n      // in principle in the constraint group you could get multiple of these.\n      matchRatio = (isX ? 'x' : 'y') + matchRatio;\n    }\n\n    updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);\n  } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.matches: \"' + axIn.matches + '\" to avoid an infinite loop');\n  }\n\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio'); // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n\n    if (!scaleratio) scaleratio = axOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);\n  } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + axOut._name + '.scaleanchor: \"' + axIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because this axis ' + 'declares a *matches* constraint.');\n  }\n}\n\nfunction extent(layoutOut, ax) {\n  var domain = ax.domain;\n\n  if (!domain) {\n    // at this point overlaying axes haven't yet inherited their main domains\n    // TODO: constrain: domain with overlaying axes is likely a bug.\n    domain = layoutOut[id2name(ax.overlaying)].domain;\n  }\n\n  return domain[1] - domain[0];\n}\n\nfunction getConstraintGroup(groups, thisID) {\n  for (var i = 0; i < groups.length; i++) {\n    if (groups[i][thisID]) {\n      return groups[i];\n    }\n  }\n\n  return null;\n}\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale (or matching).\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * thatID: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the thatID axis\n */\n\n\nfunction updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n  var thisGroup = getConstraintGroup(constraintGroups, thisID);\n\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n\n  var thisGroupKeys = Object.keys(thisGroup); // we know that this axis isn't in any other groups, but we don't know\n  // about the thatID axis. If it is, we need to merge the groups.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n\n    if (i !== thisGroupIndex && groupi[thatID]) {\n      var baseScale = groupi[thatID];\n\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));\n      }\n\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  } // otherwise, we insert the new thatID axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n\n\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      var key = thisGroupKeys[j];\n      thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);\n    }\n  }\n\n  thisGroup[thatID] = 1;\n} // scales may be numbers or 'x1.3', 'yy4.5' etc to multiply by as-yet-unknown\n// ratios between x and y plot sizes n times\n\n\nfunction multiplyScales(a, b) {\n  var aPrefix = '';\n  var bPrefix = '';\n  var aLen, bLen;\n\n  if (typeof a === 'string') {\n    aPrefix = a.match(/^[xy]*/)[0];\n    aLen = aPrefix.length;\n    a = +a.substr(aLen);\n  }\n\n  if (typeof b === 'string') {\n    bPrefix = b.match(/^[xy]*/)[0];\n    bLen = bPrefix.length;\n    b = +b.substr(bLen);\n  }\n\n  var c = a * b; // just two numbers\n\n  if (!aLen && !bLen) {\n    return c;\n  } // one or more prefixes of the same type\n\n\n  if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {\n    return aPrefix + bPrefix + a * b;\n  } // x and y cancel each other out exactly - back to a number\n\n\n  if (aLen === bLen) {\n    return c;\n  } // partial cancelation of prefixes\n\n\n  return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;\n}\n\nfunction finalRatios(group, fullLayout) {\n  var size = fullLayout._size;\n  var yRatio = size.h / size.w;\n  var out = {};\n  var keys = Object.keys(group);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var val = group[key];\n\n    if (typeof val === 'string') {\n      var prefix = val.match(/^[xy]*/)[0];\n      var pLen = prefix.length;\n      val = +val.substr(pLen);\n      var mult = prefix.charAt(0) === 'y' ? yRatio : 1 / yRatio;\n\n      for (var j = 0; j < pLen; j++) {\n        val *= mult;\n      }\n    }\n\n    out[key] = val;\n  }\n\n  return out;\n}\n\nexports.enforce = function enforce(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, group, axisID, ax, normScale, mode, factor; // matching constraints are handled in the autorange code when autoranged,\n  // or in the supplyDefaults code when explicitly ranged.\n  // now we just need to handle scaleanchor constraints\n  // matches constraints that chain with scaleanchor constraints are included\n  // here too, but because matches has already been satisfied,\n  // any changes here should preserve that.\n\n  for (i = 0; i < constraintGroups.length; i++) {\n    group = finalRatios(constraintGroups[i], fullLayout);\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0; // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false; // find the (normalized) scale of each axis in the group\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice(); // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n\n      ax.setScale(); // abs: inverted scales still satisfy the constraint\n\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      } // this has served its purpose, so remove it\n\n\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    } // Do we have a constraint mismatch? Give a small buffer for rounding errors\n\n\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue; // now increase any ranges we need to until all normalized scales are equal\n\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain; // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter); // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPadMin = autorange.makePadFn(fullLayout, ax, 0);\n            var getPadMax = autorange.makePadFn(fullLayout, ax, 1);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = autorange.concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPadMin(minArray[k]) / m;\n\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;\n\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n};\n\nexports.getAxisGroup = function getAxisGroup(fullLayout, axId) {\n  var matchGroups = fullLayout._axisMatchGroups;\n\n  for (var i = 0; i < matchGroups.length; i++) {\n    var group = matchGroups[i];\n    if (group[axId]) return 'g' + i;\n  }\n\n  return axId;\n}; // For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\n\n\nexports.clean = function clean(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\n\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":null,"metadata":{},"sourceType":"script"}