{"ast":null,"code":"'use strict';\n\nvar polybool = require('polybooljs');\n\nvar pointInPolygon = require('point-in-polygon/nested'); // could we use contains lib/polygon instead?\n\n\nvar Registry = require('../../registry');\n\nvar dashStyle = require('../drawing').dashStyle;\n\nvar Color = require('../color');\n\nvar Fx = require('../fx');\n\nvar makeEventData = require('../fx/helpers').makeEventData;\n\nvar dragHelpers = require('../dragelement/helpers');\n\nvar freeMode = dragHelpers.freeMode;\nvar rectMode = dragHelpers.rectMode;\nvar drawMode = dragHelpers.drawMode;\nvar openMode = dragHelpers.openMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar shapeHelpers = require('../shapes/helpers');\n\nvar shapeConstants = require('../shapes/constants');\n\nvar displayOutlines = require('../shapes/display_outlines');\n\nvar clearOutline = require('../shapes/handle_outline').clearOutline;\n\nvar newShapeHelpers = require('../shapes/draw_newshape/helpers');\n\nvar handleEllipse = newShapeHelpers.handleEllipse;\nvar readPaths = newShapeHelpers.readPaths;\n\nvar newShapes = require('../shapes/draw_newshape/newshapes');\n\nvar newSelections = require('./draw_newselection/newselections');\n\nvar activateLastSelection = require('./draw').activateLastSelection;\n\nvar Lib = require('../../lib');\n\nvar ascending = Lib.sorterAsc;\n\nvar libPolygon = require('../../lib/polygon');\n\nvar throttle = require('../../lib/throttle');\n\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar constants = require('./constants');\n\nvar MINSELECT = constants.MINSELECT;\nvar filteredPolygon = libPolygon.filter;\nvar polygonTester = libPolygon.tester;\n\nvar helpers = require('./helpers');\n\nvar p2r = helpers.p2r;\nvar axValue = helpers.axValue;\nvar getTransform = helpers.getTransform;\n\nfunction hasSubplot(dragOptions) {\n  // N.B. subplot may be falsy e.g zero sankey index!\n  return dragOptions.subplot !== undefined;\n}\n\nfunction prepSelect(evt, startX, startY, dragOptions, mode) {\n  var isCartesian = !hasSubplot(dragOptions);\n  var isFreeMode = freeMode(mode);\n  var isRectMode = rectMode(mode);\n  var isOpenMode = openMode(mode);\n  var isDrawMode = drawMode(mode);\n  var isSelectMode = selectMode(mode);\n  var isLine = mode === 'drawline';\n  var isEllipse = mode === 'drawcircle';\n  var isLineOrEllipse = isLine || isEllipse; // cases with two start & end positions\n\n  var gd = dragOptions.gd;\n  var fullLayout = gd._fullLayout;\n  var immediateSelect = isSelectMode && fullLayout.newselection.mode === 'immediate' && isCartesian; // N.B. only cartesian subplots have persistent selection\n\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragBBox = dragOptions.element.getBoundingClientRect();\n  var plotinfo = dragOptions.plotinfo;\n  var transform = getTransform(plotinfo);\n  var x0 = startX - dragBBox.left;\n  var y0 = startY - dragBBox.top;\n\n  fullLayout._calcInverseTransform(gd);\n\n  var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n  x0 = transformedCoords[0];\n  y0 = transformedCoords[1];\n  var scaleX = fullLayout._invScaleX;\n  var scaleY = fullLayout._invScaleY;\n  var x1 = x0;\n  var y1 = y0;\n  var path0 = 'M' + x0 + ',' + y0;\n  var xAxis = dragOptions.xaxes[0];\n  var yAxis = dragOptions.yaxes[0];\n  var pw = xAxis._length;\n  var ph = yAxis._length;\n  var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);\n  var filterPoly, selectionTesters, mergedPolygons, currentPolygon;\n  var i, searchInfo, eventData;\n  coerceSelectionsCache(evt, gd, dragOptions);\n\n  if (isFreeMode) {\n    filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);\n  }\n\n  var outlines = zoomLayer.selectAll('path.select-outline-' + plotinfo.id).data([1]);\n  var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;\n  var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : 'rgba(0,0,0,0)';\n  var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : '#7f7f7f' // non-cartesian subplot\n  );\n  outlines.enter().append('path').attr('class', 'select-outline select-outline-' + plotinfo.id).style({\n    opacity: isDrawMode ? newStyle.opacity / 2 : 1,\n    'stroke-dasharray': dashStyle(newStyle.line.dash, newStyle.line.width),\n    'stroke-width': newStyle.line.width + 'px',\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr('fill-rule', 'evenodd').classed('cursor-move', isDrawMode ? true : false).attr('transform', transform).attr('d', path0 + 'Z');\n  var corners = zoomLayer.append('path').attr('class', 'zoombox-corners').style({\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': 1\n  }).attr('transform', transform).attr('d', 'M0,0Z');\n  var throttleID = fullLayout._uid + constants.SELECTID;\n  var selection = []; // find the traces to search for selection points\n\n  var searchTraces = determineSearchTraces(gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot);\n\n  if (immediateSelect && !evt.shiftKey) {\n    dragOptions._clearSubplotSelections = function () {\n      if (!isCartesian) return;\n      var xRef = xAxis._id;\n      var yRef = yAxis._id;\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n      var selections = (gd.layout || {}).selections || [];\n      var list = [];\n      var selectionErased = false;\n\n      for (var q = 0; q < selections.length; q++) {\n        var s = fullLayout.selections[q];\n\n        if (s.xref !== xRef || s.yref !== yRef) {\n          list.push(selections[q]);\n        } else {\n          selectionErased = true;\n        }\n      }\n\n      if (selectionErased) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: list\n        });\n      }\n    };\n  }\n\n  var fillRangeItems = getFillRangeItems(dragOptions);\n\n  dragOptions.moveFn = function (dx0, dy0) {\n    if (dragOptions._clearSubplotSelections) {\n      dragOptions._clearSubplotSelections();\n\n      dragOptions._clearSubplotSelections = undefined;\n    }\n\n    x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));\n    y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));\n    var dx = Math.abs(x1 - x0);\n    var dy = Math.abs(y1 - y0);\n\n    if (isRectMode) {\n      var direction;\n      var start, end;\n\n      if (isSelectMode) {\n        var q = fullLayout.selectdirection;\n\n        if (q === 'any') {\n          if (dy < Math.min(dx * 0.6, MINSELECT)) {\n            direction = 'h';\n          } else if (dx < Math.min(dy * 0.6, MINSELECT)) {\n            direction = 'v';\n          } else {\n            direction = 'd';\n          }\n        } else {\n          direction = q;\n        }\n\n        switch (direction) {\n          case 'h':\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'v':\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n        }\n      }\n\n      if (isDrawMode) {\n        switch (fullLayout.newshape.drawdirection) {\n          case 'vertical':\n            direction = 'h';\n            start = isEllipse ? ph / 2 : 0;\n            end = ph;\n            break;\n\n          case 'horizontal':\n            direction = 'v';\n            start = isEllipse ? pw / 2 : 0;\n            end = pw;\n            break;\n\n          case 'ortho':\n            if (dx < dy) {\n              direction = 'h';\n              start = y0;\n              end = y1;\n            } else {\n              direction = 'v';\n              start = x0;\n              end = x1;\n            }\n\n            break;\n\n          default:\n            // i.e. case of 'diagonal'\n            direction = 'd';\n        }\n      }\n\n      if (direction === 'h') {\n        // horizontal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : // using x1 instead of x0 allows adjusting the line while drawing\n        [[x0, start], [x0, end], [x1, end], [x1, start]]; // make a vertical box\n\n        currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);\n        currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(start, end);\n        currentPolygon.ymax = Math.max(start, end); // extras to guide users in keeping a straight selection\n\n        corners.attr('d', 'M' + currentPolygon.xmin + ',' + (y0 - MINSELECT) + 'h-4v' + 2 * MINSELECT + 'h4Z' + 'M' + (currentPolygon.xmax - 1) + ',' + (y0 - MINSELECT) + 'h4v' + 2 * MINSELECT + 'h-4Z');\n      } else if (direction === 'v') {\n        // vertical motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : // using y1 instead of y0 allows adjusting the line while drawing\n        [[start, y0], [start, y1], [end, y1], [end, y0]]; // make a horizontal box\n\n        currentPolygon.xmin = Math.min(start, end);\n        currentPolygon.xmax = Math.max(start, end);\n        currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);\n        currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);\n        corners.attr('d', 'M' + (x0 - MINSELECT) + ',' + currentPolygon.ymin + 'v-4h' + 2 * MINSELECT + 'v4Z' + 'M' + (x0 - MINSELECT) + ',' + (currentPolygon.ymax - 1) + 'v4h' + 2 * MINSELECT + 'v-4Z');\n      } else if (direction === 'd') {\n        // diagonal motion\n        currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n        currentPolygon.xmin = Math.min(x0, x1);\n        currentPolygon.xmax = Math.max(x0, x1);\n        currentPolygon.ymin = Math.min(y0, y1);\n        currentPolygon.ymax = Math.max(y0, y1);\n        corners.attr('d', 'M0,0Z');\n      }\n    } else if (isFreeMode) {\n      filterPoly.addPt([x1, y1]);\n      currentPolygon = filterPoly.filtered;\n    } // create outline & tester\n\n\n    if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {\n      mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);\n      currentPolygon.subtract = subtract;\n      selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    } // display polygons on the screen\n\n\n    displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);\n\n    if (isSelectMode) {\n      var _res = reselect(gd, false);\n\n      var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];\n      _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);\n      selectionTesters = _res.selectionTesters;\n      eventData = _res.eventData;\n      var poly;\n\n      if (filterPoly) {\n        poly = filterPoly.filtered;\n      } else {\n        poly = castMultiPolygon(mergedPolygons);\n      }\n\n      throttle.throttle(throttleID, constants.SELECTDELAY, function () {\n        selection = _doSelect(selectionTesters, searchTraces);\n        var newPoints = selection.slice();\n\n        for (var w = 0; w < extraPoints.length; w++) {\n          var p = extraPoints[w];\n          var found = false;\n\n          for (var u = 0; u < newPoints.length; u++) {\n            if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {\n              found = true;\n              break;\n            }\n          }\n\n          if (!found) newPoints.push(p);\n        }\n\n        if (newPoints.length) {\n          if (!eventData) eventData = {};\n          eventData.points = newPoints;\n        }\n\n        fillRangeItems(eventData, poly);\n        emitSelecting(gd, eventData);\n      });\n    }\n  };\n\n  dragOptions.clickFn = function (numClicks, evt) {\n    corners.remove();\n\n    if (gd._fullLayout._activeShapeIndex >= 0) {\n      gd._fullLayout._deactivateShape(gd);\n\n      return;\n    }\n\n    if (isDrawMode) return;\n    var clickmode = fullLayout.clickmode;\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n\n      if (numClicks === 2) {\n        // clear selection on doubleclick\n        outlines.remove();\n\n        for (i = 0; i < searchTraces.length; i++) {\n          searchInfo = searchTraces[i];\n\n          searchInfo._module.selectPoints(searchInfo, false);\n        }\n\n        updateSelectedState(gd, searchTraces);\n        clearSelectionsCache(dragOptions);\n        emitDeselect(gd);\n\n        if (searchTraces.length) {\n          var clickedXaxis = searchTraces[0].xaxis;\n          var clickedYaxis = searchTraces[0].yaxis;\n\n          if (clickedXaxis && clickedYaxis) {\n            // drop selections in the clicked subplot\n            var subSelections = [];\n            var allSelections = gd._fullLayout.selections;\n\n            for (var k = 0; k < allSelections.length; k++) {\n              var s = allSelections[k];\n              if (!s) continue; // also drop null selections if any\n\n              if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {\n                subSelections.push(s);\n              }\n            }\n\n            if (subSelections.length < allSelections.length) {\n              gd._fullLayout._noEmitSelectedAtStart = true;\n              Registry.call('_guiRelayout', gd, {\n                selections: subSelections\n              });\n            }\n          }\n        }\n      } else {\n        if (clickmode.indexOf('select') > -1) {\n          selectOnClick(evt, gd, dragOptions.xaxes, dragOptions.yaxes, dragOptions.subplot, dragOptions, outlines);\n        }\n\n        if (clickmode === 'event') {\n          // TODO: remove in v3 - this was probably never intended to work as it does,\n          // but in case anyone depends on it we don't want to break it now.\n          // Note that click-to-select introduced pre v3 also emitts proper\n          // event data when clickmode is having 'select' in its flag list.\n          emitSelected(gd, undefined);\n        }\n      }\n\n      Fx.click(gd, evt);\n    }).catch(Lib.error);\n  };\n\n  dragOptions.doneFn = function () {\n    corners.remove();\n    throttle.done(throttleID).then(function () {\n      throttle.clear(throttleID);\n\n      if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {\n        // save last polygons\n        currentPolygon.subtract = subtract;\n        dragOptions.selectionDefs.push(currentPolygon); // we have to keep reference to arrays container\n\n        dragOptions.mergedPolygons.length = 0;\n        [].push.apply(dragOptions.mergedPolygons, mergedPolygons);\n      }\n\n      if (immediateSelect || isDrawMode) {\n        clearSelectionsCache(dragOptions, immediateSelect);\n      }\n\n      if (dragOptions.doneFnCompleted) {\n        dragOptions.doneFnCompleted(selection);\n      }\n\n      if (isSelectMode) {\n        emitSelected(gd, eventData);\n      }\n    }).catch(Lib.error);\n  };\n}\n\nfunction selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {\n  var hoverData = gd._hoverdata;\n  var fullLayout = gd._fullLayout;\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1;\n  var selection = [];\n  var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;\n  var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;\n\n  if (isHoverDataSet(hoverData)) {\n    coerceSelectionsCache(evt, gd, dragOptions);\n    searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);\n    var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);\n    var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0; // Note: potentially costly operation isPointOrBinSelected is\n    // called as late as possible through the use of an assignment\n    // in an if condition.\n\n    if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {\n      if (polygonOutlines) polygonOutlines.remove();\n\n      for (i = 0; i < searchTraces.length; i++) {\n        searchInfo = searchTraces[i];\n\n        searchInfo._module.selectPoints(searchInfo, false);\n      }\n\n      updateSelectedState(gd, searchTraces);\n      clearSelectionsCache(dragOptions);\n\n      if (sendEvents) {\n        emitDeselect(gd);\n      }\n    } else {\n      subtract = evt.shiftKey && (pointOrBinSelected !== undefined ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));\n      currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);\n      var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);\n      selectionTesters = multiTester(allSelectionDefs, selectionTesters);\n\n      for (i = 0; i < searchTraces.length; i++) {\n        traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);\n        thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);\n\n        if (selection.length) {\n          for (var j = 0; j < thisTracesSelection.length; j++) {\n            selection.push(thisTracesSelection[j]);\n          }\n        } else selection = thisTracesSelection;\n      }\n\n      eventData = {\n        points: selection\n      };\n      updateSelectedState(gd, searchTraces, eventData);\n\n      if (currentSelectionDef && dragOptions) {\n        dragOptions.selectionDefs.push(currentSelectionDef);\n      }\n\n      if (polygonOutlines) {\n        var polygons = dragOptions.mergedPolygons;\n        var isOpenMode = openMode(dragOptions.dragmode); // display polygons on the screen\n\n        displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);\n      }\n\n      if (sendEvents) {\n        emitSelected(gd, eventData);\n      }\n    }\n  }\n}\n/**\n * Constructs a new point selection definition object.\n */\n\n\nfunction newPointSelectionDef(pointNumber, searchInfo, subtract) {\n  return {\n    pointNumber: pointNumber,\n    searchInfo: searchInfo,\n    subtract: !!subtract\n  };\n}\n\nfunction isPointSelectionDef(o) {\n  return 'pointNumber' in o && 'searchInfo' in o;\n}\n/*\n * Constructs a new point number tester.\n */\n\n\nfunction newPointNumTester(pointSelectionDef) {\n  return {\n    xmin: 0,\n    xmax: 0,\n    ymin: 0,\n    ymax: 0,\n    pts: [],\n    contains: function contains(pt, omitFirstEdge, pointNumber, searchInfo) {\n      var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace._expandedIndex;\n      var idxActualTrace = searchInfo.cd[0].trace._expandedIndex;\n      return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;\n    },\n    isRect: false,\n    degenerate: false,\n    subtract: !!pointSelectionDef.subtract\n  };\n}\n/**\n * Wraps multiple selection testers.\n *\n * @param {Array} list - An array of selection testers.\n *\n * @return a selection tester object with a contains function\n * that can be called to evaluate a point against all wrapped\n * selection testers that were passed in list.\n */\n\n\nfunction multiTester(list) {\n  if (!list.length) return;\n  var testers = [];\n  var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];\n  var xmax = xmin;\n  var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];\n  var ymax = ymin;\n\n  for (var i = 0; i < list.length; i++) {\n    if (isPointSelectionDef(list[i])) {\n      testers.push(newPointNumTester(list[i]));\n    } else {\n      var tester = polygonTester(list[i]);\n      tester.subtract = !!list[i].subtract;\n      testers.push(tester);\n      xmin = Math.min(xmin, tester.xmin);\n      xmax = Math.max(xmax, tester.xmax);\n      ymin = Math.min(ymin, tester.ymin);\n      ymax = Math.max(ymax, tester.ymax);\n    }\n  }\n  /**\n   * Tests if the given point is within this tester.\n   *\n   * @param {Array} pt - [0] is the x coordinate, [1] is the y coordinate of the point.\n   * @param {*} arg - An optional parameter to pass down to wrapped testers.\n   * @param {number} pointNumber - The point number of the point within the underlying data array.\n   * @param {number} searchInfo - An object identifying the trace the point is contained in.\n   *\n   * @return {boolean} true if point is considered to be selected, false otherwise.\n   */\n\n\n  function contains(pt, arg, pointNumber, searchInfo) {\n    var contained = false;\n\n    for (var i = 0; i < testers.length; i++) {\n      if (testers[i].contains(pt, arg, pointNumber, searchInfo)) {\n        // if contained by subtract tester - exclude the point\n        contained = !testers[i].subtract;\n      }\n    }\n\n    return contained;\n  }\n\n  return {\n    xmin: xmin,\n    xmax: xmax,\n    ymin: ymin,\n    ymax: ymax,\n    pts: [],\n    contains: contains,\n    isRect: false,\n    degenerate: false\n  };\n}\n\nfunction coerceSelectionsCache(evt, gd, dragOptions) {\n  var fullLayout = gd._fullLayout;\n  var plotinfo = dragOptions.plotinfo;\n  var dragmode = dragOptions.dragmode;\n  var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;\n  var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));\n\n  if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {\n    // take over selection definitions from prev mode, if any\n    dragOptions.selectionDefs = plotinfo.selection.selectionDefs;\n    dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;\n  } else if (!hasModifierKey || !plotinfo.selection) {\n    clearSelectionsCache(dragOptions);\n  } // clear selection outline when selecting a different subplot\n\n\n  if (!selectingOnSameSubplot) {\n    clearOutline(gd);\n    fullLayout._lastSelectedSubplot = plotinfo.id;\n  }\n}\n\nfunction hasActiveShape(gd) {\n  return gd._fullLayout._activeShapeIndex >= 0;\n}\n\nfunction hasActiveSelection(gd) {\n  return gd._fullLayout._activeSelectionIndex >= 0;\n}\n\nfunction clearSelectionsCache(dragOptions, immediateSelect) {\n  var dragmode = dragOptions.dragmode;\n  var plotinfo = dragOptions.plotinfo;\n  var gd = dragOptions.gd;\n\n  if (hasActiveShape(gd)) {\n    gd._fullLayout._deactivateShape(gd);\n  }\n\n  if (hasActiveSelection(gd)) {\n    gd._fullLayout._deactivateSelection(gd);\n  }\n\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var isDrawMode = drawMode(dragmode);\n  var isSelectMode = selectMode(dragmode);\n\n  if (isDrawMode || isSelectMode) {\n    var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n\n    if (outlines && gd._fullLayout._outlining) {\n      // add shape\n      var shapes;\n\n      if (isDrawMode) {\n        shapes = newShapes(outlines, dragOptions);\n      }\n\n      if (shapes) {\n        Registry.call('_guiRelayout', gd, {\n          shapes: shapes\n        });\n      } // add selection\n\n\n      var selections;\n\n      if (isSelectMode && !hasSubplot(dragOptions) // only allow cartesian - no mapbox for now\n      ) {\n          selections = newSelections(outlines, dragOptions);\n        }\n\n      if (selections) {\n        gd._fullLayout._noEmitSelectedAtStart = true;\n        Registry.call('_guiRelayout', gd, {\n          selections: selections\n        }).then(function () {\n          if (immediateSelect) {\n            activateLastSelection(gd);\n          }\n        });\n      }\n\n      gd._fullLayout._outlining = false;\n    }\n  }\n\n  plotinfo.selection = {};\n  plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];\n  plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];\n}\n\nfunction getAxId(ax) {\n  return ax._id;\n}\n\nfunction determineSearchTraces(gd, xAxes, yAxes, subplot) {\n  if (!gd.calcdata) return [];\n  var searchTraces = [];\n  var xAxisIds = xAxes.map(getAxId);\n  var yAxisIds = yAxes.map(getAxId);\n  var cd, trace, i;\n\n  for (i = 0; i < gd.calcdata.length; i++) {\n    cd = gd.calcdata[i];\n    trace = cd[0].trace;\n    if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;\n\n    if (hasSubplot({\n      subplot: subplot\n    }) && (trace.subplot === subplot || trace.geo === subplot)) {\n      searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));\n    } else if (trace.type === 'splom') {\n      // FIXME: make sure we don't have more than single axis for splom\n      if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {\n        var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n        info.scene = gd._fullLayout._splomScenes[trace.uid];\n        searchTraces.push(info);\n      }\n    } else if (trace.type === 'sankey') {\n      var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);\n      searchTraces.push(sankeyInfo);\n    } else {\n      if (xAxisIds.indexOf(trace.xaxis) === -1) continue;\n      if (yAxisIds.indexOf(trace.yaxis) === -1) continue;\n      searchTraces.push(createSearchInfo(trace._module, cd, getFromId(gd, trace.xaxis), getFromId(gd, trace.yaxis)));\n    }\n  }\n\n  return searchTraces;\n}\n\nfunction createSearchInfo(module, calcData, xaxis, yaxis) {\n  return {\n    _module: module,\n    cd: calcData,\n    xaxis: xaxis,\n    yaxis: yaxis\n  };\n}\n\nfunction isHoverDataSet(hoverData) {\n  return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;\n}\n\nfunction extractClickedPtInfo(hoverData, searchTraces) {\n  var hoverDatum = hoverData[0];\n  var pointNumber = -1;\n  var pointNumbers = [];\n  var searchInfo, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (hoverDatum.fullData._expandedIndex === searchInfo.cd[0].trace._expandedIndex) {\n      // Special case for box (and violin)\n      if (hoverDatum.hoverOnBox === true) {\n        break;\n      } // Hint: in some traces like histogram, one graphical element\n      // doesn't correspond to one particular data point, but to\n      // bins of data points. Thus, hoverDatum can have a binNumber\n      // property instead of pointNumber.\n\n\n      if (hoverDatum.pointNumber !== undefined) {\n        pointNumber = hoverDatum.pointNumber;\n      } else if (hoverDatum.binNumber !== undefined) {\n        pointNumber = hoverDatum.binNumber;\n        pointNumbers = hoverDatum.pointNumbers;\n      }\n\n      break;\n    }\n  }\n\n  return {\n    pointNumber: pointNumber,\n    pointNumbers: pointNumbers,\n    searchInfo: searchInfo\n  };\n}\n\nfunction isPointOrBinSelected(clickedPtInfo) {\n  var trace = clickedPtInfo.searchInfo.cd[0].trace;\n  var ptNum = clickedPtInfo.pointNumber;\n  var ptNums = clickedPtInfo.pointNumbers;\n  var ptNumsSet = ptNums.length > 0; // When pointsNumbers is set (e.g. histogram's binning),\n  // it is assumed that when the first point of\n  // a bin is selected, all others are as well\n\n  var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum; // TODO potential performance improvement\n  // Primarily we need this function to determine if a click adds\n  // or subtracts from a selection.\n  // In cases `trace.selectedpoints` is a huge array, indexOf\n  // might be slow. One remedy would be to introduce a hash somewhere.\n\n  return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;\n}\n\nfunction isOnlyThisBinSelected(searchTraces, clickedPtInfo) {\n  var tracesWithSelectedPts = [];\n  var searchInfo, trace, isSameTrace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n\n    if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {\n      tracesWithSelectedPts.push(searchInfo);\n    }\n  }\n\n  if (tracesWithSelectedPts.length === 1) {\n    isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;\n\n    if (isSameTrace) {\n      trace = clickedPtInfo.searchInfo.cd[0].trace;\n\n      if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {\n        for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {\n          if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isOnlyOnePointSelected(searchTraces) {\n  var len = 0;\n  var searchInfo, trace, i;\n\n  for (i = 0; i < searchTraces.length; i++) {\n    searchInfo = searchTraces[i];\n    trace = searchInfo.cd[0].trace;\n\n    if (trace.selectedpoints) {\n      if (trace.selectedpoints.length > 1) return false;\n      len += trace.selectedpoints.length;\n      if (len > 1) return false;\n    }\n  }\n\n  return len === 1;\n}\n\nfunction updateSelectedState(gd, searchTraces, eventData) {\n  var i; // before anything else, update preGUI if necessary\n\n  for (i = 0; i < searchTraces.length; i++) {\n    var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;\n    var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};\n\n    if (tracePreGUI.selectedpoints === undefined) {\n      tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;\n    }\n  }\n\n  var trace;\n\n  if (eventData) {\n    var pts = eventData.points || [];\n\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      trace._input.selectedpoints = trace._fullInput.selectedpoints = [];\n      if (trace._fullInput !== trace) trace.selectedpoints = [];\n    }\n\n    for (var k = 0; k < pts.length; k++) {\n      var pt = pts[k];\n      var data = pt.data;\n      var fullData = pt.fullData;\n      var pointIndex = pt.pointIndex;\n      var pointIndices = pt.pointIndices;\n\n      if (pointIndices) {\n        [].push.apply(data.selectedpoints, pointIndices);\n\n        if (trace._fullInput !== trace) {\n          [].push.apply(fullData.selectedpoints, pointIndices);\n        }\n      } else {\n        data.selectedpoints.push(pointIndex);\n\n        if (trace._fullInput !== trace) {\n          fullData.selectedpoints.push(pointIndex);\n        }\n      }\n    }\n  } else {\n    for (i = 0; i < searchTraces.length; i++) {\n      trace = searchTraces[i].cd[0].trace;\n      delete trace.selectedpoints;\n      delete trace._input.selectedpoints;\n\n      if (trace._fullInput !== trace) {\n        delete trace._fullInput.selectedpoints;\n      }\n    }\n  }\n\n  updateReglSelectedState(gd, searchTraces);\n}\n\nfunction updateReglSelectedState(gd, searchTraces) {\n  var hasRegl = false;\n\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    var cd = searchInfo.cd;\n\n    if (Registry.traceIs(cd[0].trace, 'regl')) {\n      hasRegl = true;\n    }\n\n    var _module = searchInfo._module;\n    var fn = _module.styleOnSelect || _module.style;\n\n    if (fn) {\n      fn(gd, cd, cd[0].node3);\n      if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);\n    }\n  }\n\n  if (hasRegl) {\n    clearGlCanvases(gd);\n    redrawReglTraces(gd);\n  }\n}\n\nfunction mergePolygons(list, poly, subtract) {\n  var fn = subtract ? polybool.difference : polybool.union;\n  var res = fn({\n    regions: list\n  }, {\n    regions: [poly]\n  });\n  var allPolygons = res.regions.reverse();\n\n  for (var i = 0; i < allPolygons.length; i++) {\n    var polygon = allPolygons[i];\n    polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));\n  }\n\n  return allPolygons;\n}\n\nfunction fillSelectionItem(selection, searchInfo) {\n  if (Array.isArray(selection)) {\n    var cd = searchInfo.cd;\n    var trace = searchInfo.cd[0].trace;\n\n    for (var i = 0; i < selection.length; i++) {\n      selection[i] = makeEventData(selection[i], trace, cd);\n    }\n  }\n\n  return selection;\n}\n\nfunction convertPoly(polygonsIn, isOpenMode) {\n  // add M and L command to draft positions\n  var polygonsOut = [];\n\n  for (var i = 0; i < polygonsIn.length; i++) {\n    polygonsOut[i] = [];\n\n    for (var j = 0; j < polygonsIn[i].length; j++) {\n      polygonsOut[i][j] = [];\n      polygonsOut[i][j][0] = j ? 'L' : 'M';\n\n      for (var k = 0; k < polygonsIn[i][j].length; k++) {\n        polygonsOut[i][j].push(polygonsIn[i][j][k]);\n      }\n    }\n\n    if (!isOpenMode) {\n      polygonsOut[i].push(['Z', polygonsOut[i][0][1], // initial x\n      polygonsOut[i][0][2] // initial y\n      ]);\n    }\n  }\n\n  return polygonsOut;\n}\n\nfunction _doSelect(selectionTesters, searchTraces) {\n  var allSelections = [];\n  var thisSelection;\n  var traceSelections = [];\n  var traceSelection;\n\n  for (var i = 0; i < searchTraces.length; i++) {\n    var searchInfo = searchTraces[i];\n    traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);\n    traceSelections.push(traceSelection);\n    thisSelection = fillSelectionItem(traceSelection, searchInfo);\n    allSelections = allSelections.concat(thisSelection);\n  }\n\n  return allSelections;\n}\n\nfunction reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {\n  var hadSearchTraces = !!searchTraces;\n  var plotinfo, xRef, yRef;\n\n  if (dragOptions) {\n    plotinfo = dragOptions.plotinfo;\n    xRef = dragOptions.xaxes[0]._id;\n    yRef = dragOptions.yaxes[0]._id;\n  }\n\n  var allSelections = [];\n  var allSearchTraces = []; // select layout.selection polygons\n\n  var layoutPolygons = getLayoutPolygons(gd); // add draft outline polygons to layoutPolygons\n\n  var fullLayout = gd._fullLayout;\n\n  if (plotinfo) {\n    var zoomLayer = fullLayout._zoomlayer;\n    var mode = fullLayout.dragmode;\n    var isDrawMode = drawMode(mode);\n    var isSelectMode = selectMode(mode);\n\n    if (isDrawMode || isSelectMode) {\n      var xaxis = getFromId(gd, xRef, 'x');\n      var yaxis = getFromId(gd, yRef, 'y');\n\n      if (xaxis && yaxis) {\n        var outlines = zoomLayer.selectAll('.select-outline-' + plotinfo.id);\n\n        if (outlines && gd._fullLayout._outlining) {\n          if (outlines.length) {\n            var e = outlines[0][0]; // pick first\n\n            var d = e.getAttribute('d');\n            var outlinePolys = readPaths(d, gd, plotinfo);\n            var draftPolygons = [];\n\n            for (var u = 0; u < outlinePolys.length; u++) {\n              var p = outlinePolys[u];\n              var polygon = [];\n\n              for (var t = 0; t < p.length; t++) {\n                polygon.push([convert(xaxis, p[t][1]), convert(yaxis, p[t][2])]);\n              }\n\n              polygon.xref = xRef;\n              polygon.yref = yRef;\n              polygon.subtract = getSubtract(polygon, draftPolygons);\n              draftPolygons.push(polygon);\n            }\n\n            layoutPolygons = layoutPolygons.concat(draftPolygons);\n          }\n        }\n      }\n    }\n  }\n\n  var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;\n  epmtySplomSelectionBatch(gd);\n  var seenSplom = {};\n\n  for (var i = 0; i < subplots.length; i++) {\n    var subplot = subplots[i];\n    var yAt = subplot.indexOf('y');\n\n    var _xRef = subplot.slice(0, yAt);\n\n    var _yRef = subplot.slice(yAt);\n\n    var _selectionTesters = xRef && yRef ? selectionTesters : undefined;\n\n    _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);\n\n    if (_selectionTesters) {\n      var _searchTraces = searchTraces;\n\n      if (!hadSearchTraces) {\n        var _xA = getFromId(gd, _xRef, 'x');\n\n        var _yA = getFromId(gd, _yRef, 'y');\n\n        _searchTraces = determineSearchTraces(gd, [_xA], [_yA], subplot);\n\n        for (var w = 0; w < _searchTraces.length; w++) {\n          var s = _searchTraces[w];\n          var cd0 = s.cd[0];\n          var trace = cd0.trace;\n\n          if (s._module.name === 'scattergl' && !cd0.t.xpx) {\n            var x = trace.x;\n            var y = trace.y;\n            var len = trace._length; // generate stash for scattergl\n\n            cd0.t.xpx = [];\n            cd0.t.ypx = [];\n\n            for (var j = 0; j < len; j++) {\n              cd0.t.xpx[j] = _xA.c2p(x[j]);\n              cd0.t.ypx[j] = _yA.c2p(y[j]);\n            }\n          }\n\n          if (s._module.name === 'splom') {\n            if (!seenSplom[trace.uid]) {\n              seenSplom[trace.uid] = true;\n            }\n          }\n        }\n      }\n\n      var selection = _doSelect(_selectionTesters, _searchTraces);\n\n      allSelections = allSelections.concat(selection);\n      allSearchTraces = allSearchTraces.concat(_searchTraces);\n    }\n  }\n\n  var eventData = {\n    points: allSelections\n  };\n  updateSelectedState(gd, allSearchTraces, eventData);\n  var clickmode = fullLayout.clickmode;\n  var sendEvents = clickmode.indexOf('event') > -1 && mayEmitSelected;\n\n  if (!plotinfo && // get called from plot_api & plots\n  mayEmitSelected) {\n    var activePolygons = getLayoutPolygons(gd, true);\n\n    if (activePolygons.length) {\n      var xref = activePolygons[0].xref;\n      var yref = activePolygons[0].yref;\n\n      if (xref && yref) {\n        var poly = castMultiPolygon(activePolygons);\n        var fillRangeItems = makeFillRangeItems([getFromId(gd, xref, 'x'), getFromId(gd, yref, 'y')]);\n        fillRangeItems(eventData, poly);\n      }\n    }\n\n    if (gd._fullLayout._noEmitSelectedAtStart) {\n      gd._fullLayout._noEmitSelectedAtStart = false;\n    } else {\n      if (sendEvents) emitSelected(gd, eventData);\n    }\n\n    fullLayout._reselect = false;\n  }\n\n  if (!plotinfo && // get called from plot_api & plots\n  fullLayout._deselect) {\n    var deselect = fullLayout._deselect;\n    xRef = deselect.xref;\n    yRef = deselect.yref;\n\n    if (!subplotSelected(xRef, yRef, allSearchTraces)) {\n      deselectSubplot(gd, xRef, yRef, searchTraces);\n    }\n\n    if (sendEvents) {\n      if (eventData.points.length) {\n        emitSelected(gd, eventData);\n      } else {\n        emitDeselect(gd);\n      }\n    }\n\n    fullLayout._deselect = false;\n  }\n\n  return {\n    eventData: eventData,\n    selectionTesters: selectionTesters\n  };\n}\n\nfunction epmtySplomSelectionBatch(gd) {\n  var cd = gd.calcdata;\n  if (!cd) return;\n\n  for (var i = 0; i < cd.length; i++) {\n    var cd0 = cd[i][0];\n    var trace = cd0.trace;\n    var splomScenes = gd._fullLayout._splomScenes;\n\n    if (splomScenes) {\n      var scene = splomScenes[trace.uid];\n\n      if (scene) {\n        scene.selectBatch = [];\n      }\n    }\n  }\n}\n\nfunction subplotSelected(xRef, yRef, searchTraces) {\n  for (var i = 0; i < searchTraces.length; i++) {\n    var s = searchTraces[i];\n\n    if (s.xaxis && s.xaxis._id === xRef && s.yaxis && s.yaxis._id === yRef) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction deselectSubplot(gd, xRef, yRef, searchTraces) {\n  searchTraces = determineSearchTraces(gd, [getFromId(gd, xRef, 'x')], [getFromId(gd, yRef, 'y')], xRef + yRef);\n\n  for (var k = 0; k < searchTraces.length; k++) {\n    var searchInfo = searchTraces[k];\n\n    searchInfo._module.selectPoints(searchInfo, false);\n  }\n\n  updateSelectedState(gd, searchTraces);\n}\n\nfunction addTester(layoutPolygons, xRef, yRef, selectionTesters) {\n  var mergedPolygons;\n\n  for (var i = 0; i < layoutPolygons.length; i++) {\n    var currentPolygon = layoutPolygons[i];\n    if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;\n\n    if (mergedPolygons) {\n      var subtract = !!currentPolygon.subtract;\n      mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);\n      selectionTesters = multiTester(mergedPolygons);\n    } else {\n      mergedPolygons = [currentPolygon];\n      selectionTesters = polygonTester(currentPolygon);\n    }\n  }\n\n  return selectionTesters;\n}\n\nfunction getLayoutPolygons(gd, onlyActiveOnes) {\n  var allPolygons = [];\n  var fullLayout = gd._fullLayout;\n  var allSelections = fullLayout.selections;\n  var len = allSelections.length;\n\n  for (var i = 0; i < len; i++) {\n    if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;\n    var selection = allSelections[i];\n    if (!selection) continue;\n    var xref = selection.xref;\n    var yref = selection.yref;\n    var xaxis = getFromId(gd, xref, 'x');\n    var yaxis = getFromId(gd, yref, 'y');\n    var xmin, xmax, ymin, ymax;\n    var polygon;\n\n    if (selection.type === 'rect') {\n      polygon = [];\n      var x0 = convert(xaxis, selection.x0);\n      var x1 = convert(xaxis, selection.x1);\n      var y0 = convert(yaxis, selection.y0);\n      var y1 = convert(yaxis, selection.y1);\n      polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];\n      xmin = Math.min(x0, x1);\n      xmax = Math.max(x0, x1);\n      ymin = Math.min(y0, y1);\n      ymax = Math.max(y0, y1);\n      polygon.xmin = xmin;\n      polygon.xmax = xmax;\n      polygon.ymin = ymin;\n      polygon.ymax = ymax;\n      polygon.xref = xref;\n      polygon.yref = yref;\n      polygon.subtract = false;\n      polygon.isRect = true;\n      allPolygons.push(polygon);\n    } else if (selection.type === 'path') {\n      var segments = selection.path.split('Z');\n      var multiPolygons = [];\n\n      for (var j = 0; j < segments.length; j++) {\n        var path = segments[j];\n        if (!path) continue;\n        path += 'Z';\n        var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, 'raw');\n        var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, 'raw');\n        xmin = Infinity;\n        xmax = -Infinity;\n        ymin = Infinity;\n        ymax = -Infinity;\n        polygon = [];\n\n        for (var k = 0; k < allX.length; k++) {\n          var x = convert(xaxis, allX[k]);\n          var y = convert(yaxis, allY[k]);\n          polygon.push([x, y]);\n          xmin = Math.min(x, xmin);\n          xmax = Math.max(x, xmax);\n          ymin = Math.min(y, ymin);\n          ymax = Math.max(y, ymax);\n        }\n\n        polygon.xmin = xmin;\n        polygon.xmax = xmax;\n        polygon.ymin = ymin;\n        polygon.ymax = ymax;\n        polygon.xref = xref;\n        polygon.yref = yref;\n        polygon.subtract = getSubtract(polygon, multiPolygons);\n        multiPolygons.push(polygon);\n        allPolygons.push(polygon);\n      }\n    }\n  }\n\n  return allPolygons;\n}\n\nfunction getSubtract(polygon, previousPolygons) {\n  var subtract = false;\n\n  for (var i = 0; i < previousPolygons.length; i++) {\n    var previousPolygon = previousPolygons[i]; // find out if a point of polygon is inside previous polygons\n\n    for (var k = 0; k < polygon.length; k++) {\n      if (pointInPolygon(polygon[k], previousPolygon)) {\n        subtract = !subtract;\n        break;\n      }\n    }\n  }\n\n  return subtract;\n}\n\nfunction convert(ax, d) {\n  if (ax.type === 'date') d = d.replace('_', ' ');\n  return ax.type === 'log' ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);\n}\n\nfunction castMultiPolygon(allPolygons) {\n  var len = allPolygons.length; // descibe multi polygons in one polygon\n\n  var p = [];\n\n  for (var i = 0; i < len; i++) {\n    var polygon = allPolygons[i];\n    p = p.concat(polygon); // add starting vertex to close\n    // which indicates next polygon\n\n    p = p.concat([polygon[0]]);\n  }\n\n  return computeRectAndRanges(p);\n}\n\nfunction computeRectAndRanges(poly) {\n  poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1] || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];\n\n  if (poly.isRect) {\n    poly.xmin = Math.min(poly[0][0], poly[2][0]);\n    poly.xmax = Math.max(poly[0][0], poly[2][0]);\n    poly.ymin = Math.min(poly[0][1], poly[2][1]);\n    poly.ymax = Math.max(poly[0][1], poly[2][1]);\n  }\n\n  return poly;\n}\n\nfunction makeFillRangeItems(allAxes) {\n  return function (eventData, poly) {\n    var range;\n    var lassoPoints;\n\n    for (var i = 0; i < allAxes.length; i++) {\n      var ax = allAxes[i];\n      var id = ax._id;\n      var axLetter = id.charAt(0);\n\n      if (poly.isRect) {\n        if (!range) range = {};\n        var min = poly[axLetter + 'min'];\n        var max = poly[axLetter + 'max'];\n\n        if (min !== undefined && max !== undefined) {\n          range[id] = [p2r(ax, min), p2r(ax, max)].sort(ascending);\n        }\n      } else {\n        if (!lassoPoints) lassoPoints = {};\n        lassoPoints[id] = poly.map(axValue(ax));\n      }\n    }\n\n    if (range) {\n      eventData.range = range;\n    }\n\n    if (lassoPoints) {\n      eventData.lassoPoints = lassoPoints;\n    }\n  };\n}\n\nfunction getFillRangeItems(dragOptions) {\n  var plotinfo = dragOptions.plotinfo;\n  return plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, sankey) to override fillRangeItems routine\n  makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));\n}\n\nfunction emitSelecting(gd, eventData) {\n  gd.emit('plotly_selecting', eventData);\n}\n\nfunction emitSelected(gd, eventData) {\n  if (eventData) {\n    eventData.selections = (gd.layout || {}).selections || [];\n  }\n\n  gd.emit('plotly_selected', eventData);\n}\n\nfunction emitDeselect(gd) {\n  gd.emit('plotly_deselect', null);\n}\n\nmodule.exports = {\n  reselect: reselect,\n  prepSelect: prepSelect,\n  clearOutline: clearOutline,\n  clearSelectionsCache: clearSelectionsCache,\n  selectOnClick: selectOnClick\n};","map":null,"metadata":{},"sourceType":"script"}