{"ast":null,"code":"/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n'use strict';\n\nvar _slicedToArray = require(\"/Users/danaliulica/Documents/PROIECT/DS202230643_Dragusanu_Octavian_1_Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/danaliulica/Documents/PROIECT/DS202230643_Dragusanu_Octavian_1_Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar search = require('binary-search-bounds');\n\nvar clamp = require('clamp');\n\nvar rect = require('parse-rect');\n\nvar getBounds = require('array-bounds');\n\nvar pick = require('pick-by-alias');\n\nvar defined = require('defined');\n\nvar flatten = require('flatten-vertex-data');\n\nvar isObj = require('is-obj');\n\nvar dtype = require('dtype');\n\nvar log2 = require('math-log2');\n\nvar MAX_GROUP_ID = 1073741824;\n\nmodule.exports = function cluster(srcPoints, options) {\n  if (!options) options = {};\n  srcPoints = flatten(srcPoints, 'float64');\n  options = pick(options, {\n    bounds: 'range bounds dataBox databox',\n    maxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n    dtype: 'type dtype format out dst output destination' // sort: 'sortBy sortby sort',\n    // pick: 'pick levelPoint',\n    // nodeSize: 'node nodeSize minNodeSize minSize size'\n\n  }); // let nodeSize = defined(options.nodeSize, 1)\n\n  var maxDepth = defined(options.maxDepth, 255);\n  var bounds = defined(options.bounds, getBounds(srcPoints, 2));\n  if (bounds[0] === bounds[2]) bounds[2]++;\n  if (bounds[1] === bounds[3]) bounds[3]++;\n  var points = normalize(srcPoints, bounds); // init variables\n\n  var n = srcPoints.length >>> 1;\n  var ids;\n  if (!options.dtype) options.dtype = 'array';\n\n  if (typeof options.dtype === 'string') {\n    ids = new (dtype(options.dtype))(n);\n  } else if (options.dtype) {\n    ids = options.dtype;\n    if (Array.isArray(ids)) ids.length = n;\n  }\n\n  for (var i = 0; i < n; ++i) {\n    ids[i] = i;\n  } // representative point indexes for levels\n\n\n  var levels = []; // starting indexes of subranges in sub levels, levels.length * 4\n\n  var sublevels = []; // unique group ids, sorted in z-curve fashion within levels by shifting bits\n\n  var groups = []; // level offsets in `ids`\n\n  var offsets = []; // sort points\n\n  sort(0, 0, 1, ids, 0, 1); // return reordered ids with provided methods\n  // save level offsets in output buffer\n\n  var offset = 0;\n\n  for (var level = 0; level < levels.length; level++) {\n    var levelItems = levels[level];\n    if (ids.set) ids.set(levelItems, offset);else {\n      for (var _i = 0, l = levelItems.length; _i < l; _i++) {\n        ids[_i + offset] = levelItems[_i];\n      }\n    }\n    var nextOffset = offset + levels[level].length;\n    offsets[level] = [offset, nextOffset];\n    offset = nextOffset;\n  }\n\n  ids.range = range;\n  return ids; // FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n\n  function sort(x, y, diam, ids, level, group) {\n    if (!ids.length) return null; // save first point as level representative\n\n    var levelItems = levels[level] || (levels[level] = []);\n    var levelGroups = groups[level] || (groups[level] = []);\n    var sublevel = sublevels[level] || (sublevels[level] = []);\n    var offset = levelItems.length;\n    level++; // max depth reached - put all items into a first group\n    // alternatively - if group id overflow - avoid proceeding\n\n    if (level > maxDepth || group > MAX_GROUP_ID) {\n      for (var _i2 = 0; _i2 < ids.length; _i2++) {\n        levelItems.push(ids[_i2]);\n        levelGroups.push(group);\n        sublevel.push(null, null, null, null);\n      }\n\n      return offset;\n    }\n\n    levelItems.push(ids[0]);\n    levelGroups.push(group);\n\n    if (ids.length <= 1) {\n      sublevel.push(null, null, null, null);\n      return offset;\n    }\n\n    var d2 = diam * .5;\n    var cx = x + d2,\n        cy = y + d2; // distribute points by 4 buckets\n\n    var lolo = [],\n        lohi = [],\n        hilo = [],\n        hihi = [];\n\n    for (var _i3 = 1, _l = ids.length; _i3 < _l; _i3++) {\n      var idx = ids[_i3],\n          _x = points[idx * 2],\n          _y = points[idx * 2 + 1];\n      _x < cx ? _y < cy ? lolo.push(idx) : lohi.push(idx) : _y < cy ? hilo.push(idx) : hihi.push(idx);\n    }\n\n    group <<= 2;\n    sublevel.push(sort(x, y, d2, lolo, level, group), sort(x, cy, d2, lohi, level, group + 1), sort(cx, y, d2, hilo, level, group + 2), sort(cx, cy, d2, hihi, level, group + 3));\n    return offset;\n  } // get all points within the passed range\n\n\n  function range() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var options;\n\n    if (isObj(args[args.length - 1])) {\n      var arg = args.pop(); // detect if that was a rect object\n\n      if (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n        args = [arg];\n        options = {};\n      }\n\n      options = pick(arg, {\n        level: 'level maxLevel',\n        d: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n        lod: 'lod details ranges offsets'\n      });\n    } else {\n      options = {};\n    }\n\n    if (!args.length) args = bounds;\n    var box = rect.apply(void 0, _toConsumableArray(args));\n    var _ref = [Math.min(box.x, box.x + box.width), Math.min(box.y, box.y + box.height), Math.max(box.x, box.x + box.width), Math.max(box.y, box.y + box.height)],\n        minX = _ref[0],\n        minY = _ref[1],\n        maxX = _ref[2],\n        maxY = _ref[3];\n\n    var _normalize = normalize([minX, minY, maxX, maxY], bounds),\n        _normalize2 = _slicedToArray(_normalize, 4),\n        nminX = _normalize2[0],\n        nminY = _normalize2[1],\n        nmaxX = _normalize2[2],\n        nmaxY = _normalize2[3];\n\n    var maxLevel = defined(options.level, levels.length); // limit maxLevel by px size\n\n    if (options.d != null) {\n      var d;\n      if (typeof options.d === 'number') d = [options.d, options.d];else if (options.d.length) d = options.d;\n      maxLevel = Math.min(Math.max(Math.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))), Math.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))), maxLevel);\n    }\n\n    maxLevel = Math.min(maxLevel, levels.length); // return levels of details\n\n    if (options.lod) {\n      return lod(nminX, nminY, nmaxX, nmaxY, maxLevel);\n    } // do selection ids\n\n\n    var selection = []; // FIXME: probably we can do LOD here beforehead\n\n    select(0, 0, 1, 0, 0, 1);\n\n    function select(lox, loy, d, level, from, to) {\n      if (from === null || to === null) return;\n      var hix = lox + d;\n      var hiy = loy + d; // if box does not intersect level - ignore\n\n      if (nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy) return;\n      if (level >= maxLevel) return;\n      if (from === to) return; // if points fall into box range - take it\n\n      var levelItems = levels[level];\n      if (to === undefined) to = levelItems.length;\n\n      for (var _i4 = from; _i4 < to; _i4++) {\n        var id = levelItems[_i4];\n        var px = srcPoints[id * 2];\n        var py = srcPoints[id * 2 + 1];\n\n        if (px >= minX && px <= maxX && py >= minY && py <= maxY) {\n          selection.push(id);\n        }\n      } // for every subsection do select\n\n\n      var offsets = sublevels[level];\n      var off0 = offsets[from * 4 + 0];\n      var off1 = offsets[from * 4 + 1];\n      var off2 = offsets[from * 4 + 2];\n      var off3 = offsets[from * 4 + 3];\n      var end = nextOffset(offsets, from + 1);\n      var d2 = d * .5;\n      var nextLevel = level + 1;\n      select(lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end);\n      select(lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end);\n      select(lox + d2, loy, d2, nextLevel, off2, off3 || end);\n      select(lox + d2, loy + d2, d2, nextLevel, off3, end);\n    }\n\n    function nextOffset(offsets, from) {\n      var offset = null,\n          i = 0;\n\n      while (offset === null) {\n        offset = offsets[from * 4 + i];\n        i++;\n        if (i > offsets.length) return null;\n      }\n\n      return offset;\n    }\n\n    return selection;\n  } // get range offsets within levels to render lods appropriate for zoom level\n  // TODO: it is possible to store minSize of a point to optimize neede level calc\n\n\n  function lod(lox, loy, hix, hiy, maxLevel) {\n    var ranges = [];\n\n    for (var _level = 0; _level < maxLevel; _level++) {\n      var levelGroups = groups[_level];\n      var from = offsets[_level][0];\n      var levelGroupStart = group(lox, loy, _level);\n      var levelGroupEnd = group(hix, hiy, _level); // FIXME: utilize sublevels to speed up search range here\n\n      var startOffset = search.ge(levelGroups, levelGroupStart);\n      var endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1);\n      ranges[_level] = [startOffset + from, endOffset + from];\n    }\n\n    return ranges;\n  } // get group id closest to the x,y coordinate, corresponding to a level\n\n\n  function group(x, y, level) {\n    var group = 1;\n    var cx = .5,\n        cy = .5;\n    var diam = .5;\n\n    for (var _i5 = 0; _i5 < level; _i5++) {\n      group <<= 2;\n      group += x < cx ? y < cy ? 0 : 1 : y < cy ? 2 : 3;\n      diam *= .5;\n      cx += x < cx ? -diam : diam;\n      cy += y < cy ? -diam : diam;\n    }\n\n    return group;\n  }\n}; // normalize points by bounds\n\n\nfunction normalize(pts, bounds) {\n  var _bounds = _slicedToArray(bounds, 4),\n      lox = _bounds[0],\n      loy = _bounds[1],\n      hix = _bounds[2],\n      hiy = _bounds[3];\n\n  var scaleX = 1.0 / (hix - lox);\n  var scaleY = 1.0 / (hiy - loy);\n  var result = new Array(pts.length);\n\n  for (var i = 0, n = pts.length / 2; i < n; i++) {\n    result[2 * i] = clamp((pts[2 * i] - lox) * scaleX, 0, 1);\n    result[2 * i + 1] = clamp((pts[2 * i + 1] - loy) * scaleY, 0, 1);\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}