{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Color = require('../../components/color');\n\nvar fillText = Lib.fillText;\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var hoveron = trace.hoveron;\n  var closeBoxData = [];\n  var closePtData;\n\n  if (hoveron.indexOf('boxes') !== -1) {\n    closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n  }\n\n  if (hoveron.indexOf('points') !== -1) {\n    closePtData = hoverOnPoints(pointData, xval, yval);\n  } // If there's a point in range and hoveron has points, show the best single point only.\n  // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n\n\n  if (hovermode === 'closest') {\n    if (closePtData) return [closePtData];\n    return closeBoxData;\n  } // Otherwise in compare mode, allow a point AND the box stats to be labeled\n  // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n\n\n  if (closePtData) {\n    closeBoxData.push(closePtData);\n    return closeBoxData;\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isViolin = trace.type === 'violin';\n  var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos, hoverPseudoDistance, spikePseudoDistance;\n  var boxDelta = t.bdPos;\n  var boxDeltaPos, boxDeltaNeg;\n  var posAcceptance = t.wHover;\n\n  var shiftPos = function shiftPos(di) {\n    return pAxis.c2l(di.pos) + t.bPos - pAxis.c2l(pVal);\n  };\n\n  if (isViolin && trace.side !== 'both') {\n    if (trace.side === 'positive') {\n      dPos = function dPos(di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n      };\n\n      boxDeltaPos = boxDelta;\n      boxDeltaNeg = 0;\n    }\n\n    if (trace.side === 'negative') {\n      dPos = function dPos(di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n      };\n\n      boxDeltaPos = 0;\n      boxDeltaNeg = boxDelta;\n    }\n  } else {\n    dPos = function dPos(di) {\n      var pos = shiftPos(di);\n      return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n    };\n\n    boxDeltaPos = boxDeltaNeg = boxDelta;\n  }\n\n  var dVal;\n\n  if (isViolin) {\n    dVal = function dVal(di) {\n      return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n    };\n  } else {\n    dVal = function dVal(di) {\n      return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n    };\n  }\n\n  if (trace.orientation === 'h') {\n    vVal = xval;\n    pVal = yval;\n    dx = dVal;\n    dy = dPos;\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    vVal = yval;\n    pVal = xval;\n    dx = dPos;\n    dy = dVal;\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  } // if two boxes are overlaying, let the narrowest one win\n\n\n  var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n  // and create the item(s) in closedata for this point\n\n  if (pointData.index === false) return [];\n  var di = cd[pointData.index];\n  var lc = trace.line.color;\n  var mc = (trace.marker || {}).color;\n  if (Color.opacity(lc) && trace.line.width) pointData.color = lc;else if (Color.opacity(mc) && trace.boxpoints) pointData.color = mc;else pointData.color = trace.fillcolor;\n  pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);\n  pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);\n  pointData[pLetter + 'LabelVal'] = di.orig_p !== undefined ? di.orig_p : di.pos;\n  var spikePosAttr = pLetter + 'Spike';\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n  var hasMean = trace.boxmean || (trace.meanline || {}).visible;\n  var hasFences = trace.boxpoints || trace.points; // labels with equal values (e.g. when min === q1) should still be presented in the order they have when they're unequal\n\n  var attrs = hasFences && hasMean ? ['max', 'uf', 'q3', 'med', 'mean', 'q1', 'lf', 'min'] : hasFences && !hasMean ? ['max', 'uf', 'q3', 'med', 'q1', 'lf', 'min'] : !hasFences && hasMean ? ['max', 'q3', 'med', 'mean', 'q1', 'min'] : ['max', 'q3', 'med', 'q1', 'min'];\n  var rev = vAxis.range[1] < vAxis.range[0];\n\n  if (trace.orientation === (rev ? 'v' : 'h')) {\n    attrs.reverse();\n  }\n\n  var spikeDistance = pointData.spikeDistance;\n  var spikePosition = pointData[spikePosAttr];\n  var closeBoxData = [];\n\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!(attr in di)) continue; // copy out to a new object for each value to label\n\n    var val = di[attr];\n    var valPx = vAxis.c2p(val, true);\n    var pointData2 = Lib.extendFlat({}, pointData);\n    pointData2.attr = attr;\n    pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n    pointData2[vLetter + 'LabelVal'] = val;\n    pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val, trace[vLetter + 'hoverformat']); // Note: introduced to be able to distinguish a\n    // clicked point from a box during click-to-select\n\n    pointData2.hoverOnBox = true;\n\n    if (attr === 'mean' && 'sd' in di && trace.boxmean === 'sd') {\n      pointData2[vLetter + 'err'] = di.sd;\n    } // no hovertemplate support yet\n\n\n    pointData2.hovertemplate = false;\n    closeBoxData.push(pointData2);\n  } // only keep name and spikes on the median\n\n\n  pointData.name = '';\n  pointData.spikeDistance = undefined;\n  pointData[spikePosAttr] = undefined;\n\n  for (var k = 0; k < closeBoxData.length; k++) {\n    if (closeBoxData[k].attr !== 'med') {\n      closeBoxData[k].name = '';\n      closeBoxData[k].spikeDistance = undefined;\n      closeBoxData[k][spikePosAttr] = undefined;\n    } else {\n      closeBoxData[k].spikeDistance = spikeDistance;\n      closeBoxData[k][spikePosAttr] = spikePosition;\n    }\n  }\n\n  return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var xPx = xa.c2p(xval);\n  var yPx = ya.c2p(yval);\n  var closePtData;\n\n  var dx = function dx(di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n  };\n\n  var dy = function dy(di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n  };\n\n  var distfn = Fx.quadrature(dx, dy); // show one point per trace\n\n  var ijClosest = false;\n  var di, pt;\n\n  for (var i = 0; i < cd.length; i++) {\n    di = cd[i];\n\n    for (var j = 0; j < (di.pts || []).length; j++) {\n      pt = di.pts[j];\n      var newDistance = distfn(pt);\n\n      if (newDistance <= pointData.distance) {\n        pointData.distance = newDistance;\n        ijClosest = [i, j];\n      }\n    }\n  }\n\n  if (!ijClosest) return false;\n  di = cd[ijClosest[0]];\n  pt = di.pts[ijClosest[1]];\n  var xc = xa.c2p(pt.x, true);\n  var yc = ya.c2p(pt.y, true);\n  var rad = pt.mrc || 1;\n  closePtData = Lib.extendFlat({}, pointData, {\n    // corresponds to index in x/y input data array\n    index: pt.i,\n    color: (trace.marker || {}).color,\n    name: trace.name,\n    x0: xc - rad,\n    x1: xc + rad,\n    y0: yc - rad,\n    y1: yc + rad,\n    spikeDistance: pointData.distance,\n    hovertemplate: trace.hovertemplate\n  });\n  var origPos = di.orig_p;\n  var pos = origPos !== undefined ? origPos : di.pos;\n  var pa;\n\n  if (trace.orientation === 'h') {\n    pa = ya;\n    closePtData.xLabelVal = pt.x;\n    closePtData.yLabelVal = pos;\n  } else {\n    pa = xa;\n    closePtData.xLabelVal = pos;\n    closePtData.yLabelVal = pt.y;\n  }\n\n  var pLetter = pa._id.charAt(0);\n\n  closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n  fillText(pt, trace, closePtData);\n  return closePtData;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBoxes: hoverOnBoxes,\n  hoverOnPoints: hoverOnPoints\n};","map":null,"metadata":{},"sourceType":"script"}