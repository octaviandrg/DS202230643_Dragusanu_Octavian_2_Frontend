{"ast":null,"code":"'use strict';\n\nvar colorScaleAttrs = require('../../components/colorscale/attributes');\n\nvar axisHoverFormat = require('../../plots/cartesian/axis_format_attributes').axisHoverFormat;\n\nvar hovertemplateAttrs = require('../../plots/template_attributes').hovertemplateAttrs;\n\nvar surfaceAttrs = require('../surface/attributes');\n\nvar baseAttrs = require('../../plots/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = extendFlat({\n  x: {\n    valType: 'data_array',\n    editType: 'calc+clearAxisTypes',\n    description: ['Sets the X coordinates of the vertices. The nth element of vectors `x`, `y` and `z`', 'jointly represent the X, Y and Z coordinates of the nth vertex.'].join(' ')\n  },\n  y: {\n    valType: 'data_array',\n    editType: 'calc+clearAxisTypes',\n    description: ['Sets the Y coordinates of the vertices. The nth element of vectors `x`, `y` and `z`', 'jointly represent the X, Y and Z coordinates of the nth vertex.'].join(' ')\n  },\n  z: {\n    valType: 'data_array',\n    editType: 'calc+clearAxisTypes',\n    description: ['Sets the Z coordinates of the vertices. The nth element of vectors `x`, `y` and `z`', 'jointly represent the X, Y and Z coordinates of the nth vertex.'].join(' ')\n  },\n  i: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['A vector of vertex indices, i.e. integer values between 0 and the length of the vertex', 'vectors, representing the *first* vertex of a triangle. For example, `{i[m], j[m], k[m]}`', 'together represent face m (triangle m) in the mesh, where `i[m] = n` points to the triplet', '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `i` represents a', 'point in space, which is the first vertex of a triangle.'].join(' ')\n  },\n  j: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['A vector of vertex indices, i.e. integer values between 0 and the length of the vertex', 'vectors, representing the *second* vertex of a triangle. For example, `{i[m], j[m], k[m]}` ', 'together represent face m (triangle m) in the mesh, where `j[m] = n` points to the triplet', '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `j` represents a', 'point in space, which is the second vertex of a triangle.'].join(' ')\n  },\n  k: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['A vector of vertex indices, i.e. integer values between 0 and the length of the vertex', 'vectors, representing the *third* vertex of a triangle. For example, `{i[m], j[m], k[m]}`', 'together represent face m (triangle m) in the mesh, where `k[m] = n` points to the triplet ', '`{x[n], y[n], z[n]}` in the vertex arrays. Therefore, each element in `k` represents a', 'point in space, which is the third vertex of a triangle.'].join(' ')\n  },\n  text: {\n    valType: 'string',\n    dflt: '',\n    arrayOk: true,\n    editType: 'calc',\n    description: ['Sets the text elements associated with the vertices.', 'If trace `hoverinfo` contains a *text* flag and *hovertext* is not set,', 'these elements will be seen in the hover labels.'].join(' ')\n  },\n  hovertext: {\n    valType: 'string',\n    dflt: '',\n    arrayOk: true,\n    editType: 'calc',\n    description: 'Same as `text`.'\n  },\n  hovertemplate: hovertemplateAttrs({\n    editType: 'calc'\n  }),\n  xhoverformat: axisHoverFormat('x'),\n  yhoverformat: axisHoverFormat('y'),\n  zhoverformat: axisHoverFormat('z'),\n  delaunayaxis: {\n    valType: 'enumerated',\n    values: ['x', 'y', 'z'],\n    dflt: 'z',\n    editType: 'calc',\n    description: ['Sets the Delaunay axis, which is the axis that is perpendicular to the surface of the', 'Delaunay triangulation.', 'It has an effect if `i`, `j`, `k` are not provided and `alphahull` is set to indicate', 'Delaunay triangulation.'].join(' ')\n  },\n  alphahull: {\n    valType: 'number',\n    dflt: -1,\n    editType: 'calc',\n    description: ['Determines how the mesh surface triangles are derived from the set of', 'vertices (points) represented by the `x`, `y` and `z` arrays, if', 'the `i`, `j`, `k` arrays are not supplied.', 'For general use of `mesh3d` it is preferred that `i`, `j`, `k` are', 'supplied.', 'If *-1*, Delaunay triangulation is used, which is mainly suitable if the', 'mesh is a single, more or less layer surface that is perpendicular to `delaunayaxis`.', 'In case the `delaunayaxis` intersects the mesh surface at more than one point', 'it will result triangles that are very long in the dimension of `delaunayaxis`.', 'If *>0*, the alpha-shape algorithm is used. In this case, the positive `alphahull` value', 'signals the use of the alpha-shape algorithm, _and_ its value', 'acts as the parameter for the mesh fitting.', 'If *0*,  the convex-hull algorithm is used. It is suitable for convex bodies', 'or if the intention is to enclose the `x`, `y` and `z` point set into a convex', 'hull.'].join(' ')\n  },\n  intensity: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['Sets the intensity values for vertices or cells', 'as defined by `intensitymode`.', 'It can be used for plotting fields on meshes.'].join(' ')\n  },\n  intensitymode: {\n    valType: 'enumerated',\n    values: ['vertex', 'cell'],\n    dflt: 'vertex',\n    editType: 'calc',\n    description: ['Determines the source of `intensity` values.'].join(' ')\n  },\n  // Color field\n  color: {\n    valType: 'color',\n    editType: 'calc',\n    description: 'Sets the color of the whole mesh'\n  },\n  vertexcolor: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['Sets the color of each vertex', 'Overrides *color*. While Red, green and blue colors', 'are in the range of 0 and 255; in the case of having', 'vertex color data in RGBA format, the alpha color', 'should be normalized to be between 0 and 1.'].join(' ')\n  },\n  facecolor: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['Sets the color of each face', 'Overrides *color* and *vertexcolor*.'].join(' ')\n  },\n  transforms: undefined\n}, colorScaleAttrs('', {\n  colorAttr: '`intensity`',\n  showScaleDflt: true,\n  editTypeOverride: 'calc'\n}), {\n  opacity: surfaceAttrs.opacity,\n  // Flat shaded mode\n  flatshading: {\n    valType: 'boolean',\n    dflt: false,\n    editType: 'calc',\n    description: ['Determines whether or not normal smoothing is applied to the meshes,', 'creating meshes with an angular, low-poly look via flat reflections.'].join(' ')\n  },\n  contour: {\n    show: extendFlat({}, surfaceAttrs.contours.x.show, {\n      description: ['Sets whether or not dynamic contours are shown on hover'].join(' ')\n    }),\n    color: surfaceAttrs.contours.x.color,\n    width: surfaceAttrs.contours.x.width,\n    editType: 'calc'\n  },\n  lightposition: {\n    x: extendFlat({}, surfaceAttrs.lightposition.x, {\n      dflt: 1e5\n    }),\n    y: extendFlat({}, surfaceAttrs.lightposition.y, {\n      dflt: 1e5\n    }),\n    z: extendFlat({}, surfaceAttrs.lightposition.z, {\n      dflt: 0\n    }),\n    editType: 'calc'\n  },\n  lighting: extendFlat({\n    vertexnormalsepsilon: {\n      valType: 'number',\n      min: 0.00,\n      max: 1,\n      dflt: 1e-12,\n      // otherwise finely tessellated things eg. the brain will have no specular light reflection\n      editType: 'calc',\n      description: 'Epsilon for vertex normals calculation avoids math issues arising from degenerate geometry.'\n    },\n    facenormalsepsilon: {\n      valType: 'number',\n      min: 0.00,\n      max: 1,\n      dflt: 1e-6,\n      // even the brain model doesn't appear to need finer than this\n      editType: 'calc',\n      description: 'Epsilon for face normals calculation avoids math issues arising from degenerate geometry.'\n    },\n    editType: 'calc'\n  }, surfaceAttrs.lighting),\n  hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {\n    editType: 'calc'\n  }),\n  showlegend: extendFlat({}, baseAttrs.showlegend, {\n    dflt: false\n  })\n});","map":null,"metadata":{},"sourceType":"script"}