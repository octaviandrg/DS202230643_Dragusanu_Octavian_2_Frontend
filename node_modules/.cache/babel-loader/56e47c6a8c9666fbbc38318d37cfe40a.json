{"ast":null,"code":"'use strict';\n\nvar createHeatmap2D = require('../../../stackgl_modules').gl_heatmap2d;\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar str2RGBArray = require('../../lib/str2rgbarray');\n\nfunction Heatmap(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.type = 'heatmapgl';\n  this.name = '';\n  this.hoverinfo = 'all';\n  this.xData = [];\n  this.yData = [];\n  this.zData = [];\n  this.textLabels = [];\n  this.idToIndex = [];\n  this.bounds = [0, 0, 0, 0];\n  this.options = {\n    zsmooth: 'fast',\n    z: [],\n    x: [],\n    y: [],\n    shape: [0, 0],\n    colorLevels: [0],\n    colorValues: [0, 0, 0, 1]\n  };\n  this.heatmap = createHeatmap2D(scene.glplot, this.options);\n  this.heatmap._trace = this;\n}\n\nvar proto = Heatmap.prototype;\n\nproto.handlePick = function (pickResult) {\n  var options = this.options;\n  var shape = options.shape;\n  var index = pickResult.pointId;\n  var xIndex = index % shape[0];\n  var yIndex = Math.floor(index / shape[0]);\n  var zIndex = index;\n  return {\n    trace: this,\n    dataCoord: pickResult.dataCoord,\n    traceCoord: [options.x[xIndex], options.y[yIndex], options.z[zIndex]],\n    textLabel: this.textLabels[index],\n    name: this.name,\n    pointIndex: [yIndex, xIndex],\n    hoverinfo: this.hoverinfo\n  };\n};\n\nproto.update = function (fullTrace, calcTrace) {\n  var calcPt = calcTrace[0];\n  this.index = fullTrace.index;\n  this.name = fullTrace.name;\n  this.hoverinfo = fullTrace.hoverinfo; // convert z from 2D -> 1D\n\n  var z = calcPt.z;\n  this.options.z = [].concat.apply([], z);\n  var rowLen = z[0].length;\n  var colLen = z.length;\n  this.options.shape = [rowLen, colLen];\n  this.options.x = calcPt.x;\n  this.options.y = calcPt.y;\n  this.options.zsmooth = fullTrace.zsmooth;\n  var colorOptions = convertColorscale(fullTrace);\n  this.options.colorLevels = colorOptions.colorLevels;\n  this.options.colorValues = colorOptions.colorValues; // convert text from 2D -> 1D\n\n  this.textLabels = [].concat.apply([], fullTrace.text);\n  this.heatmap.update(this.options);\n  var xa = this.scene.xaxis;\n  var ya = this.scene.yaxis;\n  var xOpts, yOpts;\n\n  if (fullTrace.zsmooth === false) {\n    // increase padding for discretised heatmap as suggested by Louise Ord\n    xOpts = {\n      ppad: calcPt.x[1] - calcPt.x[0]\n    };\n    yOpts = {\n      ppad: calcPt.y[1] - calcPt.y[0]\n    };\n  }\n\n  fullTrace._extremes[xa._id] = Axes.findExtremes(xa, calcPt.x, xOpts);\n  fullTrace._extremes[ya._id] = Axes.findExtremes(ya, calcPt.y, yOpts);\n};\n\nproto.dispose = function () {\n  this.heatmap.dispose();\n};\n\nfunction convertColorscale(fullTrace) {\n  var scl = fullTrace.colorscale;\n  var zmin = fullTrace.zmin;\n  var zmax = fullTrace.zmax;\n  var N = scl.length;\n  var domain = new Array(N);\n  var range = new Array(4 * N);\n\n  for (var i = 0; i < N; i++) {\n    var si = scl[i];\n    var color = str2RGBArray(si[1]);\n    domain[i] = zmin + si[0] * (zmax - zmin);\n\n    for (var j = 0; j < 4; j++) {\n      range[4 * i + j] = color[j];\n    }\n  }\n\n  return {\n    colorLevels: domain,\n    colorValues: range\n  };\n}\n\nfunction createHeatmap(scene, fullTrace, calcTrace) {\n  var plot = new Heatmap(scene, fullTrace.uid);\n  plot.update(fullTrace, calcTrace);\n  return plot;\n}\n\nmodule.exports = createHeatmap;","map":null,"metadata":{},"sourceType":"script"}