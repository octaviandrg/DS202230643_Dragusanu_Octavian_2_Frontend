{"ast":null,"code":"'use strict';\n\nvar tube2mesh = require('../../../stackgl_modules').gl_streamtube3d;\n\nvar createTubeMesh = tube2mesh.createTubeMesh;\n\nvar Lib = require('../../lib');\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar axisName2scaleIndex = {\n  xaxis: 0,\n  yaxis: 1,\n  zaxis: 2\n};\n\nfunction Streamtube(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = null;\n  this.data = null;\n}\n\nvar proto = Streamtube.prototype;\n\nproto.handlePick = function (selection) {\n  var sceneLayout = this.scene.fullSceneLayout;\n  var dataScale = this.scene.dataScale;\n\n  function fromDataScale(v, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return ax.l2c(v) / scale;\n  }\n\n  if (selection.object === this.mesh) {\n    var pos = selection.data.position;\n    var uvx = selection.data.velocity;\n    selection.traceCoordinate = [fromDataScale(pos[0], 'xaxis'), fromDataScale(pos[1], 'yaxis'), fromDataScale(pos[2], 'zaxis'), fromDataScale(uvx[0], 'xaxis'), fromDataScale(uvx[1], 'yaxis'), fromDataScale(uvx[2], 'zaxis'), // u/v/w norm\n    selection.data.intensity * this.data._normMax, // divergence\n    selection.data.divergence];\n    selection.textLabel = this.data.hovertext || this.data.text;\n    return true;\n  }\n};\n\nfunction getDfltStartingPositions(vec) {\n  var len = vec.length;\n  var s;\n\n  if (len > 2) {\n    s = vec.slice(1, len - 1);\n  } else if (len === 2) {\n    s = [(vec[0] + vec[1]) / 2];\n  } else {\n    s = vec;\n  }\n\n  return s;\n}\n\nfunction getBoundPads(vec) {\n  var len = vec.length;\n\n  if (len === 1) {\n    return [0.5, 0.5];\n  } else {\n    return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];\n  }\n}\n\nfunction convert(scene, trace) {\n  var sceneLayout = scene.fullSceneLayout;\n  var dataScale = scene.dataScale;\n  var len = trace._len;\n  var tubeOpts = {};\n\n  function toDataCoords(arr, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return Lib.simpleMap(arr, function (v) {\n      return ax.d2l(v) * scale;\n    });\n  }\n\n  tubeOpts.vectors = zip3(toDataCoords(trace._u, 'xaxis'), toDataCoords(trace._v, 'yaxis'), toDataCoords(trace._w, 'zaxis'), len); // Over-specified mesh case, this would error in tube2mesh\n\n  if (!len) {\n    return {\n      positions: [],\n      cells: []\n    };\n  }\n\n  var meshx = toDataCoords(trace._Xs, 'xaxis');\n  var meshy = toDataCoords(trace._Ys, 'yaxis');\n  var meshz = toDataCoords(trace._Zs, 'zaxis');\n  tubeOpts.meshgrid = [meshx, meshy, meshz];\n  tubeOpts.gridFill = trace._gridFill;\n  var slen = trace._slen;\n\n  if (slen) {\n    tubeOpts.startingPositions = zip3(toDataCoords(trace._startsX, 'xaxis'), toDataCoords(trace._startsY, 'yaxis'), toDataCoords(trace._startsZ, 'zaxis'));\n  } else {\n    // Default starting positions:\n    //\n    // if len>2, cut xz plane at min-y,\n    // takes all x/y/z pts on that plane except those on the edges\n    // to generate \"well-defined\" tubes,\n    //\n    // if len=2, take position halfway between two the pts,\n    //\n    // if len=1, take that pt\n    var sy0 = meshy[0];\n    var sx = getDfltStartingPositions(meshx);\n    var sz = getDfltStartingPositions(meshz);\n    var startingPositions = new Array(sx.length * sz.length);\n    var m = 0;\n\n    for (var i = 0; i < sx.length; i++) {\n      for (var k = 0; k < sz.length; k++) {\n        startingPositions[m++] = [sx[i], sy0, sz[k]];\n      }\n    }\n\n    tubeOpts.startingPositions = startingPositions;\n  }\n\n  tubeOpts.colormap = parseColorScale(trace);\n  tubeOpts.tubeSize = trace.sizeref;\n  tubeOpts.maxLength = trace.maxdisplayed; // add some padding around the bounds\n  // to e.g. allow tubes starting from a slice of the x/y/z mesh\n  // to go beyond bounds a little bit w/o getting clipped\n\n  var xbnds = toDataCoords(trace._xbnds, 'xaxis');\n  var ybnds = toDataCoords(trace._ybnds, 'yaxis');\n  var zbnds = toDataCoords(trace._zbnds, 'zaxis');\n  var xpads = getBoundPads(meshx);\n  var ypads = getBoundPads(meshy);\n  var zpads = getBoundPads(meshz);\n  var bounds = [[xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]], [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]];\n  var meshData = tube2mesh(tubeOpts, bounds); // N.B. cmin/cmax correspond to the min/max vector norm\n  // in the u/v/w arrays, which in general is NOT equal to max\n  // intensity that colors the tubes.\n\n  var cOpts = extractOpts(trace);\n  meshData.vertexIntensityBounds = [cOpts.min / trace._normMax, cOpts.max / trace._normMax]; // pass gl-mesh3d lighting attributes\n\n  var lp = trace.lightposition;\n  meshData.lightPosition = [lp.x, lp.y, lp.z];\n  meshData.ambient = trace.lighting.ambient;\n  meshData.diffuse = trace.lighting.diffuse;\n  meshData.specular = trace.lighting.specular;\n  meshData.roughness = trace.lighting.roughness;\n  meshData.fresnel = trace.lighting.fresnel;\n  meshData.opacity = trace.opacity; // stash autorange pad value\n\n  trace._pad = meshData.tubeScale * trace.sizeref * 2;\n  return meshData;\n}\n\nproto.update = function (data) {\n  this.data = data;\n  var meshData = convert(this.scene, data);\n  this.mesh.update(meshData);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nfunction createStreamtubeTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var meshData = convert(scene, data);\n  var mesh = createTubeMesh(gl, meshData);\n  var streamtube = new Streamtube(scene, data.uid);\n  streamtube.mesh = mesh;\n  streamtube.data = data;\n  mesh._trace = streamtube;\n  scene.glplot.add(mesh);\n  return streamtube;\n}\n\nmodule.exports = createStreamtubeTrace;","map":null,"metadata":{},"sourceType":"script"}