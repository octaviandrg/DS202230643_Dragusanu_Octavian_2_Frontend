{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/danaliulica/Documents/PROIECT/DS202230643_Dragusanu_Octavian_1_Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/danaliulica/Documents/PROIECT/DS202230643_Dragusanu_Octavian_1_Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar createScatter = require('regl-scatter2d');\n\nvar pick = require('pick-by-alias');\n\nvar getBounds = require('array-bounds');\n\nvar raf = require('raf');\n\nvar arrRange = require('array-range');\n\nvar rect = require('parse-rect');\n\nvar flatten = require('flatten-vertex-data');\n\nmodule.exports = SPLOM; // @constructor\n\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options); // render passes\n\n  this.traces = []; // passes for scatter, combined across traces\n\n  this.passes = {};\n  this.regl = regl; // main scatter drawing instance\n\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n} // update & draw passes once per frame\n\n\nSPLOM.prototype.render = function () {\n  var _this = this;\n\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw(); // make sure draw is not called more often than once a frame\n\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(function () {\n        _this.draw();\n\n        _this.dirty = true;\n        _this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(function () {\n      _this.dirty = false;\n    });\n  }\n\n  return this;\n}; // update passes\n\n\nSPLOM.prototype.update = function () {\n  var _this$scatter;\n\n  if (!arguments.length) return;\n\n  for (var i = 0; i < arguments.length; i++) {\n    this.updateItem(i, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  } // remove nulled passes\n\n\n  this.traces = this.traces.filter(Boolean); // FIXME: update passes independently\n\n  var passes = [];\n  var offset = 0;\n\n  for (var _i = 0; _i < this.traces.length; _i++) {\n    var trace = this.traces[_i];\n    var tracePasses = this.traces[_i].passes;\n\n    for (var j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    } // save offset of passes\n\n\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n\n  (_this$scatter = this.scatter).update.apply(_this$scatter, passes);\n\n  return this;\n}; // update trace by index, not supposed to be called directly\n\n\nSPLOM.prototype.updateItem = function (i, options) {\n  var regl = this.regl; // remove pass if null\n\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n\n  if (!options) return this;\n  var o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  }); // we provide regl buffer per-trace, since trace data can be changed\n\n  var trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  }); // save styles\n\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower; // put flattened data into buffer\n\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length; // detect bounds per-column\n\n    trace.bounds = [];\n\n    for (var _i2 = 0; _i2 < trace.columns; _i2++) {\n      trace.bounds[_i2] = getBounds(o.data[_i2], 1);\n    }\n  } // add proper range updating markers\n\n\n  var multirange;\n\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n\n  var multipadding = false;\n\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    } // single padding\n    else {\n        trace.padding = getPad(o.padding);\n      }\n  } // create passes\n\n\n  var m = trace.columns;\n  var n = trace.count;\n  var w = trace.viewport.width;\n  var h = trace.viewport.height;\n  var left = trace.viewport.x;\n  var top = trace.viewport.y;\n  var iw = w / m;\n  var ih = h / m;\n  trace.passes = [];\n\n  for (var _i3 = 0; _i3 < m; _i3++) {\n    for (var j = 0; j < m; j++) {\n      if (!trace.diagonal && j === _i3) continue;\n      if (!trace.upper && _i3 > j) continue;\n      if (!trace.lower && _i3 < j) continue;\n      var key = passId(trace.id, _i3, j);\n      var pass = this.passes[key] || (this.passes[key] = {});\n\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3 * n,\n              count: n\n            }\n          };\n        }\n\n        pass.bounds = getBox(trace.bounds, _i3, j);\n      }\n\n      if (o.domain || o.viewport || o.data) {\n        var pad = multipadding ? getBox(trace.padding, _i3, j) : trace.padding;\n\n        if (trace.domain) {\n          var _getBox = getBox(trace.domain, _i3, j),\n              _getBox2 = _slicedToArray(_getBox, 4),\n              lox = _getBox2[0],\n              loy = _getBox2[1],\n              hix = _getBox2[2],\n              hiy = _getBox2[3];\n\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        } // consider auto-domain equipartial\n        else {\n            pass.viewport = [left + j * iw + iw * pad[0], top + _i3 * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (_i3 + 1) * ih - ih * pad[3]];\n          }\n      }\n\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, _i3, j) : trace.range || pass.bounds;\n      }\n\n      trace.passes.push(key);\n    }\n  }\n\n  return this;\n}; // draw all or passed passes\n\n\nSPLOM.prototype.draw = function () {\n  var _this2 = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    (function () {\n      var _this2$scatter;\n\n      var idx = [];\n\n      for (var i = 0; i < args.length; i++) {\n        // draw(0, 2, 5) - draw traces\n        if (typeof args[i] === 'number') {\n          var _this2$traces$args$i = _this2.traces[args[i]],\n              passes = _this2$traces$args$i.passes,\n              passOffset = _this2$traces$args$i.passOffset;\n          idx.push.apply(idx, _toConsumableArray(arrRange(passOffset, passOffset + passes.length)));\n        } // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n        else if (args[i].length) {\n            (function () {\n              var els = args[i];\n              var _this2$traces$i = _this2.traces[i],\n                  passes = _this2$traces$i.passes,\n                  passOffset = _this2$traces$i.passOffset;\n              passes = passes.map(function (passId, i) {\n                idx[passOffset + i] = els;\n              });\n            })();\n          }\n      }\n\n      (_this2$scatter = _this2.scatter).draw.apply(_this2$scatter, idx);\n    })();\n  }\n\n  return this;\n}; // dispose resources\n\n\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(function (trace) {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n}; // return pass corresponding to trace i- j- square\n\n\nfunction passId(trace, i, j) {\n  var id = trace.id != null ? trace.id : trace;\n  var n = i;\n  var m = j;\n  var key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n} // return bounding box corresponding to a pass\n\n\nfunction getBox(items, i, j) {\n  var ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  var iitem = items[i],\n      jitem = items[j];\n\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n\n  return [jlox, iloy, jhix, ihiy];\n}\n\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    var box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}