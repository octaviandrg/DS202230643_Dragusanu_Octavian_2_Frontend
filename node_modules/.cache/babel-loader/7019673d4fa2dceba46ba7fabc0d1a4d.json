{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\n\nvar colorscaleDefaults = require('../../components/colorscale/defaults');\n\nvar handleDomainDefaults = require('../../plots/domain').defaults;\n\nvar handleArrayContainerDefaults = require('../../plots/array_container_defaults');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar attributes = require('./attributes');\n\nvar axisBrush = require('./axisbrush');\n\nvar maxDimensionCount = require('./constants').maxDimensionCount;\n\nvar mergeLength = require('./merge_length');\n\nfunction handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce) {\n  var lineColor = coerce('line.color', defaultColor);\n\n  if (hasColorscale(traceIn, 'line') && Lib.isArrayOrTypedArray(lineColor)) {\n    if (lineColor.length) {\n      coerce('line.colorscale');\n      colorscaleDefaults(traceIn, traceOut, layout, coerce, {\n        prefix: 'line.',\n        cLetter: 'c'\n      }); // TODO: I think it would be better to keep showing lines beyond the last line color\n      // but I'm not sure what color to give these lines - probably black or white\n      // depending on the background color?\n\n      return lineColor.length;\n    } else {\n      traceOut.line.color = defaultColor;\n    }\n  }\n\n  return Infinity;\n}\n\nfunction dimensionDefaults(dimensionIn, dimensionOut, parentOut, opts) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(dimensionIn, dimensionOut, attributes.dimensions, attr, dflt);\n  }\n\n  var values = coerce('values');\n  var visible = coerce('visible');\n\n  if (!(values && values.length)) {\n    visible = dimensionOut.visible = false;\n  }\n\n  if (visible) {\n    coerce('label');\n    coerce('tickvals');\n    coerce('ticktext');\n    coerce('tickformat');\n    var range = coerce('range');\n    dimensionOut._ax = {\n      _id: 'y',\n      type: 'linear',\n      showexponent: 'all',\n      exponentformat: 'B',\n      range: range\n    };\n    Axes.setConvert(dimensionOut._ax, opts.layout);\n    coerce('multiselect');\n    var constraintRange = coerce('constraintrange');\n\n    if (constraintRange) {\n      dimensionOut.constraintrange = axisBrush.cleanRanges(constraintRange, dimensionOut);\n    }\n  }\n}\n\nmodule.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n  }\n\n  var dimensionsIn = traceIn.dimensions;\n\n  if (Array.isArray(dimensionsIn) && dimensionsIn.length > maxDimensionCount) {\n    Lib.log('parcoords traces support up to ' + maxDimensionCount + ' dimensions at the moment');\n    dimensionsIn.splice(maxDimensionCount);\n  }\n\n  var dimensions = handleArrayContainerDefaults(traceIn, traceOut, {\n    name: 'dimensions',\n    layout: layout,\n    handleItemDefaults: dimensionDefaults\n  });\n  var len = handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);\n  handleDomainDefaults(traceOut, layout, coerce);\n\n  if (!Array.isArray(dimensions) || !dimensions.length) {\n    traceOut.visible = false;\n  }\n\n  mergeLength(traceOut, dimensions, 'values', len); // make default font size 10px (default is 12),\n  // scale linearly with global font size\n\n  var fontDflt = {\n    family: layout.font.family,\n    size: Math.round(layout.font.size / 1.2),\n    color: layout.font.color\n  };\n  Lib.coerceFont(coerce, 'labelfont', fontDflt);\n  Lib.coerceFont(coerce, 'tickfont', fontDflt);\n  Lib.coerceFont(coerce, 'rangefont', fontDflt);\n  coerce('labelangle');\n  coerce('labelside');\n  coerce('unselected.line.color');\n  coerce('unselected.line.opacity');\n};","map":null,"metadata":{},"sourceType":"script"}