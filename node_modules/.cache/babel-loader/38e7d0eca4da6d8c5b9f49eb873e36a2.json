{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar dragElement = require('../dragelement');\n\nvar dragHelpers = require('../dragelement/helpers');\n\nvar drawMode = dragHelpers.drawMode;\nvar selectMode = dragHelpers.selectMode;\n\nvar Registry = require('../../registry');\n\nvar Color = require('../color');\n\nvar constants = require('./draw_newshape/constants');\n\nvar i000 = constants.i000;\nvar i090 = constants.i090;\nvar i180 = constants.i180;\nvar i270 = constants.i270;\n\nvar handleOutline = require('./handle_outline');\n\nvar clearOutlineControllers = handleOutline.clearOutlineControllers;\n\nvar helpers = require('./draw_newshape/helpers');\n\nvar pointsOnRectangle = helpers.pointsOnRectangle;\nvar pointsOnEllipse = helpers.pointsOnEllipse;\nvar writePaths = helpers.writePaths;\n\nvar newShapes = require('./draw_newshape/newshapes');\n\nvar newSelections = require('../selections/draw_newselection/newselections');\n\nmodule.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {\n  if (!nCalls) nCalls = 0;\n  var gd = dragOptions.gd;\n\n  function redraw() {\n    // recursive call\n    displayOutlines(polygons, outlines, dragOptions, nCalls++);\n\n    if (pointsOnEllipse(polygons[0])) {\n      update({\n        redrawing: true\n      });\n    }\n  }\n\n  function update(opts) {\n    var updateObject = {};\n\n    if (dragOptions.isActiveShape !== undefined) {\n      dragOptions.isActiveShape = false; // i.e. to disable shape controllers\n\n      updateObject = newShapes(outlines, dragOptions);\n    }\n\n    if (dragOptions.isActiveSelection !== undefined) {\n      dragOptions.isActiveSelection = false; // i.e. to disable selection controllers\n\n      updateObject = newSelections(outlines, dragOptions);\n      gd._fullLayout._reselect = true;\n    }\n\n    if (Object.keys(updateObject).length) {\n      Registry.call((opts || {}).redrawing ? 'relayout' : '_guiRelayout', gd, updateObject);\n    }\n  }\n\n  var fullLayout = gd._fullLayout;\n  var zoomLayer = fullLayout._zoomlayer;\n  var dragmode = dragOptions.dragmode;\n  var isDrawMode = drawMode(dragmode);\n  var isSelectMode = selectMode(dragmode);\n\n  if (isDrawMode || isSelectMode) {\n    gd._fullLayout._outlining = true;\n  }\n\n  clearOutlineControllers(gd); // make outline\n\n  outlines.attr('d', writePaths(polygons)); // add controllers\n\n  var vertexDragOptions;\n  var groupDragOptions;\n  var indexI; // cell index\n\n  var indexJ; // vertex or cell-controller index\n\n  var copyPolygons;\n\n  if (!nCalls && (dragOptions.isActiveShape || dragOptions.isActiveSelection)) {\n    copyPolygons = recordPositions([], polygons);\n    var g = zoomLayer.append('g').attr('class', 'outline-controllers');\n    addVertexControllers(g);\n    addGroupControllers();\n  }\n\n  function startDragVertex(evt) {\n    indexI = +evt.srcElement.getAttribute('data-i');\n    indexJ = +evt.srcElement.getAttribute('data-j');\n    vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;\n  }\n\n  function moveVertexController(dx, dy) {\n    if (!polygons.length) return;\n    var x0 = copyPolygons[indexI][indexJ][1];\n    var y0 = copyPolygons[indexI][indexJ][2];\n    var cell = polygons[indexI];\n    var len = cell.length;\n\n    if (pointsOnRectangle(cell)) {\n      var _dx = dx;\n      var _dy = dy;\n\n      if (dragOptions.isActiveSelection) {\n        // handle an edge contoller for rect selections\n        var nextPoint = getNextPoint(cell, indexJ);\n\n        if (nextPoint[1] === cell[indexJ][1]) {\n          // a vertical edge\n          _dy = 0;\n        } else {\n          // a horizontal edge\n          _dx = 0;\n        }\n      }\n\n      for (var q = 0; q < len; q++) {\n        if (q === indexJ) continue; // move other corners of rectangle\n\n        var pos = cell[q];\n\n        if (pos[1] === cell[indexJ][1]) {\n          pos[1] = x0 + _dx;\n        }\n\n        if (pos[2] === cell[indexJ][2]) {\n          pos[2] = y0 + _dy;\n        }\n      } // move the corner\n\n\n      cell[indexJ][1] = x0 + _dx;\n      cell[indexJ][2] = y0 + _dy;\n\n      if (!pointsOnRectangle(cell)) {\n        // reject result to rectangles with ensure areas\n        for (var j = 0; j < len; j++) {\n          for (var k = 0; k < cell[j].length; k++) {\n            cell[j][k] = copyPolygons[indexI][j][k];\n          }\n        }\n      }\n    } else {\n      // other polylines\n      cell[indexJ][1] = x0 + dx;\n      cell[indexJ][2] = y0 + dy;\n    }\n\n    redraw();\n  }\n\n  function endDragVertexController() {\n    update();\n  }\n\n  function removeVertex() {\n    if (!polygons.length) return;\n    if (!polygons[indexI]) return;\n    if (!polygons[indexI].length) return;\n    var newPolygon = [];\n\n    for (var j = 0; j < polygons[indexI].length; j++) {\n      if (j !== indexJ) {\n        newPolygon.push(polygons[indexI][j]);\n      }\n    }\n\n    if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === 'Z')) {\n      if (indexJ === 0) {\n        newPolygon[0][0] = 'M';\n      }\n\n      polygons[indexI] = newPolygon;\n      redraw();\n      update();\n    }\n  }\n\n  function clickVertexController(numClicks, evt) {\n    if (numClicks === 2) {\n      indexI = +evt.srcElement.getAttribute('data-i');\n      indexJ = +evt.srcElement.getAttribute('data-j');\n      var cell = polygons[indexI];\n\n      if (!pointsOnRectangle(cell) && !pointsOnEllipse(cell)) {\n        removeVertex();\n      }\n    }\n  }\n\n  function addVertexControllers(g) {\n    vertexDragOptions = [];\n\n    for (var i = 0; i < polygons.length; i++) {\n      var cell = polygons[i];\n      var onRect = pointsOnRectangle(cell);\n      var onEllipse = !onRect && pointsOnEllipse(cell);\n      vertexDragOptions[i] = [];\n      var len = cell.length;\n\n      for (var j = 0; j < len; j++) {\n        if (cell[j][0] === 'Z') continue;\n\n        if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {\n          continue;\n        }\n\n        var rectSelection = onRect && dragOptions.isActiveSelection;\n        var nextPoint;\n        if (rectSelection) nextPoint = getNextPoint(cell, j);\n        var x = cell[j][1];\n        var y = cell[j][2];\n        var vertex = g.append(rectSelection ? 'rect' : 'circle').attr('data-i', i).attr('data-j', j).style({\n          fill: Color.background,\n          stroke: Color.defaultLine,\n          'stroke-width': 1,\n          'shape-rendering': 'crispEdges'\n        });\n\n        if (rectSelection) {\n          // convert a vertex controller to an edge controller for rect selections\n          var dx = nextPoint[1] - x;\n          var dy = nextPoint[2] - y;\n          var width = dy ? 5 : Math.max(Math.min(25, Math.abs(dx) - 5), 5);\n          var height = dx ? 5 : Math.max(Math.min(25, Math.abs(dy) - 5), 5);\n          vertex.classed(dy ? 'cursor-ew-resize' : 'cursor-ns-resize', true).attr('width', width).attr('height', height).attr('x', x - width / 2).attr('y', y - height / 2).attr('transform', strTranslate(dx / 2, dy / 2));\n        } else {\n          vertex.classed('cursor-grab', true).attr('r', 5).attr('cx', x).attr('cy', y);\n        }\n\n        vertexDragOptions[i][j] = {\n          element: vertex.node(),\n          gd: gd,\n          prepFn: startDragVertex,\n          doneFn: endDragVertexController,\n          clickFn: clickVertexController\n        };\n        dragElement.init(vertexDragOptions[i][j]);\n      }\n    }\n  }\n\n  function moveGroup(dx, dy) {\n    if (!polygons.length) return;\n\n    for (var i = 0; i < polygons.length; i++) {\n      for (var j = 0; j < polygons[i].length; j++) {\n        for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {\n          polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;\n          polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;\n        }\n      }\n    }\n  }\n\n  function moveGroupController(dx, dy) {\n    moveGroup(dx, dy);\n    redraw();\n  }\n\n  function startDragGroupController(evt) {\n    indexI = +evt.srcElement.getAttribute('data-i');\n    if (!indexI) indexI = 0; // ensure non-existing move button get zero index\n\n    groupDragOptions[indexI].moveFn = moveGroupController;\n  }\n\n  function endDragGroupController() {\n    update();\n  }\n\n  function clickGroupController(numClicks) {\n    if (numClicks === 2) {\n      eraseActiveSelection(gd);\n    }\n  }\n\n  function addGroupControllers() {\n    groupDragOptions = [];\n    if (!polygons.length) return;\n    var i = 0;\n    groupDragOptions[i] = {\n      element: outlines[0][0],\n      gd: gd,\n      prepFn: startDragGroupController,\n      doneFn: endDragGroupController,\n      clickFn: clickGroupController\n    };\n    dragElement.init(groupDragOptions[i]);\n  }\n};\n\nfunction recordPositions(polygonsOut, polygonsIn) {\n  for (var i = 0; i < polygonsIn.length; i++) {\n    var cell = polygonsIn[i];\n    polygonsOut[i] = [];\n\n    for (var j = 0; j < cell.length; j++) {\n      polygonsOut[i][j] = [];\n\n      for (var k = 0; k < cell[j].length; k++) {\n        polygonsOut[i][j][k] = cell[j][k];\n      }\n    }\n  }\n\n  return polygonsOut;\n}\n\nfunction getNextPoint(cell, j) {\n  var x = cell[j][1];\n  var y = cell[j][2];\n  var len = cell.length;\n  var nextJ, nextX, nextY;\n  nextJ = (j + 1) % len;\n  nextX = cell[nextJ][1];\n  nextY = cell[nextJ][2]; // avoid potential double points (closing points)\n\n  if (nextX === x && nextY === y) {\n    nextJ = (j + 2) % len;\n    nextX = cell[nextJ][1];\n    nextY = cell[nextJ][2];\n  }\n\n  return [nextJ, nextX, nextY];\n}\n\nfunction eraseActiveSelection(gd) {\n  // Do not allow removal of selections on other dragmodes.\n  // This ensures the user could still double click to\n  // deselect all trace.selectedpoints,\n  // if that's what they wanted.\n  // Also double click to zoom back won't result in\n  // any surprising selection removal.\n  if (!selectMode(gd._fullLayout.dragmode)) return;\n  clearOutlineControllers(gd);\n  var id = gd._fullLayout._activeSelectionIndex;\n  var selections = (gd.layout || {}).selections || [];\n\n  if (id < selections.length) {\n    var list = [];\n\n    for (var q = 0; q < selections.length; q++) {\n      if (q !== id) {\n        list.push(selections[q]);\n      }\n    }\n\n    delete gd._fullLayout._activeSelectionIndex;\n    var erasedSelection = gd._fullLayout.selections[id];\n    gd._fullLayout._deselect = {\n      xref: erasedSelection.xref,\n      yref: erasedSelection.yref\n    };\n    Registry.call('_guiRelayout', gd, {\n      selections: list\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}