{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var stash = cd[0].t;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var x = stash.x;\n  var y = stash.y;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var maxDistance = pointData.distance;\n  var ids; // FIXME: make sure this is a proper way to calc search radius\n\n  if (stash.tree) {\n    var xl = xa.p2c(xpx - maxDistance);\n    var xr = xa.p2c(xpx + maxDistance);\n    var yl = ya.p2c(ypx - maxDistance);\n    var yr = ya.p2c(ypx + maxDistance);\n\n    if (hovermode === 'x') {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(ya._rl[0], ya._rl[1]), Math.max(xl, xr), Math.max(ya._rl[0], ya._rl[1]));\n    } else {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(yl, yr), Math.max(xl, xr), Math.max(yl, yr));\n    }\n  } else {\n    ids = stash.ids;\n  } // pick the id closest to the point\n  // note that point possibly may not be found\n\n\n  var k, closestId, ptx, pty, i, dx, dy, dist, dxy;\n  var minDist = maxDistance;\n\n  if (hovermode === 'x') {\n    var xPeriod = !!trace.xperiodalignment;\n    var yPeriod = !!trace.yperiodalignment;\n\n    for (i = 0; i < ids.length; i++) {\n      k = ids[i];\n      ptx = x[k];\n      dx = Math.abs(xa.c2p(ptx) - xpx);\n\n      if (xPeriod) {\n        var x0 = xa.c2p(trace._xStarts[k]);\n        var x1 = xa.c2p(trace._xEnds[k]);\n        dx = xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;\n      }\n\n      if (dx < minDist) {\n        minDist = dx;\n        pty = y[k];\n        dy = ya.c2p(pty) - ypx;\n\n        if (yPeriod) {\n          var y0 = ya.c2p(trace._yStarts[k]);\n          var y1 = ya.c2p(trace._yEnds[k]);\n          dy = ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;\n        }\n\n        dxy = Math.sqrt(dx * dx + dy * dy);\n        closestId = ids[i];\n      }\n    }\n  } else {\n    for (i = ids.length - 1; i > -1; i--) {\n      k = ids[i];\n      ptx = x[k];\n      pty = y[k];\n      dx = xa.c2p(ptx) - xpx;\n      dy = ya.c2p(pty) - ypx;\n      dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist < minDist) {\n        minDist = dxy = dist;\n        closestId = k;\n      }\n    }\n  }\n\n  pointData.index = closestId;\n  pointData.distance = minDist;\n  pointData.dxy = dxy;\n  if (closestId === undefined) return [pointData];\n  return [calcHover(pointData, x, y, trace)];\n}\n\nfunction calcHover(pointData, x, y, trace) {\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var minDist = pointData.distance;\n  var dxy = pointData.dxy;\n  var id = pointData.index; // the closest data point\n\n  var di = {\n    pointNumber: id,\n    x: x[id],\n    y: y[id]\n  }; // that is single-item arrays_to_calcdata excerpt, since we are doing it for a single point and we don't have to do it beforehead for 1e6 points\n\n  di.tx = Array.isArray(trace.text) ? trace.text[id] : trace.text;\n  di.htx = Array.isArray(trace.hovertext) ? trace.hovertext[id] : trace.hovertext;\n  di.data = Array.isArray(trace.customdata) ? trace.customdata[id] : trace.customdata;\n  di.tp = Array.isArray(trace.textposition) ? trace.textposition[id] : trace.textposition;\n  var font = trace.textfont;\n\n  if (font) {\n    di.ts = Lib.isArrayOrTypedArray(font.size) ? font.size[id] : font.size;\n    di.tc = Array.isArray(font.color) ? font.color[id] : font.color;\n    di.tf = Array.isArray(font.family) ? font.family[id] : font.family;\n  }\n\n  var marker = trace.marker;\n\n  if (marker) {\n    di.ms = Lib.isArrayOrTypedArray(marker.size) ? marker.size[id] : marker.size;\n    di.mo = Lib.isArrayOrTypedArray(marker.opacity) ? marker.opacity[id] : marker.opacity;\n    di.mx = Lib.isArrayOrTypedArray(marker.symbol) ? marker.symbol[id] : marker.symbol;\n    di.ma = Lib.isArrayOrTypedArray(marker.angle) ? marker.angle[id] : marker.angle;\n    di.mc = Lib.isArrayOrTypedArray(marker.color) ? marker.color[id] : marker.color;\n  }\n\n  var line = marker && marker.line;\n\n  if (line) {\n    di.mlc = Array.isArray(line.color) ? line.color[id] : line.color;\n    di.mlw = Lib.isArrayOrTypedArray(line.width) ? line.width[id] : line.width;\n  }\n\n  var grad = marker && marker.gradient;\n\n  if (grad && grad.type !== 'none') {\n    di.mgt = Array.isArray(grad.type) ? grad.type[id] : grad.type;\n    di.mgc = Array.isArray(grad.color) ? grad.color[id] : grad.color;\n  }\n\n  var xp = xa.c2p(di.x, true);\n  var yp = ya.c2p(di.y, true);\n  var rad = di.mrc || 1;\n  var hoverlabel = trace.hoverlabel;\n\n  if (hoverlabel) {\n    di.hbg = Array.isArray(hoverlabel.bgcolor) ? hoverlabel.bgcolor[id] : hoverlabel.bgcolor;\n    di.hbc = Array.isArray(hoverlabel.bordercolor) ? hoverlabel.bordercolor[id] : hoverlabel.bordercolor;\n    di.hts = Lib.isArrayOrTypedArray(hoverlabel.font.size) ? hoverlabel.font.size[id] : hoverlabel.font.size;\n    di.htc = Array.isArray(hoverlabel.font.color) ? hoverlabel.font.color[id] : hoverlabel.font.color;\n    di.htf = Array.isArray(hoverlabel.font.family) ? hoverlabel.font.family[id] : hoverlabel.font.family;\n    di.hnl = Lib.isArrayOrTypedArray(hoverlabel.namelength) ? hoverlabel.namelength[id] : hoverlabel.namelength;\n  }\n\n  var hoverinfo = trace.hoverinfo;\n\n  if (hoverinfo) {\n    di.hi = Array.isArray(hoverinfo) ? hoverinfo[id] : hoverinfo;\n  }\n\n  var hovertemplate = trace.hovertemplate;\n\n  if (hovertemplate) {\n    di.ht = Array.isArray(hovertemplate) ? hovertemplate[id] : hovertemplate;\n  }\n\n  var fakeCd = {};\n  fakeCd[pointData.index] = di;\n  var origX = trace._origX;\n  var origY = trace._origY;\n  var pointData2 = Lib.extendFlat({}, pointData, {\n    color: getTraceColor(trace, di),\n    x0: xp - rad,\n    x1: xp + rad,\n    xLabelVal: origX ? origX[id] : di.x,\n    y0: yp - rad,\n    y1: yp + rad,\n    yLabelVal: origY ? origY[id] : di.y,\n    cd: fakeCd,\n    distance: minDist,\n    spikeDistance: dxy,\n    hovertemplate: di.ht\n  });\n  if (di.htx) pointData2.text = di.htx;else if (di.tx) pointData2.text = di.tx;else if (trace.text) pointData2.text = trace.text;\n  Lib.fillText(di, trace, pointData2);\n  Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData2);\n  return pointData2;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  calcHover: calcHover\n};","map":null,"metadata":{},"sourceType":"script"}