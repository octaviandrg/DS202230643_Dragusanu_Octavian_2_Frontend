{"ast":null,"code":"'use strict';\n\nvar hovertemplateAttrs = require('../../plots/template_attributes').hovertemplateAttrs;\n\nvar texttemplateAttrs = require('../../plots/template_attributes').texttemplateAttrs;\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterAttrs = require('../scatter/attributes');\n\nvar baseAttrs = require('../../plots/attributes');\n\nvar lineAttrs = scatterAttrs.line;\nmodule.exports = {\n  mode: scatterAttrs.mode,\n  r: {\n    valType: 'data_array',\n    editType: 'calc+clearAxisTypes',\n    description: 'Sets the radial coordinates'\n  },\n  theta: {\n    valType: 'data_array',\n    editType: 'calc+clearAxisTypes',\n    description: 'Sets the angular coordinates'\n  },\n  r0: {\n    valType: 'any',\n    dflt: 0,\n    editType: 'calc+clearAxisTypes',\n    description: ['Alternate to `r`.', 'Builds a linear space of r coordinates.', 'Use with `dr`', 'where `r0` is the starting coordinate and `dr` the step.'].join(' ')\n  },\n  dr: {\n    valType: 'number',\n    dflt: 1,\n    editType: 'calc',\n    description: 'Sets the r coordinate step.'\n  },\n  theta0: {\n    valType: 'any',\n    dflt: 0,\n    editType: 'calc+clearAxisTypes',\n    description: ['Alternate to `theta`.', 'Builds a linear space of theta coordinates.', 'Use with `dtheta`', 'where `theta0` is the starting coordinate and `dtheta` the step.'].join(' ')\n  },\n  dtheta: {\n    valType: 'number',\n    editType: 'calc',\n    description: ['Sets the theta coordinate step.', 'By default, the `dtheta` step equals the subplot\\'s period divided', 'by the length of the `r` coordinates.'].join(' ')\n  },\n  thetaunit: {\n    valType: 'enumerated',\n    values: ['radians', 'degrees', 'gradians'],\n    dflt: 'degrees',\n    editType: 'calc+clearAxisTypes',\n    description: ['Sets the unit of input *theta* values.', 'Has an effect only when on *linear* angular axes.'].join(' ')\n  },\n  text: scatterAttrs.text,\n  texttemplate: texttemplateAttrs({\n    editType: 'plot'\n  }, {\n    keys: ['r', 'theta', 'text']\n  }),\n  hovertext: scatterAttrs.hovertext,\n  line: {\n    color: lineAttrs.color,\n    width: lineAttrs.width,\n    dash: lineAttrs.dash,\n    backoff: lineAttrs.backoff,\n    shape: extendFlat({}, lineAttrs.shape, {\n      values: ['linear', 'spline']\n    }),\n    smoothing: lineAttrs.smoothing,\n    editType: 'calc'\n  },\n  connectgaps: scatterAttrs.connectgaps,\n  marker: scatterAttrs.marker,\n  cliponaxis: extendFlat({}, scatterAttrs.cliponaxis, {\n    dflt: false\n  }),\n  textposition: scatterAttrs.textposition,\n  textfont: scatterAttrs.textfont,\n  fill: extendFlat({}, scatterAttrs.fill, {\n    values: ['none', 'toself', 'tonext'],\n    dflt: 'none',\n    description: ['Sets the area to fill with a solid color.', 'Use with `fillcolor` if not *none*.', 'scatterpolar has a subset of the options available to scatter.', '*toself* connects the endpoints of the trace (or each segment', 'of the trace if it has gaps) into a closed shape.', '*tonext* fills the space between two traces if one completely', 'encloses the other (eg consecutive contour lines), and behaves like', '*toself* if there is no trace before it. *tonext* should not be', 'used if one trace does not enclose the other.'].join(' ')\n  }),\n  fillcolor: scatterAttrs.fillcolor,\n  // TODO error bars\n  // https://stackoverflow.com/a/26597487/4068492\n  // error_x (error_r, error_theta)\n  // error_y\n  hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {\n    flags: ['r', 'theta', 'text', 'name']\n  }),\n  hoveron: scatterAttrs.hoveron,\n  hovertemplate: hovertemplateAttrs(),\n  selected: scatterAttrs.selected,\n  unselected: scatterAttrs.unselected\n};","map":null,"metadata":{},"sourceType":"script"}