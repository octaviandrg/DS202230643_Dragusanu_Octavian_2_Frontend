{"ast":null,"code":"'use strict';\n\nvar boxAttrs = require('../box/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar axisHoverFormat = require('../../plots/cartesian/axis_format_attributes').axisHoverFormat;\n\nmodule.exports = {\n  y: boxAttrs.y,\n  x: boxAttrs.x,\n  x0: boxAttrs.x0,\n  y0: boxAttrs.y0,\n  xhoverformat: axisHoverFormat('x'),\n  yhoverformat: axisHoverFormat('y'),\n  name: extendFlat({}, boxAttrs.name, {\n    description: ['Sets the trace name.', 'The trace name appear as the legend item and on hover.', 'For violin traces, the name will also be used for the position', 'coordinate, if `x` and `x0` (`y` and `y0` if horizontal) are', 'missing and the position axis is categorical.', 'Note that the trace name is also used as a default value', 'for attribute `scalegroup` (please see its description for details).'].join(' ')\n  }),\n  orientation: extendFlat({}, boxAttrs.orientation, {\n    description: ['Sets the orientation of the violin(s).', 'If *v* (*h*), the distribution is visualized along', 'the vertical (horizontal).'].join(' ')\n  }),\n  bandwidth: {\n    valType: 'number',\n    min: 0,\n    editType: 'calc',\n    description: ['Sets the bandwidth used to compute the kernel density estimate.', 'By default, the bandwidth is determined by Silverman\\'s rule of thumb.'].join(' ')\n  },\n  scalegroup: {\n    valType: 'string',\n    dflt: '',\n    editType: 'calc',\n    description: ['If there are multiple violins that should be sized according to', 'to some metric (see `scalemode`), link them by providing a non-empty group id here', 'shared by every trace in the same group.', 'If a violin\\'s `width` is undefined, `scalegroup` will default to the trace\\'s name.', 'In this case, violins with the same names will be linked together'].join(' ')\n  },\n  scalemode: {\n    valType: 'enumerated',\n    values: ['width', 'count'],\n    dflt: 'width',\n    editType: 'calc',\n    description: ['Sets the metric by which the width of each violin is determined.', '*width* means each violin has the same (max) width', '*count* means the violins are scaled by the number of sample points making', 'up each violin.'].join(' ')\n  },\n  spanmode: {\n    valType: 'enumerated',\n    values: ['soft', 'hard', 'manual'],\n    dflt: 'soft',\n    editType: 'calc',\n    description: ['Sets the method by which the span in data space where the density function will be computed.', '*soft* means the span goes from the sample\\'s minimum value minus two bandwidths', 'to the sample\\'s maximum value plus two bandwidths.', '*hard* means the span goes from the sample\\'s minimum to its maximum value.', 'For custom span settings, use mode *manual* and fill in the `span` attribute.'].join(' ')\n  },\n  span: {\n    valType: 'info_array',\n    items: [{\n      valType: 'any',\n      editType: 'calc'\n    }, {\n      valType: 'any',\n      editType: 'calc'\n    }],\n    editType: 'calc',\n    description: ['Sets the span in data space for which the density function will be computed.', 'Has an effect only when `spanmode` is set to *manual*.'].join(' ')\n  },\n  line: {\n    color: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the color of line bounding the violin(s).'\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      dflt: 2,\n      editType: 'style',\n      description: 'Sets the width (in px) of line bounding the violin(s).'\n    },\n    editType: 'plot'\n  },\n  fillcolor: boxAttrs.fillcolor,\n  points: extendFlat({}, boxAttrs.boxpoints, {\n    description: ['If *outliers*, only the sample points lying outside the whiskers', 'are shown', 'If *suspectedoutliers*, the outlier points are shown and', 'points either less than 4*Q1-3*Q3 or greater than 4*Q3-3*Q1', 'are highlighted (see `outliercolor`)', 'If *all*, all sample points are shown', 'If *false*, only the violins are shown with no sample points.', 'Defaults to *suspectedoutliers* when `marker.outliercolor` or', '`marker.line.outliercolor` is set,', 'otherwise defaults to *outliers*.'].join(' ')\n  }),\n  jitter: extendFlat({}, boxAttrs.jitter, {\n    description: ['Sets the amount of jitter in the sample points drawn.', 'If *0*, the sample points align along the distribution axis.', 'If *1*, the sample points are drawn in a random jitter of width', 'equal to the width of the violins.'].join(' ')\n  }),\n  pointpos: extendFlat({}, boxAttrs.pointpos, {\n    description: ['Sets the position of the sample points in relation to the violins.', 'If *0*, the sample points are places over the center of the violins.', 'Positive (negative) values correspond to positions to the', 'right (left) for vertical violins and above (below) for horizontal violins.'].join(' ')\n  }),\n  width: extendFlat({}, boxAttrs.width, {\n    description: ['Sets the width of the violin in data coordinates.', 'If *0* (default value) the width is automatically selected based on the positions', 'of other violin traces in the same subplot.'].join(' ')\n  }),\n  marker: boxAttrs.marker,\n  text: boxAttrs.text,\n  hovertext: boxAttrs.hovertext,\n  hovertemplate: boxAttrs.hovertemplate,\n  quartilemethod: boxAttrs.quartilemethod,\n  box: {\n    visible: {\n      valType: 'boolean',\n      dflt: false,\n      editType: 'plot',\n      description: ['Determines if an miniature box plot is drawn inside the violins. '].join(' ')\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      max: 1,\n      dflt: 0.25,\n      editType: 'plot',\n      description: ['Sets the width of the inner box plots relative to', 'the violins\\' width.', 'For example, with 1, the inner box plots are as wide as the violins.'].join(' ')\n    },\n    fillcolor: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the inner box plot fill color.'\n    },\n    line: {\n      color: {\n        valType: 'color',\n        editType: 'style',\n        description: 'Sets the inner box plot bounding line color.'\n      },\n      width: {\n        valType: 'number',\n        min: 0,\n        editType: 'style',\n        description: 'Sets the inner box plot bounding line width.'\n      },\n      editType: 'style'\n    },\n    editType: 'plot'\n  },\n  meanline: {\n    visible: {\n      valType: 'boolean',\n      dflt: false,\n      editType: 'plot',\n      description: ['Determines if a line corresponding to the sample\\'s mean is shown', 'inside the violins.', 'If `box.visible` is turned on, the mean line is drawn inside the inner box.', 'Otherwise, the mean line is drawn from one side of the violin to other.'].join(' ')\n    },\n    color: {\n      valType: 'color',\n      editType: 'style',\n      description: 'Sets the mean line color.'\n    },\n    width: {\n      valType: 'number',\n      min: 0,\n      editType: 'style',\n      description: 'Sets the mean line width.'\n    },\n    editType: 'plot'\n  },\n  side: {\n    valType: 'enumerated',\n    values: ['both', 'positive', 'negative'],\n    dflt: 'both',\n    editType: 'calc',\n    description: ['Determines on which side of the position value the density function making up', 'one half of a violin is plotted.', 'Useful when comparing two violin traces under *overlay* mode, where one trace', 'has `side` set to *positive* and the other to *negative*.'].join(' ')\n  },\n  offsetgroup: boxAttrs.offsetgroup,\n  alignmentgroup: boxAttrs.alignmentgroup,\n  selected: boxAttrs.selected,\n  unselected: boxAttrs.unselected,\n  hoveron: {\n    valType: 'flaglist',\n    flags: ['violins', 'points', 'kde'],\n    dflt: 'violins+points+kde',\n    extras: ['all'],\n    editType: 'style',\n    description: ['Do the hover effects highlight individual violins', 'or sample points or the kernel density estimate or any combination of them?'].join(' ')\n  }\n};","map":null,"metadata":{},"sourceType":"script"}