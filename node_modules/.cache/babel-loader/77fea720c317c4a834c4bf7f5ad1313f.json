{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar getTraceColor = require('../scatter/get_trace_color');\n\nvar fillText = Lib.fillText;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar LAYER_PREFIX = require('../../plots/mapbox/constants').traceLayerPrefix;\n\nfunction hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var subplot = pointData.subplot;\n  var clusteredPointsIds = [];\n  var layer = LAYER_PREFIX + trace.uid + '-circle';\n  var hasCluster = trace.cluster && trace.cluster.enabled;\n\n  if (hasCluster) {\n    var elems = subplot.map.queryRenderedFeatures(null, {\n      layers: [layer]\n    });\n    clusteredPointsIds = elems.map(function (elem) {\n      return elem.id;\n    });\n  } // compute winding number about [-180, 180] globe\n\n\n  var winding = xval >= 0 ? Math.floor((xval + 180) / 360) : Math.ceil((xval - 180) / 360); // shift longitude to [-180, 180] to determine closest point\n\n  var lonShift = winding * 360;\n  var xval2 = xval - lonShift;\n\n  function distFn(d) {\n    var lonlat = d.lonlat;\n    if (lonlat[0] === BADNUM) return Infinity;\n    if (hasCluster && clusteredPointsIds.indexOf(d.i + 1) === -1) return Infinity;\n    var lon = Lib.modHalf(lonlat[0], 360);\n    var lat = lonlat[1];\n    var pt = subplot.project([lon, lat]);\n    var dx = pt.x - xa.c2p([xval2, lat]);\n    var dy = pt.y - ya.c2p([lon, yval]);\n    var rad = Math.max(3, d.mrc || 0);\n    return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - 3 / rad);\n  }\n\n  Fx.getClosest(cd, distFn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n  if (pointData.index === false) return;\n  var di = cd[pointData.index];\n  var lonlat = di.lonlat;\n  var lonlatShifted = [Lib.modHalf(lonlat[0], 360) + lonShift, lonlat[1]]; // shift labels back to original winded globe\n\n  var xc = xa.c2p(lonlatShifted);\n  var yc = ya.c2p(lonlatShifted);\n  var rad = di.mrc || 1;\n  pointData.x0 = xc - rad;\n  pointData.x1 = xc + rad;\n  pointData.y0 = yc - rad;\n  pointData.y1 = yc + rad;\n  var fullLayout = {};\n  fullLayout[trace.subplot] = {\n    _subplot: subplot\n  };\n\n  var labels = trace._module.formatLabels(di, trace, fullLayout);\n\n  pointData.lonLabel = labels.lonLabel;\n  pointData.latLabel = labels.latLabel;\n  pointData.color = getTraceColor(trace, di);\n  pointData.extraText = getExtraText(trace, di, cd[0].t.labels);\n  pointData.hovertemplate = trace.hovertemplate;\n  return [pointData];\n}\n\nfunction getExtraText(trace, di, labels) {\n  if (trace.hovertemplate) return;\n  var hoverinfo = di.hi || trace.hoverinfo;\n  var parts = hoverinfo.split('+');\n  var isAll = parts.indexOf('all') !== -1;\n  var hasLon = parts.indexOf('lon') !== -1;\n  var hasLat = parts.indexOf('lat') !== -1;\n  var lonlat = di.lonlat;\n  var text = []; // TODO should we use a mock axis to format hover?\n  // If so, we'll need to make precision be zoom-level dependent\n\n  function format(v) {\n    return v + \"\\xB0\";\n  }\n\n  if (isAll || hasLon && hasLat) {\n    text.push('(' + format(lonlat[1]) + ', ' + format(lonlat[0]) + ')');\n  } else if (hasLon) {\n    text.push(labels.lon + format(lonlat[0]));\n  } else if (hasLat) {\n    text.push(labels.lat + format(lonlat[1]));\n  }\n\n  if (isAll || parts.indexOf('text') !== -1) {\n    fillText(di, trace, text);\n  }\n\n  return text.join('<br>');\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  getExtraText: getExtraText\n};","map":null,"metadata":{},"sourceType":"script"}