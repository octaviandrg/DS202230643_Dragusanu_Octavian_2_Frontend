{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strRotate = Lib.strRotate;\nvar strTranslate = Lib.strTranslate;\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar Plots = require('../plots');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar setConvertPolar = require('./set_convert');\n\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\n\nvar dragBox = require('../cartesian/dragbox');\n\nvar dragElement = require('../../components/dragelement');\n\nvar Fx = require('../../components/fx');\n\nvar Titles = require('../../components/titles');\n\nvar prepSelect = require('../../components/selections').prepSelect;\n\nvar selectOnClick = require('../../components/selections').selectOnClick;\n\nvar clearOutline = require('../../components/selections').clearOutline;\n\nvar setCursor = require('../../lib/setcursor');\n\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\n\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\n\nvar constants = require('./constants');\n\nvar helpers = require('./helpers');\n\nvar smithHelpers = require('../smith/helpers');\n\nvar smith = smithHelpers.smith;\nvar reactanceArc = smithHelpers.reactanceArc;\nvar resistanceArc = smithHelpers.resistanceArc;\nvar smithTransform = smithHelpers.smithTransform;\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\nfunction Polar(gd, id, isSmith) {\n  this.isSmith = isSmith || false;\n  this.id = id;\n  this.gd = gd;\n  this._hasClipOnAxisFalse = null;\n  this.vangles = null;\n  this.radialAxisAngle = null;\n  this.traceHash = {};\n  this.layers = {};\n  this.clipPaths = {};\n  this.clipIds = {};\n  this.viewInitial = {};\n  var fullLayout = gd._fullLayout;\n  var clipIdBase = 'clip' + fullLayout._uid + id;\n  this.clipIds.forTraces = clipIdBase + '-for-traces';\n  this.clipPaths.forTraces = fullLayout._clips.append('clipPath').attr('id', this.clipIds.forTraces);\n  this.clipPaths.forTraces.append('path');\n  this.framework = fullLayout['_' + (isSmith ? 'smith' : 'polar') + 'layer'].append('g').attr('class', id);\n\n  this.getHole = function (s) {\n    return this.isSmith ? 0 : s.hole;\n  };\n\n  this.getSector = function (s) {\n    return this.isSmith ? [0, 360] : s.sector;\n  };\n\n  this.getRadial = function (s) {\n    return this.isSmith ? s.realaxis : s.radialaxis;\n  };\n\n  this.getAngular = function (s) {\n    return this.isSmith ? s.imaginaryaxis : s.angularaxis;\n  };\n\n  if (!isSmith) {\n    // unfortunately, we have to keep track of some axis tick settings\n    // as polar subplots do not implement the 'ticks' editType\n    this.radialTickLayout = null;\n    this.angularTickLayout = null;\n  }\n}\n\nvar proto = Polar.prototype;\n\nmodule.exports = function createPolar(gd, id, isSmith) {\n  return new Polar(gd, id, isSmith);\n};\n\nproto.plot = function (polarCalcData, fullLayout) {\n  var _this = this;\n\n  var polarLayout = fullLayout[_this.id];\n  var found = false;\n\n  for (var i = 0; i < polarCalcData.length; i++) {\n    var trace = polarCalcData[i][0].trace;\n\n    if (trace.cliponaxis === false) {\n      found = true;\n      break;\n    }\n  }\n\n  _this._hasClipOnAxisFalse = found;\n\n  _this.updateLayers(fullLayout, polarLayout);\n\n  _this.updateLayout(fullLayout, polarLayout);\n\n  Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n\n  _this.updateFx(fullLayout, polarLayout);\n\n  if (_this.isSmith) {\n    delete polarLayout.realaxis.range;\n    delete polarLayout.imaginaryaxis.range;\n  }\n};\n\nproto.updateLayers = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var layers = _this.layers;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var angularLayout = _this.getAngular(polarLayout);\n\n  var layerNames = constants.layerNames;\n  var frontPlotIndex = layerNames.indexOf('frontplot');\n  var layerData = layerNames.slice(0, frontPlotIndex);\n  var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n  var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n  if (isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (isRadialAxisBelowTraces) layerData.push('radial-axis');\n  layerData.push('frontplot');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-axis');\n  var subLayer = (isSmith ? 'smith' : 'polar') + 'sublayer';\n\n  var join = _this.framework.selectAll('.' + subLayer).data(layerData, String);\n\n  join.enter().append('g').attr('class', function (d) {\n    return subLayer + ' ' + d;\n  }).each(function (d) {\n    var sel = layers[d] = d3.select(this);\n\n    switch (d) {\n      case 'frontplot':\n        // TODO add option to place in 'backplot' layer??\n        if (!isSmith) {\n          sel.append('g').classed('barlayer', true);\n        }\n\n        sel.append('g').classed('scatterlayer', true);\n        break;\n\n      case 'backplot':\n        sel.append('g').classed('maplayer', true);\n        break;\n\n      case 'plotbg':\n        layers.bg = sel.append('path');\n        break;\n\n      case 'radial-grid':\n        sel.style('fill', 'none');\n        break;\n\n      case 'angular-grid':\n        sel.style('fill', 'none');\n        break;\n\n      case 'radial-line':\n        sel.append('line').style('fill', 'none');\n        break;\n\n      case 'angular-line':\n        sel.append('path').style('fill', 'none');\n        break;\n    }\n  });\n  join.order();\n};\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - getRadial(polarLayout) (aka radialLayout in this file):\n * - getAngular(polarLayout) (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends getRadial(polarLayout), adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends getAngular(polarLayout), adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\n\n\nproto.updateLayout = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var layers = _this.layers;\n  var gs = fullLayout._size; // axis attributes\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var angularLayout = _this.getAngular(polarLayout); // layout domains\n\n\n  var xDomain = polarLayout.domain.x;\n  var yDomain = polarLayout.domain.y; // offsets from paper edge to layout domain box\n\n  _this.xOffset = gs.l + gs.w * xDomain[0];\n  _this.yOffset = gs.t + gs.h * (1 - yDomain[1]); // lengths of the layout domain box\n\n  var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n  var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]); // sector to plot\n\n  var sector = _this.getSector(polarLayout);\n\n  _this.sectorInRad = sector.map(deg2rad);\n  var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n  var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n  var dySectorBBox = sectorBBox[3] - sectorBBox[1]; // aspect ratios\n\n  var arDomain = yLength / xLength;\n  var arSector = Math.abs(dySectorBBox / dxSectorBBox); // actual lengths and domains of subplot box\n\n  var xLength2, yLength2;\n  var xDomain2, yDomain2;\n  var gap;\n\n  if (arDomain > arSector) {\n    xLength2 = xLength;\n    yLength2 = xLength * arSector;\n    gap = (yLength - yLength2) / gs.h / 2;\n    xDomain2 = [xDomain[0], xDomain[1]];\n    yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n  } else {\n    xLength2 = yLength / arSector;\n    yLength2 = yLength;\n    gap = (xLength - xLength2) / gs.w / 2;\n    xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n    yDomain2 = [yDomain[0], yDomain[1]];\n  }\n\n  _this.xLength2 = xLength2;\n  _this.yLength2 = yLength2;\n  _this.xDomain2 = xDomain2;\n  _this.yDomain2 = yDomain2; // actual offsets from paper edge to the subplot box top-left corner\n\n  var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n  var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]); // circle radius in px\n\n  var radius = _this.radius = xLength2 / dxSectorBBox; // 'inner' radius in px (when polar.hole is set)\n\n  var innerRadius = _this.innerRadius = _this.getHole(polarLayout) * radius; // circle center position in px\n\n  var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n  var cy = _this.cy = yOffset2 + radius * sectorBBox[3]; // circle center in the coordinate system of plot area\n\n  var cxx = _this.cxx = cx - xOffset2;\n  var cyy = _this.cyy = cy - yOffset2;\n  var side = radialLayout.side;\n  var trueSide;\n\n  if (side === 'counterclockwise') {\n    trueSide = side;\n    side = 'top';\n  } else if (side === 'clockwise') {\n    trueSide = side;\n    side = 'bottom';\n  }\n\n  _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n    // make this an 'x' axis to make positioning (especially rotation) easier\n    _id: 'x',\n    // convert to 'x' axis equivalent\n    side: side,\n    // keep track of real side\n    _trueSide: trueSide,\n    // spans length 1 radius\n    domain: [innerRadius / gs.w, radius / gs.w]\n  });\n  _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n    side: 'right',\n    // to get auto nticks right\n    domain: [0, Math.PI],\n    // don't pass through autorange logic\n    autorange: false\n  });\n\n  _this.doAutoRange(fullLayout, polarLayout); // N.B. this sets _this.vangles\n\n\n  _this.updateAngularAxis(fullLayout, polarLayout); // N.B. this sets _this.radialAxisAngle\n\n\n  _this.updateRadialAxis(fullLayout, polarLayout);\n\n  _this.updateRadialAxisTitle(fullLayout, polarLayout);\n\n  _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'x',\n    domain: xDomain2\n  });\n  _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'y',\n    domain: yDomain2\n  });\n\n  var dPath = _this.pathSubplot();\n\n  _this.clipPaths.forTraces.select('path').attr('d', dPath).attr('transform', strTranslate(cxx, cyy));\n\n  layers.frontplot.attr('transform', strTranslate(xOffset2, yOffset2)).call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n  layers.bg.attr('d', dPath).attr('transform', strTranslate(cx, cy)).call(Color.fill, polarLayout.bgcolor);\n};\n\nproto.mockAxis = function (fullLayout, polarLayout, axLayout, opts) {\n  var ax = Lib.extendFlat({}, axLayout, opts);\n  setConvertPolar(ax, polarLayout, fullLayout);\n  return ax;\n};\n\nproto.mockCartesianAxis = function (fullLayout, polarLayout, opts) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var axId = opts._id;\n  var ax = Lib.extendFlat({\n    type: 'linear'\n  }, opts);\n  setConvertCartesian(ax, fullLayout);\n  var bboxIndices = {\n    x: [0, 2],\n    y: [1, 3]\n  };\n\n  ax.setRange = function () {\n    var sectorBBox = _this.sectorBBox;\n    var ind = bboxIndices[axId];\n    var rl = _this.radialAxis._rl;\n\n    var drl = (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout));\n\n    ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n  };\n\n  ax.isPtWithinRange = axId === 'x' && !isSmith ? function (d) {\n    return _this.isPtInside(d);\n  } : function () {\n    return true;\n  };\n  ax.setRange();\n  ax.setScale();\n  return ax;\n};\n\nproto.doAutoRange = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var radialAxis = _this.radialAxis;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  doAutoRange(gd, radialAxis);\n  var rng = radialAxis.range;\n  radialLayout.range = rng.slice();\n  radialLayout._input.range = rng.slice();\n  radialAxis._rl = [radialAxis.r2l(rng[0], null, 'gregorian'), radialAxis.r2l(rng[1], null, 'gregorian')];\n};\n\nproto.updateRadialAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var a0 = mod(_this.getSector(polarLayout)[0], 360);\n  var ax = _this.radialAxis;\n  var hasRoomForIt = innerRadius < radius;\n  var isSmith = _this.isSmith;\n\n  if (!isSmith) {\n    _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n\n    _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n\n    ax.setGeometry();\n  } // rotate auto tick labels by 180 if in quadrant II and III to make them\n  // readable from left-to-right\n  //\n  // TODO try moving deeper in Axes.drawLabels for better results?\n\n\n  if (ax.tickangle === 'auto' && a0 > 90 && a0 <= 270) {\n    ax.tickangle = 180;\n  } // easier to set rotate angle with custom translate function\n\n\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([d.x, 0]));\n    return strTranslate(t[0] - cx, t[1] - cy);\n  } : function (d) {\n    return strTranslate(ax.l2p(d.x) + innerRadius, 0);\n  }; // set special grid path function\n\n  var gridPathFn = isSmith ? function (d) {\n    return resistanceArc(_this, d.x, -Infinity, Infinity);\n  } : function (d) {\n    return _this.pathArc(ax.r2p(d.x) + innerRadius);\n  };\n  var newTickLayout = strTickLayout(radialLayout);\n\n  if (_this.radialTickLayout !== newTickLayout) {\n    layers['radial-axis'].selectAll('.xtick').remove();\n    _this.radialTickLayout = newTickLayout;\n  }\n\n  if (hasRoomForIt) {\n    ax.setScale();\n    var labelShift = 0;\n    var vals = isSmith ? (ax.tickvals || []).filter(function (x) {\n      // filter negative\n      return x >= 0;\n    }).map(function (x) {\n      return Axes.tickText(ax, x, true, false);\n    }) : Axes.calcTicks(ax);\n    var valsClipped = isSmith ? vals : Axes.clipEnds(ax, vals);\n    var tickSign = Axes.getTickSigns(ax)[2];\n\n    if (isSmith) {\n      if (ax.ticks === 'top' && ax.side === 'bottom' || ax.ticks === 'bottom' && ax.side === 'top') {\n        // invert sign\n        tickSign = -tickSign;\n      }\n\n      if (ax.ticks === 'top' && ax.side === 'top') labelShift = -ax.ticklen;\n      if (ax.ticks === 'bottom' && ax.side === 'bottom') labelShift = ax.ticklen;\n    }\n\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      path: Axes.makeTickPath(ax, 0, tickSign),\n      transFn: transFn,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: valsClipped,\n      layer: layers['radial-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      transFn: transFn,\n      labelFns: Axes.makeLabelFns(ax, labelShift)\n    });\n  } // stash 'actual' radial axis angle for drag handlers (in degrees)\n\n\n  var angle = _this.radialAxisAngle = _this.vangles ? rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) : radialLayout.angle;\n  var tLayer = strTranslate(cx, cy);\n  var tLayer2 = tLayer + strRotate(-angle);\n  updateElement(layers['radial-axis'], hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks), {\n    transform: tLayer2\n  });\n  updateElement(layers['radial-grid'], hasRoomForIt && radialLayout.showgrid, {\n    transform: isSmith ? '' : tLayer\n  });\n  updateElement(layers['radial-line'].select('line'), hasRoomForIt && radialLayout.showline, {\n    x1: isSmith ? -radius : innerRadius,\n    y1: 0,\n    x2: radius,\n    y2: 0,\n    transform: tLayer2\n  }).attr('stroke-width', radialLayout.linewidth).call(Color.stroke, radialLayout.linecolor);\n};\n\nproto.updateRadialAxisTitle = function (fullLayout, polarLayout, _angle) {\n  if (this.isSmith) return;\n\n  var _this = this;\n\n  var gd = _this.gd;\n  var radius = _this.radius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var radialLayout = _this.getRadial(polarLayout);\n\n  var titleClass = _this.id + 'title';\n  var pad = 0; // Hint: no need to check if there is in fact a title.text set\n  // because if plot is editable, pad needs to be calculated anyways\n  // to properly show placeholder text when title is empty.\n\n  if (radialLayout.title) {\n    var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n    var ts = radialLayout.title.font.size;\n    var side = radialLayout.side;\n    pad = side === 'top' ? ts : side === 'counterclockwise' ? -(h + ts * 0.4) : h + ts * 0.8;\n  }\n\n  var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n  var angleRad = deg2rad(angle);\n  var cosa = Math.cos(angleRad);\n  var sina = Math.sin(angleRad);\n  var x = cx + radius / 2 * cosa + pad * sina;\n  var y = cy - radius / 2 * sina + pad * cosa;\n  _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n    propContainer: radialLayout,\n    propName: _this.id + '.radialaxis.title',\n    placeholder: _(gd, 'Click to enter radial axis title'),\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    },\n    transform: {\n      rotate: -angle\n    }\n  });\n};\n\nproto.updateAngularAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n\n  var angularLayout = _this.getAngular(polarLayout);\n\n  var ax = _this.angularAxis;\n  var isSmith = _this.isSmith;\n\n  if (!isSmith) {\n    _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n\n    ax.setGeometry();\n    ax.setScale();\n  } // 't'ick to 'g'eometric radians is used all over the place here\n\n\n  var t2g = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n  } : function (d) {\n    return ax.t2g(d.x);\n  }; // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n\n  if (ax.type === 'linear' && ax.thetaunit === 'radians') {\n    ax.tick0 = rad2deg(ax.tick0);\n    ax.dtick = rad2deg(ax.dtick);\n  }\n\n  var _transFn = function _transFn(rad) {\n    return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n  };\n\n  var transFn = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    return strTranslate(t[0], t[1]);\n  } : function (d) {\n    return _transFn(t2g(d));\n  };\n  var transFn2 = isSmith ? function (d) {\n    var t = smithTransform(_this, smith([0, d.x]));\n    var rad = Math.atan2(t[0] - cx, t[1] - cy) - Math.PI / 2;\n    return strTranslate(t[0], t[1]) + strRotate(-rad2deg(rad));\n  } : function (d) {\n    var rad = t2g(d);\n    return _transFn(rad) + strRotate(-rad2deg(rad));\n  };\n  var gridPathFn = isSmith ? function (d) {\n    return reactanceArc(_this, d.x, 0, Infinity);\n  } : function (d) {\n    var rad = t2g(d);\n    var cosRad = Math.cos(rad);\n    var sinRad = Math.sin(rad);\n    return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] + 'L' + [cx + radius * cosRad, cy - radius * sinRad];\n  };\n  var out = Axes.makeLabelFns(ax, 0);\n  var labelStandoff = out.labelStandoff;\n  var labelFns = {};\n\n  labelFns.xFn = function (d) {\n    var rad = t2g(d);\n    return Math.cos(rad) * labelStandoff;\n  };\n\n  labelFns.yFn = function (d) {\n    var rad = t2g(d);\n    var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n    return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) + Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n  };\n\n  labelFns.anchorFn = function (d) {\n    var rad = t2g(d);\n    var cos = Math.cos(rad);\n    return Math.abs(cos) < 0.1 ? 'middle' : cos > 0 ? 'start' : 'end';\n  };\n\n  labelFns.heightFn = function (d, a, h) {\n    var rad = t2g(d);\n    return -0.5 * (1 + Math.sin(rad)) * h;\n  };\n\n  var newTickLayout = strTickLayout(angularLayout);\n\n  if (_this.angularTickLayout !== newTickLayout) {\n    layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n    _this.angularTickLayout = newTickLayout;\n  }\n\n  var vals = isSmith ? [Infinity].concat(ax.tickvals || []).map(function (x) {\n    return Axes.tickText(ax, x, true, false);\n  }) : Axes.calcTicks(ax);\n\n  if (isSmith) {\n    vals[0].text = '∞';\n    vals[0].fontSize *= 1.75;\n  } // angle of polygon vertices in geometric radians (null means circles)\n  // TODO what to do when ax.period > ax._categories ??\n\n\n  var vangles;\n\n  if (polarLayout.gridshape === 'linear') {\n    vangles = vals.map(t2g); // ax._vals should be always ordered, make them\n    // always turn counterclockwise for convenience here\n\n    if (Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n      vangles = vangles.slice().reverse();\n    }\n  } else {\n    vangles = null;\n  }\n\n  _this.vangles = vangles; // Use tickval filter for category axes instead of tweaking\n  // the range w.r.t sector, so that sectors that cross 360 can\n  // show all their ticks.\n\n  if (ax.type === 'category') {\n    vals = vals.filter(function (d) {\n      return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n    });\n  }\n\n  if (ax.visible) {\n    var tickSign = ax.ticks === 'inside' ? -1 : 1;\n    var pad = (ax.linewidth || 1) / 2;\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      path: 'M' + tickSign * pad + ',0h' + tickSign * ax.ticklen,\n      transFn: transFn2,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: vals,\n      layer: layers['angular-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      repositionOnUpdate: true,\n      transFn: transFn,\n      labelFns: labelFns\n    });\n  } // TODO maybe two arcs is better here?\n  // maybe split style attributes between inner and outer angular axes?\n\n\n  updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n    d: _this.pathSubplot(),\n    transform: strTranslate(cx, cy)\n  }).attr('stroke-width', angularLayout.linewidth).call(Color.stroke, angularLayout.linecolor);\n};\n\nproto.updateFx = function (fullLayout, polarLayout) {\n  if (!this.gd._context.staticPlot) {\n    var hasDrag = !this.isSmith;\n\n    if (hasDrag) {\n      this.updateAngularDrag(fullLayout);\n      this.updateRadialDrag(fullLayout, polarLayout, 0);\n      this.updateRadialDrag(fullLayout, polarLayout, 1);\n    }\n\n    this.updateHoverAndMainDrag(fullLayout);\n  }\n};\n\nproto.updateHoverAndMainDrag = function (fullLayout) {\n  var _this = this;\n\n  var isSmith = _this.isSmith;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var zoomlayer = fullLayout._zoomlayer;\n  var MINZOOM = constants.MINZOOM;\n  var OFFEDGE = constants.OFFEDGE;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var sectorInRad = _this.sectorInRad;\n  var vangles = _this.vangles;\n  var radialAxis = _this.radialAxis;\n  var clampTiny = helpers.clampTiny;\n  var findXYatLength = helpers.findXYatLength;\n  var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n  var chw = constants.cornerHalfWidth;\n  var chl = constants.cornerLen / 2;\n  var scaleX;\n  var scaleY;\n  var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', fullLayout.dragmode === false ? 'none' : 'crosshair');\n  d3.select(mainDrag).attr('d', _this.pathSubplot()).attr('transform', strTranslate(cx, cy));\n\n  mainDrag.onmousemove = function (evt) {\n    Fx.hover(gd, evt, _this.id);\n    gd._fullLayout._lasthover = mainDrag;\n    gd._fullLayout._hoversubplot = _this.id;\n  };\n\n  mainDrag.onmouseout = function (evt) {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, evt);\n  };\n\n  var dragOpts = {\n    element: mainDrag,\n    gd: gd,\n    subplot: _this.id,\n    plotinfo: {\n      id: _this.id,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis\n    },\n    xaxes: [_this.xaxis],\n    yaxes: [_this.yaxis]\n  }; // mouse px position at drag start (0), move (1)\n\n  var x0, y0; // radial distance from circle center at drag start (0), move (1)\n\n  var r0, r1; // zoombox persistent quantities\n\n  var path0, dimmed, lum; // zoombox, corners elements\n\n  var zb, corners;\n\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n\n  function xy2r(x, y) {\n    return norm(x - cxx, y - cyy);\n  }\n\n  function xy2a(x, y) {\n    return Math.atan2(cyy - y, x - cxx);\n  }\n\n  function ra2xy(r, a) {\n    return [r * Math.cos(a), r * Math.sin(-a)];\n  }\n\n  function pathCorner(r, a) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var da = chl / r;\n    var am = a - da;\n    var ap = a + da;\n    var rb = Math.max(0, Math.min(r, radius));\n    var rm = rb - chw;\n    var rp = rb + chw;\n    return 'M' + ra2xy(rm, am) + 'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) + 'L' + ra2xy(rp, ap) + 'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) + 'Z';\n  } // (x,y) is the pt at middle of the va0 <-> va1 edge\n  //\n  // ... we could eventually add another mode for cursor\n  // angles 'close to' enough to a particular vertex.\n\n\n  function pathCornerForPolygons(r, va0, va1) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var xy0 = ra2xy(r, va0);\n    var xy1 = ra2xy(r, va1);\n    var x = clampTiny((xy0[0] + xy1[0]) / 2);\n    var y = clampTiny((xy0[1] + xy1[1]) / 2);\n    var innerPts, outerPts;\n\n    if (x && y) {\n      var m = y / x;\n      var mperp = -1 / m;\n      var midPts = findXYatLength(chw, m, x, y);\n      innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n      outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n    } else {\n      var dx, dy;\n\n      if (y) {\n        // horizontal handles\n        dx = chl;\n        dy = chw;\n      } else {\n        // vertical handles\n        dx = chw;\n        dy = chl;\n      }\n\n      innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n      outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n    }\n\n    return 'M' + innerPts.join('L') + 'L' + outerPts.reverse().join('L') + 'Z';\n  }\n\n  function zoomPrep() {\n    r0 = null;\n    r1 = null;\n    path0 = _this.pathSubplot();\n    dimmed = false;\n    var polarLayoutNow = gd._fullLayout[_this.id];\n    lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n    zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n    zb.attr('fill-rule', 'evenodd');\n    corners = dragBox.makeCorners(zoomlayer, cx, cy);\n    clearOutline(gd);\n  } // N.B. this sets scoped 'r0' and 'r1'\n  // return true if 'valid' zoom distance, false otherwise\n\n\n  function clampAndSetR0R1(rr0, rr1) {\n    rr1 = Math.max(Math.min(rr1, radius), innerRadius); // starting or ending drag near center (outer edge),\n    // clamps radial distance at origin (at r=radius)\n\n    if (rr0 < OFFEDGE) rr0 = 0;else if (radius - rr0 < OFFEDGE) rr0 = radius;else if (rr1 < OFFEDGE) rr1 = 0;else if (radius - rr1 < OFFEDGE) rr1 = radius; // make sure r0 < r1,\n    // to get correct fill pattern in path1 below\n\n    if (Math.abs(rr1 - rr0) > MINZOOM) {\n      if (rr0 < rr1) {\n        r0 = rr0;\n        r1 = rr1;\n      } else {\n        r0 = rr1;\n        r1 = rr0;\n      }\n\n      return true;\n    } else {\n      r0 = null;\n      r1 = null;\n      return false;\n    }\n  }\n\n  function applyZoomMove(path1, cpath) {\n    path1 = path1 || path0;\n    cpath = cpath || 'M0,0Z';\n    zb.attr('d', path1);\n    corners.attr('d', cpath);\n    dragBox.transitionZoombox(zb, corners, dimmed, lum);\n    dimmed = true;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    gd.emit('plotly_relayouting', updateObj);\n  }\n\n  function zoomMove(dx, dy) {\n    dx = dx * scaleX;\n    dy = dy * scaleY;\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var rr0 = xy2r(x0, y0);\n    var rr1 = Math.min(xy2r(x1, y1), radius);\n    var a0 = xy2a(x0, y0);\n    var path1;\n    var cpath;\n\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0); // keep 'starting' angle\n\n      cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n    }\n\n    applyZoomMove(path1, cpath);\n  }\n\n  function findPolygonRadius(x, y, va0, va1) {\n    var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n    return norm(xy[0], xy[1]);\n  }\n\n  function zoomMoveForPolygons(dx, dy) {\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var a0 = xy2a(x0, y0);\n    var a1 = xy2a(x1, y1);\n    var vangles0 = findEnclosingVertexAngles(a0, vangles);\n    var vangles1 = findEnclosingVertexAngles(a1, vangles);\n    var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n    var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n    var path1;\n    var cpath;\n\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0); // keep 'starting' angle here too\n\n      cpath = [pathCornerForPolygons(r0, vangles0[0], vangles0[1]), pathCornerForPolygons(r1, vangles0[0], vangles0[1])].join(' ');\n    }\n\n    applyZoomMove(path1, cpath);\n  }\n\n  function zoomDone() {\n    dragBox.removeZoombox(gd);\n    if (r0 === null || r1 === null) return;\n    var updateObj = {};\n    computeZoomUpdates(updateObj);\n    dragBox.showDoubleClickNotifier(gd);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n\n  function computeZoomUpdates(update) {\n    var rl = radialAxis._rl;\n    var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n    var newRng = [rl[0] + (r0 - innerRadius) * m, rl[0] + (r1 - innerRadius) * m];\n    update[_this.id + '.radialaxis.range'] = newRng;\n  }\n\n  function zoomClick(numClicks, evt) {\n    var clickMode = gd._fullLayout.clickmode;\n    dragBox.removeZoombox(gd); // TODO double once vs twice logic (autorange vs fixed range)\n\n    if (numClicks === 2) {\n      var updateObj = {};\n\n      for (var k in _this.viewInitial) {\n        updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n      }\n\n      gd.emit('plotly_doubleclick', null);\n      Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    if (clickMode.indexOf('select') > -1 && numClicks === 1) {\n      selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n    }\n\n    if (clickMode.indexOf('event') > -1) {\n      Fx.click(gd, evt, _this.id);\n    }\n  }\n\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var dragModeNow = gd._fullLayout.dragmode;\n    var bbox = mainDrag.getBoundingClientRect();\n\n    gd._fullLayout._calcInverseTransform(gd);\n\n    var inverse = gd._fullLayout._invTransform;\n    scaleX = gd._fullLayout._invScaleX;\n    scaleY = gd._fullLayout._invScaleY;\n    var transformedCoords = Lib.apply3DTransform(inverse)(startX - bbox.left, startY - bbox.top);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1]; // need to offset x/y as bbox center does not\n    // match origin for asymmetric polygons\n\n    if (vangles) {\n      var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n      x0 += cxx + offset[0];\n      y0 += cyy + offset[1];\n    }\n\n    switch (dragModeNow) {\n      case 'zoom':\n        dragOpts.clickFn = zoomClick;\n\n        if (!isSmith) {\n          if (vangles) {\n            dragOpts.moveFn = zoomMoveForPolygons;\n          } else {\n            dragOpts.moveFn = zoomMove;\n          }\n\n          dragOpts.doneFn = zoomDone;\n          zoomPrep(evt, startX, startY);\n        }\n\n        break;\n\n      case 'select':\n      case 'lasso':\n        prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n        break;\n    }\n  };\n\n  dragElement.init(dragOpts);\n};\n\nproto.updateRadialDrag = function (fullLayout, polarLayout, rngIndex) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialAxis = _this.radialAxis;\n  var bl = constants.radialDragBoxSize;\n  var bl2 = bl / 2;\n  if (!radialAxis.visible) return;\n  var angle0 = deg2rad(_this.radialAxisAngle);\n  var rl = radialAxis._rl;\n  var rl0 = rl[0];\n  var rl1 = rl[1];\n  var rbase = rl[rngIndex];\n  var m = 0.75 * (rl[1] - rl[0]) / (1 - _this.getHole(polarLayout)) / radius;\n  var tx, ty, className;\n\n  if (rngIndex) {\n    tx = cx + (radius + bl2) * Math.cos(angle0);\n    ty = cy - (radius + bl2) * Math.sin(angle0);\n    className = 'radialdrag';\n  } else {\n    // the 'inner' box can get called:\n    // - when polar.hole>0\n    // - when polar.sector isn't a full circle\n    // otherwise it is hidden behind the main drag.\n    tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n    ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n    className = 'radialdrag-inner';\n  }\n\n  var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n  var dragOpts = {\n    element: radialDrag,\n    gd: gd\n  };\n\n  if (fullLayout.dragmode === false) {\n    dragOpts.dragmode = false;\n  }\n\n  updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n    transform: strTranslate(tx, ty)\n  }); // move function (either rotate or re-range flavor)\n\n  var moveFn2; // rotate angle on done\n\n  var angle1; // re-range range[1] (or range[0]) on done\n\n  var rprime;\n\n  function moveFn(dx, dy) {\n    if (moveFn2) {\n      moveFn2(dx, dy);\n    } else {\n      var dvec = [dx, -dy];\n      var rvec = [Math.cos(angle0), Math.sin(angle0)];\n      var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec))); // mostly perpendicular motions rotate,\n      // mostly parallel motions re-range\n\n      if (!isNaN(comp)) {\n        moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n      }\n    }\n\n    var update = {};\n    computeRadialAxisUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n\n  function computeRadialAxisUpdates(update) {\n    if (angle1 !== null) {\n      update[_this.id + '.radialaxis.angle'] = angle1;\n    } else if (rprime !== null) {\n      update[_this.id + '.radialaxis.range[' + rngIndex + ']'] = rprime;\n    }\n  }\n\n  function doneFn() {\n    if (angle1 !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n    } else if (rprime !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n    }\n  }\n\n  function rotateMove(dx, dy) {\n    // disable for inner drag boxes\n    if (rngIndex === 0) return;\n    var x1 = tx + dx;\n    var y1 = ty + dy;\n    angle1 = Math.atan2(cy - y1, x1 - cx);\n    if (_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n    angle1 = rad2deg(angle1);\n    var transform = strTranslate(cx, cy) + strRotate(-angle1);\n    layers['radial-axis'].attr('transform', transform);\n    layers['radial-line'].select('line').attr('transform', transform);\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n\n    _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n  }\n\n  function rerangeMove(dx, dy) {\n    // project (dx, dy) unto unit radial axis vector\n    var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n    rprime = rbase - m * dr; // make sure rprime does not change the range[0] -> range[1] sign\n\n    if (m > 0 !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n      rprime = null;\n      return;\n    }\n\n    var fullLayoutNow = gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id]; // update radial range -> update c2g -> update _m,_b\n\n    radialAxis.range[rngIndex] = rprime;\n    radialAxis._rl[rngIndex] = rprime;\n\n    _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n\n    _this.xaxis.setRange();\n\n    _this.xaxis.setScale();\n\n    _this.yaxis.setRange();\n\n    _this.yaxis.setScale();\n\n    var hasRegl = false;\n\n    for (var traceType in _this.traceHash) {\n      var moduleCalcData = _this.traceHash[traceType];\n      var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n      var _module = moduleCalcData[0][0].trace._module;\n\n      _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n\n      if (Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n    }\n\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n  }\n\n  dragOpts.prepFn = function () {\n    moveFn2 = null;\n    angle1 = null;\n    rprime = null;\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearOutline(gd);\n  };\n\n  dragOpts.clampFn = function (dx, dy) {\n    if (Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n      dx = 0;\n      dy = 0;\n    }\n\n    return [dx, dy];\n  };\n\n  dragElement.init(dragOpts);\n};\n\nproto.updateAngularDrag = function (fullLayout) {\n  var _this = this;\n\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var angularAxis = _this.angularAxis;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var dbs = constants.angularDragBoxSize;\n  var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', fullLayout.dragmode === false ? 'none' : 'move');\n  var dragOpts = {\n    element: angularDrag,\n    gd: gd\n  };\n\n  if (fullLayout.dragmode === false) {\n    dragOpts.dragmode = false;\n  } else {\n    d3.select(angularDrag).attr('d', _this.pathAnnulus(radius, radius + dbs)).attr('transform', strTranslate(cx, cy)).call(setCursor, 'move');\n  }\n\n  function xy2a(x, y) {\n    return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n  } // scatter trace, points and textpoints selections\n\n\n  var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n  var scatterPoints = scatterTraces.selectAll('.point');\n  var scatterTextPoints = scatterTraces.selectAll('.textpoint'); // mouse px position at drag start (0), move (1)\n\n  var x0, y0; // angular axis angle rotation at drag start (0), move (1)\n\n  var rot0, rot1; // induced radial axis rotation (only used on polygon grids)\n\n  var rrot1; // angle about circle center at drag start\n\n  var a0;\n\n  function moveFn(dx, dy) {\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    var x1 = x0 + dx * fullLayout._invScaleX;\n    var y1 = y0 + dy * fullLayout._invScaleY;\n    var a1 = xy2a(x1, y1);\n    var da = rad2deg(a1 - a0);\n    rot1 = rot0 + da;\n    layers.frontplot.attr('transform', strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy]));\n\n    if (_this.vangles) {\n      rrot1 = _this.radialAxisAngle + da;\n      var trans = strTranslate(cx, cy) + strRotate(-da);\n      var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n      layers.bg.attr('transform', trans);\n      layers['radial-grid'].attr('transform', trans);\n      layers['radial-axis'].attr('transform', trans2);\n      layers['radial-line'].select('line').attr('transform', trans2);\n\n      _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n    } else {\n      _this.clipPaths.forTraces.select('path').attr('transform', strTranslate(cxx, cyy) + strRotate(da));\n    } // 'un-rotate' marker and text points\n\n\n    scatterPoints.each(function () {\n      var sel = d3.select(this);\n      var xy = Drawing.getTranslate(sel);\n      sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n    });\n    scatterTextPoints.each(function () {\n      var sel = d3.select(this);\n      var tx = sel.select('text');\n      var xy = Drawing.getTranslate(sel); // N.B rotate -> translate ordering matters\n\n      sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n    }); // update rotation -> range -> _m,_b\n\n    angularAxis.rotation = Lib.modHalf(rot1, 360);\n\n    _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n\n    if (_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n      scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n    }\n\n    var hasRegl = false;\n\n    for (var traceType in _this.traceHash) {\n      if (Registry.traceIs(traceType, 'gl')) {\n        var moduleCalcData = _this.traceHash[traceType];\n        var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n        var _module = moduleCalcData[0][0].trace._module;\n\n        _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n\n        if (moduleCalcDataVisible.length) hasRegl = true;\n      }\n    }\n\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n\n    var update = {};\n    computeRotationUpdates(update);\n    gd.emit('plotly_relayouting', update);\n  }\n\n  function computeRotationUpdates(updateObj) {\n    updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n\n    if (_this.vangles) {\n      updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n    }\n  }\n\n  function doneFn() {\n    scatterTextPoints.select('text').attr('transform', null);\n    var updateObj = {};\n    computeRotationUpdates(updateObj);\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var polarLayoutNow = fullLayout[_this.id];\n    rot0 = polarLayoutNow.angularaxis.rotation;\n    var bbox = angularDrag.getBoundingClientRect();\n    x0 = startX - bbox.left;\n    y0 = startY - bbox.top;\n\n    gd._fullLayout._calcInverseTransform(gd);\n\n    var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);\n    x0 = transformedCoords[0];\n    y0 = transformedCoords[1];\n    a0 = xy2a(x0, y0);\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearOutline(gd);\n  }; // I don't what we should do in this case, skip we now\n\n\n  if (_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n    dragOpts.prepFn = Lib.noop;\n    setCursor(d3.select(angularDrag), null);\n  }\n\n  dragElement.init(dragOpts);\n};\n\nproto.isPtInside = function (d) {\n  if (this.isSmith) return true;\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var thetag = this.angularAxis.c2g(d.theta);\n  var radialAxis = this.radialAxis;\n  var r = radialAxis.c2l(d.r);\n  var rl = radialAxis._rl;\n  var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n  return fn(r, thetag, rl, sectorInRad, vangles);\n};\n\nproto.pathArc = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSector = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathAnnulus = function (r0, r1) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n  return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSubplot = function () {\n  var r0 = this.innerRadius;\n  var r1 = this.radius;\n  return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\n\nproto.fillViewInitialKey = function (key, val) {\n  if (!(key in this.viewInitial)) {\n    this.viewInitial[key] = val;\n  }\n};\n\nfunction strTickLayout(axLayout) {\n  var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n  if ('side' in axLayout) out += axLayout.side;\n  return out;\n} // Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\n\n\nfunction computeSectorBBox(sector) {\n  var s0 = sector[0];\n  var s1 = sector[1];\n  var arc = s1 - s0;\n  var a0 = mod(s0, 360);\n  var a1 = a0 + arc;\n  var ax0 = Math.cos(deg2rad(a0));\n  var ay0 = Math.sin(deg2rad(a0));\n  var ax1 = Math.cos(deg2rad(a1));\n  var ay1 = Math.sin(deg2rad(a1));\n  var x0, y0, x1, y1;\n\n  if (a0 <= 90 && a1 >= 90 || a0 > 90 && a1 >= 450) {\n    y1 = 1;\n  } else if (ay0 <= 0 && ay1 <= 0) {\n    y1 = 0;\n  } else {\n    y1 = Math.max(ay0, ay1);\n  }\n\n  if (a0 <= 180 && a1 >= 180 || a0 > 180 && a1 >= 540) {\n    x0 = -1;\n  } else if (ax0 >= 0 && ax1 >= 0) {\n    x0 = 0;\n  } else {\n    x0 = Math.min(ax0, ax1);\n  }\n\n  if (a0 <= 270 && a1 >= 270 || a0 > 270 && a1 >= 630) {\n    y0 = -1;\n  } else if (ay0 >= 0 && ay1 >= 0) {\n    y0 = 0;\n  } else {\n    y0 = Math.min(ay0, ay1);\n  }\n\n  if (a1 >= 360) {\n    x1 = 1;\n  } else if (ax0 <= 0 && ax1 <= 0) {\n    x1 = 0;\n  } else {\n    x1 = Math.max(ax0, ax1);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction snapToVertexAngle(a, vangles) {\n  var fn = function fn(v) {\n    return Lib.angleDist(a, v);\n  };\n\n  var ind = Lib.findIndexOfMin(vangles, fn);\n  return vangles[ind];\n}\n\nfunction updateElement(sel, showAttr, attrs) {\n  if (showAttr) {\n    sel.attr('display', null);\n    sel.attr(attrs);\n  } else if (sel) {\n    sel.attr('display', 'none');\n  }\n\n  return sel;\n}","map":null,"metadata":{},"sourceType":"script"}