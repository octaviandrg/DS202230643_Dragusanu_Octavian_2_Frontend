{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nmodule.exports = function calcGridlines(trace, axisLetter, crossAxisLetter) {\n  var i, j, j0;\n  var eps, bounds, n1, n2, n, value, v;\n  var j1, v0, v1, d;\n  var data = trace['_' + axisLetter];\n  var axis = trace[axisLetter + 'axis'];\n  var gridlines = axis._gridlines = [];\n  var minorgridlines = axis._minorgridlines = [];\n  var boundarylines = axis._boundarylines = [];\n  var crossData = trace['_' + crossAxisLetter];\n  var crossAxis = trace[crossAxisLetter + 'axis'];\n\n  if (axis.tickmode === 'array') {\n    axis.tickvals = data.slice();\n  }\n\n  var xcp = trace._xctrl;\n  var ycp = trace._yctrl;\n  var nea = xcp[0].length;\n  var neb = xcp.length;\n  var na = trace._a.length;\n  var nb = trace._b.length;\n  Axes.prepTicks(axis); // don't leave tickvals in axis looking like an attribute\n\n  if (axis.tickmode === 'array') delete axis.tickvals; // The default is an empty array that will cause the join to remove the gridline if\n  // it's just disappeared:\n  // axis._startline = axis._endline = [];\n  // If the cross axis uses bicubic interpolation, then the grid\n  // lines fall once every three expanded grid row/cols:\n\n  var stride = axis.smoothing ? 3 : 1;\n\n  function constructValueGridline(value) {\n    var i, j, j0, tj, pxy, i0, ti, xy, dxydi0, dxydi1, dxydj0, dxydj1;\n    var xpoints = [];\n    var ypoints = [];\n    var ret = {}; // Search for the fractional grid index giving this line:\n\n    if (axisLetter === 'b') {\n      // For the position we use just the i-j coordinates:\n      j = trace.b2j(value); // The derivatives for catmull-rom splines are discontinuous across cell\n      // boundaries though, so we need to provide both the cell and the position\n      // within the cell separately:\n\n      j0 = Math.floor(Math.max(0, Math.min(nb - 2, j)));\n      tj = j - j0;\n      ret.length = nb;\n      ret.crossLength = na;\n\n      ret.xy = function (i) {\n        return trace.evalxy([], i, j);\n      };\n\n      ret.dxy = function (i0, ti) {\n        return trace.dxydi([], i0, j0, ti, tj);\n      };\n\n      for (i = 0; i < na; i++) {\n        i0 = Math.min(na - 2, i);\n        ti = i - i0;\n        xy = trace.evalxy([], i, j);\n\n        if (crossAxis.smoothing && i > 0) {\n          // First control point:\n          dxydi0 = trace.dxydi([], i - 1, j0, 0, tj);\n          xpoints.push(pxy[0] + dxydi0[0] / 3);\n          ypoints.push(pxy[1] + dxydi0[1] / 3); // Second control point:\n\n          dxydi1 = trace.dxydi([], i - 1, j0, 1, tj);\n          xpoints.push(xy[0] - dxydi1[0] / 3);\n          ypoints.push(xy[1] - dxydi1[1] / 3);\n        }\n\n        xpoints.push(xy[0]);\n        ypoints.push(xy[1]);\n        pxy = xy;\n      }\n    } else {\n      i = trace.a2i(value);\n      i0 = Math.floor(Math.max(0, Math.min(na - 2, i)));\n      ti = i - i0;\n      ret.length = na;\n      ret.crossLength = nb;\n\n      ret.xy = function (j) {\n        return trace.evalxy([], i, j);\n      };\n\n      ret.dxy = function (j0, tj) {\n        return trace.dxydj([], i0, j0, ti, tj);\n      };\n\n      for (j = 0; j < nb; j++) {\n        j0 = Math.min(nb - 2, j);\n        tj = j - j0;\n        xy = trace.evalxy([], i, j);\n\n        if (crossAxis.smoothing && j > 0) {\n          // First control point:\n          dxydj0 = trace.dxydj([], i0, j - 1, ti, 0);\n          xpoints.push(pxy[0] + dxydj0[0] / 3);\n          ypoints.push(pxy[1] + dxydj0[1] / 3); // Second control point:\n\n          dxydj1 = trace.dxydj([], i0, j - 1, ti, 1);\n          xpoints.push(xy[0] - dxydj1[0] / 3);\n          ypoints.push(xy[1] - dxydj1[1] / 3);\n        }\n\n        xpoints.push(xy[0]);\n        ypoints.push(xy[1]);\n        pxy = xy;\n      }\n    }\n\n    ret.axisLetter = axisLetter;\n    ret.axis = axis;\n    ret.crossAxis = crossAxis;\n    ret.value = value;\n    ret.constvar = crossAxisLetter;\n    ret.index = n;\n    ret.x = xpoints;\n    ret.y = ypoints;\n    ret.smoothing = crossAxis.smoothing;\n    return ret;\n  }\n\n  function constructArrayGridline(idx) {\n    var j, i0, j0, ti, tj;\n    var xpoints = [];\n    var ypoints = [];\n    var ret = {};\n    ret.length = data.length;\n    ret.crossLength = crossData.length;\n\n    if (axisLetter === 'b') {\n      j0 = Math.max(0, Math.min(nb - 2, idx));\n      tj = Math.min(1, Math.max(0, idx - j0));\n\n      ret.xy = function (i) {\n        return trace.evalxy([], i, idx);\n      };\n\n      ret.dxy = function (i0, ti) {\n        return trace.dxydi([], i0, j0, ti, tj);\n      }; // In the tickmode: array case, this operation is a simple\n      // transfer of data:\n\n\n      for (j = 0; j < nea; j++) {\n        xpoints[j] = xcp[idx * stride][j];\n        ypoints[j] = ycp[idx * stride][j];\n      }\n    } else {\n      i0 = Math.max(0, Math.min(na - 2, idx));\n      ti = Math.min(1, Math.max(0, idx - i0));\n\n      ret.xy = function (j) {\n        return trace.evalxy([], idx, j);\n      };\n\n      ret.dxy = function (j0, tj) {\n        return trace.dxydj([], i0, j0, ti, tj);\n      }; // In the tickmode: array case, this operation is a simple\n      // transfer of data:\n\n\n      for (j = 0; j < neb; j++) {\n        xpoints[j] = xcp[j][idx * stride];\n        ypoints[j] = ycp[j][idx * stride];\n      }\n    }\n\n    ret.axisLetter = axisLetter;\n    ret.axis = axis;\n    ret.crossAxis = crossAxis;\n    ret.value = data[idx];\n    ret.constvar = crossAxisLetter;\n    ret.index = idx;\n    ret.x = xpoints;\n    ret.y = ypoints;\n    ret.smoothing = crossAxis.smoothing;\n    return ret;\n  }\n\n  if (axis.tickmode === 'array') {\n    // var j0 = axis.startline ? 1 : 0;\n    // var j1 = data.length - (axis.endline ? 1 : 0);\n    eps = 5e-15;\n    bounds = [Math.floor((data.length - 1 - axis.arraytick0) / axis.arraydtick * (1 + eps)), Math.ceil(-axis.arraytick0 / axis.arraydtick / (1 + eps))].sort(function (a, b) {\n      return a - b;\n    }); // Unpack sorted values so we can be sure to avoid infinite loops if something\n    // is backwards:\n\n    n1 = bounds[0] - 1;\n    n2 = bounds[1] + 1; // If the axes fall along array lines, then this is a much simpler process since\n    // we already have all the control points we need\n\n    for (n = n1; n < n2; n++) {\n      j = axis.arraytick0 + axis.arraydtick * n;\n      if (j < 0 || j > data.length - 1) continue;\n      gridlines.push(extendFlat(constructArrayGridline(j), {\n        color: axis.gridcolor,\n        width: axis.gridwidth,\n        dash: axis.griddash\n      }));\n    }\n\n    for (n = n1; n < n2; n++) {\n      j0 = axis.arraytick0 + axis.arraydtick * n;\n      j1 = Math.min(j0 + axis.arraydtick, data.length - 1); // TODO: fix the bounds computation so we don't have to do a large range and then throw\n      // out unneeded numbers\n\n      if (j0 < 0 || j0 > data.length - 1) continue;\n      if (j1 < 0 || j1 > data.length - 1) continue;\n      v0 = data[j0];\n      v1 = data[j1];\n\n      for (i = 0; i < axis.minorgridcount; i++) {\n        d = j1 - j0; // TODO: fix the bounds computation so we don't have to do a large range and then throw\n        // out unneeded numbers\n\n        if (d <= 0) continue; // XXX: This calculation isn't quite right. Off by one somewhere?\n\n        v = v0 + (v1 - v0) * (i + 1) / (axis.minorgridcount + 1) * (axis.arraydtick / d); // TODO: fix the bounds computation so we don't have to do a large range and then throw\n        // out unneeded numbers\n\n        if (v < data[0] || v > data[data.length - 1]) continue;\n        minorgridlines.push(extendFlat(constructValueGridline(v), {\n          color: axis.minorgridcolor,\n          width: axis.minorgridwidth,\n          dash: axis.minorgriddash\n        }));\n      }\n    }\n\n    if (axis.startline) {\n      boundarylines.push(extendFlat(constructArrayGridline(0), {\n        color: axis.startlinecolor,\n        width: axis.startlinewidth\n      }));\n    }\n\n    if (axis.endline) {\n      boundarylines.push(extendFlat(constructArrayGridline(data.length - 1), {\n        color: axis.endlinecolor,\n        width: axis.endlinewidth\n      }));\n    }\n  } else {\n    // If the lines do not fall along the axes, then we have to interpolate\n    // the contro points and so some math to figure out where the lines are\n    // in the first place.\n    // Compute the integer boudns of tick0 + n * dtick that fall within the range\n    // (roughly speaking):\n    // Give this a nice generous epsilon. We use at as * (1 + eps) in order to make\n    // inequalities a little tolerant in a more or less correct manner:\n    eps = 5e-15;\n    bounds = [Math.floor((data[data.length - 1] - axis.tick0) / axis.dtick * (1 + eps)), Math.ceil((data[0] - axis.tick0) / axis.dtick / (1 + eps))].sort(function (a, b) {\n      return a - b;\n    }); // Unpack sorted values so we can be sure to avoid infinite loops if something\n    // is backwards:\n\n    n1 = bounds[0];\n    n2 = bounds[1];\n\n    for (n = n1; n <= n2; n++) {\n      value = axis.tick0 + axis.dtick * n;\n      gridlines.push(extendFlat(constructValueGridline(value), {\n        color: axis.gridcolor,\n        width: axis.gridwidth,\n        dash: axis.griddash\n      }));\n    }\n\n    for (n = n1 - 1; n < n2 + 1; n++) {\n      value = axis.tick0 + axis.dtick * n;\n\n      for (i = 0; i < axis.minorgridcount; i++) {\n        v = value + axis.dtick * (i + 1) / (axis.minorgridcount + 1);\n        if (v < data[0] || v > data[data.length - 1]) continue;\n        minorgridlines.push(extendFlat(constructValueGridline(v), {\n          color: axis.minorgridcolor,\n          width: axis.minorgridwidth,\n          dash: axis.minorgriddash\n        }));\n      }\n    }\n\n    if (axis.startline) {\n      boundarylines.push(extendFlat(constructValueGridline(data[0]), {\n        color: axis.startlinecolor,\n        width: axis.startlinewidth\n      }));\n    }\n\n    if (axis.endline) {\n      boundarylines.push(extendFlat(constructValueGridline(data[data.length - 1]), {\n        color: axis.endlinecolor,\n        width: axis.endlinewidth\n      }));\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}