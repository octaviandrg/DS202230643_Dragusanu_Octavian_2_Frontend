{"ast":null,"code":"'use strict';\n\nvar axisIds = require('../../plots/cartesian/axis_ids');\n\nvar scatterSubTypes = require('../../traces/scatter/subtypes');\n\nvar Registry = require('../../registry');\n\nvar isUnifiedHover = require('../fx/helpers').isUnifiedHover;\n\nvar createModeBar = require('./modebar');\n\nvar modeBarButtons = require('./buttons');\n\nvar DRAW_MODES = require('./constants').DRAW_MODES;\n\nvar extendDeep = require('../../lib').extendDeep;\n/**\n * ModeBar wrapper around 'create' and 'update',\n * chooses buttons to pass to ModeBar constructor based on\n * plot type and plot config.\n *\n * @param {object} gd main plot object\n *\n */\n\n\nmodule.exports = function manageModeBar(gd) {\n  var fullLayout = gd._fullLayout;\n  var context = gd._context;\n  var modeBar = fullLayout._modeBar;\n\n  if (!context.displayModeBar && !context.watermark) {\n    if (modeBar) {\n      modeBar.destroy();\n      delete fullLayout._modeBar;\n    }\n\n    return;\n  }\n\n  if (!Array.isArray(context.modeBarButtonsToRemove)) {\n    throw new Error(['*modeBarButtonsToRemove* configuration options', 'must be an array.'].join(' '));\n  }\n\n  if (!Array.isArray(context.modeBarButtonsToAdd)) {\n    throw new Error(['*modeBarButtonsToAdd* configuration options', 'must be an array.'].join(' '));\n  }\n\n  var customButtons = context.modeBarButtons;\n  var buttonGroups;\n\n  if (Array.isArray(customButtons) && customButtons.length) {\n    buttonGroups = fillCustomButton(customButtons);\n  } else if (!context.displayModeBar && context.watermark) {\n    buttonGroups = [];\n  } else {\n    buttonGroups = getButtonGroups(gd);\n  }\n\n  if (modeBar) modeBar.update(gd, buttonGroups);else fullLayout._modeBar = createModeBar(gd, buttonGroups);\n}; // logic behind which buttons are displayed by default\n\n\nfunction getButtonGroups(gd) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var context = gd._context;\n\n  function match(name, B) {\n    if (typeof B === 'string') {\n      if (B.toLowerCase() === name.toLowerCase()) return true;\n    } else {\n      var v0 = B.name;\n      var v1 = B._cat || B.name;\n      if (v0 === name || v1 === name.toLowerCase()) return true;\n    }\n\n    return false;\n  }\n\n  var layoutAdd = fullLayout.modebar.add;\n  if (typeof layoutAdd === 'string') layoutAdd = [layoutAdd];\n  var layoutRemove = fullLayout.modebar.remove;\n  if (typeof layoutRemove === 'string') layoutRemove = [layoutRemove];\n  var buttonsToAdd = context.modeBarButtonsToAdd.concat(layoutAdd.filter(function (e) {\n    for (var i = 0; i < context.modeBarButtonsToRemove.length; i++) {\n      if (match(e, context.modeBarButtonsToRemove[i])) return false;\n    }\n\n    return true;\n  }));\n  var buttonsToRemove = context.modeBarButtonsToRemove.concat(layoutRemove.filter(function (e) {\n    for (var i = 0; i < context.modeBarButtonsToAdd.length; i++) {\n      if (match(e, context.modeBarButtonsToAdd[i])) return false;\n    }\n\n    return true;\n  }));\n\n  var hasCartesian = fullLayout._has('cartesian');\n\n  var hasGL3D = fullLayout._has('gl3d');\n\n  var hasGeo = fullLayout._has('geo');\n\n  var hasPie = fullLayout._has('pie');\n\n  var hasFunnelarea = fullLayout._has('funnelarea');\n\n  var hasGL2D = fullLayout._has('gl2d');\n\n  var hasTernary = fullLayout._has('ternary');\n\n  var hasMapbox = fullLayout._has('mapbox');\n\n  var hasPolar = fullLayout._has('polar');\n\n  var hasSmith = fullLayout._has('smith');\n\n  var hasSankey = fullLayout._has('sankey');\n\n  var allAxesFixed = areAllAxesFixed(fullLayout);\n  var hasUnifiedHoverLabel = isUnifiedHover(fullLayout.hovermode);\n  var groups = [];\n\n  function addGroup(newGroup) {\n    if (!newGroup.length) return;\n    var out = [];\n\n    for (var i = 0; i < newGroup.length; i++) {\n      var name = newGroup[i];\n      var B = modeBarButtons[name];\n      var v0 = B.name.toLowerCase();\n      var v1 = (B._cat || B.name).toLowerCase();\n      var found = false;\n\n      for (var q = 0; q < buttonsToRemove.length; q++) {\n        var t = buttonsToRemove[q].toLowerCase();\n\n        if (t === v0 || t === v1) {\n          found = true;\n          break;\n        }\n      }\n\n      if (found) continue;\n      out.push(modeBarButtons[name]);\n    }\n\n    groups.push(out);\n  } // buttons common to all plot types\n\n\n  var commonGroup = ['toImage'];\n  if (context.showEditInChartStudio) commonGroup.push('editInChartStudio');else if (context.showSendToCloud) commonGroup.push('sendDataToCloud');\n  addGroup(commonGroup);\n  var zoomGroup = [];\n  var hoverGroup = [];\n  var resetGroup = [];\n  var dragModeGroup = [];\n\n  if ((hasCartesian || hasGL2D || hasPie || hasFunnelarea || hasTernary) + hasGeo + hasGL3D + hasMapbox + hasPolar + hasSmith > 1) {\n    // graphs with more than one plot types get 'union buttons'\n    // which reset the view or toggle hover labels across all subplots.\n    hoverGroup = ['toggleHover'];\n    resetGroup = ['resetViews'];\n  } else if (hasGeo) {\n    zoomGroup = ['zoomInGeo', 'zoomOutGeo'];\n    hoverGroup = ['hoverClosestGeo'];\n    resetGroup = ['resetGeo'];\n  } else if (hasGL3D) {\n    hoverGroup = ['hoverClosest3d'];\n    resetGroup = ['resetCameraDefault3d', 'resetCameraLastSave3d'];\n  } else if (hasMapbox) {\n    zoomGroup = ['zoomInMapbox', 'zoomOutMapbox'];\n    hoverGroup = ['toggleHover'];\n    resetGroup = ['resetViewMapbox'];\n  } else if (hasGL2D) {\n    hoverGroup = ['hoverClosestGl2d'];\n  } else if (hasPie) {\n    hoverGroup = ['hoverClosestPie'];\n  } else if (hasSankey) {\n    hoverGroup = ['hoverClosestCartesian', 'hoverCompareCartesian'];\n    resetGroup = ['resetViewSankey'];\n  } else {\n    // hasPolar, hasSmith, hasTernary\n    // always show at least one hover icon.\n    hoverGroup = ['toggleHover'];\n  } // if we have cartesian, allow switching between closest and compare\n  // regardless of what other types are on the plot, since they'll all\n  // just treat any truthy hovermode as 'closest'\n\n\n  if (hasCartesian) {\n    hoverGroup = ['toggleSpikelines', 'hoverClosestCartesian', 'hoverCompareCartesian'];\n  }\n\n  if (hasNoHover(fullData) || hasUnifiedHoverLabel) {\n    hoverGroup = [];\n  }\n\n  if ((hasCartesian || hasGL2D) && !allAxesFixed) {\n    zoomGroup = ['zoomIn2d', 'zoomOut2d', 'autoScale2d'];\n    if (resetGroup[0] !== 'resetViews') resetGroup = ['resetScale2d'];\n  }\n\n  if (hasGL3D) {\n    dragModeGroup = ['zoom3d', 'pan3d', 'orbitRotation', 'tableRotation'];\n  } else if ((hasCartesian || hasGL2D) && !allAxesFixed || hasTernary) {\n    dragModeGroup = ['zoom2d', 'pan2d'];\n  } else if (hasMapbox || hasGeo) {\n    dragModeGroup = ['pan2d'];\n  } else if (hasPolar) {\n    dragModeGroup = ['zoom2d'];\n  }\n\n  if (isSelectable(fullData)) {\n    dragModeGroup.push('select2d', 'lasso2d');\n  }\n\n  var enabledHoverGroup = [];\n\n  var enableHover = function enableHover(a) {\n    // return if already added\n    if (enabledHoverGroup.indexOf(a) !== -1) return; // should be in hoverGroup\n\n    if (hoverGroup.indexOf(a) !== -1) {\n      enabledHoverGroup.push(a);\n    }\n  };\n\n  if (Array.isArray(buttonsToAdd)) {\n    var newList = [];\n\n    for (var i = 0; i < buttonsToAdd.length; i++) {\n      var b = buttonsToAdd[i];\n\n      if (typeof b === 'string') {\n        b = b.toLowerCase();\n\n        if (DRAW_MODES.indexOf(b) !== -1) {\n          // accept pre-defined drag modes i.e. shape drawing features as string\n          if (fullLayout._has('mapbox') || // draw shapes in paper coordinate (could be improved in future to support data coordinate, when there is no pitch)\n          fullLayout._has('cartesian') // draw shapes in data coordinate\n          ) {\n              dragModeGroup.push(b);\n            }\n        } else if (b === 'togglespikelines') {\n          enableHover('toggleSpikelines');\n        } else if (b === 'togglehover') {\n          enableHover('toggleHover');\n        } else if (b === 'hovercompare') {\n          enableHover('hoverCompareCartesian');\n        } else if (b === 'hoverclosest') {\n          enableHover('hoverClosestCartesian');\n          enableHover('hoverClosestGeo');\n          enableHover('hoverClosest3d');\n          enableHover('hoverClosestGl2d');\n          enableHover('hoverClosestPie');\n        } else if (b === 'v1hovermode') {\n          enableHover('toggleHover');\n          enableHover('hoverClosestCartesian');\n          enableHover('hoverCompareCartesian');\n          enableHover('hoverClosestGeo');\n          enableHover('hoverClosest3d');\n          enableHover('hoverClosestGl2d');\n          enableHover('hoverClosestPie');\n        }\n      } else newList.push(b);\n    }\n\n    buttonsToAdd = newList;\n  }\n\n  addGroup(dragModeGroup);\n  addGroup(zoomGroup.concat(resetGroup));\n  addGroup(enabledHoverGroup);\n  return appendButtonsToGroups(groups, buttonsToAdd);\n}\n\nfunction areAllAxesFixed(fullLayout) {\n  var axList = axisIds.list({\n    _fullLayout: fullLayout\n  }, null, true);\n\n  for (var i = 0; i < axList.length; i++) {\n    if (!axList[i].fixedrange) {\n      return false;\n    }\n  }\n\n  return true;\n} // look for traces that support selection\n// to be updated as we add more selectPoints handlers\n\n\nfunction isSelectable(fullData) {\n  var selectable = false;\n\n  for (var i = 0; i < fullData.length; i++) {\n    if (selectable) break;\n    var trace = fullData[i];\n    if (!trace._module || !trace._module.selectPoints) continue;\n\n    if (Registry.traceIs(trace, 'scatter-like')) {\n      if (scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {\n        selectable = true;\n      }\n    } else if (Registry.traceIs(trace, 'box-violin')) {\n      if (trace.boxpoints === 'all' || trace.points === 'all') {\n        selectable = true;\n      }\n    } else {\n      // assume that in general if the trace module has selectPoints,\n      // then it's selectable. Scatter is an exception to this because it must\n      // have markers or text, not just be a scatter type.\n      selectable = true;\n    }\n  }\n\n  return selectable;\n} // check whether all trace are 'noHover'\n\n\nfunction hasNoHover(fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (!Registry.traceIs(fullData[i], 'noHover')) return false;\n  }\n\n  return true;\n}\n\nfunction appendButtonsToGroups(groups, buttons) {\n  if (buttons.length) {\n    if (Array.isArray(buttons[0])) {\n      for (var i = 0; i < buttons.length; i++) {\n        groups.push(buttons[i]);\n      }\n    } else groups.push(buttons);\n  }\n\n  return groups;\n} // fill in custom buttons referring to default mode bar buttons\n\n\nfunction fillCustomButton(originalModeBarButtons) {\n  var customButtons = extendDeep([], originalModeBarButtons);\n\n  for (var i = 0; i < customButtons.length; i++) {\n    var buttonGroup = customButtons[i];\n\n    for (var j = 0; j < buttonGroup.length; j++) {\n      var button = buttonGroup[j];\n\n      if (typeof button === 'string') {\n        if (modeBarButtons[button] !== undefined) {\n          customButtons[i][j] = modeBarButtons[button];\n        } else {\n          throw new Error(['*modeBarButtons* configuration options', 'invalid button name'].join(' '));\n        }\n      }\n    }\n  }\n\n  return customButtons;\n}","map":null,"metadata":{},"sourceType":"script"}