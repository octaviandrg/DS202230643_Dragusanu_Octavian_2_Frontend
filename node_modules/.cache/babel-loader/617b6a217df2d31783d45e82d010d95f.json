{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar Colorscale = require('../../components/colorscale');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar heatmapPlot = require('../heatmap/plot');\n\nvar makeCrossings = require('./make_crossings');\n\nvar findAllPaths = require('./find_all_paths');\n\nvar emptyPathinfo = require('./empty_pathinfo');\n\nvar convertToConstraints = require('./convert_to_constraints');\n\nvar closeBoundaries = require('./close_boundaries');\n\nvar constants = require('./constants');\n\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var x = cd0.x;\n    var y = cd0.y;\n    var contours = trace.contours;\n    var pathinfo = emptyPathinfo(contours, plotinfo, cd0); // use a heatmap to fill - draw it behind the lines\n\n    var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n    var cdheatmaps = [];\n\n    if (contours.coloring === 'heatmap') {\n      cdheatmaps = [cd];\n    }\n\n    heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n    makeCrossings(pathinfo);\n    findAllPaths(pathinfo);\n    var leftedge = xa.c2p(x[0], true);\n    var rightedge = xa.c2p(x[x.length - 1], true);\n    var bottomedge = ya.c2p(y[0], true);\n    var topedge = ya.c2p(y[y.length - 1], true);\n    var perimeter = [[leftedge, topedge], [rightedge, topedge], [rightedge, bottomedge], [leftedge, bottomedge]];\n    var fillPathinfo = pathinfo;\n\n    if (contours.type === 'constraint') {\n      // N.B. this also mutates pathinfo\n      fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n    } // draw everything\n\n\n    makeBackground(plotGroup, perimeter, contours);\n    makeFills(plotGroup, fillPathinfo, perimeter, contours);\n    makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);\n    clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n  });\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n  var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n  var bgfill = bggroup.selectAll('path').data(contours.coloring === 'fill' ? [0] : []);\n  bgfill.enter().append('path');\n  bgfill.exit().remove();\n  bgfill.attr('d', 'M' + perimeter.join('L') + 'Z').style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n  var hasFills = contours.coloring === 'fill' || contours.type === 'constraint' && contours._operation !== '=';\n  var boundaryPath = 'M' + perimeter.join('L') + 'Z'; // fills prefixBoundary in pathinfo items\n\n  if (hasFills) {\n    closeBoundaries(pathinfo, contours);\n  }\n\n  var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n  var fillitems = fillgroup.selectAll('path').data(hasFills ? pathinfo : []);\n  fillitems.enter().append('path');\n  fillitems.exit().remove();\n  fillitems.each(function (pi) {\n    // join all paths for this level together into a single path\n    // first follow clockwise around the perimeter to close any open paths\n    // if the whole perimeter is above this level, start with a path\n    // enclosing the whole thing. With all that, the parity should mean\n    // that we always fill everything above the contour, nothing below\n    var fullpath = (pi.prefixBoundary ? boundaryPath : '') + joinAllPaths(pi, perimeter);\n\n    if (!fullpath) {\n      d3.select(this).remove();\n    } else {\n      d3.select(this).attr('d', fullpath).style('stroke', 'none');\n    }\n  });\n}\n\nfunction joinAllPaths(pi, perimeter) {\n  var fullpath = '';\n  var i = 0;\n  var startsleft = pi.edgepaths.map(function (v, i) {\n    return i;\n  });\n  var newloop = true;\n  var endpt;\n  var newendpt;\n  var cnt;\n  var nexti;\n  var possiblei;\n  var addpath;\n\n  function istop(pt) {\n    return Math.abs(pt[1] - perimeter[0][1]) < 0.01;\n  }\n\n  function isbottom(pt) {\n    return Math.abs(pt[1] - perimeter[2][1]) < 0.01;\n  }\n\n  function isleft(pt) {\n    return Math.abs(pt[0] - perimeter[0][0]) < 0.01;\n  }\n\n  function isright(pt) {\n    return Math.abs(pt[0] - perimeter[2][0]) < 0.01;\n  }\n\n  while (startsleft.length) {\n    addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n    fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n    startsleft.splice(startsleft.indexOf(i), 1);\n    endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n    nexti = -1; // now loop through sides, moving our endpoint until we find a new start\n\n    for (cnt = 0; cnt < 4; cnt++) {\n      // just to prevent infinite loops\n      if (!endpt) {\n        Lib.log('Missing end?', i, pi);\n        break;\n      }\n\n      if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n      else if (isleft(endpt)) newendpt = perimeter[0]; // left top\n        else if (isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n          else if (isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n      for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n        var ptNew = pi.edgepaths[possiblei][0]; // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n\n        if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n          if (Math.abs(endpt[0] - ptNew[0]) < 0.01 && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n          if (Math.abs(endpt[1] - ptNew[1]) < 0.01 && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else {\n          Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n        }\n      }\n\n      endpt = newendpt;\n      if (nexti >= 0) break;\n      fullpath += 'L' + newendpt;\n    }\n\n    if (nexti === pi.edgepaths.length) {\n      Lib.log('unclosed perimeter path');\n      break;\n    }\n\n    i = nexti; // if we closed back on a loop we already included,\n    // close it and start a new loop\n\n    newloop = startsleft.indexOf(i) === -1;\n\n    if (newloop) {\n      i = startsleft[0];\n      fullpath += 'Z';\n    }\n  } // finally add the interior paths\n\n\n  for (i = 0; i < pi.paths.length; i++) {\n    fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n  }\n\n  return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {\n  var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n  var showLines = contours.showlines !== false;\n  var showLabels = contours.showlabels;\n  var clipLinesForLabels = showLines && showLabels; // Even if we're not going to show lines, we need to create them\n  // if we're showing labels, because the fill paths include the perimeter\n  // so can't be used to position the labels correctly.\n  // In this case we'll remove the lines after making the labels.\n\n  var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n  var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n  var labelGroup = plotgroup.selectAll('g.contourlabels').data(showLabels ? [0] : []);\n  labelGroup.exit().remove();\n  labelGroup.enter().append('g').classed('contourlabels', true);\n\n  if (showLabels) {\n    var labelClipPathData = [];\n    var labelData = []; // invalidate the getTextLocation cache in case paths changed\n\n    Lib.clearLocationCache();\n    var contourFormat = exports.labelFormatter(gd, cd0);\n    var dummyText = Drawing.tester.append('text').attr('data-notex', 1).call(Drawing.font, contours.labelfont);\n    var xa = pathinfo[0].xaxis;\n    var ya = pathinfo[0].yaxis;\n    var xLen = xa._length;\n    var yLen = ya._length;\n    var xRng = xa.range;\n    var yRng = ya.range;\n    var xMin = Lib.aggNums(Math.min, null, cd0.x);\n    var xMax = Lib.aggNums(Math.max, null, cd0.x);\n    var yMin = Lib.aggNums(Math.min, null, cd0.y);\n    var yMax = Lib.aggNums(Math.max, null, cd0.y);\n    var x0 = Math.max(xa.c2p(xMin, true), 0);\n    var x1 = Math.min(xa.c2p(xMax, true), xLen);\n    var y0 = Math.max(ya.c2p(yMax, true), 0);\n    var y1 = Math.min(ya.c2p(yMin, true), yLen); // visible bounds of the contour trace (and the midpoints, to\n    // help with cost calculations)\n\n    var bounds = {};\n\n    if (xRng[0] < xRng[1]) {\n      bounds.left = x0;\n      bounds.right = x1;\n    } else {\n      bounds.left = x1;\n      bounds.right = x0;\n    }\n\n    if (yRng[0] < yRng[1]) {\n      bounds.top = y0;\n      bounds.bottom = y1;\n    } else {\n      bounds.top = y1;\n      bounds.bottom = y0;\n    }\n\n    bounds.middle = (bounds.top + bounds.bottom) / 2;\n    bounds.center = (bounds.left + bounds.right) / 2;\n    labelClipPathData.push([[bounds.left, bounds.top], [bounds.right, bounds.top], [bounds.right, bounds.bottom], [bounds.left, bounds.bottom]]);\n    var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen); // the path length to use to scale the number of labels to draw:\n\n    var normLength = constants.LABELDISTANCE * plotDiagonal / Math.max(1, pathinfo.length / constants.LABELINCREASE);\n    linegroup.each(function (d) {\n      var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n      d3.select(this).selectAll('path').each(function () {\n        var path = this;\n        var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n        if (!pathBounds) return;\n        if (pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n        var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength), constants.LABELMAX);\n\n        for (var i = 0; i < maxLabels; i++) {\n          var loc = exports.findBestTextLocation(path, pathBounds, textOpts, labelData, bounds);\n          if (!loc) break;\n          exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n        }\n      });\n    });\n    dummyText.remove();\n    exports.drawLabels(labelGroup, labelData, gd, lineClip, clipLinesForLabels ? labelClipPathData : null);\n  }\n\n  if (showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function (lineContainer, makeLines, pathinfo) {\n  var smoothing = pathinfo[0].smoothing;\n  var linegroup = lineContainer.selectAll('g.contourlevel').data(makeLines ? pathinfo : []);\n  linegroup.exit().remove();\n  linegroup.enter().append('g').classed('contourlevel', true);\n\n  if (makeLines) {\n    // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n    // edgepaths / paths are used by contour since it's in x/y from the start\n    var opencontourlines = linegroup.selectAll('path.openline').data(function (d) {\n      return d.pedgepaths || d.edgepaths;\n    });\n    opencontourlines.exit().remove();\n    opencontourlines.enter().append('path').classed('openline', true);\n    opencontourlines.attr('d', function (d) {\n      return Drawing.smoothopen(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n    var closedcontourlines = linegroup.selectAll('path.closedline').data(function (d) {\n      return d.ppaths || d.paths;\n    });\n    closedcontourlines.exit().remove();\n    closedcontourlines.enter().append('path').classed('closedline', true);\n    closedcontourlines.attr('d', function (d) {\n      return Drawing.smoothclosed(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n  }\n\n  return linegroup;\n};\n\nexports.createLineClip = function (lineContainer, clipLinesForLabels, gd, uid) {\n  var clips = gd._fullLayout._clips;\n  var clipId = clipLinesForLabels ? 'clipline' + uid : null;\n  var lineClip = clips.selectAll('#' + clipId).data(clipLinesForLabels ? [0] : []);\n  lineClip.exit().remove();\n  lineClip.enter().append('clipPath').classed('contourlineclip', true).attr('id', clipId);\n  Drawing.setClipUrl(lineContainer, clipId, gd);\n  return lineClip;\n};\n\nexports.labelFormatter = function (gd, cd0) {\n  var fullLayout = gd._fullLayout;\n  var trace = cd0.trace;\n  var contours = trace.contours;\n  var formatAxis = {\n    type: 'linear',\n    _id: 'ycontour',\n    showexponent: 'all',\n    exponentformat: 'B'\n  };\n\n  if (contours.labelformat) {\n    formatAxis.tickformat = contours.labelformat;\n    setConvert(formatAxis, fullLayout);\n  } else {\n    var cOpts = Colorscale.extractOpts(trace);\n\n    if (cOpts && cOpts.colorbar && cOpts.colorbar._axis) {\n      formatAxis = cOpts.colorbar._axis;\n    } else {\n      if (contours.type === 'constraint') {\n        var value = contours.value;\n\n        if (Array.isArray(value)) {\n          formatAxis.range = [value[0], value[value.length - 1]];\n        } else formatAxis.range = [value, value];\n      } else {\n        formatAxis.range = [contours.start, contours.end];\n        formatAxis.nticks = (contours.end - contours.start) / contours.size;\n      }\n\n      if (formatAxis.range[0] === formatAxis.range[1]) {\n        formatAxis.range[1] += formatAxis.range[0] || 1;\n      }\n\n      if (!formatAxis.nticks) formatAxis.nticks = 1000;\n      setConvert(formatAxis, fullLayout);\n      Axes.prepTicks(formatAxis);\n      formatAxis._tmin = null;\n      formatAxis._tmax = null;\n    }\n  }\n\n  return function (v) {\n    return Axes.tickText(formatAxis, v).text;\n  };\n};\n\nexports.calcTextOpts = function (level, contourFormat, dummyText, gd) {\n  var text = contourFormat(level);\n  dummyText.text(text).call(svgTextUtils.convertToTspans, gd);\n  var el = dummyText.node();\n  var bBox = Drawing.bBox(el, true);\n  return {\n    text: text,\n    width: bBox.width,\n    height: bBox.height,\n    fontSize: +el.style['font-size'].replace('px', ''),\n    level: level,\n    dy: (bBox.top + bBox.bottom) / 2\n  };\n};\n\nexports.findBestTextLocation = function (path, pathBounds, textOpts, labelData, plotBounds) {\n  var textWidth = textOpts.width;\n  var p0, dp, pMax, pMin, loc;\n\n  if (pathBounds.isClosed) {\n    dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n    p0 = pathBounds.min + dp / 2;\n    pMax = pathBounds.max;\n  } else {\n    dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n    p0 = pathBounds.min + dp + textWidth / 2;\n    pMax = pathBounds.max - (dp + textWidth) / 2;\n  }\n\n  var cost = Infinity;\n\n  for (var j = 0; j < costConstants.ITERATIONS; j++) {\n    for (var p = p0; p < pMax; p += dp) {\n      var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n      var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n\n      if (newCost < cost) {\n        cost = newCost;\n        loc = newLocation;\n        pMin = p;\n      }\n    }\n\n    if (cost > costConstants.MAXCOST * 2) break; // subsequent iterations just look half steps away from the\n    // best we found in the previous iteration\n\n    if (j) dp /= 2;\n    p0 = pMin - dp / 2;\n    pMax = p0 + dp * 1.5;\n  }\n\n  if (cost <= costConstants.MAXCOST) return loc;\n};\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\n\n\nfunction locationCost(loc, textOpts, labelData, bounds) {\n  var halfWidth = textOpts.width / 2;\n  var halfHeight = textOpts.height / 2;\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var dx = Math.cos(theta) * halfWidth;\n  var dy = Math.sin(theta) * halfWidth; // cost for being near an edge\n\n  var normX = (x > bounds.center ? bounds.right - x : x - bounds.left) / (dx + Math.abs(Math.sin(theta) * halfHeight));\n  var normY = (y > bounds.middle ? bounds.bottom - y : y - bounds.top) / (Math.abs(dy) + Math.cos(theta) * halfHeight);\n  if (normX < 1 || normY < 1) return Infinity;\n  var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1)); // cost for not being horizontal\n\n  cost += costConstants.ANGLECOST * theta * theta; // cost for being close to other labels\n\n  var x1 = x - dx;\n  var y1 = y - dy;\n  var x2 = x + dx;\n  var y2 = y + dy;\n\n  for (var i = 0; i < labelData.length; i++) {\n    var labeli = labelData[i];\n    var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n    var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n    var dist = Lib.segmentDistance(x1, y1, x2, y2, labeli.x - dxd, labeli.y - dyd, labeli.x + dxd, labeli.y + dyd) * 2 / (textOpts.height + labeli.height);\n    var sameLevel = labeli.level === textOpts.level;\n    var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n    if (dist <= distOffset) return Infinity;\n    var distFactor = costConstants.NEIGHBORCOST * (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n    cost += distFactor / (dist - distOffset);\n  }\n\n  return cost;\n}\n\nexports.addLabelData = function (loc, textOpts, labelData, labelClipPathData) {\n  var fontSize = textOpts.fontSize;\n  var w = textOpts.width + fontSize / 3;\n  var h = Math.max(0, textOpts.height - fontSize / 3);\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var sin = Math.sin(theta);\n  var cos = Math.cos(theta);\n\n  var rotateXY = function rotateXY(dx, dy) {\n    return [x + dx * cos - dy * sin, y + dx * sin + dy * cos];\n  };\n\n  var bBoxPts = [rotateXY(-w / 2, -h / 2), rotateXY(-w / 2, h / 2), rotateXY(w / 2, h / 2), rotateXY(w / 2, -h / 2)];\n  labelData.push({\n    text: textOpts.text,\n    x: x,\n    y: y,\n    dy: textOpts.dy,\n    theta: theta,\n    level: textOpts.level,\n    width: w,\n    height: h\n  });\n  labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function (labelGroup, labelData, gd, lineClip, labelClipPathData) {\n  var labels = labelGroup.selectAll('text').data(labelData, function (d) {\n    return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n  });\n  labels.exit().remove();\n  labels.enter().append('text').attr({\n    'data-notex': 1,\n    'text-anchor': 'middle'\n  }).each(function (d) {\n    var x = d.x + Math.sin(d.theta) * d.dy;\n    var y = d.y - Math.cos(d.theta) * d.dy;\n    d3.select(this).text(d.text).attr({\n      x: x,\n      y: y,\n      transform: 'rotate(' + 180 * d.theta / Math.PI + ' ' + x + ' ' + y + ')'\n    }).call(svgTextUtils.convertToTspans, gd);\n  });\n\n  if (labelClipPathData) {\n    var clipPath = '';\n\n    for (var i = 0; i < labelClipPathData.length; i++) {\n      clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n    }\n\n    var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n    lineClipPath.attr('d', clipPath);\n  }\n};\n\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n  var trace = cd0.trace;\n  var clips = gd._fullLayout._clips;\n  var clipId = 'clip' + trace.uid;\n  var clipPath = clips.selectAll('#' + clipId).data(trace.connectgaps ? [] : [0]);\n  clipPath.enter().append('clipPath').classed('contourclip', true).attr('id', clipId);\n  clipPath.exit().remove();\n\n  if (trace.connectgaps === false) {\n    var clipPathInfo = {\n      // fraction of the way from missing to present point\n      // to draw the boundary.\n      // if you make this 1 (or 1-epsilon) then a point in\n      // a sea of missing data will disappear entirely.\n      level: 0.9,\n      crossings: {},\n      starts: [],\n      edgepaths: [],\n      paths: [],\n      xaxis: plotinfo.xaxis,\n      yaxis: plotinfo.yaxis,\n      x: cd0.x,\n      y: cd0.y,\n      // 0 = no data, 1 = data\n      z: makeClipMask(cd0),\n      smoothing: 0\n    };\n    makeCrossings([clipPathInfo]);\n    findAllPaths([clipPathInfo]);\n    closeBoundaries([clipPathInfo], {\n      type: 'levels'\n    });\n    var path = Lib.ensureSingle(clipPath, 'path', '');\n    path.attr('d', (clipPathInfo.prefixBoundary ? 'M' + perimeter.join('L') + 'Z' : '') + joinAllPaths(clipPathInfo, perimeter));\n  } else clipId = null;\n\n  Drawing.setClipUrl(plotGroup, clipId, gd);\n}\n\nfunction makeClipMask(cd0) {\n  var empties = cd0.trace._emptypoints;\n  var z = [];\n  var m = cd0.z.length;\n  var n = cd0.z[0].length;\n  var i;\n  var row = [];\n  var emptyPoint;\n\n  for (i = 0; i < n; i++) {\n    row.push(1);\n  }\n\n  for (i = 0; i < m; i++) {\n    z.push(row.slice());\n  }\n\n  for (i = 0; i < empties.length; i++) {\n    emptyPoint = empties[i];\n    z[emptyPoint[0]][emptyPoint[1]] = 0;\n  } // save this mask to determine whether to show this data in hover\n\n\n  cd0.zmask = z;\n  return z;\n}","map":null,"metadata":{},"sourceType":"script"}