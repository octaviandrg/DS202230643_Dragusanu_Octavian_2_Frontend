{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {\n  if (!opts) opts = {};\n  var isContour = opts.isContour;\n  var cd0 = pointData.cd[0];\n  var trace = cd0.trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var x = cd0.x;\n  var y = cd0.y;\n  var z = cd0.z;\n  var xc = cd0.xCenter;\n  var yc = cd0.yCenter;\n  var zmask = cd0.zmask;\n  var zhoverformat = trace.zhoverformat;\n  var x2 = x;\n  var y2 = y;\n  var xl, yl, nx, ny;\n\n  if (pointData.index !== false) {\n    try {\n      nx = Math.round(pointData.index[1]);\n      ny = Math.round(pointData.index[0]);\n    } catch (e) {\n      Lib.error('Error hovering on heatmap, ' + 'pointNumber must be [row,col], found:', pointData.index);\n      return;\n    }\n\n    if (nx < 0 || nx >= z[0].length || ny < 0 || ny > z.length) {\n      return;\n    }\n  } else if (Fx.inbox(xval - x[0], xval - x[x.length - 1], 0) > 0 || Fx.inbox(yval - y[0], yval - y[y.length - 1], 0) > 0) {\n    return;\n  } else {\n    if (isContour) {\n      var i2;\n      x2 = [2 * x[0] - x[1]];\n\n      for (i2 = 1; i2 < x.length; i2++) {\n        x2.push((x[i2] + x[i2 - 1]) / 2);\n      }\n\n      x2.push([2 * x[x.length - 1] - x[x.length - 2]]);\n      y2 = [2 * y[0] - y[1]];\n\n      for (i2 = 1; i2 < y.length; i2++) {\n        y2.push((y[i2] + y[i2 - 1]) / 2);\n      }\n\n      y2.push([2 * y[y.length - 1] - y[y.length - 2]]);\n    }\n\n    nx = Math.max(0, Math.min(x2.length - 2, Lib.findBin(xval, x2)));\n    ny = Math.max(0, Math.min(y2.length - 2, Lib.findBin(yval, y2)));\n  }\n\n  var x0 = xa.c2p(x[nx]);\n  var x1 = xa.c2p(x[nx + 1]);\n  var y0 = ya.c2p(y[ny]);\n  var y1 = ya.c2p(y[ny + 1]);\n\n  var _x, _y;\n\n  if (isContour) {\n    _x = cd0.orig_x || x;\n    _y = cd0.orig_y || y;\n    x1 = x0;\n    xl = _x[nx];\n    y1 = y0;\n    yl = _y[ny];\n  } else {\n    _x = cd0.orig_x || xc || x;\n    _y = cd0.orig_y || yc || y;\n    xl = xc ? _x[nx] : (_x[nx] + _x[nx + 1]) / 2;\n    yl = yc ? _y[ny] : (_y[ny] + _y[ny + 1]) / 2;\n    if (xa && xa.type === 'category') xl = x[nx];\n    if (ya && ya.type === 'category') yl = y[ny];\n\n    if (trace.zsmooth) {\n      x0 = x1 = xa.c2p(xl);\n      y0 = y1 = ya.c2p(yl);\n    }\n  }\n\n  var zVal = z[ny][nx];\n  if (zmask && !zmask[ny][nx]) zVal = undefined;\n  if (zVal === undefined && !trace.hoverongaps) return;\n  var text;\n\n  if (Array.isArray(cd0.hovertext) && Array.isArray(cd0.hovertext[ny])) {\n    text = cd0.hovertext[ny][nx];\n  } else if (Array.isArray(cd0.text) && Array.isArray(cd0.text[ny])) {\n    text = cd0.text[ny][nx];\n  } // dummy axis for formatting the z value\n\n\n  var cOpts = extractOpts(trace);\n  var dummyAx = {\n    type: 'linear',\n    range: [cOpts.min, cOpts.max],\n    hoverformat: zhoverformat,\n    _separators: xa._separators,\n    _numFormat: xa._numFormat\n  };\n  var zLabel = Axes.tickText(dummyAx, zVal, 'hover').text;\n  return [Lib.extendFlat(pointData, {\n    index: trace._after2before ? trace._after2before[ny][nx] : [ny, nx],\n    // never let a 2D override 1D type as closest point\n    distance: pointData.maxHoverDistance,\n    spikeDistance: pointData.maxSpikeDistance,\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1,\n    xLabelVal: xl,\n    yLabelVal: yl,\n    zLabelVal: zVal,\n    zLabel: zLabel,\n    text: text\n  })];\n};","map":null,"metadata":{},"sourceType":"script"}