{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar utcFormat = require('d3-time-format').utcFormat;\n\nvar Lib = require('../../lib');\n\nvar numberFormat = Lib.numberFormat;\n\nvar isNumeric = require('fast-isnumeric');\n\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\nvar numConstants = require('../../constants/numerical');\n\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar ONEWEEK = numConstants.ONEWEEK;\nvar ONEDAY = numConstants.ONEDAY;\nvar ONEHOUR = numConstants.ONEHOUR;\nvar ONEMIN = numConstants.ONEMIN;\nvar ONESEC = numConstants.ONESEC;\n\nvar axisIds = require('./axis_ids');\n\nvar constants = require('./constants');\n\nvar HOUR_PATTERN = constants.HOUR_PATTERN;\nvar WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;\n\nfunction fromLog(v) {\n  return Math.pow(10, v);\n}\n\nfunction isValidCategory(v) {\n  return v !== null && v !== undefined;\n}\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v3.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\n\n\nmodule.exports = function setConvert(ax, fullLayout) {\n  fullLayout = fullLayout || {};\n  var axId = ax._id || 'x';\n  var axLetter = axId.charAt(0);\n\n  function toLog(v, clip) {\n    if (v > 0) return Math.log(v) / Math.LN10;else if (v <= 0 && clip && ax.range && ax.range.length === 2) {\n      // clip NaN (ie past negative infinity) to LOG_CLIP axis\n      // length past the negative edge\n      var r0 = ax.range[0];\n      var r1 = ax.range[1];\n      return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n    } else return BADNUM;\n  }\n  /*\n   * wrapped dateTime2ms that:\n   * - accepts ms numbers for backward compatibility\n   * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n   * - defaults to ax.calendar\n   */\n\n\n  function dt2ms(v, _, calendar, opts) {\n    if ((opts || {}).msUTC && isNumeric(v)) {\n      // For now it is only used\n      // to fix bar length in milliseconds & gl3d ticks\n      // It could be applied in other places in v3\n      return +v;\n    } // NOTE: Changed this behavior: previously we took any numeric value\n    // to be a ms, even if it was a string that could be a bare year.\n    // Now we convert it as a date if at all possible, and only try\n    // as (local) ms if that fails.\n\n\n    var ms = dateTime2ms(v, calendar || ax.calendar);\n\n    if (ms === BADNUM) {\n      if (isNumeric(v)) {\n        v = +v; // keep track of tenths of ms, that `new Date` will drop\n        // same logic as in Lib.ms2DateTime\n\n        var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n        var msRounded = Math.round(v - msecTenths / 10);\n        ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n      } else return BADNUM;\n    }\n\n    return ms;\n  } // wrapped ms2DateTime to insert default ax.calendar\n\n\n  function ms2dt(v, r, calendar) {\n    return ms2DateTime(v, r, calendar || ax.calendar);\n  }\n\n  function getCategoryName(v) {\n    return ax._categories[Math.round(v)];\n  }\n  /*\n   * setCategoryIndex: return the index of category v,\n   * inserting it in the list if it's not already there\n   *\n   * this will enter the categories in the order it\n   * encounters them, ie all the categories from the\n   * first data set, then all the ones from the second\n   * that aren't in the first etc.\n   *\n   * it is assumed that this function is being invoked in the\n   * already sorted category order; otherwise there would be\n   * a disconnect between the array and the index returned\n   */\n\n\n  function setCategoryIndex(v) {\n    if (isValidCategory(v)) {\n      if (ax._categoriesMap === undefined) {\n        ax._categoriesMap = {};\n      }\n\n      if (ax._categoriesMap[v] !== undefined) {\n        return ax._categoriesMap[v];\n      } else {\n        ax._categories.push(typeof v === 'number' ? String(v) : v);\n\n        var curLength = ax._categories.length - 1;\n        ax._categoriesMap[v] = curLength;\n        return curLength;\n      }\n    }\n\n    return BADNUM;\n  }\n\n  function setMultiCategoryIndex(arrayIn, len) {\n    var arrayOut = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      var v0 = (arrayIn[0] || [])[i];\n      var v1 = (arrayIn[1] || [])[i];\n      arrayOut[i] = getCategoryIndex([v0, v1]);\n    }\n\n    return arrayOut;\n  }\n\n  function getCategoryIndex(v) {\n    if (ax._categoriesMap) {\n      return ax._categoriesMap[v];\n    }\n  }\n\n  function getCategoryPosition(v) {\n    // d2l/d2c variant that that won't add categories but will also\n    // allow numbers to be mapped to the linearized axis positions\n    var index = getCategoryIndex(v);\n    if (index !== undefined) return index;\n    if (isNumeric(v)) return +v;\n  }\n\n  function getRangePosition(v) {\n    return isNumeric(v) ? +v : getCategoryIndex(v);\n  } // include 2 fractional digits on pixel, for PDF zooming etc\n\n\n  function _l2p(v, m, b) {\n    return d3.round(b + m * v, 2);\n  }\n\n  function _p2l(px, m, b) {\n    return (px - b) / m;\n  }\n\n  var l2p = function l2p(v) {\n    if (!isNumeric(v)) return BADNUM;\n    return _l2p(v, ax._m, ax._b);\n  };\n\n  var p2l = function p2l(px) {\n    return _p2l(px, ax._m, ax._b);\n  };\n\n  if (ax.rangebreaks) {\n    var isY = axLetter === 'y';\n\n    l2p = function l2p(v) {\n      if (!isNumeric(v)) return BADNUM;\n      var len = ax._rangebreaks.length;\n      if (!len) return _l2p(v, ax._m, ax._b);\n      var flip = isY;\n      if (ax.range[0] > ax.range[1]) flip = !flip;\n      var signAx = flip ? -1 : 1;\n      var pos = signAx * v;\n      var q = 0;\n\n      for (var i = 0; i < len; i++) {\n        var min = signAx * ax._rangebreaks[i].min;\n        var max = signAx * ax._rangebreaks[i].max;\n        if (pos < min) break;\n        if (pos > max) q = i + 1;else {\n          // when falls into break, pick 'closest' offset\n          q = pos < (min + max) / 2 ? i : i + 1;\n          break;\n        }\n      }\n\n      var b2 = ax._B[q] || 0;\n      if (!isFinite(b2)) return 0; // avoid NaN translate e.g. in positionLabels if one keep zooming exactly into a break\n\n      return _l2p(v, ax._m2, b2);\n    };\n\n    p2l = function p2l(px) {\n      var len = ax._rangebreaks.length;\n      if (!len) return _p2l(px, ax._m, ax._b);\n      var q = 0;\n\n      for (var i = 0; i < len; i++) {\n        if (px < ax._rangebreaks[i].pmin) break;\n        if (px > ax._rangebreaks[i].pmax) q = i + 1;\n      }\n\n      return _p2l(px, ax._m2, ax._B[q]);\n    };\n  } // conversions among c/l/p are fairly simple - do them together for all axis types\n\n\n  ax.c2l = ax.type === 'log' ? toLog : ensureNumber;\n  ax.l2c = ax.type === 'log' ? fromLog : ensureNumber;\n  ax.l2p = l2p;\n  ax.p2l = p2l;\n  ax.c2p = ax.type === 'log' ? function (v, clip) {\n    return l2p(toLog(v, clip));\n  } : l2p;\n  ax.p2c = ax.type === 'log' ? function (px) {\n    return fromLog(p2l(px));\n  } : p2l;\n  /*\n   * now type-specific conversions for **ALL** other combinations\n   * they're all written out, instead of being combinations of each other, for\n   * both clarity and speed.\n   */\n\n  if (['linear', '-'].indexOf(ax.type) !== -1) {\n    // all are data vals, but d and r need cleaning\n    ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n\n    ax.d2p = ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n\n    ax.p2d = ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'log') {\n    // d and c are data vals, r and l are logged (but d and r need cleaning)\n    ax.d2r = ax.d2l = function (v, clip) {\n      return toLog(cleanNumber(v), clip);\n    };\n\n    ax.r2d = ax.r2c = function (v) {\n      return fromLog(cleanNumber(v));\n    };\n\n    ax.d2c = ax.r2l = cleanNumber;\n    ax.c2d = ax.l2r = ensureNumber;\n    ax.c2r = toLog;\n    ax.l2d = fromLog;\n\n    ax.d2p = function (v, clip) {\n      return ax.l2p(ax.d2r(v, clip));\n    };\n\n    ax.p2d = function (px) {\n      return fromLog(p2l(px));\n    };\n\n    ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n\n    ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'date') {\n    // r and d are date strings, l and c are ms\n\n    /*\n     * Any of these functions with r and d on either side, calendar is the\n     * **3rd** argument. log has reserved the second argument.\n     *\n     * Unless you need the special behavior of the second arg (ms2DateTime\n     * uses this to limit precision, toLog uses true to clip negatives\n     * to offscreen low rather than undefined), it's safe to pass 0.\n     */\n    ax.d2r = ax.r2d = Lib.identity;\n    ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n    ax.d2p = ax.r2p = function (v, _, calendar) {\n      return ax.l2p(dt2ms(v, 0, calendar));\n    };\n\n    ax.p2d = ax.p2r = function (px, r, calendar) {\n      return ms2dt(p2l(px), r, calendar);\n    };\n\n    ax.cleanPos = function (v) {\n      return Lib.cleanDate(v, BADNUM, ax.calendar);\n    };\n  } else if (ax.type === 'category') {\n    // d is categories (string)\n    // c and l are indices (numbers)\n    // r is categories or numbers\n    ax.d2c = ax.d2l = setCategoryIndex;\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n    ax.r2c = function (v) {\n      var index = getRangePosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getRangePosition;\n\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n\n    ax.cleanPos = function (v) {\n      if (typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n  } else if (ax.type === 'multicategory') {\n    // N.B. multicategory axes don't define d2c and d2l,\n    // as 'data-to-calcdata' conversion needs to take into\n    // account all data array items as in ax.makeCalcdata.\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n    ax.r2c = function (v) {\n      var index = getCategoryPosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n\n    ax.r2c_just_indices = getCategoryIndex;\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getCategoryPosition;\n\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n\n    ax.cleanPos = function (v) {\n      if (Array.isArray(v) || typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n\n    ax.setupMultiCategory = function (fullData) {\n      var traceIndices = ax._traceIndices;\n      var i, j;\n      var group = ax._matchGroup;\n\n      if (group && ax._categories.length === 0) {\n        for (var axId2 in group) {\n          if (axId2 !== axId) {\n            var ax2 = fullLayout[axisIds.id2name(axId2)];\n            traceIndices = traceIndices.concat(ax2._traceIndices);\n          }\n        }\n      } // [ [cnt, {$cat: index}], for 1,2 ]\n\n\n      var seen = [[0, {}], [0, {}]]; // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n\n      var list = [];\n\n      for (i = 0; i < traceIndices.length; i++) {\n        var trace = fullData[traceIndices[i]];\n\n        if (axLetter in trace) {\n          var arrayIn = trace[axLetter];\n          var len = trace._length || Lib.minRowLength(arrayIn);\n\n          if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n            for (j = 0; j < len; j++) {\n              var v0 = arrayIn[0][j];\n              var v1 = arrayIn[1][j];\n\n              if (isValidCategory(v0) && isValidCategory(v1)) {\n                list.push([v0, v1]);\n\n                if (!(v0 in seen[0][1])) {\n                  seen[0][1][v0] = seen[0][0]++;\n                }\n\n                if (!(v1 in seen[1][1])) {\n                  seen[1][1][v1] = seen[1][0]++;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      list.sort(function (a, b) {\n        var ind0 = seen[0][1];\n        var d = ind0[a[0]] - ind0[b[0]];\n        if (d) return d;\n        var ind1 = seen[1][1];\n        return ind1[a[1]] - ind1[b[1]];\n      });\n\n      for (i = 0; i < list.length; i++) {\n        setCategoryIndex(list[i]);\n      }\n    };\n  } // find the range value at the specified (linear) fraction of the axis\n\n\n  ax.fraction2r = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return ax.l2r(rl0 + v * (rl1 - rl0));\n  }; // find the fraction of the range at the specified range value\n\n\n  ax.r2fraction = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return (ax.r2l(v) - rl0) / (rl1 - rl0);\n  };\n  /*\n   * cleanRange: make sure range is a couplet of valid & distinct values\n   * keep numbers away from the limits of floating point numbers,\n   * and dates away from the ends of our date system (+/- 9999 years)\n   *\n   * optional param rangeAttr: operate on a different attribute, like\n   * ax._r, rather than ax.range\n   */\n\n\n  ax.cleanRange = function (rangeAttr, opts) {\n    if (!opts) opts = {};\n    if (!rangeAttr) rangeAttr = 'range';\n    var range = Lib.nestedProperty(ax, rangeAttr).get();\n    var i, dflt;\n    if (ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);else if (axLetter === 'y') dflt = constants.DFLTRANGEY;else if (ax._name === 'realaxis') dflt = [0, 1];else dflt = opts.dfltRange || constants.DFLTRANGEX; // make sure we don't later mutate the defaults\n\n    dflt = dflt.slice();\n\n    if (ax.rangemode === 'tozero' || ax.rangemode === 'nonnegative') {\n      dflt[0] = 0;\n    }\n\n    if (!range || range.length !== 2) {\n      Lib.nestedProperty(ax, rangeAttr).set(dflt);\n      return;\n    }\n\n    if (ax.type === 'date' && !ax.autorange) {\n      // check if milliseconds or js date objects are provided for range\n      // and convert to date strings\n      range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n      range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n    }\n\n    for (i = 0; i < 2; i++) {\n      if (ax.type === 'date') {\n        if (!Lib.isDateTime(range[i], ax.calendar)) {\n          ax[rangeAttr] = dflt;\n          break;\n        }\n\n        if (ax.r2l(range[0]) === ax.r2l(range[1])) {\n          // split by +/- 1 second\n          var linCenter = Lib.constrain(ax.r2l(range[0]), Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n          range[0] = ax.l2r(linCenter - 1000);\n          range[1] = ax.l2r(linCenter + 1000);\n          break;\n        }\n      } else {\n        if (!isNumeric(range[i])) {\n          if (isNumeric(range[1 - i])) {\n            range[i] = range[1 - i] * (i ? 10 : 0.1);\n          } else {\n            ax[rangeAttr] = dflt;\n            break;\n          }\n        }\n\n        if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;else if (range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n        if (range[0] === range[1]) {\n          // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n          var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n          range[0] -= inc;\n          range[1] += inc;\n        }\n      }\n    }\n  }; // set scaling to pixels\n\n\n  ax.setScale = function (usePrivateRange) {\n    var gs = fullLayout._size; // make sure we have a domain (pull it in from the axis\n    // this one is overlaying if necessary)\n\n    if (ax.overlaying) {\n      var ax2 = axisIds.getFromId({\n        _fullLayout: fullLayout\n      }, ax.overlaying);\n      ax.domain = ax2.domain;\n    } // While transitions are occurring, we get a double-transform\n    // issue if we transform the drawn layer *and* use the new axis range to\n    // draw the data. This allows us to construct setConvert using the pre-\n    // interaction values of the range:\n\n\n    var rangeAttr = usePrivateRange && ax._r ? '_r' : 'range';\n    var calendar = ax.calendar;\n    ax.cleanRange(rangeAttr);\n    var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n    var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n    var isY = axLetter === 'y';\n\n    if (isY) {\n      ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n      ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl0 - rl1);\n      ax._b = -ax._m * rl1;\n    } else {\n      ax._offset = gs.l + ax.domain[0] * gs.w;\n      ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl1 - rl0);\n      ax._b = -ax._m * rl0;\n    } // set of \"N\" disjoint rangebreaks inside the range\n\n\n    ax._rangebreaks = []; // length of these rangebreaks in value space - negative on reversed axes\n\n    ax._lBreaks = 0; // l2p slope (same for all intervals)\n\n    ax._m2 = 0; // set of l2p offsets (one for each of the (N+1) piecewise intervals)\n\n    ax._B = [];\n\n    if (ax.rangebreaks) {\n      var i, brk;\n      ax._rangebreaks = ax.locateBreaks(Math.min(rl0, rl1), Math.max(rl0, rl1));\n\n      if (ax._rangebreaks.length) {\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          ax._lBreaks += Math.abs(brk.max - brk.min);\n        }\n\n        var flip = isY;\n        if (rl0 > rl1) flip = !flip;\n        if (flip) ax._rangebreaks.reverse();\n        var sign = flip ? -1 : 1;\n        ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);\n\n        ax._B.push(-ax._m2 * (isY ? rl1 : rl0));\n\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n\n          ax._B.push(ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min));\n        } // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2l`\n\n\n        for (i = 0; i < ax._rangebreaks.length; i++) {\n          brk = ax._rangebreaks[i];\n          brk.pmin = l2p(brk.min);\n          brk.pmax = l2p(brk.max);\n        }\n      }\n    }\n\n    if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {\n      fullLayout._replotting = false;\n      throw new Error('Something went wrong with axis scaling');\n    }\n  };\n\n  ax.maskBreaks = function (v) {\n    var rangebreaksIn = ax.rangebreaks || [];\n    var bnds, b0, b1, vb, vDate;\n\n    if (!rangebreaksIn._cachedPatterns) {\n      rangebreaksIn._cachedPatterns = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.bounds ? Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.d2c // case of pattern: ''\n        ) : null;\n      });\n    }\n\n    if (!rangebreaksIn._cachedValues) {\n      rangebreaksIn._cachedValues = rangebreaksIn.map(function (brk) {\n        return brk.enabled && brk.values ? Lib.simpleMap(brk.values, ax.d2c).sort(Lib.sorterAsc) : null;\n      });\n    }\n\n    for (var i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var pattern = brk.pattern;\n          bnds = rangebreaksIn._cachedPatterns[i];\n          b0 = bnds[0];\n          b1 = bnds[1];\n\n          switch (pattern) {\n            case WEEKDAY_PATTERN:\n              vDate = new Date(v);\n              vb = vDate.getUTCDay();\n\n              if (b0 > b1) {\n                b1 += 7;\n                if (vb < b0) vb += 7;\n              }\n\n              break;\n\n            case HOUR_PATTERN:\n              vDate = new Date(v);\n              var hours = vDate.getUTCHours();\n              var minutes = vDate.getUTCMinutes();\n              var seconds = vDate.getUTCSeconds();\n              var milliseconds = vDate.getUTCMilliseconds();\n              vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 3600000);\n\n              if (b0 > b1) {\n                b1 += 24;\n                if (vb < b0) vb += 24;\n              }\n\n              break;\n\n            case '':\n              // N.B. should work on date axes as well!\n              // e.g. { bounds: ['2020-01-04', '2020-01-05 23:59'] }\n              // TODO should work with reversed-range axes\n              vb = v;\n              break;\n          }\n\n          if (vb >= b0 && vb < b1) return BADNUM;\n        } else {\n          var vals = rangebreaksIn._cachedValues[i];\n\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            if (v >= b0 && v < b1) return BADNUM;\n          }\n        }\n      }\n    }\n\n    return v;\n  };\n\n  ax.locateBreaks = function (r0, r1) {\n    var i, bnds, b0, b1;\n    var rangebreaksOut = [];\n    if (!ax.rangebreaks) return rangebreaksOut;\n    var rangebreaksIn = ax.rangebreaks.slice().sort(function (a, b) {\n      if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;\n      if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;\n      return 0;\n    });\n\n    var addBreak = function addBreak(min, max) {\n      min = Lib.constrain(min, r0, r1);\n      max = Lib.constrain(max, r0, r1);\n      if (min === max) return;\n      var isNewBreak = true;\n\n      for (var j = 0; j < rangebreaksOut.length; j++) {\n        var brkj = rangebreaksOut[j];\n\n        if (min < brkj.max && max >= brkj.min) {\n          if (min < brkj.min) {\n            brkj.min = min;\n          }\n\n          if (max > brkj.max) {\n            brkj.max = max;\n          }\n\n          isNewBreak = false;\n        }\n      }\n\n      if (isNewBreak) {\n        rangebreaksOut.push({\n          min: min,\n          max: max\n        });\n      }\n    };\n\n    for (i = 0; i < rangebreaksIn.length; i++) {\n      var brk = rangebreaksIn[i];\n\n      if (brk.enabled) {\n        if (brk.bounds) {\n          var t0 = r0;\n          var t1 = r1;\n\n          if (brk.pattern) {\n            // to remove decimal (most often found in auto ranges)\n            t0 = Math.floor(t0);\n          }\n\n          bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);\n          b0 = bnds[0];\n          b1 = bnds[1]; // r0 value as date\n\n          var t0Date = new Date(t0); // r0 value for break pattern\n\n          var bndDelta; // step in ms between rangebreaks\n\n          var step;\n\n          switch (brk.pattern) {\n            case WEEKDAY_PATTERN:\n              step = ONEWEEK;\n              bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;\n              t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n\n            case HOUR_PATTERN:\n              step = ONEDAY;\n              bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;\n              t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());\n              break;\n\n            default:\n              t0 = Math.min(bnds[0], bnds[1]);\n              t1 = Math.max(bnds[0], bnds[1]);\n              step = t1 - t0;\n              bndDelta = step;\n          }\n\n          for (var t = t0; t < t1; t += step) {\n            addBreak(t, t + bndDelta);\n          }\n        } else {\n          var vals = Lib.simpleMap(brk.values, ax.d2c);\n\n          for (var j = 0; j < vals.length; j++) {\n            b0 = vals[j];\n            b1 = b0 + brk.dvalue;\n            addBreak(b0, b1);\n          }\n        }\n      }\n    }\n\n    rangebreaksOut.sort(function (a, b) {\n      return a.min - b.min;\n    });\n    return rangebreaksOut;\n  }; // makeCalcdata: takes an x or y array and converts it\n  // to a position on the axis object \"ax\"\n  // inputs:\n  //      trace - a data object from gd.data\n  //      axLetter - a string, either 'x' or 'y', for which item\n  //          to convert (TODO: is this now always the same as\n  //          the first letter of ax._id?)\n  // in case the expected data isn't there, make a list of\n  // integers based on the opposite data\n\n\n  ax.makeCalcdata = function (trace, axLetter, opts) {\n    var arrayIn, arrayOut, i, len;\n    var axType = ax.type;\n    var cal = axType === 'date' && trace[axLetter + 'calendar'];\n\n    if (axLetter in trace) {\n      arrayIn = trace[axLetter];\n      len = trace._length || Lib.minRowLength(arrayIn);\n\n      if (Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n\n      if (axType === 'multicategory') {\n        return setMultiCategoryIndex(arrayIn, len);\n      }\n\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);\n      }\n    } else {\n      var v0 = axLetter + '0' in trace ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n      var dv = trace['d' + axLetter] ? Number(trace['d' + axLetter]) : 1; // the opposing data, for size if we have x and dx etc\n\n      arrayIn = trace[{\n        x: 'y',\n        y: 'x'\n      }[axLetter]];\n      len = trace._length || arrayIn.length;\n      arrayOut = new Array(len);\n\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    } // mask (i.e. set to BADNUM) coords that fall inside rangebreaks\n\n\n    if (ax.rangebreaks) {\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.maskBreaks(arrayOut[i]);\n      }\n    }\n\n    return arrayOut;\n  };\n\n  ax.isValidRange = function (range) {\n    return Array.isArray(range) && range.length === 2 && isNumeric(ax.r2l(range[0])) && isNumeric(ax.r2l(range[1]));\n  };\n\n  ax.isPtWithinRange = function (d, calendar) {\n    var coord = ax.c2l(d[axLetter], null, calendar);\n    var r0 = ax.r2l(ax.range[0]);\n    var r1 = ax.r2l(ax.range[1]);\n\n    if (r0 < r1) {\n      return r0 <= coord && coord <= r1;\n    } else {\n      // Reversed axis case.\n      return r1 <= coord && coord <= r0;\n    }\n  };\n\n  ax._emptyCategories = function () {\n    ax._categories = [];\n    ax._categoriesMap = {};\n  }; // should skip if not category nor multicategory\n\n\n  ax.clearCalc = function () {\n    var group = ax._matchGroup;\n\n    if (group) {\n      var categories = null;\n      var categoriesMap = null;\n\n      for (var axId2 in group) {\n        var ax2 = fullLayout[axisIds.id2name(axId2)];\n\n        if (ax2._categories) {\n          categories = ax2._categories;\n          categoriesMap = ax2._categoriesMap;\n          break;\n        }\n      }\n\n      if (categories && categoriesMap) {\n        ax._categories = categories;\n        ax._categoriesMap = categoriesMap;\n      } else {\n        ax._emptyCategories();\n      }\n    } else {\n      ax._emptyCategories();\n    }\n\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n  }; // sort the axis (and all the matching ones) by _initialCategories\n  // returns the indices of the traces affected by the reordering\n\n\n  ax.sortByInitialCategories = function () {\n    var affectedTraces = [];\n\n    ax._emptyCategories();\n\n    if (ax._initialCategories) {\n      for (var j = 0; j < ax._initialCategories.length; j++) {\n        setCategoryIndex(ax._initialCategories[j]);\n      }\n    }\n\n    affectedTraces = affectedTraces.concat(ax._traceIndices); // Propagate to matching axes\n\n    var group = ax._matchGroup;\n\n    for (var axId2 in group) {\n      if (axId === axId2) continue;\n      var ax2 = fullLayout[axisIds.id2name(axId2)];\n      ax2._categories = ax._categories;\n      ax2._categoriesMap = ax._categoriesMap;\n      affectedTraces = affectedTraces.concat(ax2._traceIndices);\n    }\n\n    return affectedTraces;\n  }; // Propagate localization into the axis so that\n  // methods in Axes can use it w/o having to pass fullLayout\n  // Default (non-d3) number formatting uses separators directly\n  // dates and d3-formatted numbers use the d3 locale\n  // Fall back on default format for dummy axes that don't care about formatting\n\n\n  var locale = fullLayout._d3locale;\n\n  if (ax.type === 'date') {\n    ax._dateFormat = locale ? locale.timeFormat : utcFormat;\n    ax._extraFormat = fullLayout._extraFormat;\n  } // occasionally we need _numFormat to pass through\n  // even though it won't be needed by this axis\n\n\n  ax._separators = fullLayout.separators;\n  ax._numFormat = locale ? locale.numberFormat : numberFormat; // and for bar charts and box plots: reset forced minimum tick spacing\n\n  delete ax._minDtick;\n  delete ax._forceTick0;\n};","map":null,"metadata":{},"sourceType":"script"}