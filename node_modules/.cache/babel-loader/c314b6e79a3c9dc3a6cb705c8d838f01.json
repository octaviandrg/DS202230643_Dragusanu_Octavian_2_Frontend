{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Registry = require('../../registry');\n\nvar Color = require('../../components/color');\n\nvar handlePeriodDefaults = require('../scatter/period_defaults');\n\nvar handleGroupingDefaults = require('../bar/defaults').handleGroupingDefaults;\n\nvar autoType = require('../../plots/cartesian/axis_autotype');\n\nvar attributes = require('./attributes');\n\nfunction supplyDefaults(traceIn, traceOut, defaultColor, layout) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);\n  }\n\n  handleSampleDefaults(traceIn, traceOut, coerce, layout);\n  if (traceOut.visible === false) return;\n  handlePeriodDefaults(traceIn, traceOut, layout, coerce);\n  coerce('xhoverformat');\n  coerce('yhoverformat');\n  var hasPreCompStats = traceOut._hasPreCompStats;\n\n  if (hasPreCompStats) {\n    coerce('lowerfence');\n    coerce('upperfence');\n  }\n\n  coerce('line.color', (traceIn.marker || {}).color || defaultColor);\n  coerce('line.width');\n  coerce('fillcolor', Color.addOpacity(traceOut.line.color, 0.5));\n  var boxmeanDflt = false;\n\n  if (hasPreCompStats) {\n    var mean = coerce('mean');\n    var sd = coerce('sd');\n\n    if (mean && mean.length) {\n      boxmeanDflt = true;\n      if (sd && sd.length) boxmeanDflt = 'sd';\n    }\n  }\n\n  coerce('boxmean', boxmeanDflt);\n  coerce('whiskerwidth');\n  coerce('width');\n  coerce('quartilemethod');\n  var notchedDflt = false;\n\n  if (hasPreCompStats) {\n    var notchspan = coerce('notchspan');\n\n    if (notchspan && notchspan.length) {\n      notchedDflt = true;\n    }\n  } else if (Lib.validate(traceIn.notchwidth, attributes.notchwidth)) {\n    notchedDflt = true;\n  }\n\n  var notched = coerce('notched', notchedDflt);\n  if (notched) coerce('notchwidth');\n  handlePointsDefaults(traceIn, traceOut, coerce, {\n    prefix: 'box'\n  });\n}\n\nfunction handleSampleDefaults(traceIn, traceOut, coerce, layout) {\n  function getDims(arr) {\n    var dims = 0;\n\n    if (arr && arr.length) {\n      dims += 1;\n\n      if (Lib.isArrayOrTypedArray(arr[0]) && arr[0].length) {\n        dims += 1;\n      }\n    }\n\n    return dims;\n  }\n\n  function valid(astr) {\n    return Lib.validate(traceIn[astr], attributes[astr]);\n  }\n\n  var y = coerce('y');\n  var x = coerce('x');\n  var sLen;\n\n  if (traceOut.type === 'box') {\n    var q1 = coerce('q1');\n    var median = coerce('median');\n    var q3 = coerce('q3');\n    traceOut._hasPreCompStats = q1 && q1.length && median && median.length && q3 && q3.length;\n    sLen = Math.min(Lib.minRowLength(q1), Lib.minRowLength(median), Lib.minRowLength(q3));\n  }\n\n  var yDims = getDims(y);\n  var xDims = getDims(x);\n  var yLen = yDims && Lib.minRowLength(y);\n  var xLen = xDims && Lib.minRowLength(x);\n  var calendar = layout.calendar;\n  var opts = {\n    autotypenumbers: layout.autotypenumbers\n  };\n  var defaultOrientation, len;\n\n  if (traceOut._hasPreCompStats) {\n    switch (String(xDims) + String(yDims)) {\n      // no x / no y\n      case '00':\n        var setInX = valid('x0') || valid('dx');\n        var setInY = valid('y0') || valid('dy');\n\n        if (setInY && !setInX) {\n          defaultOrientation = 'h';\n        } else {\n          defaultOrientation = 'v';\n        }\n\n        len = sLen;\n        break;\n      // just x\n\n      case '10':\n        defaultOrientation = 'v';\n        len = Math.min(sLen, xLen);\n        break;\n\n      case '20':\n        defaultOrientation = 'h';\n        len = Math.min(sLen, x.length);\n        break;\n      // just y\n\n      case '01':\n        defaultOrientation = 'h';\n        len = Math.min(sLen, yLen);\n        break;\n\n      case '02':\n        defaultOrientation = 'v';\n        len = Math.min(sLen, y.length);\n        break;\n      // both\n\n      case '12':\n        defaultOrientation = 'v';\n        len = Math.min(sLen, xLen, y.length);\n        break;\n\n      case '21':\n        defaultOrientation = 'h';\n        len = Math.min(sLen, x.length, yLen);\n        break;\n\n      case '11':\n        // this one is ill-defined\n        len = 0;\n        break;\n\n      case '22':\n        var hasCategories = false;\n        var i;\n\n        for (i = 0; i < x.length; i++) {\n          if (autoType(x[i], calendar, opts) === 'category') {\n            hasCategories = true;\n            break;\n          }\n        }\n\n        if (hasCategories) {\n          defaultOrientation = 'v';\n          len = Math.min(sLen, xLen, y.length);\n        } else {\n          for (i = 0; i < y.length; i++) {\n            if (autoType(y[i], calendar, opts) === 'category') {\n              hasCategories = true;\n              break;\n            }\n          }\n\n          if (hasCategories) {\n            defaultOrientation = 'h';\n            len = Math.min(sLen, x.length, yLen);\n          } else {\n            defaultOrientation = 'v';\n            len = Math.min(sLen, xLen, y.length);\n          }\n        }\n\n        break;\n    }\n  } else if (yDims > 0) {\n    defaultOrientation = 'v';\n\n    if (xDims > 0) {\n      len = Math.min(xLen, yLen);\n    } else {\n      len = Math.min(yLen);\n    }\n  } else if (xDims > 0) {\n    defaultOrientation = 'h';\n    len = Math.min(xLen);\n  } else {\n    len = 0;\n  }\n\n  if (!len) {\n    traceOut.visible = false;\n    return;\n  }\n\n  traceOut._length = len;\n  var orientation = coerce('orientation', defaultOrientation); // these are just used for positioning, they never define the sample\n\n  if (traceOut._hasPreCompStats) {\n    if (orientation === 'v' && xDims === 0) {\n      coerce('x0', 0);\n      coerce('dx', 1);\n    } else if (orientation === 'h' && yDims === 0) {\n      coerce('y0', 0);\n      coerce('dy', 1);\n    }\n  } else {\n    if (orientation === 'v' && xDims === 0) {\n      coerce('x0');\n    } else if (orientation === 'h' && yDims === 0) {\n      coerce('y0');\n    }\n  }\n\n  var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleTraceDefaults');\n  handleCalendarDefaults(traceIn, traceOut, ['x', 'y'], layout);\n}\n\nfunction handlePointsDefaults(traceIn, traceOut, coerce, opts) {\n  var prefix = opts.prefix;\n  var outlierColorDflt = Lib.coerce2(traceIn, traceOut, attributes, 'marker.outliercolor');\n  var lineoutliercolor = coerce('marker.line.outliercolor');\n  var modeDflt = 'outliers';\n\n  if (traceOut._hasPreCompStats) {\n    modeDflt = 'all';\n  } else if (outlierColorDflt || lineoutliercolor) {\n    modeDflt = 'suspectedoutliers';\n  }\n\n  var mode = coerce(prefix + 'points', modeDflt);\n\n  if (mode) {\n    coerce('jitter', mode === 'all' ? 0.3 : 0);\n    coerce('pointpos', mode === 'all' ? -1.5 : 0);\n    coerce('marker.symbol');\n    coerce('marker.opacity');\n    coerce('marker.size');\n    coerce('marker.angle');\n    coerce('marker.color', traceOut.line.color);\n    coerce('marker.line.color');\n    coerce('marker.line.width');\n\n    if (mode === 'suspectedoutliers') {\n      coerce('marker.line.outliercolor', traceOut.marker.color);\n      coerce('marker.line.outlierwidth');\n    }\n\n    coerce('selected.marker.color');\n    coerce('unselected.marker.color');\n    coerce('selected.marker.size');\n    coerce('unselected.marker.size');\n    coerce('text');\n    coerce('hovertext');\n  } else {\n    delete traceOut.marker;\n  }\n\n  var hoveron = coerce('hoveron');\n\n  if (hoveron === 'all' || hoveron.indexOf('points') !== -1) {\n    coerce('hovertemplate');\n  }\n\n  Lib.coerceSelectionMarkerOpacity(traceOut, coerce);\n}\n\nfunction crossTraceDefaults(fullData, fullLayout) {\n  var traceIn, traceOut;\n\n  function coerce(attr) {\n    return Lib.coerce(traceOut._input, traceOut, attributes, attr);\n  }\n\n  for (var i = 0; i < fullData.length; i++) {\n    traceOut = fullData[i];\n    var traceType = traceOut.type;\n\n    if (traceType === 'box' || traceType === 'violin') {\n      traceIn = traceOut._input;\n\n      if (fullLayout[traceType + 'mode'] === 'group') {\n        handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce);\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  supplyDefaults: supplyDefaults,\n  crossTraceDefaults: crossTraceDefaults,\n  handleSampleDefaults: handleSampleDefaults,\n  handlePointsDefaults: handlePointsDefaults\n};","map":null,"metadata":{},"sourceType":"script"}