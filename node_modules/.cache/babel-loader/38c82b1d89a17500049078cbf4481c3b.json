{"ast":null,"code":"var π = Math.PI;\n\nvar _120 = radians(120);\n\nmodule.exports = normalize;\n/**\n * describe `path` in terms of cubic bézier \n * curves and move commands\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction normalize(path) {\n  // init state\n  var prev;\n  var result = [];\n  var bezierX = 0;\n  var bezierY = 0;\n  var startX = 0;\n  var startY = 0;\n  var quadX = null;\n  var quadY = null;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    var seg = path[i];\n    var command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n\n      case 'A':\n        seg = arc(x, y, seg[1], seg[2], radians(seg[3]), seg[4], seg[5], seg[6], seg[7]); // split multi part\n\n        seg.unshift('C');\n\n        if (seg.length > 7) {\n          result.push(seg.splice(0, 7));\n          seg.unshift('C');\n        }\n\n        break;\n\n      case 'S':\n        // default control point\n        var cx = x;\n        var cy = y;\n\n        if (prev == 'C' || prev == 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n\n          cy += cy - bezierY; // point relative to the current point\n        }\n\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n\n      case 'T':\n        if (prev == 'Q' || prev == 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n    } // update state\n\n\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n\n    result.push(seg);\n  }\n\n  return result;\n}\n\nfunction line(x1, y1, x2, y2) {\n  return ['C', x1, y1, x2, y2, x2, y2];\n}\n\nfunction quadratic(x1, y1, cx, cy, x2, y2) {\n  return ['C', x1 / 3 + 2 / 3 * cx, y1 / 3 + 2 / 3 * cy, x2 / 3 + 2 / 3 * cx, y2 / 3 + 2 / 3 * cy, x2, y2];\n} // This function is ripped from \n// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 \n// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n// TODO: make it human readable\n\n\nfunction arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  if (!recursive) {\n    var xy = rotate(x1, y1, -angle);\n    x1 = xy.x;\n    y1 = xy.y;\n    xy = rotate(x2, y2, -angle);\n    x2 = xy.x;\n    y2 = xy.y;\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    if (k == Infinity) k = 1; // neutralize\n\n    var cx = k * rx * y / ry + (x1 + x2) / 2;\n    var cy = k * -ry * x / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(((y1 - cy) / ry).toFixed(9));\n    var f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? π - f1 : f1;\n    f2 = x2 < cx ? π - f2 : f2;\n    if (f1 < 0) f1 = π * 2 + f1;\n    if (f2 < 0) f2 = π * 2 + f2;\n    if (sweep_flag && f1 > f2) f1 = f1 - π * 2;\n    if (!sweep_flag && f2 > f1) f2 = f2 - π * 2;\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  } // greater than 120 degrees requires multiple segments\n\n\n  if (Math.abs(f2 - f1) > _120) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  var t = Math.tan((f2 - f1) / 4);\n  var hx = 4 / 3 * rx * t;\n  var hy = 4 / 3 * ry * t;\n  var curve = [2 * x1 - (x1 + hx * Math.sin(f1)), 2 * y1 - (y1 - hy * Math.cos(f1)), x2 + hx * Math.sin(f2), y2 - hy * Math.cos(f2), x2, y2];\n  if (recursive) return curve;\n  if (res) curve = curve.concat(res);\n\n  for (var i = 0; i < curve.length;) {\n    var rot = rotate(curve[i], curve[i + 1], angle);\n    curve[i++] = rot.x;\n    curve[i++] = rot.y;\n  }\n\n  return curve;\n}\n\nfunction rotate(x, y, rad) {\n  return {\n    x: x * Math.cos(rad) - y * Math.sin(rad),\n    y: x * Math.sin(rad) + y * Math.cos(rad)\n  };\n}\n\nfunction radians(degress) {\n  return degress * (π / 180);\n}","map":null,"metadata":{},"sourceType":"script"}