{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nexports.moduleType = 'transform';\nexports.name = 'sort';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    editType: 'calc',\n    description: ['Determines whether this sort transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    editType: 'calc',\n    description: ['Sets the target by which the sort transform is applied.', 'If a string, *target* is assumed to be a reference to a data array', 'in the parent trace object.', 'To sort about nested variables, use *.* to access them.', 'For example, set `target` to *marker.size* to sort', 'about the marker size array.', 'If an array, *target* is then the data array by which', 'the sort transform is applied.'].join(' ')\n  },\n  order: {\n    valType: 'enumerated',\n    values: ['ascending', 'descending'],\n    dflt: 'ascending',\n    editType: 'calc',\n    description: ['Sets the sort transform order.'].join(' ')\n  },\n  editType: 'calc'\n};\n\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n\n  if (enabled) {\n    coerce('target');\n    coerce('order');\n  }\n\n  return transformOut;\n};\n\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var arrayAttrs = trace._arrayAttrs;\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var indices = getIndices(opts, targetArray, d2c, len);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n  var indexToPoints = {};\n  var i, j;\n\n  for (i = 0; i < arrayAttrs.length; i++) {\n    var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n    var arrayOld = np.get();\n    var arrayNew = new Array(len);\n\n    for (j = 0; j < len; j++) {\n      arrayNew[j] = arrayOld[indices[j]];\n    }\n\n    np.set(arrayNew);\n  }\n\n  for (j = 0; j < len; j++) {\n    indexToPoints[j] = originalPointsAccessor(indices[j]);\n  }\n\n  opts._indexToPoints = indexToPoints;\n  trace._length = len;\n};\n\nfunction getIndices(opts, targetArray, d2c, len) {\n  var sortedArray = new Array(len);\n  var indices = new Array(len);\n  var i;\n\n  for (i = 0; i < len; i++) {\n    sortedArray[i] = {\n      v: targetArray[i],\n      i: i\n    };\n  }\n\n  sortedArray.sort(getSortFunc(opts, d2c));\n\n  for (i = 0; i < len; i++) {\n    indices[i] = sortedArray[i].i;\n  }\n\n  return indices;\n}\n\nfunction getSortFunc(opts, d2c) {\n  switch (opts.order) {\n    case 'ascending':\n      return function (a, b) {\n        var ac = d2c(a.v);\n        var bc = d2c(b.v);\n\n        if (ac === BADNUM) {\n          return 1;\n        }\n\n        if (bc === BADNUM) {\n          return -1;\n        }\n\n        return ac - bc;\n      };\n\n    case 'descending':\n      return function (a, b) {\n        var ac = d2c(a.v);\n        var bc = d2c(b.v);\n\n        if (ac === BADNUM) {\n          return 1;\n        }\n\n        if (bc === BADNUM) {\n          return -1;\n        }\n\n        return bc - ac;\n      };\n  }\n}","map":null,"metadata":{},"sourceType":"script"}