{"ast":null,"code":"'use strict';\n\nvar createLine = require('regl-line2d');\n\nvar Registry = require('../../registry');\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar getModuleCalcData = require('../../plots/get_data').getModuleCalcData;\n\nvar Cartesian = require('../../plots/cartesian');\n\nvar getFromId = require('../../plots/cartesian/axis_ids').getFromId;\n\nvar shouldShowZeroLine = require('../../plots/cartesian/axes').shouldShowZeroLine;\n\nvar SPLOM = 'splom';\nvar reglPrecompiled = {};\n\nfunction plot(gd) {\n  var fullLayout = gd._fullLayout;\n\n  var _module = Registry.getModule(SPLOM);\n\n  var splomCalcData = getModuleCalcData(gd.calcdata, _module)[0];\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint'], reglPrecompiled);\n  if (!success) return;\n\n  if (fullLayout._hasOnlyLargeSploms) {\n    updateGrid(gd);\n  }\n\n  _module.plot(gd, {}, splomCalcData);\n}\n\nfunction drag(gd) {\n  var cd = gd.calcdata;\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._hasOnlyLargeSploms) {\n    updateGrid(gd);\n  }\n\n  for (var i = 0; i < cd.length; i++) {\n    var cd0 = cd[i][0];\n    var trace = cd0.trace;\n    var scene = fullLayout._splomScenes[trace.uid];\n\n    if (trace.type === 'splom' && scene && scene.matrix) {\n      dragOne(gd, trace, scene);\n    }\n  }\n}\n\nfunction dragOne(gd, trace, scene) {\n  var visibleLength = scene.matrixOptions.data.length;\n  var visibleDims = trace._visibleDims;\n  var ranges = scene.viewOpts.ranges = new Array(visibleLength);\n\n  for (var k = 0; k < visibleDims.length; k++) {\n    var i = visibleDims[k];\n    var rng = ranges[k] = new Array(4);\n    var xa = getFromId(gd, trace._diag[i][0]);\n\n    if (xa) {\n      rng[0] = xa.r2l(xa.range[0]);\n      rng[2] = xa.r2l(xa.range[1]);\n    }\n\n    var ya = getFromId(gd, trace._diag[i][1]);\n\n    if (ya) {\n      rng[1] = ya.r2l(ya.range[0]);\n      rng[3] = ya.r2l(ya.range[1]);\n    }\n  }\n\n  if (scene.selectBatch.length || scene.unselectBatch.length) {\n    scene.matrix.update({\n      ranges: ranges\n    }, {\n      ranges: ranges\n    });\n  } else {\n    scene.matrix.update({\n      ranges: ranges\n    });\n  }\n}\n\nfunction updateGrid(gd) {\n  var fullLayout = gd._fullLayout;\n\n  var regl = fullLayout._glcanvas.data()[0].regl;\n\n  var splomGrid = fullLayout._splomGrid;\n\n  if (!splomGrid) {\n    splomGrid = fullLayout._splomGrid = createLine(regl);\n  }\n\n  splomGrid.update(makeGridData(gd));\n}\n\nfunction makeGridData(gd) {\n  var plotGlPixelRatio = gd._context.plotGlPixelRatio;\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var fullView = [0, 0, fullLayout.width * plotGlPixelRatio, fullLayout.height * plotGlPixelRatio];\n  var lookup = {};\n  var k;\n\n  function push(prefix, ax, x0, x1, y0, y1) {\n    x0 *= plotGlPixelRatio;\n    x1 *= plotGlPixelRatio;\n    y0 *= plotGlPixelRatio;\n    y1 *= plotGlPixelRatio;\n    var lcolor = ax[prefix + 'color'];\n    var lwidth = ax[prefix + 'width'];\n    var key = String(lcolor + lwidth);\n\n    if (key in lookup) {\n      lookup[key].data.push(NaN, NaN, x0, x1, y0, y1);\n    } else {\n      lookup[key] = {\n        data: [x0, x1, y0, y1],\n        join: 'rect',\n        thickness: lwidth * plotGlPixelRatio,\n        color: lcolor,\n        viewport: fullView,\n        range: fullView,\n        overlay: false\n      };\n    }\n  }\n\n  for (k in fullLayout._splomSubplots) {\n    var sp = fullLayout._plots[k];\n    var xa = sp.xaxis;\n    var ya = sp.yaxis;\n    var xVals = xa._gridVals;\n    var yVals = ya._gridVals;\n    var xOffset = xa._offset;\n    var xLength = xa._length;\n    var yLength = ya._length; // ya.l2p assumes top-to-bottom coordinate system (a la SVG),\n    // we need to compute bottom-to-top offsets and slopes:\n\n    var yOffset = gs.b + ya.domain[0] * gs.h;\n    var ym = -ya._m;\n    var yb = -ym * ya.r2l(ya.range[0], ya.calendar);\n    var x, y;\n\n    if (xa.showgrid) {\n      for (k = 0; k < xVals.length; k++) {\n        x = xOffset + xa.l2p(xVals[k].x);\n        push('grid', xa, x, yOffset, x, yOffset + yLength);\n      }\n    }\n\n    if (ya.showgrid) {\n      for (k = 0; k < yVals.length; k++) {\n        y = yOffset + yb + ym * yVals[k].x;\n        push('grid', ya, xOffset, y, xOffset + xLength, y);\n      }\n    }\n\n    if (shouldShowZeroLine(gd, xa, ya)) {\n      x = xOffset + xa.l2p(0);\n      push('zeroline', xa, x, yOffset, x, yOffset + yLength);\n    }\n\n    if (shouldShowZeroLine(gd, ya, xa)) {\n      y = yOffset + yb + 0;\n      push('zeroline', ya, xOffset, y, xOffset + xLength, y);\n    }\n  }\n\n  var gridBatches = [];\n\n  for (k in lookup) {\n    gridBatches.push(lookup[k]);\n  }\n\n  return gridBatches;\n}\n\nfunction clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var lookup = {};\n  var i;\n\n  if (oldFullLayout._splomScenes) {\n    for (i = 0; i < newFullData.length; i++) {\n      var newTrace = newFullData[i];\n\n      if (newTrace.type === 'splom') {\n        lookup[newTrace.uid] = 1;\n      }\n    }\n\n    for (i = 0; i < oldFullData.length; i++) {\n      var oldTrace = oldFullData[i];\n\n      if (!lookup[oldTrace.uid]) {\n        var scene = oldFullLayout._splomScenes[oldTrace.uid];\n        if (scene && scene.destroy) scene.destroy(); // must first set scene to null in order to get garbage collected\n\n        oldFullLayout._splomScenes[oldTrace.uid] = null;\n        delete oldFullLayout._splomScenes[oldTrace.uid];\n      }\n    }\n  }\n\n  if (Object.keys(oldFullLayout._splomScenes || {}).length === 0) {\n    delete oldFullLayout._splomScenes;\n  }\n\n  if (oldFullLayout._splomGrid && !newFullLayout._hasOnlyLargeSploms && oldFullLayout._hasOnlyLargeSploms) {\n    // must first set scene to null in order to get garbage collected\n    oldFullLayout._splomGrid.destroy();\n\n    oldFullLayout._splomGrid = null;\n    delete oldFullLayout._splomGrid;\n  }\n\n  Cartesian.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n}\n\nmodule.exports = {\n  name: SPLOM,\n  attr: Cartesian.attr,\n  attrRegex: Cartesian.attrRegex,\n  layoutAttributes: Cartesian.layoutAttributes,\n  supplyLayoutDefaults: Cartesian.supplyLayoutDefaults,\n  drawFramework: Cartesian.drawFramework,\n  plot: plot,\n  drag: drag,\n  updateGrid: updateGrid,\n  clean: clean,\n  updateFx: Cartesian.updateFx,\n  toSVG: Cartesian.toSVG,\n  reglPrecompiled: reglPrecompiled\n};","map":null,"metadata":{},"sourceType":"script"}