{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\n\nvar dateTime2ms = Lib.dateTime2ms;\nvar incrementMonth = Lib.incrementMonth;\n\nvar constants = require('../../constants/numerical');\n\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\n\nmodule.exports = function alignPeriod(trace, ax, axLetter, vals) {\n  if (ax.type !== 'date') return {\n    vals: vals\n  };\n  var alignment = trace[axLetter + 'periodalignment'];\n  if (!alignment) return {\n    vals: vals\n  };\n  var period = trace[axLetter + 'period'];\n  var mPeriod;\n\n  if (isNumeric(period)) {\n    period = +period;\n    if (period <= 0) return {\n      vals: vals\n    };\n  } else if (typeof period === 'string' && period.charAt(0) === 'M') {\n    var n = +period.substring(1);\n\n    if (n > 0 && Math.round(n) === n) {\n      mPeriod = n;\n    } else return {\n      vals: vals\n    };\n  }\n\n  var calendar = ax.calendar;\n  var isStart = 'start' === alignment; // var isMiddle = 'middle' === alignment;\n\n  var isEnd = 'end' === alignment;\n  var period0 = trace[axLetter + 'period0'];\n  var base = dateTime2ms(period0, calendar) || 0;\n  var newVals = [];\n  var starts = [];\n  var ends = [];\n  var len = vals.length;\n\n  for (var i = 0; i < len; i++) {\n    var v = vals[i];\n    var nEstimated, startTime, endTime;\n\n    if (mPeriod) {\n      // guess at how many periods away from base we are\n      nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));\n      endTime = incrementMonth(base, mPeriod * nEstimated, calendar); // iterate to get the exact bounds before and after v\n      // there may be ways to make this faster, but most of the time\n      // we'll only execute each loop zero or one time.\n\n      while (endTime > v) {\n        endTime = incrementMonth(endTime, -mPeriod, calendar);\n      }\n\n      while (endTime <= v) {\n        endTime = incrementMonth(endTime, mPeriod, calendar);\n      } // now we know endTime is the boundary immediately after v\n      // so startTime is obtained by incrementing backward one period.\n\n\n      startTime = incrementMonth(endTime, -mPeriod, calendar);\n    } else {\n      // case of ms\n      nEstimated = Math.round((v - base) / period);\n      endTime = base + nEstimated * period;\n\n      while (endTime > v) {\n        endTime -= period;\n      }\n\n      while (endTime <= v) {\n        endTime += period;\n      }\n\n      startTime = endTime - period;\n    }\n\n    newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;\n    starts[i] = startTime;\n    ends[i] = endTime;\n  }\n\n  return {\n    vals: newVals,\n    starts: starts,\n    ends: ends\n  };\n};","map":null,"metadata":{},"sourceType":"script"}