{"ast":null,"code":"'use strict';\n\nvar tarjan = require('strongly-connected-components');\n\nvar Lib = require('../../lib');\n\nvar wrap = require('../../lib/gup').wrap;\n\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar isIndex = Lib.isIndex;\n\nvar Colorscale = require('../../components/colorscale');\n\nfunction convertToD3Sankey(trace) {\n  var nodeSpec = trace.node;\n  var linkSpec = trace.link;\n  var links = [];\n  var hasLinkColorArray = isArrayOrTypedArray(linkSpec.color);\n  var hasLinkCustomdataArray = isArrayOrTypedArray(linkSpec.customdata);\n  var linkedNodes = {};\n  var components = {};\n  var componentCount = linkSpec.colorscales.length;\n  var i;\n\n  for (i = 0; i < componentCount; i++) {\n    var cscale = linkSpec.colorscales[i];\n    var specs = Colorscale.extractScale(cscale, {\n      cLetter: 'c'\n    });\n    var scale = Colorscale.makeColorScaleFunc(specs);\n    components[cscale.label] = scale;\n  }\n\n  var maxNodeId = 0;\n\n  for (i = 0; i < linkSpec.value.length; i++) {\n    if (linkSpec.source[i] > maxNodeId) maxNodeId = linkSpec.source[i];\n    if (linkSpec.target[i] > maxNodeId) maxNodeId = linkSpec.target[i];\n  }\n\n  var nodeCount = maxNodeId + 1;\n  trace.node._count = nodeCount; // Group nodes\n\n  var j;\n  var groups = trace.node.groups;\n  var groupLookup = {};\n\n  for (i = 0; i < groups.length; i++) {\n    var group = groups[i]; // Build a lookup table to quickly find in which group a node is\n\n    for (j = 0; j < group.length; j++) {\n      var nodeIndex = group[j];\n      var groupIndex = nodeCount + i;\n\n      if (groupLookup.hasOwnProperty(nodeIndex)) {\n        Lib.warn('Node ' + nodeIndex + ' is already part of a group.');\n      } else {\n        groupLookup[nodeIndex] = groupIndex;\n      }\n    }\n  } // Process links\n\n\n  var groupedLinks = {\n    source: [],\n    target: []\n  };\n\n  for (i = 0; i < linkSpec.value.length; i++) {\n    var val = linkSpec.value[i]; // remove negative values, but keep zeros with special treatment\n\n    var source = linkSpec.source[i];\n    var target = linkSpec.target[i];\n\n    if (!(val > 0 && isIndex(source, nodeCount) && isIndex(target, nodeCount))) {\n      continue;\n    } // Remove links that are within the same group\n\n\n    if (groupLookup.hasOwnProperty(source) && groupLookup.hasOwnProperty(target) && groupLookup[source] === groupLookup[target]) {\n      continue;\n    } // if link targets a node in the group, relink target to that group\n\n\n    if (groupLookup.hasOwnProperty(target)) {\n      target = groupLookup[target];\n    } // if link originates from a node in a group, relink source to that group\n\n\n    if (groupLookup.hasOwnProperty(source)) {\n      source = groupLookup[source];\n    }\n\n    source = +source;\n    target = +target;\n    linkedNodes[source] = linkedNodes[target] = true;\n    var label = '';\n    if (linkSpec.label && linkSpec.label[i]) label = linkSpec.label[i];\n    var concentrationscale = null;\n    if (label && components.hasOwnProperty(label)) concentrationscale = components[label];\n    links.push({\n      pointNumber: i,\n      label: label,\n      color: hasLinkColorArray ? linkSpec.color[i] : linkSpec.color,\n      customdata: hasLinkCustomdataArray ? linkSpec.customdata[i] : linkSpec.customdata,\n      concentrationscale: concentrationscale,\n      source: source,\n      target: target,\n      value: +val\n    });\n    groupedLinks.source.push(source);\n    groupedLinks.target.push(target);\n  } // Process nodes\n\n\n  var totalCount = nodeCount + groups.length;\n  var hasNodeColorArray = isArrayOrTypedArray(nodeSpec.color);\n  var hasNodeCustomdataArray = isArrayOrTypedArray(nodeSpec.customdata);\n  var nodes = [];\n\n  for (i = 0; i < totalCount; i++) {\n    if (!linkedNodes[i]) continue;\n    var l = nodeSpec.label[i];\n    nodes.push({\n      group: i > nodeCount - 1,\n      childrenNodes: [],\n      pointNumber: i,\n      label: l,\n      color: hasNodeColorArray ? nodeSpec.color[i] : nodeSpec.color,\n      customdata: hasNodeCustomdataArray ? nodeSpec.customdata[i] : nodeSpec.customdata\n    });\n  } // Check if we have circularity on the resulting graph\n\n\n  var circular = false;\n\n  if (circularityPresent(totalCount, groupedLinks.source, groupedLinks.target)) {\n    circular = true;\n  }\n\n  return {\n    circular: circular,\n    links: links,\n    nodes: nodes,\n    // Data structure for groups\n    groups: groups,\n    groupLookup: groupLookup\n  };\n}\n\nfunction circularityPresent(nodeLen, sources, targets) {\n  var nodes = Lib.init2dArray(nodeLen, 0);\n\n  for (var i = 0; i < Math.min(sources.length, targets.length); i++) {\n    if (Lib.isIndex(sources[i], nodeLen) && Lib.isIndex(targets[i], nodeLen)) {\n      if (sources[i] === targets[i]) {\n        return true; // self-link which is also a scc of one\n      }\n\n      nodes[sources[i]].push(targets[i]);\n    }\n  }\n\n  var scc = tarjan(nodes); // TarjÃ¡n's strongly connected components algorithm coded by Mikola Lysenko\n  // returns at least one non-singular component if there's circularity in the graph\n\n  return scc.components.some(function (c) {\n    return c.length > 1;\n  });\n}\n\nmodule.exports = function calc(gd, trace) {\n  var result = convertToD3Sankey(trace);\n  return wrap({\n    circular: result.circular,\n    _nodes: result.nodes,\n    _links: result.links,\n    // Data structure for grouping\n    _groups: result.groups,\n    _groupLookup: result.groupLookup\n  });\n};","map":null,"metadata":{},"sourceType":"script"}