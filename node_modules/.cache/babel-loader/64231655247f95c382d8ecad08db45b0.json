{"ast":null,"code":"'use strict';\n\nvar createSurface = require('../../../stackgl_modules').gl_surface3d;\n\nvar ndarray = require('../../../stackgl_modules').ndarray;\n\nvar ndarrayInterp2d = require('../../../stackgl_modules').ndarray_linear_interpolate.d2;\n\nvar interp2d = require('../heatmap/interp2d');\n\nvar findEmpties = require('../heatmap/find_empties');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nfunction SurfaceTrace(scene, surface, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.surface = surface;\n  this.data = null;\n  this.showContour = [false, false, false];\n  this.contourStart = [null, null, null];\n  this.contourEnd = [null, null, null];\n  this.contourSize = [0, 0, 0];\n  this.minValues = [Infinity, Infinity, Infinity];\n  this.maxValues = [-Infinity, -Infinity, -Infinity];\n  this.dataScaleX = 1.0;\n  this.dataScaleY = 1.0;\n  this.refineData = true;\n  this.objectOffset = [0, 0, 0];\n}\n\nvar proto = SurfaceTrace.prototype;\n\nproto.getXat = function (a, b, calendar, axis) {\n  var v = !isArrayOrTypedArray(this.data.x) ? a : isArrayOrTypedArray(this.data.x[0]) ? this.data.x[b][a] : this.data.x[a];\n  return calendar === undefined ? v : axis.d2l(v, 0, calendar);\n};\n\nproto.getYat = function (a, b, calendar, axis) {\n  var v = !isArrayOrTypedArray(this.data.y) ? b : isArrayOrTypedArray(this.data.y[0]) ? this.data.y[b][a] : this.data.y[b];\n  return calendar === undefined ? v : axis.d2l(v, 0, calendar);\n};\n\nproto.getZat = function (a, b, calendar, axis) {\n  var v = this.data.z[b][a];\n\n  if (v === null && this.data.connectgaps && this.data._interpolatedZ) {\n    v = this.data._interpolatedZ[b][a];\n  }\n\n  return calendar === undefined ? v : axis.d2l(v, 0, calendar);\n};\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.surface) {\n    var xRatio = (selection.data.index[0] - 1) / this.dataScaleX - 1;\n    var yRatio = (selection.data.index[1] - 1) / this.dataScaleY - 1;\n    var j = Math.max(Math.min(Math.round(xRatio), this.data.z[0].length - 1), 0);\n    var k = Math.max(Math.min(Math.round(yRatio), this.data._ylength - 1), 0);\n    selection.index = [j, k];\n    selection.traceCoordinate = [this.getXat(j, k), this.getYat(j, k), this.getZat(j, k)];\n    selection.dataCoordinate = [this.getXat(j, k, this.data.xcalendar, this.scene.fullSceneLayout.xaxis), this.getYat(j, k, this.data.ycalendar, this.scene.fullSceneLayout.yaxis), this.getZat(j, k, this.data.zcalendar, this.scene.fullSceneLayout.zaxis)];\n\n    for (var i = 0; i < 3; i++) {\n      var v = selection.dataCoordinate[i];\n\n      if (v !== null && v !== undefined) {\n        selection.dataCoordinate[i] *= this.scene.dataScale[i];\n      }\n    }\n\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[k] && text[k][j] !== undefined) {\n      selection.textLabel = text[k][j];\n    } else if (text) {\n      selection.textLabel = text;\n    } else {\n      selection.textLabel = '';\n    }\n\n    selection.data.dataCoordinate = selection.dataCoordinate.slice();\n    this.surface.highlight(selection.data); // Snap spikes to data coordinate\n\n    this.scene.glplot.spikes.position = selection.dataCoordinate;\n    return true;\n  }\n};\n\nfunction isColormapCircular(colormap) {\n  var first = colormap[0].rgb;\n  var last = colormap[colormap.length - 1].rgb;\n  return first[0] === last[0] && first[1] === last[1] && first[2] === last[2] && first[3] === last[3];\n}\n\nvar shortPrimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999];\n\nfunction getPow(a, b) {\n  if (a < b) return 0;\n  var n = 0;\n\n  while (Math.floor(a % b) === 0) {\n    a /= b;\n    n++;\n  }\n\n  return n;\n}\n\nfunction getFactors(a) {\n  var powers = [];\n\n  for (var i = 0; i < shortPrimes.length; i++) {\n    var b = shortPrimes[i];\n    powers.push(getPow(a, b));\n  }\n\n  return powers;\n}\n\nfunction smallestDivisor(a) {\n  var A = getFactors(a);\n  var result = a;\n\n  for (var i = 0; i < shortPrimes.length; i++) {\n    if (A[i] > 0) {\n      result = shortPrimes[i];\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction leastCommonMultiple(a, b) {\n  if (a < 1 || b < 1) return undefined;\n  var A = getFactors(a);\n  var B = getFactors(b);\n  var n = 1;\n\n  for (var i = 0; i < shortPrimes.length; i++) {\n    n *= Math.pow(shortPrimes[i], Math.max(A[i], B[i]));\n  }\n\n  return n;\n}\n\nfunction arrayLCM(A) {\n  if (A.length === 0) return undefined;\n  var n = 1;\n\n  for (var i = 0; i < A.length; i++) {\n    n = leastCommonMultiple(n, A[i]);\n  }\n\n  return n;\n}\n\nproto.calcXnums = function (xlen) {\n  var i;\n  var nums = [];\n\n  for (i = 1; i < xlen; i++) {\n    var a = this.getXat(i - 1, 0);\n    var b = this.getXat(i, 0);\n\n    if (b !== a && a !== undefined && a !== null && b !== undefined && b !== null) {\n      nums[i - 1] = Math.abs(b - a);\n    } else {\n      nums[i - 1] = 0;\n    }\n  }\n\n  var totalDist = 0;\n\n  for (i = 1; i < xlen; i++) {\n    totalDist += nums[i - 1];\n  }\n\n  for (i = 1; i < xlen; i++) {\n    if (nums[i - 1] === 0) {\n      nums[i - 1] = 1;\n    } else {\n      nums[i - 1] = Math.round(totalDist / nums[i - 1]);\n    }\n  }\n\n  return nums;\n};\n\nproto.calcYnums = function (ylen) {\n  var i;\n  var nums = [];\n\n  for (i = 1; i < ylen; i++) {\n    var a = this.getYat(0, i - 1);\n    var b = this.getYat(0, i);\n\n    if (b !== a && a !== undefined && a !== null && b !== undefined && b !== null) {\n      nums[i - 1] = Math.abs(b - a);\n    } else {\n      nums[i - 1] = 0;\n    }\n  }\n\n  var totalDist = 0;\n\n  for (i = 1; i < ylen; i++) {\n    totalDist += nums[i - 1];\n  }\n\n  for (i = 1; i < ylen; i++) {\n    if (nums[i - 1] === 0) {\n      nums[i - 1] = 1;\n    } else {\n      nums[i - 1] = Math.round(totalDist / nums[i - 1]);\n    }\n  }\n\n  return nums;\n};\n\nvar highlyComposites = [1, 2, 4, 6, 12, 24, 36, 48, 60, 120, 180, 240, 360, 720, 840, 1260];\nvar MIN_RESOLUTION = highlyComposites[9];\nvar MAX_RESOLUTION = highlyComposites[13];\n\nproto.estimateScale = function (resSrc, axis) {\n  var nums = axis === 0 ? this.calcXnums(resSrc) : this.calcYnums(resSrc);\n  var resDst = 1 + arrayLCM(nums);\n\n  while (resDst < MIN_RESOLUTION) {\n    resDst *= 2;\n  }\n\n  while (resDst > MAX_RESOLUTION) {\n    resDst--;\n    resDst /= smallestDivisor(resDst);\n    resDst++;\n\n    if (resDst < MIN_RESOLUTION) {\n      // resDst = MIN_RESOLUTION; // option 1: use min resolution\n      resDst = MAX_RESOLUTION; // option 2: use max resolution\n    }\n  }\n\n  var scale = Math.round(resDst / resSrc);\n  return scale > 1 ? scale : 1;\n}; // based on Mikola Lysenko's ndarray-homography\n// see https://github.com/scijs/ndarray-homography\n\n\nfunction fnHomography(out, inp, X) {\n  var w = X[8] + X[2] * inp[0] + X[5] * inp[1];\n  out[0] = (X[6] + X[0] * inp[0] + X[3] * inp[1]) / w;\n  out[1] = (X[7] + X[1] * inp[0] + X[4] * inp[1]) / w;\n  return out;\n}\n\nfunction homography(dest, src, X) {\n  warp(dest, src, fnHomography, X);\n  return dest;\n} // based on Mikola Lysenko's ndarray-warp\n// see https://github.com/scijs/ndarray-warp\n\n\nfunction warp(dest, src, func, X) {\n  var warped = [0, 0];\n  var ni = dest.shape[0];\n  var nj = dest.shape[1];\n\n  for (var i = 0; i < ni; i++) {\n    for (var j = 0; j < nj; j++) {\n      func(warped, [i, j], X);\n      dest.set(i, j, ndarrayInterp2d(src, warped[0], warped[1]));\n    }\n  }\n\n  return dest;\n}\n\nproto.refineCoords = function (coords) {\n  var scaleW = this.dataScaleX;\n  var scaleH = this.dataScaleY;\n  var width = coords[0].shape[0];\n  var height = coords[0].shape[1];\n  var newWidth = Math.floor(coords[0].shape[0] * scaleW + 1) | 0;\n  var newHeight = Math.floor(coords[0].shape[1] * scaleH + 1) | 0; // Pad coords by +1\n\n  var padWidth = 1 + width + 1;\n  var padHeight = 1 + height + 1;\n  var padImg = ndarray(new Float32Array(padWidth * padHeight), [padWidth, padHeight]);\n  var X = [1 / scaleW, 0, 0, 0, 1 / scaleH, 0, 0, 0, 1];\n\n  for (var i = 0; i < coords.length; ++i) {\n    this.surface.padField(padImg, coords[i]);\n    var scaledImg = ndarray(new Float32Array(newWidth * newHeight), [newWidth, newHeight]);\n    homography(scaledImg, padImg, X);\n    coords[i] = scaledImg;\n  }\n};\n\nfunction insertIfNewLevel(arr, newValue) {\n  var found = false;\n\n  for (var k = 0; k < arr.length; k++) {\n    if (newValue === arr[k]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (found === false) arr.push(newValue);\n}\n\nproto.setContourLevels = function () {\n  var newLevels = [[], [], []];\n  var useNewLevels = [false, false, false];\n  var needsUpdate = false;\n  var i, j, value;\n\n  for (i = 0; i < 3; ++i) {\n    if (this.showContour[i]) {\n      needsUpdate = true;\n\n      if (this.contourSize[i] > 0 && this.contourStart[i] !== null && this.contourEnd[i] !== null && this.contourEnd[i] > this.contourStart[i]) {\n        useNewLevels[i] = true;\n\n        for (j = this.contourStart[i]; j < this.contourEnd[i]; j += this.contourSize[i]) {\n          value = j * this.scene.dataScale[i];\n          insertIfNewLevel(newLevels[i], value);\n        }\n      }\n    }\n  }\n\n  if (needsUpdate) {\n    var allLevels = [[], [], []];\n\n    for (i = 0; i < 3; ++i) {\n      if (this.showContour[i]) {\n        allLevels[i] = useNewLevels[i] ? newLevels[i] : this.scene.contourLevels[i];\n      }\n    }\n\n    this.surface.update({\n      levels: allLevels\n    });\n  }\n};\n\nproto.update = function (data) {\n  var scene = this.scene;\n  var sceneLayout = scene.fullSceneLayout;\n  var surface = this.surface;\n  var colormap = parseColorScale(data);\n  var scaleFactor = scene.dataScale;\n  var xlen = data.z[0].length;\n  var ylen = data._ylength;\n  var contourLevels = scene.contourLevels; // Save data\n\n  this.data = data;\n  /*\n   * Fill and transpose zdata.\n   * Consistent with 'heatmap' and 'contour', plotly 'surface'\n   * 'z' are such that sub-arrays correspond to y-coords\n   * and that the sub-array entries correspond to a x-coords,\n   * which is the transpose of 'gl-surface-plot'.\n   */\n\n  var i, j, k, v;\n  var rawCoords = [];\n\n  for (i = 0; i < 3; i++) {\n    rawCoords[i] = [];\n\n    for (j = 0; j < xlen; j++) {\n      rawCoords[i][j] = [];\n      /*\n      for(k = 0; k < ylen; k++) {\n          rawCoords[i][j][k] = undefined;\n      }\n      */\n    }\n  } // coords x, y & z\n\n\n  for (j = 0; j < xlen; j++) {\n    for (k = 0; k < ylen; k++) {\n      rawCoords[0][j][k] = this.getXat(j, k, data.xcalendar, sceneLayout.xaxis);\n      rawCoords[1][j][k] = this.getYat(j, k, data.ycalendar, sceneLayout.yaxis);\n      rawCoords[2][j][k] = this.getZat(j, k, data.zcalendar, sceneLayout.zaxis);\n    }\n  }\n\n  if (data.connectgaps) {\n    data._emptypoints = findEmpties(rawCoords[2]);\n    interp2d(rawCoords[2], data._emptypoints);\n    data._interpolatedZ = [];\n\n    for (j = 0; j < xlen; j++) {\n      data._interpolatedZ[j] = [];\n\n      for (k = 0; k < ylen; k++) {\n        data._interpolatedZ[j][k] = rawCoords[2][j][k];\n      }\n    }\n  } // Note: log axes are not defined in surfaces yet.\n  // but they could be defined here...\n\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < xlen; j++) {\n      for (k = 0; k < ylen; k++) {\n        v = rawCoords[i][j][k];\n\n        if (v === null || v === undefined) {\n          rawCoords[i][j][k] = NaN;\n        } else {\n          v = rawCoords[i][j][k] *= scaleFactor[i];\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < xlen; j++) {\n      for (k = 0; k < ylen; k++) {\n        v = rawCoords[i][j][k];\n\n        if (v !== null && v !== undefined) {\n          if (this.minValues[i] > v) {\n            this.minValues[i] = v;\n          }\n\n          if (this.maxValues[i] < v) {\n            this.maxValues[i] = v;\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < 3; i++) {\n    this.objectOffset[i] = 0.5 * (this.minValues[i] + this.maxValues[i]);\n  }\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < xlen; j++) {\n      for (k = 0; k < ylen; k++) {\n        v = rawCoords[i][j][k];\n\n        if (v !== null && v !== undefined) {\n          rawCoords[i][j][k] -= this.objectOffset[i];\n        }\n      }\n    }\n  } // convert processed raw data to Float32 matrices\n\n\n  var coords = [ndarray(new Float32Array(xlen * ylen), [xlen, ylen]), ndarray(new Float32Array(xlen * ylen), [xlen, ylen]), ndarray(new Float32Array(xlen * ylen), [xlen, ylen])];\n\n  for (i = 0; i < 3; i++) {\n    for (j = 0; j < xlen; j++) {\n      for (k = 0; k < ylen; k++) {\n        coords[i].set(j, k, rawCoords[i][j][k]);\n      }\n    }\n  }\n\n  rawCoords = []; // free memory\n\n  var params = {\n    colormap: colormap,\n    levels: [[], [], []],\n    showContour: [true, true, true],\n    showSurface: !data.hidesurface,\n    contourProject: [[false, false, false], [false, false, false], [false, false, false]],\n    contourWidth: [1, 1, 1],\n    contourColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n    contourTint: [1, 1, 1],\n    dynamicColor: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n    dynamicWidth: [1, 1, 1],\n    dynamicTint: [1, 1, 1],\n    opacityscale: data.opacityscale,\n    opacity: data.opacity\n  };\n  var cOpts = extractOpts(data);\n  params.intensityBounds = [cOpts.min, cOpts.max]; // Refine surface color if necessary\n\n  if (data.surfacecolor) {\n    var intensity = ndarray(new Float32Array(xlen * ylen), [xlen, ylen]);\n\n    for (j = 0; j < xlen; j++) {\n      for (k = 0; k < ylen; k++) {\n        intensity.set(j, k, data.surfacecolor[k][j]);\n      }\n    }\n\n    coords.push(intensity);\n  } else {\n    // when 'z' is used as 'intensity',\n    // we must scale its value\n    params.intensityBounds[0] *= scaleFactor[2];\n    params.intensityBounds[1] *= scaleFactor[2];\n  }\n\n  if (MAX_RESOLUTION < coords[0].shape[0] || MAX_RESOLUTION < coords[0].shape[1]) {\n    this.refineData = false;\n  }\n\n  if (this.refineData === true) {\n    this.dataScaleX = this.estimateScale(coords[0].shape[0], 0);\n    this.dataScaleY = this.estimateScale(coords[0].shape[1], 1);\n\n    if (this.dataScaleX !== 1 || this.dataScaleY !== 1) {\n      this.refineCoords(coords);\n    }\n  }\n\n  if (data.surfacecolor) {\n    params.intensity = coords.pop();\n  }\n\n  var highlightEnable = [true, true, true];\n  var axis = ['x', 'y', 'z'];\n\n  for (i = 0; i < 3; ++i) {\n    var contourParams = data.contours[axis[i]];\n    highlightEnable[i] = contourParams.highlight;\n    params.showContour[i] = contourParams.show || contourParams.highlight;\n    if (!params.showContour[i]) continue;\n    params.contourProject[i] = [contourParams.project.x, contourParams.project.y, contourParams.project.z];\n\n    if (contourParams.show) {\n      this.showContour[i] = true;\n      params.levels[i] = contourLevels[i];\n      surface.highlightColor[i] = params.contourColor[i] = str2RgbaArray(contourParams.color);\n\n      if (contourParams.usecolormap) {\n        surface.highlightTint[i] = params.contourTint[i] = 0;\n      } else {\n        surface.highlightTint[i] = params.contourTint[i] = 1;\n      }\n\n      params.contourWidth[i] = contourParams.width;\n      this.contourStart[i] = contourParams.start;\n      this.contourEnd[i] = contourParams.end;\n      this.contourSize[i] = contourParams.size;\n    } else {\n      this.showContour[i] = false;\n      this.contourStart[i] = null;\n      this.contourEnd[i] = null;\n      this.contourSize[i] = 0;\n    }\n\n    if (contourParams.highlight) {\n      params.dynamicColor[i] = str2RgbaArray(contourParams.highlightcolor);\n      params.dynamicWidth[i] = contourParams.highlightwidth;\n    }\n  } // see https://github.com/plotly/plotly.js/issues/940\n\n\n  if (isColormapCircular(colormap)) {\n    params.vertexColor = true;\n  }\n\n  params.objectOffset = this.objectOffset;\n  params.coords = coords;\n  surface.update(params);\n  surface.visible = data.visible;\n  surface.enableDynamic = highlightEnable;\n  surface.enableHighlight = highlightEnable;\n  surface.snapToData = true;\n\n  if ('lighting' in data) {\n    surface.ambientLight = data.lighting.ambient;\n    surface.diffuseLight = data.lighting.diffuse;\n    surface.specularLight = data.lighting.specular;\n    surface.roughness = data.lighting.roughness;\n    surface.fresnel = data.lighting.fresnel;\n  }\n\n  if ('lightposition' in data) {\n    surface.lightPosition = [data.lightposition.x, data.lightposition.y, data.lightposition.z];\n  }\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.surface);\n  this.surface.dispose();\n};\n\nfunction createSurfaceTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var surface = createSurface({\n    gl: gl\n  });\n  var result = new SurfaceTrace(scene, surface, data.uid);\n  surface._trace = result;\n  result.update(data);\n  scene.glplot.add(surface);\n  return result;\n}\n\nmodule.exports = createSurfaceTrace;","map":null,"metadata":{},"sourceType":"script"}