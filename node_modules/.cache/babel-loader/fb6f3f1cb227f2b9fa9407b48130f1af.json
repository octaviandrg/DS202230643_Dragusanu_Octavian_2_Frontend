{"ast":null,"code":"'use strict';\n\nvar d3Hierarchy = require('d3-hierarchy');\n\nvar flipTree = require('./flip_tree');\n\nmodule.exports = function partition(entry, size, opts) {\n  var flipX = opts.flipX;\n  var flipY = opts.flipY;\n  var swapXY = opts.packing === 'dice-slice';\n  var top = opts.pad[flipY ? 'bottom' : 'top'];\n  var left = opts.pad[flipX ? 'right' : 'left'];\n  var right = opts.pad[flipX ? 'left' : 'right'];\n  var bottom = opts.pad[flipY ? 'top' : 'bottom'];\n  var tmp;\n\n  if (swapXY) {\n    tmp = left;\n    left = top;\n    top = tmp;\n    tmp = right;\n    right = bottom;\n    bottom = tmp;\n  }\n\n  var result = d3Hierarchy.treemap().tile(getTilingMethod(opts.packing, opts.squarifyratio)).paddingInner(opts.pad.inner).paddingLeft(left).paddingRight(right).paddingTop(top).paddingBottom(bottom).size(swapXY ? [size[1], size[0]] : size)(entry);\n\n  if (swapXY || flipX || flipY) {\n    flipTree(result, size, {\n      swapXY: swapXY,\n      flipX: flipX,\n      flipY: flipY\n    });\n  }\n\n  return result;\n};\n\nfunction getTilingMethod(key, squarifyratio) {\n  switch (key) {\n    case 'squarify':\n      return d3Hierarchy.treemapSquarify.ratio(squarifyratio);\n\n    case 'binary':\n      return d3Hierarchy.treemapBinary;\n\n    case 'dice':\n      return d3Hierarchy.treemapDice;\n\n    case 'slice':\n      return d3Hierarchy.treemapSlice;\n\n    default:\n      // i.e. 'slice-dice' | 'dice-slice'\n      return d3Hierarchy.treemapSliceDice;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}