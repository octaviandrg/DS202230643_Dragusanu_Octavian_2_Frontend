{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\n\nvar geoJsonUtils = require('../../lib/geojson_utils');\n\nvar geoUtils = require('../../lib/geo_location_utils');\n\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\n\nvar subTypes = require('../scatter/subtypes');\n\nvar style = require('./style');\n\nfunction plot(gd, geo, calcData) {\n  var scatterLayer = geo.layers.frontplot.select('.scatterlayer');\n  var gTraces = Lib.makeTraceGroups(scatterLayer, calcData, 'trace scattergeo');\n\n  function removeBADNUM(d, node) {\n    if (d.lonlat[0] === BADNUM) {\n      d3.select(node).remove();\n    }\n  } // TODO find a way to order the inner nodes on update\n\n\n  gTraces.selectAll('*').remove();\n  gTraces.each(function (calcTrace) {\n    var s = d3.select(this);\n    var trace = calcTrace[0].trace;\n\n    if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n      var lineCoords = geoJsonUtils.calcTraceToLineCoords(calcTrace);\n      var lineData = trace.fill !== 'none' ? geoJsonUtils.makePolygon(lineCoords) : geoJsonUtils.makeLine(lineCoords);\n      s.selectAll('path.js-line').data([{\n        geojson: lineData,\n        trace: trace\n      }]).enter().append('path').classed('js-line', true).style('stroke-miterlimit', 2);\n    }\n\n    if (subTypes.hasMarkers(trace)) {\n      s.selectAll('path.point').data(Lib.identity).enter().append('path').classed('point', true).each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    }\n\n    if (subTypes.hasText(trace)) {\n      s.selectAll('g').data(Lib.identity).enter().append('g').append('text').each(function (calcPt) {\n        removeBADNUM(calcPt, this);\n      });\n    } // call style here within topojson request callback\n\n\n    style(gd, calcTrace);\n  });\n}\n\nfunction calcGeoJSON(calcTrace, fullLayout) {\n  var trace = calcTrace[0].trace;\n  var geoLayout = fullLayout[trace.geo];\n  var geo = geoLayout._subplot;\n  var len = trace._length;\n  var i, calcPt;\n\n  if (Array.isArray(trace.locations)) {\n    var locationmode = trace.locationmode;\n    var features = locationmode === 'geojson-id' ? geoUtils.extractTraceFeature(calcTrace) : getTopojsonFeatures(trace, geo.topojson);\n\n    for (i = 0; i < len; i++) {\n      calcPt = calcTrace[i];\n      var feature = locationmode === 'geojson-id' ? calcPt.fOut : geoUtils.locationToFeature(locationmode, calcPt.loc, features);\n      calcPt.lonlat = feature ? feature.properties.ct : [BADNUM, BADNUM];\n    }\n  }\n\n  var opts = {\n    padded: true\n  };\n  var lonArray;\n  var latArray;\n\n  if (geoLayout.fitbounds === 'geojson' && trace.locationmode === 'geojson-id') {\n    var bboxGeojson = geoUtils.computeBbox(geoUtils.getTraceGeojson(trace));\n    lonArray = [bboxGeojson[0], bboxGeojson[2]];\n    latArray = [bboxGeojson[1], bboxGeojson[3]];\n  } else {\n    lonArray = new Array(len);\n    latArray = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      calcPt = calcTrace[i];\n      lonArray[i] = calcPt.lonlat[0];\n      latArray[i] = calcPt.lonlat[1];\n    }\n\n    opts.ppad = calcMarkerSize(trace, len);\n  }\n\n  trace._extremes.lon = findExtremes(geoLayout.lonaxis._ax, lonArray, opts);\n  trace._extremes.lat = findExtremes(geoLayout.lataxis._ax, latArray, opts);\n}\n\nmodule.exports = {\n  calcGeoJSON: calcGeoJSON,\n  plot: plot\n};","map":null,"metadata":{},"sourceType":"script"}