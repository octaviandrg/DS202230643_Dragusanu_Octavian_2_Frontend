{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar Drawing = require('../../components/drawing');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar partition = require('./partition');\n\nvar styleOne = require('./style').styleOne;\n\nvar constants = require('./constants');\n\nvar helpers = require('../sunburst/helpers');\n\nvar attachFxHandlers = require('../sunburst/fx');\n\nvar formatSliceLabel = require('../sunburst/plot').formatSliceLabel;\n\nvar onPathbar = false; // for Descendants\n\nmodule.exports = function drawDescendants(gd, cd, entry, slices, opts) {\n  var width = opts.width;\n  var height = opts.height;\n  var viewX = opts.viewX;\n  var viewY = opts.viewY;\n  var pathSlice = opts.pathSlice;\n  var toMoveInsideSlice = opts.toMoveInsideSlice;\n  var strTransform = opts.strTransform;\n  var hasTransition = opts.hasTransition;\n  var handleSlicesExit = opts.handleSlicesExit;\n  var makeUpdateSliceInterpolator = opts.makeUpdateSliceInterpolator;\n  var makeUpdateTextInterpolator = opts.makeUpdateTextInterpolator;\n  var prevEntry = opts.prevEntry;\n  var refRect = {};\n  var isStatic = gd._context.staticPlot;\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hasLeft = trace.textposition.indexOf('left') !== -1;\n  var hasRight = trace.textposition.indexOf('right') !== -1;\n  var hasBottom = trace.textposition.indexOf('bottom') !== -1;\n  var noRoomForHeader = !hasBottom && !trace.marker.pad.t || hasBottom && !trace.marker.pad.b; // N.B. slice data isn't the calcdata,\n  // grab corresponding calcdata item in sliceData[i].data.data\n\n  var allData = partition(entry, [width, height], {\n    packing: trace.tiling.packing,\n    squarifyratio: trace.tiling.squarifyratio,\n    flipX: trace.tiling.flip.indexOf('x') > -1,\n    flipY: trace.tiling.flip.indexOf('y') > -1,\n    pad: {\n      inner: trace.tiling.pad,\n      top: trace.marker.pad.t,\n      left: trace.marker.pad.l,\n      right: trace.marker.pad.r,\n      bottom: trace.marker.pad.b\n    }\n  });\n  var sliceData = allData.descendants();\n  var minVisibleDepth = Infinity;\n  var maxVisibleDepth = -Infinity;\n  sliceData.forEach(function (pt) {\n    var depth = pt.depth;\n\n    if (depth >= trace._maxDepth) {\n      // hide slices that won't show up on graph\n      pt.x0 = pt.x1 = (pt.x0 + pt.x1) / 2;\n      pt.y0 = pt.y1 = (pt.y0 + pt.y1) / 2;\n    } else {\n      minVisibleDepth = Math.min(minVisibleDepth, depth);\n      maxVisibleDepth = Math.max(maxVisibleDepth, depth);\n    }\n  });\n  slices = slices.data(sliceData, helpers.getPtId);\n  trace._maxVisibleLayers = isFinite(maxVisibleDepth) ? maxVisibleDepth - minVisibleDepth + 1 : 0;\n  slices.enter().append('g').classed('slice', true);\n  handleSlicesExit(slices, onPathbar, refRect, [width, height], pathSlice);\n  slices.order(); // next coords of previous entry\n\n  var nextOfPrevEntry = null;\n\n  if (hasTransition && prevEntry) {\n    var prevEntryId = helpers.getPtId(prevEntry);\n    slices.each(function (pt) {\n      if (nextOfPrevEntry === null && helpers.getPtId(pt) === prevEntryId) {\n        nextOfPrevEntry = {\n          x0: pt.x0,\n          x1: pt.x1,\n          y0: pt.y0,\n          y1: pt.y1\n        };\n      }\n    });\n  }\n\n  var getRefRect = function getRefRect() {\n    return nextOfPrevEntry || {\n      x0: 0,\n      x1: width,\n      y0: 0,\n      y1: height\n    };\n  };\n\n  var updateSlices = slices;\n\n  if (hasTransition) {\n    updateSlices = updateSlices.transition().each('end', function () {\n      // N.B. gd._transitioning is (still) *true* by the time\n      // transition updates get here\n      var sliceTop = d3.select(this);\n      helpers.setSliceCursor(sliceTop, gd, {\n        hideOnRoot: true,\n        hideOnLeaves: false,\n        isTransitioning: false\n      });\n    });\n  }\n\n  updateSlices.each(function (pt) {\n    var isHeader = helpers.isHeader(pt, trace); // for bbox\n\n    pt._x0 = viewX(pt.x0);\n    pt._x1 = viewX(pt.x1);\n    pt._y0 = viewY(pt.y0);\n    pt._y1 = viewY(pt.y1);\n    pt._hoverX = viewX(pt.x1 - trace.marker.pad.r), pt._hoverY = hasBottom ? viewY(pt.y1 - trace.marker.pad.b / 2) : viewY(pt.y0 + trace.marker.pad.t / 2);\n    var sliceTop = d3.select(this);\n    var slicePath = Lib.ensureSingle(sliceTop, 'path', 'surface', function (s) {\n      s.style('pointer-events', isStatic ? 'none' : 'all');\n    });\n\n    if (hasTransition) {\n      slicePath.transition().attrTween('d', function (pt2) {\n        var interp = makeUpdateSliceInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return pathSlice(interp(t));\n        };\n      });\n    } else {\n      slicePath.attr('d', pathSlice);\n    }\n\n    sliceTop.call(attachFxHandlers, entry, gd, cd, {\n      styleOne: styleOne,\n      eventDataKeys: constants.eventDataKeys,\n      transitionTime: constants.CLICK_TRANSITION_TIME,\n      transitionEasing: constants.CLICK_TRANSITION_EASING\n    }).call(helpers.setSliceCursor, gd, {\n      isTransitioning: gd._transitioning\n    });\n    slicePath.call(styleOne, pt, trace, {\n      hovered: false\n    });\n\n    if (pt.x0 === pt.x1 || pt.y0 === pt.y1) {\n      pt._text = '';\n    } else {\n      if (isHeader) {\n        pt._text = noRoomForHeader ? '' : helpers.getPtLabel(pt) || '';\n      } else {\n        pt._text = formatSliceLabel(pt, entry, trace, cd, fullLayout) || '';\n      }\n    }\n\n    var sliceTextGroup = Lib.ensureSingle(sliceTop, 'g', 'slicetext');\n    var sliceText = Lib.ensureSingle(sliceTextGroup, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var font = Lib.ensureUniformFontSize(gd, helpers.determineTextFont(trace, pt, fullLayout.font));\n    sliceText.text(pt._text || ' ') // use one space character instead of a blank string to avoid jumps during transition\n    .classed('slicetext', true).attr('text-anchor', hasRight ? 'end' : hasLeft || isHeader ? 'start' : 'middle').call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);\n    pt.textBB = Drawing.bBox(sliceText.node());\n    pt.transform = toMoveInsideSlice(pt, {\n      fontSize: font.size,\n      isHeader: isHeader\n    });\n    pt.transform.fontSize = font.size;\n\n    if (hasTransition) {\n      sliceText.transition().attrTween('transform', function (pt2) {\n        var interp = makeUpdateTextInterpolator(pt2, onPathbar, getRefRect(), [width, height]);\n        return function (t) {\n          return strTransform(interp(t));\n        };\n      });\n    } else {\n      sliceText.attr('transform', strTransform(pt));\n    }\n  });\n  return nextOfPrevEntry;\n};","map":null,"metadata":{},"sourceType":"script"}