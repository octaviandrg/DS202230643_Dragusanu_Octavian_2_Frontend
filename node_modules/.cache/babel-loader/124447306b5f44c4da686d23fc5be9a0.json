{"ast":null,"code":"'use strict';\n/**\r\n * @module parenthesis\r\n */\n\nfunction parse(str, opts) {\n  // pretend non-string parsed per-se\n  if (typeof str !== 'string') return [str];\n  var res = [str];\n\n  if (typeof opts === 'string' || Array.isArray(opts)) {\n    opts = {\n      brackets: opts\n    };\n  } else if (!opts) opts = {};\n\n  var brackets = opts.brackets ? Array.isArray(opts.brackets) ? opts.brackets : [opts.brackets] : ['{}', '[]', '()'];\n  var escape = opts.escape || '___';\n  var flat = !!opts.flat;\n  brackets.forEach(function (bracket) {\n    // create parenthesis regex\n    var pRE = new RegExp(['\\\\', bracket[0], '[^\\\\', bracket[0], '\\\\', bracket[1], ']*\\\\', bracket[1]].join(''));\n    var ids = [];\n\n    function replaceToken(token, idx, str) {\n      // save token to res\n      var refId = res.push(token.slice(bracket[0].length, -bracket[1].length)) - 1;\n      ids.push(refId);\n      return escape + refId + escape;\n    }\n\n    res.forEach(function (str, i) {\n      var prevStr; // replace paren tokens till thereâ€™s none\n\n      var a = 0;\n\n      while (str != prevStr) {\n        prevStr = str;\n        str = str.replace(pRE, replaceToken);\n        if (a++ > 10e3) throw Error('References have circular dependency. Please, check them.');\n      }\n\n      res[i] = str;\n    }); // wrap found refs to brackets\n\n    ids = ids.reverse();\n    res = res.map(function (str) {\n      ids.forEach(function (id) {\n        str = str.replace(new RegExp('(\\\\' + escape + id + '\\\\' + escape + ')', 'g'), bracket[0] + '$1' + bracket[1]);\n      });\n      return str;\n    });\n  });\n  var re = new RegExp('\\\\' + escape + '([0-9]+)' + '\\\\' + escape); // transform references to tree\n\n  function nest(str, refs, escape) {\n    var res = [],\n        match;\n    var a = 0;\n\n    while (match = re.exec(str)) {\n      if (a++ > 10e3) throw Error('Circular references in parenthesis');\n      res.push(str.slice(0, match.index));\n      res.push(nest(refs[match[1]], refs));\n      str = str.slice(match.index + match[0].length);\n    }\n\n    res.push(str);\n    return res;\n  }\n\n  return flat ? res : nest(res[0], res);\n}\n\nfunction stringify(arg, opts) {\n  if (opts && opts.flat) {\n    var escape = opts && opts.escape || '___';\n    var str = arg[0],\n        prevStr; // pretend bad string stringified with no parentheses\n\n    if (!str) return '';\n    var re = new RegExp('\\\\' + escape + '([0-9]+)' + '\\\\' + escape);\n    var a = 0;\n\n    while (str != prevStr) {\n      if (a++ > 10e3) throw Error('Circular references in ' + arg);\n      prevStr = str;\n      str = str.replace(re, replaceRef);\n    }\n\n    return str;\n  }\n\n  return arg.reduce(function f(prev, curr) {\n    if (Array.isArray(curr)) {\n      curr = curr.reduce(f, '');\n    }\n\n    return prev + curr;\n  }, '');\n\n  function replaceRef(match, idx) {\n    if (arg[idx] == null) throw Error('Reference ' + idx + 'is undefined');\n    return arg[idx];\n  }\n}\n\nfunction parenthesis(arg, opts) {\n  if (Array.isArray(arg)) {\n    return stringify(arg, opts);\n  } else {\n    return parse(arg, opts);\n  }\n}\n\nparenthesis.parse = parse;\nparenthesis.stringify = stringify;\nmodule.exports = parenthesis;","map":null,"metadata":{},"sourceType":"script"}