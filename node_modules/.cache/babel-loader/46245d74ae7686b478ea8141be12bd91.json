{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar getAxisGroup = require('../../plots/cartesian/constraints').getAxisGroup;\n\nvar Sieve = require('./sieve.js');\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorz = [];\n  var calcTracesVert = [];\n\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorz.push(calcTraces[i]);\n      } else {\n        calcTracesVert.push(calcTraces[i]);\n      }\n\n      if (fullTrace._computePh) {\n        var cd = gd.calcdata[i];\n\n        for (var j = 0; j < cd.length; j++) {\n          if (typeof cd[j].ph0 === 'function') cd[j].ph0 = cd[j].ph0();\n          if (typeof cd[j].ph1 === 'function') cd[j].ph1 = cd[j].ph1();\n        }\n      }\n    }\n  }\n\n  var opts = {\n    xCat: xa.type === 'category' || xa.type === 'multicategory',\n    yCat: ya.type === 'category' || ya.type === 'multicategory',\n    mode: fullLayout.barmode,\n    norm: fullLayout.barnorm,\n    gap: fullLayout.bargap,\n    groupgap: fullLayout.bargroupgap\n  };\n  setGroupPositions(gd, xa, ya, calcTracesVert, opts);\n  setGroupPositions(gd, ya, xa, calcTracesHorz, opts);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces, opts) {\n  if (!calcTraces.length) return;\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(sa, calcTraces);\n\n  switch (opts.mode) {\n    case 'overlay':\n      setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts);\n      break;\n\n    case 'group':\n      // exclude from the group those traces for which the user set an offset\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInGroupMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n\n    case 'stack':\n    case 'relative':\n      // exclude from the stack those traces for which the user set a base\n      excluded = [];\n      included = [];\n\n      for (i = 0; i < calcTraces.length; i++) {\n        calcTrace = calcTraces[i];\n        fullTrace = calcTrace[0].trace;\n        if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n      }\n\n      if (included.length) {\n        setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);\n      }\n\n      if (excluded.length) {\n        setGroupPositionsInOverlayMode(pa, sa, excluded, opts);\n      }\n\n      break;\n  }\n\n  collectExtents(calcTraces, pa);\n}\n\nfunction initBase(sa, calcTraces) {\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.type === 'funnel' ? trace._base : trace.base;\n    var b; // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar; // 'base' on categorical axes makes no sense\n\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\n\nfunction setGroupPositionsInOverlayMode(pa, sa, calcTraces, opts) {\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], {\n      posAxis: pa,\n      sepNegVal: false,\n      overlapNoMerge: !opts.norm\n    }); // set bar offsets and widths, and update position axis\n\n    setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n\n    if (opts.norm) {\n      sieveBars(sieve);\n      normalizeBars(sa, sieve, opts);\n    } else {\n      setBaseAndTop(sa, sieve);\n    }\n  }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: false,\n    overlapNoMerge: !opts.norm\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidthInGroupMode(gd, pa, sieve, opts); // relative-stack bars within the same trace that would otherwise\n  // be hidden\n\n  unhideBarsWithinTrace(sieve, pa); // set bar bases and sizes, and update size axis\n\n  if (opts.norm) {\n    sieveBars(sieve);\n    normalizeBars(sa, sieve, opts);\n  } else {\n    setBaseAndTop(sa, sieve);\n  }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {\n  var sieve = new Sieve(calcTraces, {\n    posAxis: pa,\n    sepNegVal: opts.mode === 'relative',\n    overlapNoMerge: !(opts.norm || opts.mode === 'stack' || opts.mode === 'relative')\n  }); // set bar offsets and widths, and update position axis\n\n  setOffsetAndWidth(pa, sieve, opts); // set bar bases and sizes, and update size axis\n\n  stackBars(sa, sieve, opts); // flag the outmost bar (for text display purposes)\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  } // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n\n\n  if (opts.norm) normalizeBars(sa, sieve, opts);\n}\n\nfunction setOffsetAndWidth(pa, sieve, opts) {\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces; // set bar offsets and widths\n\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0)); // computer bar group center and bar offset\n\n  var offsetFromCenter = -barWidth / 2;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t; // store bar width and offset for this trace\n\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace offset and width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve, opts) {\n  var fullLayout = gd._fullLayout;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n  var nTraces = calcTraces.length; // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n\n  var overlap = positions.length !== distinctPositions.length;\n  var barGroupWidth = minDiff * (1 - opts.gap);\n  var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;\n  var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};\n\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var trace = calcTrace[0].trace;\n    var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};\n    var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;\n    var barWidthPlusGap;\n\n    if (nOffsetGroups) {\n      barWidthPlusGap = barGroupWidth / nOffsetGroups;\n    } else {\n      barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n    }\n\n    var barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));\n    var offsetFromCenter;\n\n    if (nOffsetGroups) {\n      offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;\n    } else {\n      offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n    }\n\n    var t = calcTrace[0].t;\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  } // stack bars that only differ by rounding\n\n\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100; // if defined, apply trace width\n\n  applyAttributes(sieve); // store the bar center in each calcdata item\n\n  setBarCenterAndWidth(pa, sieve); // update position axes\n\n  updatePositionAxis(pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n\n\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length); // guard against non-numeric items\n\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      } // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n\n\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n\n      t.barwidth = newBarwidth; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        newPoffset = [];\n\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width; // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\n\nfunction setBarCenterAndWidth(pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = Array.isArray(barwidth);\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j]; // store the actual bar width and position, for use by hover\n\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n    }\n  }\n}\n\nfunction updatePositionAxis(pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = Array.isArray(poffset);\n      var barwidthIsArray = Array.isArray(barwidth);\n\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n} // store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\n\n\nfunction setBaseAndTop(sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var base = bar.b;\n      var top = base + bar.s;\n      bar[sLetter] = top;\n      pts.push(top);\n      if (bar.hasB) pts.push(base);\n\n      if (!bar.hasB || !bar.b) {\n        tozero = true;\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: true\n    });\n  }\n}\n\nfunction stackBars(sa, sieve, opts) {\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  var calcTrace;\n  var fullTrace;\n  var isFunnel;\n  var i, j;\n  var bar;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.type === 'funnel') {\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n\n        if (bar.s !== BADNUM) {\n          // create base of funnels\n          sieve.put(bar.p, -0.5 * bar.s);\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < calcTraces.length; i++) {\n    calcTrace = calcTraces[i];\n    fullTrace = calcTrace[0].trace;\n    isFunnel = fullTrace.type === 'funnel';\n    var pts = [];\n\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var value;\n\n        if (isFunnel) {\n          value = bar.s;\n        } else {\n          value = bar.s + bar.b;\n        }\n\n        var base = sieve.put(bar.p, value);\n        var top = base + value; // store the bar base and top in each calcdata item\n\n        bar.b = base;\n        bar[sLetter] = top;\n\n        if (!opts.norm) {\n          pts.push(top);\n\n          if (bar.hasB) {\n            pts.push(base);\n          }\n        }\n      }\n    } // if barnorm is set, let normalizeBars update the axis range\n\n\n    if (!opts.norm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\n\nfunction sieveBars(sieve) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        sieve.put(bar.p, bar.b + bar.s);\n      }\n    }\n  }\n}\n\nfunction unhideBarsWithinTrace(sieve, pa) {\n  var calcTraces = sieve.traces;\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n\n    if (fullTrace.base === undefined) {\n      var inTraceSieve = new Sieve([calcTrace], {\n        posAxis: pa,\n        sepNegVal: true,\n        overlapNoMerge: true\n      });\n\n      for (var j = 0; j < calcTrace.length; j++) {\n        var bar = calcTrace[j];\n\n        if (bar.p !== BADNUM) {\n          // stack current bar and get previous sum\n          var base = inTraceSieve.put(bar.p, bar.b + bar.s); // if previous sum if non-zero, this means:\n          // multiple bars have same starting point are potentially hidden,\n          // shift them vertically so that all bars are visible by default\n\n          if (base) bar.b = base;\n        }\n      }\n    }\n  }\n} // Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\n\n\nfunction normalizeBars(sa, sieve, opts) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = opts.norm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = opts.mode === 'stack' ? sTop : sMin;\n\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var tozero = false;\n    var padded = false;\n\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var base = bar.b;\n        var top = base + bar.s;\n        bar[sLetter] = top;\n        pts.push(top);\n        padded = padded || needsPadding(top);\n\n        if (bar.hasB) {\n          pts.push(base);\n          padded = padded || needsPadding(base);\n        }\n\n        if (!bar.hasB || !bar.b) {\n          tozero = true;\n        }\n      }\n    }\n\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: tozero,\n      padded: padded\n    });\n  }\n} // find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\n\n\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  } // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n\n\n  var roundFactor = 10000 / (pMax - pMin);\n\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n    }\n  }\n}\n\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\n\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":null,"metadata":{},"sourceType":"script"}