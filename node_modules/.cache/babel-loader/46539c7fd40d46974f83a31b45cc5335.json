{"ast":null,"code":"'use strict';\n\nvar createLinePlot = require('../../../stackgl_modules').gl_line3d;\n\nvar createScatterPlot = require('../../../stackgl_modules').gl_scatter3d;\n\nvar createErrorBars = require('../../../stackgl_modules').gl_error3d;\n\nvar createMesh = require('../../../stackgl_modules').gl_mesh3d;\n\nvar triangulate = require('../../../stackgl_modules').delaunay_triangulate;\n\nvar Lib = require('../../lib');\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\n\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar DASH_PATTERNS = require('../../constants/gl3d_dashes');\n\nvar MARKER_SYMBOLS = require('../../constants/gl3d_markers');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar calculateError = require('./calc_errors');\n\nfunction LineWithMarkers(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.linePlot = null;\n  this.scatterPlot = null;\n  this.errorBars = null;\n  this.textMarkers = null;\n  this.delaunayMesh = null;\n  this.color = null;\n  this.mode = '';\n  this.dataPoints = [];\n  this.axesBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.textLabels = null;\n  this.data = null;\n}\n\nvar proto = LineWithMarkers.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object && (selection.object === this.linePlot || selection.object === this.delaunayMesh || selection.object === this.textMarkers || selection.object === this.scatterPlot)) {\n    var ind = selection.index = selection.data.index;\n\n    if (selection.object.highlight) {\n      selection.object.highlight(null);\n    }\n\n    if (this.scatterPlot) {\n      selection.object = this.scatterPlot;\n      this.scatterPlot.highlight(selection.data);\n    }\n\n    selection.textLabel = '';\n\n    if (this.textLabels) {\n      if (Array.isArray(this.textLabels)) {\n        if (this.textLabels[ind] || this.textLabels[ind] === 0) {\n          selection.textLabel = this.textLabels[ind];\n        }\n      } else {\n        selection.textLabel = this.textLabels;\n      }\n    }\n\n    selection.traceCoordinate = [this.data.x[ind], this.data.y[ind], this.data.z[ind]];\n    return true;\n  }\n};\n\nfunction constructDelaunay(points, color, axis) {\n  var u = (axis + 1) % 3;\n  var v = (axis + 2) % 3;\n  var filteredPoints = [];\n  var filteredIds = [];\n  var i;\n\n  for (i = 0; i < points.length; ++i) {\n    var p = points[i];\n\n    if (isNaN(p[u]) || !isFinite(p[u]) || isNaN(p[v]) || !isFinite(p[v])) {\n      continue;\n    }\n\n    filteredPoints.push([p[u], p[v]]);\n    filteredIds.push(i);\n  }\n\n  var cells = triangulate(filteredPoints);\n\n  for (i = 0; i < cells.length; ++i) {\n    var c = cells[i];\n\n    for (var j = 0; j < c.length; ++j) {\n      c[j] = filteredIds[c[j]];\n    }\n  }\n\n  return {\n    positions: points,\n    cells: cells,\n    meshColor: color\n  };\n}\n\nfunction calculateErrorParams(errors) {\n  var capSize = [0.0, 0.0, 0.0];\n  var color = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n  var lineWidth = [1.0, 1.0, 1.0];\n\n  for (var i = 0; i < 3; i++) {\n    var e = errors[i];\n    if (e && e.copy_zstyle !== false && errors[2].visible !== false) e = errors[2];\n    if (!e || !e.visible) continue;\n    capSize[i] = e.width / 2; // ballpark rescaling\n\n    color[i] = str2RgbaArray(e.color);\n    lineWidth[i] = e.thickness;\n  }\n\n  return {\n    capSize: capSize,\n    color: color,\n    lineWidth: lineWidth\n  };\n}\n\nfunction parseAlignmentX(a) {\n  if (a === null || a === undefined) return 0;\n  return a.indexOf('left') > -1 ? -1 : a.indexOf('right') > -1 ? 1 : 0;\n}\n\nfunction parseAlignmentY(a) {\n  if (a === null || a === undefined) return 0;\n  return a.indexOf('top') > -1 ? -1 : a.indexOf('bottom') > -1 ? 1 : 0;\n}\n\nfunction calculateTextOffset(tp) {\n  // Read out text properties\n  var defaultAlignmentX = 0;\n  var defaultAlignmentY = 0;\n  var textOffset = [defaultAlignmentX, defaultAlignmentY];\n\n  if (Array.isArray(tp)) {\n    for (var i = 0; i < tp.length; i++) {\n      textOffset[i] = [defaultAlignmentX, defaultAlignmentY];\n\n      if (tp[i]) {\n        textOffset[i][0] = parseAlignmentX(tp[i]);\n        textOffset[i][1] = parseAlignmentY(tp[i]);\n      }\n    }\n  } else {\n    textOffset[0] = parseAlignmentX(tp);\n    textOffset[1] = parseAlignmentY(tp);\n  }\n\n  return textOffset;\n}\n\nfunction calculateSize(sizeIn, sizeFn) {\n  // rough parity with Plotly 2D markers\n  return sizeFn(sizeIn * 4);\n}\n\nfunction calculateSymbol(symbolIn) {\n  return MARKER_SYMBOLS[symbolIn];\n}\n\nfunction formatParam(paramIn, len, calculate, dflt, extraFn) {\n  var paramOut = null;\n\n  if (Lib.isArrayOrTypedArray(paramIn)) {\n    paramOut = [];\n\n    for (var i = 0; i < len; i++) {\n      if (paramIn[i] === undefined) paramOut[i] = dflt;else paramOut[i] = calculate(paramIn[i], extraFn);\n    }\n  } else paramOut = calculate(paramIn, Lib.identity);\n\n  return paramOut;\n}\n\nfunction convertPlotlyOptions(scene, data) {\n  var points = [];\n  var sceneLayout = scene.fullSceneLayout;\n  var scaleFactor = scene.dataScale;\n  var xaxis = sceneLayout.xaxis;\n  var yaxis = sceneLayout.yaxis;\n  var zaxis = sceneLayout.zaxis;\n  var marker = data.marker;\n  var line = data.line;\n  var x = data.x || [];\n  var y = data.y || [];\n  var z = data.z || [];\n  var len = x.length;\n  var xcalendar = data.xcalendar;\n  var ycalendar = data.ycalendar;\n  var zcalendar = data.zcalendar;\n  var xc, yc, zc;\n  var params, i;\n  var text; // Convert points\n\n  for (i = 0; i < len; i++) {\n    // sanitize numbers and apply transforms based on axes.type\n    xc = xaxis.d2l(x[i], 0, xcalendar) * scaleFactor[0];\n    yc = yaxis.d2l(y[i], 0, ycalendar) * scaleFactor[1];\n    zc = zaxis.d2l(z[i], 0, zcalendar) * scaleFactor[2];\n    points[i] = [xc, yc, zc];\n  } // convert text\n\n\n  if (Array.isArray(data.text)) text = data.text;else if (data.text !== undefined) {\n    text = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      text[i] = data.text;\n    }\n  }\n\n  function formatter(axName, val) {\n    var ax = sceneLayout[axName];\n    return Axes.tickText(ax, ax.d2l(val), true).text;\n  } // check texttemplate\n\n\n  var texttemplate = data.texttemplate;\n\n  if (texttemplate) {\n    var fullLayout = scene.fullLayout;\n    var d3locale = fullLayout._d3locale;\n    var isArray = Array.isArray(texttemplate);\n    var N = isArray ? Math.min(texttemplate.length, len) : len;\n    var txt = isArray ? function (i) {\n      return texttemplate[i];\n    } : function () {\n      return texttemplate;\n    };\n    text = new Array(N);\n\n    for (i = 0; i < N; i++) {\n      var d = {\n        x: x[i],\n        y: y[i],\n        z: z[i]\n      };\n      var labels = {\n        xLabel: formatter('xaxis', x[i]),\n        yLabel: formatter('yaxis', y[i]),\n        zLabel: formatter('zaxis', z[i])\n      };\n      var pointValues = {};\n      appendArrayPointValue(pointValues, data, i);\n      var meta = data._meta || {};\n      text[i] = Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta);\n    }\n  } // Build object parameters\n\n\n  params = {\n    position: points,\n    mode: data.mode,\n    text: text\n  };\n\n  if ('line' in data) {\n    params.lineColor = formatColor(line, 1, len);\n    params.lineWidth = line.width;\n    params.lineDashes = line.dash;\n  }\n\n  if ('marker' in data) {\n    var sizeFn = makeBubbleSizeFn(data);\n    params.scatterColor = formatColor(marker, 1, len);\n    params.scatterSize = formatParam(marker.size, len, calculateSize, 20, sizeFn);\n    params.scatterMarker = formatParam(marker.symbol, len, calculateSymbol, '●');\n    params.scatterLineWidth = marker.line.width; // arrayOk === false\n\n    params.scatterLineColor = formatColor(marker.line, 1, len);\n    params.scatterAngle = 0;\n  }\n\n  if ('textposition' in data) {\n    params.textOffset = calculateTextOffset(data.textposition);\n    params.textColor = formatColor(data.textfont, 1, len);\n    params.textSize = formatParam(data.textfont.size, len, Lib.identity, 12);\n    params.textFont = data.textfont.family; // arrayOk === false\n\n    params.textAngle = 0;\n  }\n\n  var dims = ['x', 'y', 'z'];\n  params.project = [false, false, false];\n  params.projectScale = [1, 1, 1];\n  params.projectOpacity = [1, 1, 1];\n\n  for (i = 0; i < 3; ++i) {\n    var projection = data.projection[dims[i]];\n\n    if (params.project[i] = projection.show) {\n      params.projectOpacity[i] = projection.opacity;\n      params.projectScale[i] = projection.scale;\n    }\n  }\n\n  params.errorBounds = calculateError(data, scaleFactor, sceneLayout);\n  var errorParams = calculateErrorParams([data.error_x, data.error_y, data.error_z]);\n  params.errorColor = errorParams.color;\n  params.errorLineWidth = errorParams.lineWidth;\n  params.errorCapSize = errorParams.capSize;\n  params.delaunayAxis = data.surfaceaxis;\n  params.delaunayColor = str2RgbaArray(data.surfacecolor);\n  return params;\n}\n\nfunction _arrayToColor(color) {\n  if (Lib.isArrayOrTypedArray(color)) {\n    var c = color[0];\n    if (Lib.isArrayOrTypedArray(c)) color = c;\n    return 'rgb(' + color.slice(0, 3).map(function (x) {\n      return Math.round(x * 255);\n    }) + ')';\n  }\n\n  return null;\n}\n\nfunction arrayToColor(colors) {\n  if (!Lib.isArrayOrTypedArray(colors)) {\n    return null;\n  }\n\n  if (colors.length === 4 && typeof colors[0] === 'number') {\n    return _arrayToColor(colors);\n  }\n\n  return colors.map(_arrayToColor);\n}\n\nproto.update = function (data) {\n  var gl = this.scene.glplot.gl;\n  var lineOptions;\n  var scatterOptions;\n  var errorOptions;\n  var textOptions;\n  var dashPattern = DASH_PATTERNS.solid; // Save data\n\n  this.data = data; // Run data conversion\n\n  var options = convertPlotlyOptions(this.scene, data);\n\n  if ('mode' in options) {\n    this.mode = options.mode;\n  }\n\n  if ('lineDashes' in options) {\n    if (options.lineDashes in DASH_PATTERNS) {\n      dashPattern = DASH_PATTERNS[options.lineDashes];\n    }\n  }\n\n  this.color = arrayToColor(options.scatterColor) || arrayToColor(options.lineColor); // Save data points\n\n  this.dataPoints = options.position;\n  lineOptions = {\n    gl: this.scene.glplot.gl,\n    position: options.position,\n    color: options.lineColor,\n    lineWidth: options.lineWidth || 1,\n    dashes: dashPattern[0],\n    dashScale: dashPattern[1],\n    opacity: data.opacity,\n    connectGaps: data.connectgaps\n  };\n\n  if (this.mode.indexOf('lines') !== -1) {\n    if (this.linePlot) this.linePlot.update(lineOptions);else {\n      this.linePlot = createLinePlot(lineOptions);\n      this.linePlot._trace = this;\n      this.scene.glplot.add(this.linePlot);\n    }\n  } else if (this.linePlot) {\n    this.scene.glplot.remove(this.linePlot);\n    this.linePlot.dispose();\n    this.linePlot = null;\n  } // N.B. marker.opacity must be a scalar for performance\n\n\n  var scatterOpacity = data.opacity;\n  if (data.marker && data.marker.opacity) scatterOpacity *= data.marker.opacity;\n  scatterOptions = {\n    gl: this.scene.glplot.gl,\n    position: options.position,\n    color: options.scatterColor,\n    size: options.scatterSize,\n    glyph: options.scatterMarker,\n    opacity: scatterOpacity,\n    orthographic: true,\n    lineWidth: options.scatterLineWidth,\n    lineColor: options.scatterLineColor,\n    project: options.project,\n    projectScale: options.projectScale,\n    projectOpacity: options.projectOpacity\n  };\n\n  if (this.mode.indexOf('markers') !== -1) {\n    if (this.scatterPlot) this.scatterPlot.update(scatterOptions);else {\n      this.scatterPlot = createScatterPlot(scatterOptions);\n      this.scatterPlot._trace = this;\n      this.scatterPlot.highlightScale = 1;\n      this.scene.glplot.add(this.scatterPlot);\n    }\n  } else if (this.scatterPlot) {\n    this.scene.glplot.remove(this.scatterPlot);\n    this.scatterPlot.dispose();\n    this.scatterPlot = null;\n  }\n\n  textOptions = {\n    gl: this.scene.glplot.gl,\n    position: options.position,\n    glyph: options.text,\n    color: options.textColor,\n    size: options.textSize,\n    angle: options.textAngle,\n    alignment: options.textOffset,\n    font: options.textFont,\n    orthographic: true,\n    lineWidth: 0,\n    project: false,\n    opacity: data.opacity\n  };\n  this.textLabels = data.hovertext || data.text;\n\n  if (this.mode.indexOf('text') !== -1) {\n    if (this.textMarkers) this.textMarkers.update(textOptions);else {\n      this.textMarkers = createScatterPlot(textOptions);\n      this.textMarkers._trace = this;\n      this.textMarkers.highlightScale = 1;\n      this.scene.glplot.add(this.textMarkers);\n    }\n  } else if (this.textMarkers) {\n    this.scene.glplot.remove(this.textMarkers);\n    this.textMarkers.dispose();\n    this.textMarkers = null;\n  }\n\n  errorOptions = {\n    gl: this.scene.glplot.gl,\n    position: options.position,\n    color: options.errorColor,\n    error: options.errorBounds,\n    lineWidth: options.errorLineWidth,\n    capSize: options.errorCapSize,\n    opacity: data.opacity\n  };\n\n  if (this.errorBars) {\n    if (options.errorBounds) {\n      this.errorBars.update(errorOptions);\n    } else {\n      this.scene.glplot.remove(this.errorBars);\n      this.errorBars.dispose();\n      this.errorBars = null;\n    }\n  } else if (options.errorBounds) {\n    this.errorBars = createErrorBars(errorOptions);\n    this.errorBars._trace = this;\n    this.scene.glplot.add(this.errorBars);\n  }\n\n  if (options.delaunayAxis >= 0) {\n    var delaunayOptions = constructDelaunay(options.position, options.delaunayColor, options.delaunayAxis);\n    delaunayOptions.opacity = data.opacity;\n\n    if (this.delaunayMesh) {\n      this.delaunayMesh.update(delaunayOptions);\n    } else {\n      delaunayOptions.gl = gl;\n      this.delaunayMesh = createMesh(delaunayOptions);\n      this.delaunayMesh._trace = this;\n      this.scene.glplot.add(this.delaunayMesh);\n    }\n  } else if (this.delaunayMesh) {\n    this.scene.glplot.remove(this.delaunayMesh);\n    this.delaunayMesh.dispose();\n    this.delaunayMesh = null;\n  }\n};\n\nproto.dispose = function () {\n  if (this.linePlot) {\n    this.scene.glplot.remove(this.linePlot);\n    this.linePlot.dispose();\n  }\n\n  if (this.scatterPlot) {\n    this.scene.glplot.remove(this.scatterPlot);\n    this.scatterPlot.dispose();\n  }\n\n  if (this.errorBars) {\n    this.scene.glplot.remove(this.errorBars);\n    this.errorBars.dispose();\n  }\n\n  if (this.textMarkers) {\n    this.scene.glplot.remove(this.textMarkers);\n    this.textMarkers.dispose();\n  }\n\n  if (this.delaunayMesh) {\n    this.scene.glplot.remove(this.delaunayMesh);\n    this.delaunayMesh.dispose();\n  }\n};\n\nfunction createLineWithMarkers(scene, data) {\n  var plot = new LineWithMarkers(scene, data.uid);\n  plot.update(data);\n  return plot;\n}\n\nmodule.exports = createLineWithMarkers;","map":null,"metadata":{},"sourceType":"script"}