{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Titles = require('../../components/titles');\n\nvar Color = require('../../components/color');\n\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\n\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\n\nvar ONEMAXYEAR = constants.ONEMAXYEAR;\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEMINYEAR = constants.ONEMINYEAR;\nvar ONEMAXQUARTER = constants.ONEMAXQUARTER;\nvar ONEAVGQUARTER = constants.ONEAVGQUARTER;\nvar ONEMINQUARTER = constants.ONEMINQUARTER;\nvar ONEMAXMONTH = constants.ONEMAXMONTH;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEMINMONTH = constants.ONEMINMONTH;\nvar ONEWEEK = constants.ONEWEEK;\nvar ONEDAY = constants.ONEDAY;\nvar HALFDAY = ONEDAY / 2;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\nvar ZERO_PATH = {\n  K: 'zeroline'\n};\nvar GRID_PATH = {\n  K: 'gridline',\n  L: 'path'\n};\nvar MINORGRID_PATH = {\n  K: 'minor-gridline',\n  L: 'path'\n};\nvar TICK_PATH = {\n  K: 'tick',\n  L: 'path'\n};\nvar TICK_TEXT = {\n  K: 'tick',\n  L: 'text'\n};\nvar MARGIN_MAPPING = {\n  width: ['x', 'r', 'l', 'xl', 'xr'],\n  height: ['y', 't', 'b', 'yt', 'yb'],\n  right: ['r', 'xr'],\n  left: ['l', 'xl'],\n  top: ['t', 'yt'],\n  bottom: ['b', 'yb']\n};\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar MID_SHIFT = alignmentConstants.MID_SHIFT;\nvar CAP_SHIFT = alignmentConstants.CAP_SHIFT;\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;\nvar TEXTPAD = 3;\nvar axes = module.exports = {};\naxes.setConvert = require('./set_convert');\n\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\n\nvar idSort = axisIds.idSort;\nvar isLinked = axisIds.isLinked; // tight coupling to chart studio\n\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\n\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\nvar epsilon = 0.0001;\n\nfunction expandRange(range) {\n  var delta = (range[1] - range[0]) * epsilon;\n  return [range[0] - delta, range[1] + delta];\n}\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\n\n\naxes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {\n  var axLetter = attr.charAt(attr.length - 1);\n  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n  var refAttr = attr + 'ref';\n  var attrDef = {};\n  if (!dflt) dflt = axlist[0] || (typeof extraOption === 'string' ? extraOption : extraOption[0]);\n  if (!extraOption) extraOption = dflt;\n  axlist = axlist.concat(axlist.map(function (x) {\n    return x + ' domain';\n  })); // data-ref annotations are not supported in gl2d yet\n\n  attrDef[refAttr] = {\n    valType: 'enumerated',\n    values: axlist.concat(extraOption ? typeof extraOption === 'string' ? [extraOption] : extraOption : []),\n    dflt: dflt\n  }; // xref, yref\n\n  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n/*\n * Get the type of an axis reference. This can be 'range', 'domain', or 'paper'.\n * This assumes ar is a valid axis reference and returns 'range' if it doesn't\n * match the patterns for 'paper' or 'domain'.\n *\n * ar: the axis reference string\n *\n */\n\n\naxes.getRefType = function (ar) {\n  if (ar === undefined) {\n    return ar;\n  }\n\n  if (ar === 'paper') {\n    return 'paper';\n  }\n\n  if (ar === 'pixel') {\n    return 'pixel';\n  }\n\n  if (/( domain)$/.test(ar)) {\n    return 'domain';\n  } else {\n    return 'range';\n  }\n};\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\n\n\naxes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {\n  var cleanPos, pos;\n  var axRefType = axes.getRefType(axRef);\n\n  if (axRefType !== 'range') {\n    cleanPos = Lib.ensureNumber;\n    pos = coerce(attr, dflt);\n  } else {\n    var ax = axes.getFromId(gd, axRef);\n    dflt = ax.fraction2r(dflt);\n    pos = coerce(attr, dflt);\n    cleanPos = ax.cleanPos;\n  }\n\n  containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function (pos, gd, axRef) {\n  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;\n  return cleanPos(pos);\n};\n\naxes.redrawComponents = function (gd, axIds) {\n  axIds = axIds ? axIds : axes.listIds(gd);\n  var fullLayout = gd._fullLayout;\n\n  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n    var method = Registry.getComponentMethod(moduleName, methodName);\n    var stash = {};\n\n    for (var i = 0; i < axIds.length; i++) {\n      var ax = fullLayout[axes.id2name(axIds[i])];\n      var indices = ax[stashName];\n\n      for (var j = 0; j < indices.length; j++) {\n        var ind = indices[j];\n\n        if (!stash[ind]) {\n          method(gd, ind);\n          stash[ind] = 1; // once is enough for images (which doesn't use the `i` arg anyway)\n\n          if (shortCircuit) return;\n        }\n      }\n    }\n  } // annotations and shapes 'draw' method is slow,\n  // use the finer-grained 'drawOne' method instead\n\n\n  _redrawOneComp('annotations', 'drawOne', '_annIndices');\n\n  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n\n  _redrawOneComp('images', 'draw', '_imgIndices', true);\n\n  _redrawOneComp('selections', 'drawOne', '_selectionIndices');\n};\n\nvar getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {\n  var ax; // If target points to an axis, use the type we already have for that\n  // axis to find the data type. Otherwise use the values to autotype.\n\n  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray; // In the case of an array target, make a mock data array\n  // and call supplyDefaults to the data type and\n  // setup the data-to-calc method.\n\n  if (Array.isArray(d2cTarget)) {\n    ax = {\n      type: autoType(targetArray, undefined, {\n        autotypenumbers: gd._fullLayout.autotypenumbers\n      }),\n      _categories: []\n    };\n    axes.setConvert(ax); // build up ax._categories (usually done during ax.makeCalcdata()\n\n    if (ax.type === 'category') {\n      for (var i = 0; i < targetArray.length; i++) {\n        ax.d2c(targetArray[i]);\n      }\n    } // TODO what to do for transforms?\n\n  } else {\n    ax = axes.getFromTrace(gd, trace, d2cTarget);\n  } // if 'target' has corresponding axis\n  // -> use setConvert method\n\n\n  if (ax) return {\n    d2c: ax.d2c,\n    c2d: ax.c2d\n  }; // special case for 'ids'\n  // -> cast to String\n\n  if (d2cTarget === 'ids') return {\n    d2c: toString,\n    c2d: toString\n  }; // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n  // -> cast to Number\n\n  return {\n    d2c: toNum,\n    c2d: toNum\n  };\n};\n\nfunction toNum(v) {\n  return +v;\n}\n\nfunction toString(v) {\n  return String(v);\n}\n\naxes.getDataToCoordFunc = function (gd, trace, target, targetArray) {\n  return getDataConversions(gd, trace, target, targetArray).d2c;\n}; // get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\n\n\naxes.counterLetter = function (id) {\n  var axLetter = id.charAt(0);\n  if (axLetter === 'x') return 'y';\n  if (axLetter === 'y') return 'x';\n}; // incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\n\n\naxes.minDtick = function (ax, newDiff, newFirst, allow) {\n  // doesn't make sense to do forced min dTick on log or category axes,\n  // and the plot itself may decide to cancel (ie non-grouped bars)\n  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n    ax._minDtick = 0;\n  } else if (ax._minDtick === undefined) {\n    // undefined means there's nothing there yet\n    ax._minDtick = newDiff;\n    ax._forceTick0 = newFirst;\n  } else if (ax._minDtick) {\n    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && // existing minDtick is an integer multiple of newDiff\n    // (within rounding err)\n    // and forceTick0 can be shifted to newFirst\n    ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {\n      ax._minDtick = newDiff;\n      ax._forceTick0 = newFirst;\n    } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || // if the converse is true (newDiff is a multiple of minDtick and\n    // newFirst can be shifted to forceTick0) then do nothing - same\n    // forcing stands. Otherwise, cancel forced minimum\n    ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {\n      ax._minDtick = 0;\n    }\n  }\n}; // save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\n\n\naxes.saveRangeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._rangeInitial === undefined;\n    var hasChanged = isNew || !(ax.range[0] === ax._rangeInitial[0] && ax.range[1] === ax._rangeInitial[1]);\n\n    if (isNew && ax.autorange === false || overwrite && hasChanged) {\n      ax._rangeInitial = ax.range.slice();\n      hasOneAxisChanged = true;\n    }\n  }\n\n  return hasOneAxisChanged;\n}; // save a copy of the initial spike visibility\n\n\naxes.saveShowSpikeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  var allSpikesEnabled = 'on';\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._showSpikeInitial === undefined;\n    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n    if (isNew || overwrite && hasChanged) {\n      ax._showSpikeInitial = ax.showspikes;\n      hasOneAxisChanged = true;\n    }\n\n    if (allSpikesEnabled === 'on' && !ax.showspikes) {\n      allSpikesEnabled = 'off';\n    }\n  }\n\n  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  return hasOneAxisChanged;\n};\n\naxes.autoBin = function (data, ax, nbins, is2d, calendar, size) {\n  var dataMin = Lib.aggNums(Math.min, null, data);\n  var dataMax = Lib.aggNums(Math.max, null, data);\n\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    return {\n      start: dataMin - 0.5,\n      end: dataMax + 0.5,\n      size: Math.max(1, Math.round(size) || 1),\n      _dataSpan: dataMax - dataMin\n    };\n  }\n\n  if (!calendar) calendar = ax.calendar; // piggyback off tick code to make \"nice\" bin sizes and edges\n\n  var dummyAx;\n\n  if (ax.type === 'log') {\n    dummyAx = {\n      type: 'linear',\n      range: [dataMin, dataMax]\n    };\n  } else {\n    dummyAx = {\n      type: ax.type,\n      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n      calendar: calendar\n    };\n  }\n\n  axes.setConvert(dummyAx);\n  size = size && cleanTicks.dtick(size, dummyAx.type);\n\n  if (size) {\n    dummyAx.dtick = size;\n    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n  } else {\n    var size0;\n    if (nbins) size0 = (dataMax - dataMin) / nbins;else {\n      // totally auto: scale off std deviation so the highest bin is\n      // somewhat taller than the total number of bins, but don't let\n      // the size get smaller than the 'nice' rounded down minimum\n      // difference between values\n      var distinctData = Lib.distinctVals(data);\n      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));\n      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4)); // fallback if ax.d2c output BADNUMs\n      // e.g. when user try to plot categorical bins\n      // on a layout.xaxis.type: 'linear'\n\n      if (!isNumeric(size0)) size0 = 1;\n    }\n    axes.autoTicks(dummyAx, size0);\n  }\n\n  var finalSize = dummyAx.dtick;\n  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n  var binEnd, bincount; // check for too many data points right at the edges of bins\n  // (>50% within 1% of bin edges) or all data points integral\n  // and offset the bins accordingly\n\n  if (typeof finalSize === 'number') {\n    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n    binEnd = binStart + bincount * finalSize;\n  } else {\n    // month ticks - should be the only nonlinear kind we have at this point.\n    // dtick (as supplied by axes.autoTick) only has nonlinear values on\n    // date and log axes, but even if you display a histogram on a log axis\n    // we bin it on a linear axis (which one could argue against, but that's\n    // a separate issue)\n    if (dummyAx.dtick.charAt(0) === 'M') {\n      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n    } // calculate the endpoint for nonlinear ticks - you have to\n    // just increment until you're done\n\n\n    binEnd = binStart;\n    bincount = 0;\n\n    while (binEnd <= dataMax) {\n      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n      bincount++;\n    }\n  }\n\n  return {\n    start: ax.c2r(binStart, 0, calendar),\n    end: ax.c2r(binEnd, 0, calendar),\n    size: finalSize,\n    _dataSpan: dataMax - dataMin\n  };\n};\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n  var edgecount = 0;\n  var midcount = 0;\n  var intcount = 0;\n  var blankCount = 0;\n\n  function nearEdge(v) {\n    // is a value within 1% of a bin edge?\n    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n  }\n\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;\n    if (nearEdge(data[i])) edgecount++;\n    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;\n  }\n\n  var dataCount = data.length - blankCount;\n\n  if (intcount === dataCount && ax.type !== 'date') {\n    if (ax.dtick < 1) {\n      // all integers: if bin size is <1, it's because\n      // that was specifically requested (large nbins)\n      // so respect that... but center the bins containing\n      // integers on those integers\n      binStart = dataMin - 0.5 * ax.dtick;\n    } else {\n      // otherwise start half an integer down regardless of\n      // the bin size, just enough to clear up endpoint\n      // ambiguity about which integers are in which bins.\n      binStart -= 0.5;\n      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;\n    }\n  } else if (midcount < dataCount * 0.1) {\n    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {\n      // lots of points at the edge, not many in the middle\n      // shift half a bin\n      var binshift = ax.dtick / 2;\n      binStart += binStart + binshift < dataMin ? binshift : -binshift;\n    }\n  }\n\n  return binStart;\n}\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n  var stats = Lib.findExactDates(data, calendar); // number of data points that needs to be an exact value\n  // to shift that increment to (near) the bin center\n\n  var threshold = 0.8;\n\n  if (stats.exactDays > threshold) {\n    var numMonths = Number(dtick.substr(1));\n\n    if (stats.exactYears > threshold && numMonths % 12 === 0) {\n      // The exact middle of a non-leap-year is 1.5 days into July\n      // so if we start the bins here, all but leap years will\n      // get hover-labeled as exact years.\n      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n    } else if (stats.exactMonths > threshold) {\n      // Months are not as clean, but if we shift half the *longest*\n      // month (31/2 days) then 31-day months will get labeled exactly\n      // and shorter months will get labeled with the correct month\n      // but shifted 12-36 hours into it.\n      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n    } else {\n      // Shifting half a day is exact, but since these are month bins it\n      // will always give a somewhat odd-looking label, until we do something\n      // smarter like showing the bin boundaries (or the bounds of the actual\n      // data in each bin)\n      binStart -= HALFDAY;\n    }\n\n    var nextBinStart = axes.tickIncrement(binStart, dtick);\n    if (nextBinStart <= dataMin) return nextBinStart;\n  }\n\n  return binStart;\n} // ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n// ensure we have minor tick0 and dtick calculated\n\n\naxes.prepMinorTicks = function (mockAx, ax, opts) {\n  if (!ax.minor.dtick) {\n    delete mockAx.dtick;\n    var hasMajor = ax.dtick && isNumeric(ax._tmin);\n    var mockMinorRange;\n\n    if (hasMajor) {\n      var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true); // mock range a tiny bit smaller than one major tick interval\n\n      mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];\n    } else {\n      var rl = Lib.simpleMap(ax.range, ax.r2l); // If we don't have a major dtick, the concept of minor ticks is a little\n      // ambiguous - just take a stab and say minor.nticks should span 1/5 the axis\n\n      mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];\n    }\n\n    mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);\n    mockAx._isMinor = true;\n    axes.prepTicks(mockAx, opts);\n\n    if (hasMajor) {\n      var numericMajor = isNumeric(ax.dtick);\n      var numericMinor = isNumeric(mockAx.dtick);\n      var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);\n      var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);\n\n      if (numericMajor && numericMinor) {\n        if (!isMultiple(majorNum, minorNum)) {\n          // give up on minor ticks - outside the below exceptions,\n          // this can only happen if minor.nticks is smaller than two jumps\n          // in the auto-tick scale and the first jump is not an even multiple\n          // (5 -> 2 or for dates 3 ->2, 15 -> 10 etc)  or if you provided\n          // an explicit dtick, in which case it's fine to give up,\n          // you can provide an explicit minor.dtick.\n          if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {\n            mockAx.dtick = ONEWEEK;\n          } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {\n            // minor.nticks defaults to 5, but in this one case we want 7,\n            // so the minor ticks show on all days of the week\n            mockAx.dtick = ONEDAY;\n          } else if (isClose(majorNum / minorNum, 2.5)) {\n            // 5*10^n -> 2*10^n and you've set nticks < 5\n            // quarters are pretty common, we don't do this by default as it\n            // would add an extra digit to display, but minor has no labels\n            mockAx.dtick = majorNum / 2;\n          } else {\n            mockAx.dtick = majorNum;\n          }\n        } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {\n          // this is a weird one: we don't want to automatically choose\n          // 2-day minor ticks for 2-week major, even though it IS an even multiple,\n          // because people would expect to see the weeks clearly\n          mockAx.dtick = ONEWEEK;\n        }\n      } else if (String(ax.dtick).charAt(0) === 'M') {\n        if (numericMinor) {\n          mockAx.dtick = 'M1';\n        } else {\n          if (!isMultiple(majorNum, minorNum)) {\n            // unless you provided an explicit ax.dtick (in which case\n            // it's OK for us to give up, you can provide an explicit\n            // minor.dtick too), this can only happen with:\n            // minor.nticks < 3 and dtick === M3, or\n            // minor.nticks < 5 and dtick === 5 * 10^n years\n            // so in all cases we just give up.\n            mockAx.dtick = ax.dtick;\n          } else if (majorNum >= 12 && minorNum === 2) {\n            // another special carve-out: for year major ticks, don't show\n            // 2-month minor ticks, bump to quarters\n            mockAx.dtick = 'M3';\n          }\n        }\n      } else if (String(mockAx.dtick).charAt(0) === 'L') {\n        if (String(ax.dtick).charAt(0) === 'L') {\n          if (!isMultiple(majorNum, minorNum)) {\n            mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;\n          }\n        } else {\n          mockAx.dtick = 'D1';\n        }\n      } else if (mockAx.dtick === 'D2' && +ax.dtick > 1) {\n        // the D2 log axis tick spacing is confusing for unlabeled minor ticks if\n        // the major dtick is more than one order of magnitude.\n        mockAx.dtick = 1;\n      }\n    } // put back the original range, to use to find the full set of minor ticks\n\n\n    mockAx.range = ax.range;\n  }\n\n  if (ax.minor._tick0Init === undefined) {\n    // ensure identical tick0\n    mockAx.tick0 = ax.tick0;\n  }\n};\n\nfunction isMultiple(bigger, smaller) {\n  return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 0.001;\n}\n\nfunction isClose(a, b) {\n  return Math.abs(a / b - 1) < 0.001;\n} // ensure we have tick0, dtick, and tick rounding calculated\n\n\naxes.prepTicks = function (ax, opts) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts); // calculate max number of (auto) ticks to display based on plot size\n\n  if (ax.tickmode === 'auto' || !ax.dtick) {\n    var nt = ax.nticks;\n    var minPx;\n\n    if (!nt) {\n      if (ax.type === 'category' || ax.type === 'multicategory') {\n        minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;\n        nt = ax._length / minPx;\n      } else {\n        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n      } // radial axes span half their domain,\n      // multiply nticks value by two to get correct number of auto ticks.\n\n\n      if (ax._name === 'radialaxis') nt *= 2;\n    }\n\n    if (!(ax.minor && ax.minor.tickmode !== 'array')) {\n      // add a couple of extra digits for filling in ticks when we\n      // have explicit tickvals without tick text\n      if (ax.tickmode === 'array') nt *= 100;\n    }\n\n    ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;\n    axes.autoTicks(ax, ax._roughDTick); // check for a forced minimum dtick\n\n    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n      ax.dtick = ax._minDtick;\n      ax.tick0 = ax.l2r(ax._forceTick0);\n    }\n  }\n\n  if (ax.ticklabelmode === 'period') {\n    adjustPeriodDelta(ax);\n  } // check for missing tick0\n\n\n  if (!ax.tick0) {\n    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;\n  } // ensure we don't try to make ticks below our minimum precision\n  // see https://github.com/plotly/plotly.js/issues/2892\n\n\n  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1; // now figure out rounding of tick values\n\n  autoTickRound(ax);\n};\n\nfunction nMonths(dtick) {\n  return +dtick.substring(1);\n}\n\nfunction adjustPeriodDelta(ax) {\n  // adjusts ax.dtick and sets ax._definedDelta\n  var definedDelta;\n\n  function mDate() {\n    return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== 'M');\n  }\n\n  var isMDate = mDate();\n  var tickformat = axes.getTickFormat(ax);\n\n  if (tickformat) {\n    var noDtick = ax._dtickInit !== ax.dtick;\n\n    if (!/%[fLQsSMX]/.test(tickformat) // %f: microseconds as a decimal number [000000, 999999]\n    // %L: milliseconds as a decimal number [000, 999]\n    // %Q: milliseconds since UNIX epoch\n    // %s: seconds since UNIX epoch\n    // %S: second as a decimal number [00,61]\n    // %M: minute as a decimal number [00,59]\n    // %X: the locale’s time, such as %-I:%M:%S %p\n    ) {\n        if (/%[HI]/.test(tickformat) // %H: hour (24-hour clock) as a decimal number [00,23]\n        // %I: hour (12-hour clock) as a decimal number [01,12]\n        ) {\n            definedDelta = ONEHOUR;\n            if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;\n          } else if (/%p/.test(tickformat) // %p: either AM or PM\n        ) {\n            definedDelta = HALFDAY;\n            if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;\n          } else if (/%[Aadejuwx]/.test(tickformat) // %A: full weekday name\n        // %a: abbreviated weekday name\n        // %d: zero-padded day of the month as a decimal number [01,31]\n        // %e: space-padded day of the month as a decimal number [ 1,31]\n        // %j: day of the year as a decimal number [001,366]\n        // %u: Monday-based (ISO 8601) weekday as a decimal number [1,7]\n        // %w: Sunday-based weekday as a decimal number [0,6]\n        // %x: the locale’s date, such as %-m/%-d/%Y\n        ) {\n            definedDelta = ONEDAY;\n            if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;\n          } else if (/%[UVW]/.test(tickformat) // %U: Sunday-based week of the year as a decimal number [00,53]\n        // %V: ISO 8601 week of the year as a decimal number [01, 53]\n        // %W: Monday-based week of the year as a decimal number [00,53]\n        ) {\n            definedDelta = ONEWEEK;\n            if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;\n          } else if (/%[Bbm]/.test(tickformat) // %B: full month name\n        // %b: abbreviated month name\n        // %m: month as a decimal number [01,12]\n        ) {\n            definedDelta = ONEAVGMONTH;\n            if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = 'M1';\n          } else if (/%[q]/.test(tickformat) // %q: quarter of the year as a decimal number [1,4]\n        ) {\n            definedDelta = ONEAVGQUARTER;\n            if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = 'M3';\n          } else if (/%[Yy]/.test(tickformat) // %Y: year with century as a decimal number, such as 1999\n        // %y: year without century as a decimal number [00,99]\n        ) {\n            definedDelta = ONEAVGYEAR;\n            if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = 'M12';\n          }\n      }\n  }\n\n  isMDate = mDate();\n\n  if (isMDate && ax.tick0 === ax._dowTick0) {\n    // discard Sunday/Monday tweaks\n    ax.tick0 = ax._rawTick0;\n  }\n\n  ax._definedDelta = definedDelta;\n}\n\nfunction positionPeriodTicks(tickVals, ax, definedDelta) {\n  for (var i = 0; i < tickVals.length; i++) {\n    var v = tickVals[i].value;\n    var a = i;\n    var b = i + 1;\n\n    if (i < tickVals.length - 1) {\n      a = i;\n      b = i + 1;\n    } else if (i > 0) {\n      a = i - 1;\n      b = i;\n    } else {\n      a = i;\n      b = i;\n    }\n\n    var A = tickVals[a].value;\n    var B = tickVals[b].value;\n    var actualDelta = Math.abs(B - A);\n    var delta = definedDelta || actualDelta;\n    var periodLength = 0;\n\n    if (delta >= ONEMINYEAR) {\n      if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGYEAR;\n      }\n    } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {\n      if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGQUARTER;\n      }\n    } else if (delta >= ONEMINMONTH) {\n      if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {\n        periodLength = actualDelta;\n      } else {\n        periodLength = ONEAVGMONTH;\n      }\n    } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {\n      periodLength = ONEWEEK;\n    } else if (delta >= ONEDAY) {\n      periodLength = ONEDAY;\n    } else if (definedDelta === HALFDAY && delta >= HALFDAY) {\n      periodLength = HALFDAY;\n    } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {\n      periodLength = ONEHOUR;\n    }\n\n    var inBetween;\n\n    if (periodLength >= actualDelta) {\n      // ensure new label positions remain between ticks\n      periodLength = actualDelta;\n      inBetween = true;\n    }\n\n    var endPeriod = v + periodLength;\n\n    if (ax.rangebreaks && periodLength > 0) {\n      var nAll = 84; // highly divisible 7 * 12\n\n      var n = 0;\n\n      for (var c = 0; c < nAll; c++) {\n        var r = (c + 0.5) / nAll;\n        if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;\n      }\n\n      periodLength *= n / nAll;\n\n      if (!periodLength) {\n        tickVals[i].drop = true;\n      }\n\n      if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta; // center monthly & longer periods\n    }\n\n    if (periodLength > 0 || // not instant\n    i === 0 // taking care first tick added\n    ) {\n        tickVals[i].periodX = v + periodLength / 2;\n      }\n  }\n} // calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\n\n\naxes.calcTicks = function calcTicks(ax, opts) {\n  var type = ax.type;\n  var calendar = ax.calendar;\n  var ticklabelstep = ax.ticklabelstep;\n  var isPeriod = ax.ticklabelmode === 'period';\n  var rng = Lib.simpleMap(ax.range, ax.r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var minRange = Math.min(rng[0], rng[1]);\n  var maxRange = Math.max(rng[0], rng[1]);\n  var maxTicks = Math.max(1000, ax._length || 0);\n  var ticksOut = [];\n  var minorTicks = [];\n  var tickVals = [];\n  var minorTickVals = [];\n  var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid); // calc major first\n\n  for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {\n    var isMinor = !major;\n\n    if (major) {\n      ax._dtickInit = ax.dtick;\n      ax._tick0Init = ax.tick0;\n    } else {\n      ax.minor._dtickInit = ax.minor.dtick;\n      ax.minor._tick0Init = ax.minor.tick0;\n    }\n\n    var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);\n\n    if (isMinor) {\n      axes.prepMinorTicks(mockAx, ax, opts);\n    } else {\n      axes.prepTicks(mockAx, opts);\n    } // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n\n\n    if (mockAx.tickmode === 'array') {\n      if (major) {\n        tickVals = [];\n        ticksOut = arrayTicks(ax);\n      } else {\n        minorTickVals = [];\n        minorTicks = arrayTicks(ax);\n      }\n\n      continue;\n    } // add a tiny bit so we get ticks which may have rounded out\n\n\n    var exRng = expandRange(rng);\n    var startTick = exRng[0];\n    var endTick = exRng[1];\n    var numDtick = isNumeric(mockAx.dtick);\n    var isDLog = type === 'log' && !(numDtick || mockAx.dtick.charAt(0) === 'L'); // find the first tick\n\n    var x0 = axes.tickFirst(mockAx, opts);\n\n    if (major) {\n      ax._tmin = x0; // No visible ticks? Quit.\n      // I've only seen this on category axes with all categories off the edge.\n\n      if (x0 < startTick !== axrev) break; // return the full set of tick vals\n\n      if (type === 'category' || type === 'multicategory') {\n        endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);\n      }\n    }\n\n    var prevX = null;\n    var x = x0;\n    var majorId;\n\n    if (major) {\n      // ids for ticklabelstep\n      var _dTick;\n\n      if (numDtick) {\n        _dTick = ax.dtick;\n      } else {\n        if (type === 'date') {\n          if (typeof ax.dtick === 'string' && ax.dtick.charAt(0) === 'M') {\n            _dTick = ONEAVGMONTH * ax.dtick.substring(1);\n          }\n        } else {\n          _dTick = ax._roughDTick;\n        }\n      }\n\n      majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;\n    }\n\n    var dtick = mockAx.dtick;\n\n    if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {\n      // adjust tick0\n      x = moveOutsideBreak(x, ax);\n\n      if (!axrev) {\n        x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      }\n    }\n\n    if (major && isPeriod) {\n      // add one item to label period before tick0\n      x = axes.tickIncrement(x, dtick, !axrev, calendar);\n      majorId--;\n    }\n\n    for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, dtick, axrev, calendar)) {\n      if (major) majorId++;\n\n      if (mockAx.rangebreaks) {\n        if (!axrev) {\n          if (x < startTick) continue;\n          if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;\n        }\n      } // prevent infinite loops - no more than one tick per pixel,\n      // and make sure each value is different from the previous\n\n\n      if (tickVals.length > maxTicks || x === prevX) break;\n      prevX = x;\n      var obj = {\n        value: x\n      };\n\n      if (major) {\n        if (isDLog && x !== (x | 0)) {\n          obj.simpleLabel = true;\n        }\n\n        if (ticklabelstep > 1 && majorId % ticklabelstep) {\n          obj.skipLabel = true;\n        }\n\n        tickVals.push(obj);\n      } else {\n        obj.minor = true;\n        minorTickVals.push(obj);\n      }\n    }\n  }\n\n  if (hasMinor) {\n    var canOverlap = ax.minor.ticks === 'inside' && ax.ticks === 'outside' || ax.minor.ticks === 'outside' && ax.ticks === 'inside';\n\n    if (!canOverlap) {\n      // remove duplicate minors\n      var majorValues = tickVals.map(function (d) {\n        return d.value;\n      });\n      var list = [];\n\n      for (var k = 0; k < minorTickVals.length; k++) {\n        var T = minorTickVals[k];\n        var v = T.value;\n\n        if (majorValues.indexOf(v) !== -1) {\n          continue;\n        }\n\n        var found = false;\n\n        for (var q = 0; !found && q < tickVals.length; q++) {\n          if ( // add 10e6 to eliminate problematic digits\n          10e6 + tickVals[q].value === 10e6 + v) {\n            found = true;\n          }\n        }\n\n        if (!found) list.push(T);\n      }\n\n      minorTickVals = list;\n    }\n  }\n\n  if (isPeriod) positionPeriodTicks(tickVals, ax, ax._definedDelta);\n  var i;\n\n  if (ax.rangebreaks) {\n    var flip = ax._id.charAt(0) === 'y';\n    var fontSize = 1; // one pixel minimum\n\n    if (ax.tickmode === 'auto') {\n      fontSize = ax.tickfont ? ax.tickfont.size : 12;\n    }\n\n    var prevL = NaN;\n\n    for (i = tickVals.length - 1; i > -1; i--) {\n      if (tickVals[i].drop) {\n        tickVals.splice(i, 1);\n        continue;\n      }\n\n      tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax); // avoid overlaps\n\n      var l = ax.c2p(tickVals[i].value);\n\n      if (flip ? prevL > l - fontSize : prevL < l + fontSize) {\n        // ensure one pixel minimum\n        tickVals.splice(axrev ? i + 1 : i, 1);\n      } else {\n        prevL = l;\n      }\n    }\n  } // If same angle over a full circle, the last tick vals is a duplicate.\n  // TODO must do something similar for angular date axes.\n\n\n  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n    tickVals.pop();\n  } // save the last tick as well as first, so we can\n  // show the exponent only on the last one\n\n\n  ax._tmax = (tickVals[tickVals.length - 1] || {}).value; // for showing the rest of a date when the main tick label is only the\n  // latter part: ax._prevDateHead holds what we showed most recently.\n  // Start with it cleared and mark that we're in calcTicks (ie calculating a\n  // whole string of these so we should care what the previous date head was!)\n\n  ax._prevDateHead = '';\n  ax._inCalcTicks = true;\n  var lastVisibleHead;\n\n  var hideLabel = function hideLabel(tick) {\n    tick.text = '';\n    ax._prevDateHead = lastVisibleHead;\n  };\n\n  tickVals = tickVals.concat(minorTickVals);\n  var t, p;\n\n  for (i = 0; i < tickVals.length; i++) {\n    var _minor = tickVals[i].minor;\n    var _value = tickVals[i].value;\n\n    if (_minor) {\n      minorTicks.push({\n        x: _value,\n        minor: true\n      });\n    } else {\n      lastVisibleHead = ax._prevDateHead;\n      t = axes.tickText(ax, _value, false, // hover\n      tickVals[i].simpleLabel // noSuffixPrefix\n      );\n      p = tickVals[i].periodX;\n\n      if (p !== undefined) {\n        t.periodX = p;\n\n        if (p > maxRange || p < minRange) {\n          // hide label if outside the range\n          if (p > maxRange) t.periodX = maxRange;\n          if (p < minRange) t.periodX = minRange;\n          hideLabel(t);\n        }\n      }\n\n      if (tickVals[i].skipLabel) {\n        hideLabel(t);\n      }\n\n      ticksOut.push(t);\n    }\n  }\n\n  ticksOut = ticksOut.concat(minorTicks);\n  ax._inCalcTicks = false;\n\n  if (isPeriod && ticksOut.length) {\n    // drop very first tick that we added to handle period\n    ticksOut[0].noTick = true;\n  }\n\n  return ticksOut;\n};\n\nfunction arrayTicks(ax) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  var exRng = expandRange(rng);\n  var tickMin = Math.min(exRng[0], exRng[1]);\n  var tickMax = Math.max(exRng[0], exRng[1]); // make sure showing ticks doesn't accidentally add new categories\n  // TODO multicategory, if we allow ticktext / tickvals\n\n  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l; // array ticks on log axes always show the full number\n  // (if no explicit ticktext overrides it)\n\n  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n  }\n\n  var ticksOut = [];\n\n  for (var isMinor = 0; isMinor <= 1; isMinor++) {\n    if (isMinor && !ax.minor) continue;\n    var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;\n    var text = !isMinor ? ax.ticktext : [];\n    if (!vals) continue; // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n\n    if (!Array.isArray(text)) text = [];\n\n    for (var i = 0; i < vals.length; i++) {\n      var vali = tickVal2l(vals[i]);\n\n      if (vali > tickMin && vali < tickMax) {\n        var obj = text[i] === undefined ? axes.tickText(ax, vali) : tickTextObj(ax, vali, String(text[i]));\n\n        if (isMinor) {\n          obj.minor = true;\n          obj.text = '';\n        }\n\n        ticksOut.push(obj);\n      }\n    }\n  }\n\n  if (ax.rangebreaks) {\n    // remove ticks falling inside rangebreaks\n    ticksOut = ticksOut.filter(function (d) {\n      return ax.maskBreaks(d.x) !== BADNUM;\n    });\n  }\n\n  return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30]; // 2&3 day ticks are weird, but need something btwn 1&7\n\nvar roundDays = [1, 2, 3, 7, 14]; // approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\n\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1]; // N.B. `thetaunit; 'radians' angular axes must be converted to degrees\n\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n  return base * Lib.roundUp(roughDTick / base, roundingSet);\n} // autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\n\n\naxes.autoTicks = function (ax, roughDTick, isMinor) {\n  var base;\n\n  function getBase(v) {\n    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n  }\n\n  if (ax.type === 'date') {\n    ax.tick0 = Lib.dateTick0(ax.calendar, 0); // the criteria below are all based on the rough spacing we calculate\n    // being > half of the final unit - so precalculate twice the rough val\n\n    var roughX2 = 2 * roughDTick;\n\n    if (roughX2 > ONEAVGYEAR) {\n      roughDTick /= ONEAVGYEAR;\n      base = getBase(10);\n      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);\n    } else if (roughX2 > ONEAVGMONTH) {\n      roughDTick /= ONEAVGMONTH;\n      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n    } else if (roughX2 > ONEDAY) {\n      ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);\n\n      if (!isMinor) {\n        // get week ticks on sunday\n        // this will also move the base tick off 2000-01-01 if dtick is\n        // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n        var tickformat = axes.getTickFormat(ax);\n        var isPeriod = ax.ticklabelmode === 'period';\n        if (isPeriod) ax._rawTick0 = ax.tick0;\n\n        if (/%[uVW]/.test(tickformat)) {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 2); // Monday\n        } else {\n          ax.tick0 = Lib.dateTick0(ax.calendar, 1); // Sunday\n        }\n\n        if (isPeriod) ax._dowTick0 = ax.tick0;\n      }\n    } else if (roughX2 > ONEHOUR) {\n      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n    } else if (roughX2 > ONEMIN) {\n      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n    } else if (roughX2 > ONESEC) {\n      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n    } else {\n      // milliseconds\n      base = getBase(10);\n      ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n  } else if (ax.type === 'log') {\n    ax.tick0 = 0;\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n    if (ax._isMinor) {\n      // Log axes by default get MORE than nTicks based on the metrics below\n      // But for minor ticks we don't want this increase, we already have\n      // the major ticks.\n      roughDTick *= 1.5;\n    }\n\n    if (roughDTick > 0.7) {\n      // only show powers of 10\n      ax.dtick = Math.ceil(roughDTick);\n    } else if (Math.abs(rng[1] - rng[0]) < 1) {\n      // span is less than one power of 10\n      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick); // ticks on a linear scale, labeled fully\n\n      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;\n      base = getBase(10);\n      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n    } else {\n      // include intermediates between powers of 10,\n      // labeled with small digits\n      // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';\n    }\n  } else if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax.tick0 = 0;\n    ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n  } else if (isAngular(ax)) {\n    ax.tick0 = 0;\n    base = 1;\n    ax.dtick = roundDTick(roughDTick, base, roundAngles);\n  } else {\n    // auto ticks always start at 0\n    ax.tick0 = 0;\n    base = getBase(10);\n    ax.dtick = roundDTick(roughDTick, base, roundBase10);\n  } // prevent infinite loops\n\n\n  if (ax.dtick === 0) ax.dtick = 1; // TODO: this is from log axis histograms with autorange off\n\n  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n    var olddtick = ax.dtick;\n    ax.dtick = 1;\n    throw 'ax.dtick error: ' + String(olddtick);\n  }\n}; // after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\n\n\nfunction autoTickRound(ax) {\n  var dtick = ax.dtick;\n  ax._tickexponent = 0;\n\n  if (!isNumeric(dtick) && typeof dtick !== 'string') {\n    dtick = 1;\n  }\n\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax._tickround = null;\n  }\n\n  if (ax.type === 'date') {\n    // If tick0 is unusual, give tickround a bit more information\n    // not necessarily *all* the information in tick0 though, if it's really odd\n    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n    var tick0ms = ax.r2l(ax.tick0);\n    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n    var tick0len = tick0str.length;\n\n    if (String(dtick).charAt(0) === 'M') {\n      // any tick0 more specific than a year: alway show the full date\n      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd'; // show the month unless ticks are full multiples of a year\n      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';\n    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {\n      // tickround is a number of digits of fractional seconds\n      // of any two adjacent ticks, at least one will have the maximum fractional digits\n      // of all possible ticks - so take the max. length of tick0 and the next one\n      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n      ax._tickround = Math.max(tick0len, tick1len) - 20; // We shouldn't get here... but in case there's a situation I'm\n      // not thinking of where tick0str and tick1str are identical or\n      // something, fall back on maximum precision\n\n      if (ax._tickround < 0) ax._tickround = 4;\n    }\n  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {\n    // linear or log (except D1, D2)\n    var rng = ax.range.map(ax.r2d || Number);\n    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1)); // 2 digits past largest digit of dtick\n\n    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n    var minexponent = ax.minexponent === undefined ? 3 : ax.minexponent;\n\n    if (Math.abs(rangeexp) > minexponent) {\n      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n      } else ax._tickexponent = rangeexp;\n    }\n  } else {\n    // D1 or D2 (log)\n    ax._tickround = null;\n  }\n} // months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\n\n\naxes.tickIncrement = function (x, dtick, axrev, calendar) {\n  var axSign = axrev ? -1 : 1; // includes linear, all dates smaller than month, and pure 10^n in log\n\n  if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick); // everything else is a string, one character plus a number\n\n  var tType = dtick.charAt(0);\n  var dtSigned = axSign * Number(dtick.substr(1)); // Dates: months (or years - see Lib.incrementMonth)\n\n  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar); // Log scales: Linear, Digits\n\n  if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10; // log10 of 2,5,10, or all digits (logs just have to be\n  // close enough to round)\n\n  if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var x2 = x + axSign * 0.01;\n    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  }\n\n  throw 'unrecognized dtick ' + String(dtick);\n}; // calculate the first tick on an axis\n\n\naxes.tickFirst = function (ax, opts) {\n  var r2l = ax.r2l || Number;\n  var rng = Lib.simpleMap(ax.range, r2l, undefined, undefined, opts);\n  var axrev = rng[1] < rng[0];\n  var sRound = axrev ? Math.floor : Math.ceil; // add a tiny extra bit to make sure we get ticks\n  // that may have been rounded out\n\n  var r0 = expandRange(rng)[0];\n  var dtick = ax.dtick;\n  var tick0 = r2l(ax.tick0);\n\n  if (isNumeric(dtick)) {\n    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0; // make sure no ticks outside the category list\n\n    if (ax.type === 'category' || ax.type === 'multicategory') {\n      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n    }\n\n    return tmin;\n  }\n\n  var tType = dtick.charAt(0);\n  var dtNum = Number(dtick.substr(1)); // Dates: months (or years)\n\n  if (tType === 'M') {\n    var cnt = 0;\n    var t0 = tick0;\n    var t1, mult, newDTick; // This algorithm should work for *any* nonlinear (but close to linear!)\n    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n\n    while (cnt < 10) {\n      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n\n      if ((t1 - r0) * (t0 - r0) <= 0) {\n        // t1 and t0 are on opposite sides of r0! we've succeeded!\n        if (axrev) return Math.min(t0, t1);\n        return Math.max(t0, t1);\n      }\n\n      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);\n      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;\n      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n      cnt++;\n    }\n\n    Lib.error('tickFirst did not converge', ax);\n    return t0;\n  } else if (tType === 'L') {\n    // Log scales: Linear, Digits\n    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n  } else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n}; // draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\n\n\naxes.tickText = function (ax, x, hover, noSuffixPrefix) {\n  var out = tickTextObj(ax, x);\n  var arrayMode = ax.tickmode === 'array';\n  var extraPrecision = hover || arrayMode;\n  var axType = ax.type; // TODO multicategory, if we allow ticktext / tickvals\n\n  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n  var i;\n\n  if (arrayMode && Array.isArray(ax.ticktext)) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 10000;\n\n    for (i = 0; i < ax.ticktext.length; i++) {\n      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n    }\n\n    if (i < ax.ticktext.length) {\n      out.text = String(ax.ticktext[i]);\n      return out;\n    }\n  }\n\n  function isHidden(showAttr) {\n    if (showAttr === undefined) return true;\n    if (hover) return showAttr === 'none';\n    var firstOrLast = {\n      first: ax._tmin,\n      last: ax._tmax\n    }[showAttr];\n    return showAttr !== 'all' && x !== firstOrLast;\n  }\n\n  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp); // add prefix and suffix\n\n  if (!noSuffixPrefix) {\n    if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n  } // Setup ticks and grid lines boundaries\n  // at 1/2 a 'category' to the left/bottom\n\n\n  if (ax.tickson === 'boundaries' || ax.showdividers) {\n    var inbounds = function inbounds(v) {\n      var p = ax.l2p(v);\n      return p >= 0 && p <= ax._length ? v : null;\n    };\n\n    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n  }\n\n  return out;\n};\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number or array of numbers} values: calcdata value(s) to format\n * @param {Optional(string)} hoverformat: trace (x|y)hoverformat to override axis.hoverformat\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     first value and second value as a range (ie '<val1> - <val2>') if the second value is provided and\n *     it's different from the first value.\n */\n\n\naxes.hoverLabelText = function (ax, values, hoverformat) {\n  if (hoverformat) ax = Lib.extendFlat({}, ax, {\n    hoverformat: hoverformat\n  });\n  var val = Array.isArray(values) ? values[0] : values;\n  var val2 = Array.isArray(values) ? values[1] : undefined;\n\n  if (val2 !== undefined && val2 !== val) {\n    return axes.hoverLabelText(ax, val, hoverformat) + ' - ' + axes.hoverLabelText(ax, val2, hoverformat);\n  }\n\n  var logOffScale = ax.type === 'log' && val <= 0;\n  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n  if (logOffScale) {\n    return val === 0 ? '0' : MINUS_SIGN + tx;\n  } // TODO: should we do something special if the axis calendar and\n  // the data calendar are different? Somehow display both dates with\n  // their system names? Right now it will just display in the axis calendar\n  // but users could add the other one as text.\n\n\n  return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n  var tf = ax.tickfont || {};\n  return {\n    x: x,\n    dx: 0,\n    dy: 0,\n    text: text || '',\n    fontSize: tf.size,\n    font: tf.family,\n    fontColor: tf.color\n  };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n  var tr = ax._tickround;\n  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);\n\n  if (extraPrecision) {\n    // second or sub-second precision: extra always shows max digits.\n    // for other fields, extra precision just adds one field.\n    if (isNumeric(tr)) tr = 4;else tr = {\n      y: 'm',\n      m: 'd',\n      d: 'M',\n      M: 'S',\n      S: 4\n    }[tr];\n  }\n\n  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n  var headStr;\n  var splitIndex = dateStr.indexOf('\\n');\n\n  if (splitIndex !== -1) {\n    headStr = dateStr.substr(splitIndex + 1);\n    dateStr = dateStr.substr(0, splitIndex);\n  }\n\n  if (extraPrecision) {\n    // if extraPrecision led to trailing zeros, strip them off\n    // actually, this can lead to removing even more zeros than\n    // in the original rounding, but that's fine because in these\n    // contexts uniformity is not so important (if there's even\n    // anything to be uniform with!)\n    // can we remove the whole time part?\n    if (dateStr === '00:00:00' || dateStr === '00:00') {\n      dateStr = headStr;\n      headStr = '';\n    } else if (dateStr.length === 8) {\n      // strip off seconds if they're zero (zero fractional seconds\n      // are already omitted)\n      // but we never remove minutes and leave just hours\n      dateStr = dateStr.replace(/:00$/, '');\n    }\n  }\n\n  if (headStr) {\n    if (hover) {\n      // hover puts it all on one line, so headPart works best up front\n      // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n    } else {\n      if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {\n        ax._prevDateHead = headStr;\n        dateStr += '<br>' + headStr;\n      } else {\n        var isInside = insideTicklabelposition(ax);\n        var side = ax._trueSide || ax.side; // polar mocks the side of the radial axis\n\n        if (!isInside && side === 'top' || isInside && side === 'bottom') {\n          dateStr += '<br> ';\n        }\n      }\n    }\n  }\n\n  out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n  var dtick = ax.dtick;\n  var x = out.x;\n  var tickformat = ax.tickformat;\n  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  }\n\n  if (extraPrecision && dtChar0 !== 'L') {\n    dtick = 'L3';\n    dtChar0 = 'L';\n  }\n\n  if (tickformat || dtChar0 === 'L') {\n    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {\n    var p = Math.round(x);\n    var absP = Math.abs(p);\n    var exponentFormat = ax.exponentformat;\n\n    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {\n      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n      out.fontSize *= 1.25;\n    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n    } else {\n      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n\n      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {\n        out.dy -= out.fontSize / 6;\n      }\n    }\n  } else if (dtChar0 === 'D') {\n    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n    out.fontSize *= 0.75;\n  } else throw 'unrecognized dtick ' + String(dtick); // if 9's are printed on log scale, move the 10's away a bit\n\n\n  if (ax.dtick === 'D1') {\n    var firstChar = String(out.text).charAt(0);\n\n    if (firstChar === '0' || firstChar === '1') {\n      if (ax._id.charAt(0) === 'y') {\n        out.dx -= out.fontSize / 4;\n      } else {\n        out.dy += out.fontSize / 2;\n        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);\n      }\n    }\n  }\n}\n\nfunction formatCategory(ax, out) {\n  var tt = ax._categories[Math.round(out.x)];\n\n  if (tt === undefined) tt = '';\n  out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n  var v = Math.round(out.x);\n  var cats = ax._categories[v] || [];\n  var tt = cats[1] === undefined ? '' : String(cats[1]);\n  var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n  if (hover) {\n    // TODO is this what we want?\n    out.text = tt2 + ' - ' + tt;\n  } else {\n    // setup for secondary labels\n    out.text = tt;\n    out.text2 = tt2;\n  }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    hideexp = 'hide';\n  }\n\n  out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n  if (ax.thetaunit === 'radians' && !hover) {\n    var num = out.x / 180;\n\n    if (num === 0) {\n      out.text = '0';\n    } else {\n      var frac = num2frac(num);\n\n      if (frac[1] >= 100) {\n        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n      } else {\n        var isNeg = out.x < 0;\n\n        if (frac[1] === 1) {\n          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';\n        } else {\n          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');\n        }\n\n        if (isNeg) out.text = MINUS_SIGN + out.text;\n      }\n    }\n  } else {\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n  }\n} // inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\n\n\nfunction num2frac(num) {\n  function almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n  }\n\n  function findGCD(a, b) {\n    return almostEq(b, 0) ? a : findGCD(b, a % b);\n  }\n\n  function findPrecision(n) {\n    var e = 1;\n\n    while (!almostEq(Math.round(n * e) / e, n)) {\n      e *= 10;\n    }\n\n    return e;\n  }\n\n  var precision = findPrecision(num);\n  var number = num * precision;\n  var gcd = Math.abs(findGCD(number, precision));\n  return [// numerator\n  Math.round(number / gcd), // denominator\n  Math.round(precision / gcd)];\n} // format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\n\n\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n  return exponentFormat === 'SI' || exponentFormat === 'B';\n} // are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\n\n\nfunction beyondSI(exponent) {\n  return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n  var isNeg = v < 0; // max number of digits past decimal point to show\n\n  var tickRound = ax._tickround;\n  var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n  var exponent = ax._tickexponent;\n  var tickformat = axes.getTickFormat(ax);\n  var separatethousands = ax.separatethousands; // special case for hover: set exponent just for this value, and\n  // add a couple more digits of precision over tick labels\n\n  if (hover) {\n    // make a dummy axis obj to get the auto rounding and exponent\n    var ah = {\n      exponentformat: exponentFormat,\n      minexponent: ax.minexponent,\n      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,\n      // if not showing any exponents, don't change the exponent\n      // from what we calculate\n      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n    };\n    autoTickRound(ah);\n    tickRound = (Number(ah._tickround) || 0) + 4;\n    exponent = ah._tickexponent;\n    if (ax.hoverformat) tickformat = ax.hoverformat;\n  }\n\n  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN); // 'epsilon' - rounding increment\n\n  var e = Math.pow(10, -tickRound) / 2; // exponentFormat codes:\n  // 'e' (1.2e+6, default)\n  // 'E' (1.2E+6)\n  // 'SI' (1.2M)\n  // 'B' (same as SI except 10^9=B not G)\n  // 'none' (1200000)\n  // 'power' (1.2x10^6)\n  // 'hide' (1.2, use 3rd argument=='hide' to eg\n  //      only show exponent on last tick)\n\n  if (exponentFormat === 'none') exponent = 0; // take the sign out, put it back manually at the end\n  // - makes cases easier\n\n  v = Math.abs(v);\n\n  if (v < e) {\n    // 0 is just 0, but may get exponent if it's the last tick\n    v = '0';\n    isNeg = false;\n  } else {\n    v += e; // take out a common exponent, if any\n\n    if (exponent) {\n      v *= Math.pow(10, -exponent);\n      tickRound += exponent;\n    } // round the mantissa\n\n\n    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {\n      v = String(Math.round(v));\n      v = v.substr(0, v.length + tickRound);\n\n      for (var i = tickRound; i < 0; i++) {\n        v += '0';\n      }\n    } else {\n      v = String(v);\n      var dp = v.indexOf('.') + 1;\n      if (dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n    } // insert appropriate decimal point and thousands separator\n\n    v = Lib.numSeparate(v, ax._separators, separatethousands);\n  } // add exponent\n\n\n  if (exponent && exponentFormat !== 'hide') {\n    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n    var signedExponent;\n    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);\n\n    if (exponentFormat === 'e' || exponentFormat === 'E') {\n      v += exponentFormat + signedExponent;\n    } else if (exponentFormat === 'power') {\n      v += '×10<sup>' + signedExponent + '</sup>';\n    } else if (exponentFormat === 'B' && exponent === 9) {\n      v += 'B';\n    } else if (isSIFormat(exponentFormat)) {\n      v += SIPREFIXES[exponent / 3 + 5];\n    }\n  } // put sign back in and return\n  // replace standard minus character (which is technically a hyphen)\n  // with a true minus sign\n\n\n  if (isNeg) return MINUS_SIGN + v;\n  return v;\n}\n\naxes.getTickFormat = function (ax) {\n  var i;\n\n  function convertToMs(dtick) {\n    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n  }\n\n  function compareLogTicks(left, right) {\n    var priority = ['L', 'D'];\n\n    if (typeof left === typeof right) {\n      if (typeof left === 'number') {\n        return left - right;\n      } else {\n        var leftPriority = priority.indexOf(left.charAt(0));\n        var rightPriority = priority.indexOf(right.charAt(0));\n\n        if (leftPriority === rightPriority) {\n          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n        } else {\n          return leftPriority - rightPriority;\n        }\n      }\n    } else {\n      return typeof left === 'number' ? 1 : -1;\n    }\n  }\n\n  function isProperStop(dtick, range, convert) {\n    var convertFn = convert || function (x) {\n      return x;\n    };\n\n    var leftDtick = range[0];\n    var rightDtick = range[1];\n    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));\n  }\n\n  function isProperLogStop(dtick, range) {\n    var isLeftDtickNull = range[0] === null;\n    var isRightDtickNull = range[1] === null;\n    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n  }\n\n  var tickstop, stopi;\n\n  if (ax.tickformatstops && ax.tickformatstops.length > 0) {\n    switch (ax.type) {\n      case 'date':\n      case 'linear':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n\n            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n\n          break;\n        }\n\n      case 'log':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n\n            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n\n          break;\n        }\n\n      default:\n    }\n  }\n\n  return tickstop ? tickstop.value : ax.tickformat;\n}; // getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\n\n\naxes.getSubplots = function (gd, ax) {\n  var subplotObj = gd._fullLayout._subplots;\n  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n  out.sort(function (a, b) {\n    var aParts = a.substr(1).split('y');\n    var bParts = b.substr(1).split('y');\n    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n    return +aParts[0] - +bParts[0];\n  });\n  return out;\n}; // find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\n\n\naxes.findSubplotsWithAxis = function (subplots, ax) {\n  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');\n  var subplotsWithAx = [];\n\n  for (var i = 0; i < subplots.length; i++) {\n    var sp = subplots[i];\n    if (axMatch.test(sp)) subplotsWithAx.push(sp);\n  }\n\n  return subplotsWithAx;\n}; // makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\n\n\naxes.makeClipPaths = function (gd) {\n  var fullLayout = gd._fullLayout; // for more info: https://github.com/plotly/plotly.js/issues/2595\n\n  if (fullLayout._hasOnlyLargeSploms) return;\n  var fullWidth = {\n    _offset: 0,\n    _length: fullLayout.width,\n    _id: ''\n  };\n  var fullHeight = {\n    _offset: 0,\n    _length: fullLayout.height,\n    _id: ''\n  };\n  var xaList = axes.list(gd, 'x', true);\n  var yaList = axes.list(gd, 'y', true);\n  var clipList = [];\n  var i, j;\n\n  for (i = 0; i < xaList.length; i++) {\n    clipList.push({\n      x: xaList[i],\n      y: fullHeight\n    });\n\n    for (j = 0; j < yaList.length; j++) {\n      if (i === 0) clipList.push({\n        x: fullWidth,\n        y: yaList[j]\n      });\n      clipList.push({\n        x: xaList[i],\n        y: yaList[j]\n      });\n    }\n  } // selectors don't work right with camelCase tags,\n  // have to use class instead\n  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n\n\n  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {\n    return d.x._id + d.y._id;\n  });\n\n  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {\n    return 'clip' + fullLayout._uid + d.x._id + d.y._id;\n  }).append('rect');\n  axClips.exit().remove();\n  axClips.each(function (d) {\n    d3.select(this).select('rect').attr({\n      x: d.x._offset || 0,\n      y: d.y._offset || 0,\n      width: d.x._length || 1,\n      height: d.y._length || 1\n    });\n  });\n};\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\n\n\naxes.draw = function (gd, arg, opts) {\n  var fullLayout = gd._fullLayout;\n\n  if (arg === 'redraw') {\n    fullLayout._paper.selectAll('g.subplot').each(function (d) {\n      var id = d[0];\n      var plotinfo = fullLayout._plots[id];\n\n      if (plotinfo) {\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n        plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n        plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n        if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll('path').remove();\n        if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n        if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n        fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n\n        fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n      }\n    });\n  }\n\n  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;\n  return Lib.syncOrAsync(axList.map(function (axId) {\n    return function () {\n      if (!axId) return;\n      var ax = axes.getFromId(gd, axId);\n      var axDone = axes.drawOne(gd, ax, opts);\n      ax._r = ax.range.slice();\n      ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n      return axDone;\n    };\n  }));\n};\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n *\n * Depends on:\n * - ax._mainSubplot (from linkSubplots)\n * - ax._mainAxis\n * - ax._anchorAxis\n * - ax._subplotsWith\n * - ax._counterDomainMin, ax._counterDomainMax (optionally, from linkSubplots)\n * - ax._tickAngles (on redraw only, old value relinked during supplyDefaults)\n * - ax._mainLinePosition (from lsInner)\n * - ax._mainMirrorPosition\n * - ax._linepositions\n *\n * Fills in:\n * - ax._vals:\n * - ax._gridVals:\n * - ax._selections:\n * - ax._tickAngles:\n * - ax._depth (when required only):\n * - and calls ax.setScale\n */\n\n\naxes.drawOne = function (gd, ax, opts) {\n  opts = opts || {};\n  var i, sp, plotinfo;\n  ax.setScale();\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var counterLetter = axes.counterLetter(axId);\n  var mainPlotinfo = fullLayout._plots[ax._mainSubplot]; // this happens when updating matched group with 'missing' axes\n\n  if (!mainPlotinfo) return;\n  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n  var mainLinePosition = ax._mainLinePosition;\n  var mainMirrorPosition = ax._mainMirrorPosition;\n  var vals = ax._vals = axes.calcTicks(ax); // Add a couple of axis properties that should cause us to recreate\n  // elements. Used in d3 data function.\n\n  var axInfo = [ax.mirror, mainLinePosition, mainMirrorPosition].join('_');\n\n  for (i = 0; i < vals.length; i++) {\n    vals[i].axInfo = axInfo;\n  } // stash selections to avoid DOM queries e.g.\n  // - stash tickLabels selection, so that drawTitle can use it to scoot title\n\n\n  ax._selections = {}; // stash tick angle (including the computed 'auto' values) per tick-label class\n  // linkup 'previous' tick angles on redraws\n\n  if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;\n  ax._tickAngles = {}; // measure [in px] between axis position and outward-most part of bounding box\n  // (touching either the tick label or ticks)\n  // depth can be expansive to compute, so we only do so when required\n\n  ax._depth = null; // calcLabelLevelBbox can be expensive,\n  // so make sure to not call it twice during the same Axes.drawOne call\n  // by stashing label-level bounding boxes per tick-label class\n\n  var llbboxes = {};\n\n  function getLabelLevelBbox(suffix) {\n    var cls = axId + (suffix || 'tick');\n    if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls);\n    return llbboxes[cls];\n  }\n\n  if (!ax.visible) return;\n  var transTickFn = axes.makeTransTickFn(ax);\n  var transTickLabelFn = axes.makeTransTickLabelFn(ax);\n  var tickVals; // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n  // The key case here is removing zero lines when the axis bound is zero\n\n  var valsClipped;\n  var insideTicks = ax.ticks === 'inside';\n  var outsideTicks = ax.ticks === 'outside';\n\n  if (ax.tickson === 'boundaries') {\n    var boundaryVals = getBoundaryVals(ax, vals);\n    valsClipped = axes.clipEnds(ax, boundaryVals);\n    tickVals = insideTicks ? valsClipped : boundaryVals;\n  } else {\n    valsClipped = axes.clipEnds(ax, vals);\n    tickVals = insideTicks && ax.ticklabelmode !== 'period' ? valsClipped : vals;\n  }\n\n  var gridVals = ax._gridVals = valsClipped;\n  var dividerVals = getDividerVals(ax, vals);\n\n  if (!fullLayout._hasOnlyLargeSploms) {\n    var subplotsWithAx = ax._subplotsWith; // keep track of which subplots (by main counter axis) we've already\n    // drawn grids for, so we don't overdraw overlaying subplots\n\n    var finishedGrids = {};\n\n    for (i = 0; i < subplotsWithAx.length; i++) {\n      sp = subplotsWithAx[i];\n      plotinfo = fullLayout._plots[sp];\n      var counterAxis = plotinfo[counterLetter + 'axis'];\n      var mainCounterID = counterAxis._mainAxis._id;\n      if (finishedGrids[mainCounterID]) continue;\n      finishedGrids[mainCounterID] = 1;\n      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;\n      axes.drawGrid(gd, ax, {\n        vals: gridVals,\n        counterAxis: counterAxis,\n        layer: plotinfo.gridlayer.select('.' + axId),\n        minorLayer: plotinfo.minorGridlayer.select('.' + axId),\n        path: gridPath,\n        transFn: transTickFn\n      });\n      axes.drawZeroLine(gd, ax, {\n        counterAxis: counterAxis,\n        layer: plotinfo.zerolinelayer,\n        path: gridPath,\n        transFn: transTickFn\n      });\n    }\n  }\n\n  var tickPath;\n  var majorTickSigns = axes.getTickSigns(ax);\n  var minorTickSigns = axes.getTickSigns(ax, 'minor');\n\n  if (ax.ticks || ax.minor && ax.minor.ticks) {\n    var majorTickPath = axes.makeTickPath(ax, mainLinePosition, majorTickSigns[2]);\n    var minorTickPath = axes.makeTickPath(ax, mainLinePosition, minorTickSigns[2], {\n      minor: true\n    });\n    var mirrorMajorTickPath;\n    var mirrorMinorTickPath;\n    var fullMajorTickPath;\n    var fullMinorTickPath;\n\n    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n      mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);\n      mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], {\n        minor: true\n      });\n      fullMajorTickPath = majorTickPath + mirrorMajorTickPath;\n      fullMinorTickPath = minorTickPath + mirrorMinorTickPath;\n    } else {\n      mirrorMajorTickPath = '';\n      mirrorMinorTickPath = '';\n      fullMajorTickPath = majorTickPath;\n      fullMinorTickPath = minorTickPath;\n    }\n\n    if (ax.showdividers && outsideTicks && ax.tickson === 'boundaries') {\n      var dividerLookup = {};\n\n      for (i = 0; i < dividerVals.length; i++) {\n        dividerLookup[dividerVals[i].x] = 1;\n      }\n\n      tickPath = function tickPath(d) {\n        return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;\n      };\n    } else {\n      tickPath = function tickPath(d) {\n        return d.minor ? fullMinorTickPath : fullMajorTickPath;\n      };\n    }\n  }\n\n  axes.drawTicks(gd, ax, {\n    vals: tickVals,\n    layer: mainAxLayer,\n    path: tickPath,\n    transFn: transTickFn\n  });\n\n  if (ax.mirror === 'allticks') {\n    var tickSubplots = Object.keys(ax._linepositions || {});\n\n    for (i = 0; i < tickSubplots.length; i++) {\n      sp = tickSubplots[i];\n      plotinfo = fullLayout._plots[sp]; // [bottom or left, top or right], free and main are handled above\n\n      var linepositions = ax._linepositions[sp] || [];\n      var p0 = linepositions[0];\n      var p1 = linepositions[1];\n      var isMinor = linepositions[2];\n      var spTickPath = axes.makeTickPath(ax, p0, isMinor ? majorTickSigns[0] : minorTickSigns[0], {\n        minor: isMinor\n      }) + axes.makeTickPath(ax, p1, isMinor ? majorTickSigns[1] : minorTickSigns[1], {\n        minor: isMinor\n      });\n      axes.drawTicks(gd, ax, {\n        vals: tickVals,\n        layer: plotinfo[axLetter + 'axislayer'],\n        path: spTickPath,\n        transFn: transTickFn\n      });\n    }\n  }\n\n  var seq = []; // tick labels - for now just the main labels.\n  // TODO: mirror labels, esp for subplots\n\n  seq.push(function () {\n    return axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: mainAxLayer,\n      plotinfo: plotinfo,\n      transFn: transTickLabelFn,\n      labelFns: axes.makeLabelFns(ax, mainLinePosition)\n    });\n  });\n\n  if (ax.type === 'multicategory') {\n    var pad = {\n      x: 2,\n      y: 10\n    }[axLetter];\n    seq.push(function () {\n      var bboxKey = {\n        x: 'height',\n        y: 'width'\n      }[axLetter];\n      var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0);\n      return axes.drawLabels(gd, ax, {\n        vals: getSecondaryLabelVals(ax, vals),\n        layer: mainAxLayer,\n        cls: axId + 'tick2',\n        repositionOnUpdate: true,\n        secondary: true,\n        transFn: transTickFn,\n        labelFns: axes.makeLabelFns(ax, mainLinePosition + standoff * majorTickSigns[4])\n      });\n    });\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox('tick2')[ax.side] - mainLinePosition);\n      return drawDividers(gd, ax, {\n        vals: dividerVals,\n        layer: mainAxLayer,\n        path: axes.makeTickPath(ax, mainLinePosition, majorTickSigns[4], {\n          len: ax._depth\n        }),\n        transFn: transTickFn\n      });\n    });\n  } else if (ax.title.hasOwnProperty('standoff')) {\n    seq.push(function () {\n      ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePosition);\n    });\n  }\n\n  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n  seq.push(function () {\n    var s = ax.side.charAt(0);\n    var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);\n    var pos = axes.getPxPosition(gd, ax);\n    var outsideTickLen = outsideTicks ? ax.ticklen : 0;\n    var llbbox;\n    var push;\n    var mirrorPush;\n    var rangeSliderPush;\n\n    if (ax.automargin || hasRangeSlider) {\n      if (ax.type === 'multicategory') {\n        llbbox = getLabelLevelBbox('tick2');\n      } else {\n        llbbox = getLabelLevelBbox();\n\n        if (axLetter === 'x' && s === 'b') {\n          ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);\n        }\n      }\n    }\n\n    if (ax.automargin) {\n      push = {\n        x: 0,\n        y: 0,\n        r: 0,\n        l: 0,\n        t: 0,\n        b: 0\n      };\n      var domainIndices = [0, 1];\n\n      if (axLetter === 'x') {\n        if (s === 'b') {\n          push[s] = ax._depth;\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n\n        if (llbbox.width > 0) {\n          var rExtra = llbbox.right - (ax._offset + ax._length);\n\n          if (rExtra > 0) {\n            push.xr = 1;\n            push.r = rExtra;\n          }\n\n          var lExtra = ax._offset - llbbox.left;\n\n          if (lExtra > 0) {\n            push.xl = 0;\n            push.l = lExtra;\n          }\n        }\n      } else {\n        if (s === 'l') {\n          push[s] = ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);\n        } else {\n          push[s] = ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);\n          domainIndices.reverse();\n        }\n\n        if (llbbox.height > 0) {\n          var bExtra = llbbox.bottom - (ax._offset + ax._length);\n\n          if (bExtra > 0) {\n            push.yb = 0;\n            push.b = bExtra;\n          }\n\n          var tExtra = ax._offset - llbbox.top;\n\n          if (tExtra > 0) {\n            push.yt = 1;\n            push.t = tExtra;\n          }\n        }\n      }\n\n      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[domainIndices[0]];\n\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);\n      }\n\n      if (ax.mirror && ax.anchor !== 'free') {\n        mirrorPush = {\n          x: 0,\n          y: 0,\n          r: 0,\n          l: 0,\n          t: 0,\n          b: 0\n        };\n        mirrorPush[sMirror] = ax.linewidth;\n        if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;\n\n        if (ax.mirror === true || ax.mirror === 'ticks') {\n          mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];\n        } else if (ax.mirror === 'all' || ax.mirror === 'allticks') {\n          mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];\n        }\n      }\n    }\n\n    if (hasRangeSlider) {\n      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n    }\n\n    if (typeof ax.automargin === 'string') {\n      filterPush(push, ax.automargin);\n      filterPush(mirrorPush, ax.automargin);\n    }\n\n    Plots.autoMargin(gd, axAutoMarginID(ax), push);\n    Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);\n    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n  });\n\n  if (!opts.skipTitle && !(hasRangeSlider && ax.side === 'bottom')) {\n    seq.push(function () {\n      return drawTitle(gd, ax);\n    });\n  }\n\n  return Lib.syncOrAsync(seq);\n};\n\nfunction filterPush(push, automargin) {\n  if (!push) return;\n  var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function (data, nextKey) {\n    if (automargin.indexOf(nextKey) !== -1) {\n      MARGIN_MAPPING[nextKey].forEach(function (key) {\n        data[key] = 1;\n      });\n    }\n\n    return data;\n  }, {});\n  Object.keys(push).forEach(function (key) {\n    if (!keepMargin[key]) {\n      if (key.length === 1) push[key] = 0;else delete push[key];\n    }\n  });\n}\n\nfunction getBoundaryVals(ax, vals) {\n  var out = [];\n  var i; // boundaryVals are never used for labels;\n  // no need to worry about the other tickTextObj keys\n\n  var _push = function _push(d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n\n  if (vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      _push(vals[i], 0);\n    }\n\n    _push(vals[i - 1], 1);\n  }\n\n  return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n  var out = [];\n  var lookup = {};\n\n  for (var i = 0; i < vals.length; i++) {\n    var d = vals[i];\n\n    if (lookup[d.text2]) {\n      lookup[d.text2].push(d.x);\n    } else {\n      lookup[d.text2] = [d.x];\n    }\n  }\n\n  for (var k in lookup) {\n    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n  }\n\n  return out;\n}\n\nfunction getDividerVals(ax, vals) {\n  var out = [];\n  var i, current;\n  var reversed = vals.length && vals[vals.length - 1].x < vals[0].x; // never used for labels;\n  // no need to worry about the other tickTextObj keys\n\n  var _push = function _push(d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n\n  if (ax.showdividers && vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      var d = vals[i];\n\n      if (d.text2 !== current) {\n        _push(d, reversed ? 1 : 0);\n      }\n\n      current = d.text2;\n    }\n\n    _push(vals[i - 1], reversed ? 0 : 1);\n  }\n\n  return out;\n}\n\nfunction calcLabelLevelBbox(ax, cls) {\n  var top, bottom;\n  var left, right;\n\n  if (ax._selections[cls].size()) {\n    top = Infinity;\n    bottom = -Infinity;\n    left = Infinity;\n    right = -Infinity;\n\n    ax._selections[cls].each(function () {\n      var thisLabel = selectTickLabel(this); // Use parent node <g.(x|y)tick>, to make Drawing.bBox\n      // retrieve a bbox computed with transform info\n      //\n      // To improve perf, it would be nice to use `thisLabel.node()`\n      // (like in fixLabelOverlaps) instead and use Axes.getPxPosition\n      // together with the makeLabelFns outputs and `tickangle`\n      // to compute one bbox per (tick value x tick style)\n\n      var bb = Drawing.bBox(thisLabel.node().parentNode);\n      top = Math.min(top, bb.top);\n      bottom = Math.max(bottom, bb.bottom);\n      left = Math.min(left, bb.left);\n      right = Math.max(right, bb.right);\n    });\n  } else {\n    top = 0;\n    bottom = 0;\n    left = 0;\n    right = 0;\n  }\n\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right,\n    height: bottom - top,\n    width: right - left\n  };\n}\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n *  - [4]: sign of arrow starting at axis pointing towards margin\n */\n\n\naxes.getTickSigns = function (ax, minor) {\n  var axLetter = ax._id.charAt(0);\n\n  var sideOpposite = {\n    x: 'top',\n    y: 'right'\n  }[axLetter];\n  var main = ax.side === sideOpposite ? 1 : -1;\n  var out = [-1, 1, main, -main]; // then we flip if outside XOR y axis\n\n  var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;\n\n  if (ticks !== 'inside' === (axLetter === 'x')) {\n    out = out.map(function (v) {\n      return -v;\n    });\n  } // independent of `ticks`; do not flip this one\n\n\n  if (ax.side) {\n    out.push({\n      l: -1,\n      t: -1,\n      r: 1,\n      b: 1\n    }[ax.side.charAt(0)]);\n  }\n\n  return out;\n};\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\n\n\naxes.makeTransTickFn = function (ax) {\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(ax._offset + ax.l2p(d.x), 0);\n  } : function (d) {\n    return strTranslate(0, ax._offset + ax.l2p(d.x));\n  };\n};\n\naxes.makeTransTickLabelFn = function (ax) {\n  var uv = getTickLabelUV(ax);\n  var u = uv[0];\n  var v = uv[1];\n  return ax._id.charAt(0) === 'x' ? function (d) {\n    return strTranslate(u + ax._offset + ax.l2p(getPosX(d)), v);\n  } : function (d) {\n    return strTranslate(v, u + ax._offset + ax.l2p(getPosX(d)));\n  };\n};\n\nfunction getPosX(d) {\n  return d.periodX !== undefined ? d.periodX : d.x;\n} // u is a shift along the axis,\n// v is a shift perpendicular to the axis\n\n\nfunction getTickLabelUV(ax) {\n  var ticklabelposition = ax.ticklabelposition || '';\n\n  var has = function has(str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isInside = has('inside');\n  var isAligned = isBottom || isLeft || isTop || isRight; // early return\n\n  if (!isAligned && !isInside) return [0, 0];\n  var side = ax.side;\n  var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;\n  var v = TEXTPAD;\n  var fontSize = ax.tickfont ? ax.tickfont.size : 12;\n\n  if (isBottom || isTop) {\n    u += fontSize * CAP_SHIFT;\n    v += (ax.linewidth || 0) / 2;\n  }\n\n  if (isLeft || isRight) {\n    u += (ax.linewidth || 0) / 2;\n    v += TEXTPAD;\n  }\n\n  if (isInside && side === 'top') {\n    v -= fontSize * (1 - CAP_SHIFT);\n  }\n\n  if (isLeft || isTop) u = -u;\n  if (side === 'bottom' || side === 'right') v = -v;\n  return [isAligned ? u : 0, isInside ? v : 0];\n}\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sgn tick sign\n * @param {object} opts\n * - {number (optional)} len tick length\n * @return {string}\n */\n\n\naxes.makeTickPath = function (ax, shift, sgn, opts) {\n  if (!opts) opts = {};\n  var minor = opts.minor;\n  if (minor && !ax.minor) return '';\n  var len = opts.len !== undefined ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;\n\n  var axLetter = ax._id.charAt(0);\n\n  var pad = (ax.linewidth || 1) / 2;\n  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;\n};\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} xFn\n *  - {fn} yFn\n *  - {fn} anchorFn\n *  - {fn} heightFn\n *  - {number} labelStandoff (gap parallel to ticks)\n *  - {number} labelShift (gap perpendicular to ticks)\n */\n\n\naxes.makeLabelFns = function (ax, shift, angle) {\n  var ticklabelposition = ax.ticklabelposition || '';\n\n  var has = function has(str) {\n    return ticklabelposition.indexOf(str) !== -1;\n  };\n\n  var isTop = has('top');\n  var isLeft = has('left');\n  var isRight = has('right');\n  var isBottom = has('bottom');\n  var isAligned = isBottom || isLeft || isTop || isRight;\n  var insideTickLabels = has('inside');\n  var labelsOverTicks = ticklabelposition === 'inside' && ax.ticks === 'inside' || !insideTickLabels && ax.ticks === 'outside' && ax.tickson !== 'boundaries';\n  var labelStandoff = 0;\n  var labelShift = 0;\n  var tickLen = labelsOverTicks ? ax.ticklen : 0;\n\n  if (insideTickLabels) {\n    tickLen *= -1;\n  } else if (isAligned) {\n    tickLen = 0;\n  }\n\n  if (labelsOverTicks) {\n    labelStandoff += tickLen;\n\n    if (angle) {\n      var rad = Lib.deg2rad(angle);\n      labelStandoff = tickLen * Math.cos(rad) + 1;\n      labelShift = tickLen * Math.sin(rad);\n    }\n  }\n\n  if (ax.showticklabels && (labelsOverTicks || ax.showline)) {\n    labelStandoff += 0.2 * ax.tickfont.size;\n  }\n\n  labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);\n  var out = {\n    labelStandoff: labelStandoff,\n    labelShift: labelShift\n  };\n  var x0, y0, ff, flipIt;\n  var xQ = 0;\n  var side = ax.side;\n\n  var axLetter = ax._id.charAt(0);\n\n  var tickangle = ax.tickangle;\n  var endSide;\n\n  if (axLetter === 'x') {\n    endSide = !insideTickLabels && side === 'bottom' || insideTickLabels && side === 'top';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelShift * flipIt;\n    y0 = shift + labelStandoff * flipIt;\n    ff = endSide ? 1 : -0.2;\n\n    if (Math.abs(tickangle) === 90) {\n      if (insideTickLabels) {\n        ff += MID_SHIFT;\n      } else {\n        if (tickangle === -90 && side === 'bottom') {\n          ff = CAP_SHIFT;\n        } else if (tickangle === 90 && side === 'top') {\n          ff = MID_SHIFT;\n        } else {\n          ff = 0.5;\n        }\n      }\n\n      xQ = MID_SHIFT / 2 * (tickangle / 90);\n    }\n\n    out.xFn = function (d) {\n      return d.dx + x0 + xQ * d.fontSize;\n    };\n\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * ff;\n    };\n\n    out.anchorFn = function (d, a) {\n      if (isAligned) {\n        if (isLeft) return 'end';\n        if (isRight) return 'start';\n      }\n\n      if (!isNumeric(a) || a === 0 || a === 180) {\n        return 'middle';\n      }\n\n      return a * flipIt < 0 !== insideTickLabels ? 'end' : 'start';\n    };\n\n    out.heightFn = function (d, a, h) {\n      return a < -60 || a > 60 ? -0.5 * h : ax.side === 'top' !== insideTickLabels ? -h : 0;\n    };\n  } else if (axLetter === 'y') {\n    endSide = !insideTickLabels && side === 'left' || insideTickLabels && side === 'right';\n    flipIt = endSide ? 1 : -1;\n    if (insideTickLabels) flipIt *= -1;\n    x0 = labelStandoff;\n    y0 = labelShift * flipIt;\n    ff = 0;\n\n    if (!insideTickLabels && Math.abs(tickangle) === 90) {\n      if (tickangle === -90 && side === 'left' || tickangle === 90 && side === 'right') {\n        ff = CAP_SHIFT;\n      } else {\n        ff = 0.5;\n      }\n    }\n\n    if (insideTickLabels) {\n      var ang = isNumeric(tickangle) ? +tickangle : 0;\n\n      if (ang !== 0) {\n        var rA = Lib.deg2rad(ang);\n        xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;\n        ff = 0;\n      }\n    }\n\n    out.xFn = function (d) {\n      return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;\n    };\n\n    out.yFn = function (d) {\n      return d.dy + y0 + d.fontSize * MID_SHIFT;\n    };\n\n    out.anchorFn = function (d, a) {\n      if (isNumeric(a) && Math.abs(a) === 90) {\n        return 'middle';\n      }\n\n      return endSide ? 'end' : 'start';\n    };\n\n    out.heightFn = function (d, a, h) {\n      if (ax.side === 'right') a *= -1;\n      return a < -30 ? -h : a < 30 ? -0.5 * h : 0;\n    };\n  }\n\n  return out;\n};\n\nfunction tickDataFn(d) {\n  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawTicks = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'tick';\n  var vals = [].concat(ax.minor && ax.minor.ticks ? // minor vals\n  opts.vals.filter(function (d) {\n    return d.minor && !d.noTick;\n  }) : []).concat(ax.ticks ? // major vals\n  opts.vals.filter(function (d) {\n    return !d.minor && !d.noTick;\n  }) : []);\n  var ticks = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  ticks.exit().remove();\n  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).each(function (d) {\n    return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);\n  }).style('stroke-width', function (d) {\n    return Drawing.crispRound(gd, d.minor ? ax.minor.tickwidth : ax.tickwidth, 1) + 'px';\n  }).attr('d', opts.path).style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);\n  ticks.attr('transform', opts.transFn);\n};\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {string} griddash\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawGrid = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'grid';\n  var hasMinor = ax.minor && ax.minor.showgrid;\n  var minorVals = hasMinor ? opts.vals.filter(function (d) {\n    return d.minor;\n  }) : [];\n  var majorVals = ax.showgrid ? opts.vals.filter(function (d) {\n    return !d.minor;\n  }) : [];\n  var counterAx = opts.counterAxis;\n\n  if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n    var isArrayMode = ax.tickmode === 'array';\n\n    for (var i = 0; i < majorVals.length; i++) {\n      var xi = majorVals[i].x;\n\n      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {\n        majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1)); // In array mode you can in principle have multiple\n        // ticks at 0, so test them all. Otherwise once we found\n        // one we can stop.\n\n        if (isArrayMode) i--;else break;\n      }\n    }\n  }\n\n  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n  var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);\n  var majorLayer = opts.layer;\n  var minorLayer = opts.minorLayer;\n\n  for (var major = 1; major >= 0; major--) {\n    var layer = major ? majorLayer : minorLayer;\n    if (!layer) continue;\n    var grid = layer.selectAll('path.' + cls).data(major ? majorVals : minorVals, tickDataFn);\n    grid.exit().remove();\n    grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);\n    grid.attr('transform', opts.transFn).attr('d', opts.path).each(function (d) {\n      return Color.stroke(d3.select(this), d.minor ? ax.minor.gridcolor : ax.gridcolor || '#ddd');\n    }).style('stroke-dasharray', function (d) {\n      return Drawing.dashStyle(d.minor ? ax.minor.griddash : ax.griddash, d.minor ? ax.minor.gridwidth : ax.gridwidth);\n    }).style('stroke-width', function (d) {\n      return (d.minor ? wMinor : ax._gw) + 'px';\n    }).style('display', null); // visible\n\n    if (typeof opts.path === 'function') grid.attr('d', opts.path);\n  }\n\n  hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);\n};\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\n\n\naxes.drawZeroLine = function (gd, ax, opts) {\n  opts = opts || opts;\n  var cls = ax._id + 'zl';\n  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{\n    x: 0,\n    id: ax._id\n  }] : []);\n  zl.exit().remove();\n  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {\n    // use the fact that only one element can enter to trigger a sort.\n    // If several zerolines enter at the same time we will sort once per,\n    // but generally this should be a minimal overhead.\n    opts.layer.selectAll('path').sort(function (da, db) {\n      return idSort(da.id, db.id);\n    });\n  });\n  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px').style('display', null); // visible\n\n  hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);\n};\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n *  - {object} (optional)} _prevTickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {object} labelFns\n *  + {fn} xFn\n *  + {fn} yFn\n *  + {fn} anchorFn\n *  + {fn} heightFn\n */\n\n\naxes.drawLabels = function (gd, ax, opts) {\n  opts = opts || {};\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var cls = opts.cls || axId + 'tick';\n  var vals = opts.vals.filter(function (d) {\n    return d.text;\n  });\n  var labelFns = opts.labelFns;\n  var tickAngle = opts.secondary ? 0 : ax.tickangle;\n  var prevAngle = (ax._prevTickAngles || {})[cls];\n  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);\n  var labelsReady = [];\n  tickLabels.enter().append('g').classed(cls, 1).append('text') // only so tex has predictable alignment that we can\n  // alter later\n  .attr('text-anchor', 'middle').each(function (d) {\n    var thisLabel = d3.select(this);\n    var newPromise = gd._promises.length;\n    thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, d.font, d.fontSize, d.fontColor).text(d.text).call(svgTextUtils.convertToTspans, gd);\n\n    if (gd._promises[newPromise]) {\n      // if we have an async label, we'll deal with that\n      // all here so take it out of gd._promises and\n      // instead position the label and promise this in\n      // labelsReady\n      labelsReady.push(gd._promises.pop().then(function () {\n        positionLabels(thisLabel, tickAngle);\n      }));\n    } else {\n      // sync label: just position it now.\n      positionLabels(thisLabel, tickAngle);\n    }\n  });\n  hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);\n  tickLabels.exit().remove();\n\n  if (opts.repositionOnUpdate) {\n    tickLabels.each(function (d) {\n      d3.select(this).select('text').call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));\n    });\n  }\n\n  function positionLabels(s, angle) {\n    s.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      var anchor = labelFns.anchorFn(d, angle);\n      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelFns.xFn(d) + ',' + (labelFns.yFn(d) - d.fontSize / 2) + ')' : ''); // how much to shift a multi-line label to center it vertically.\n\n      var nLines = svgTextUtils.lineCount(thisLabel);\n      var lineHeight = LINE_SPACING * d.fontSize;\n      var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);\n\n      if (anchorHeight) {\n        transform += strTranslate(0, anchorHeight);\n      }\n\n      if (mathjaxGroup.empty()) {\n        var thisText = thisLabel.select('text');\n        thisText.attr({\n          transform: transform,\n          'text-anchor': anchor\n        });\n        thisText.style('opacity', 1); // visible\n\n        if (ax._adjustTickLabelsOverflow) {\n          ax._adjustTickLabelsOverflow();\n        }\n      } else {\n        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n        var mjShift = mjWidth * {\n          end: -0.5,\n          start: 0.5\n        }[anchor];\n        mathjaxGroup.attr('transform', transform + strTranslate(mjShift, 0));\n      }\n    });\n  }\n\n  ax._adjustTickLabelsOverflow = function () {\n    var ticklabeloverflow = ax.ticklabeloverflow;\n    if (!ticklabeloverflow || ticklabeloverflow === 'allow') return;\n    var hideOverflow = ticklabeloverflow.indexOf('hide') !== -1;\n    var isX = ax._id.charAt(0) === 'x'; // div positions\n\n    var p0 = 0;\n    var p1 = isX ? gd._fullLayout.width : gd._fullLayout.height;\n\n    if (ticklabeloverflow.indexOf('domain') !== -1) {\n      // domain positions\n      var rl = Lib.simpleMap(ax.range, ax.r2l);\n      p0 = ax.l2p(rl[0]) + ax._offset;\n      p1 = ax.l2p(rl[1]) + ax._offset;\n    }\n\n    var min = Math.min(p0, p1);\n    var max = Math.max(p0, p1);\n    var side = ax.side;\n    var visibleLabelMin = Infinity;\n    var visibleLabelMax = -Infinity;\n    tickLabels.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n\n      if (mathjaxGroup.empty()) {\n        var bb = Drawing.bBox(thisLabel.node());\n        var adjust = 0;\n\n        if (isX) {\n          if (bb.right > max) adjust = 1;else if (bb.left < min) adjust = 1;\n        } else {\n          if (bb.bottom > max) adjust = 1;else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;\n        }\n\n        var t = thisLabel.select('text');\n\n        if (adjust) {\n          if (hideOverflow) t.style('opacity', 0); // hidden\n        } else {\n          t.style('opacity', 1); // visible\n\n          if (side === 'bottom' || side === 'right') {\n            visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);\n          } else {\n            visibleLabelMin = -Infinity;\n          }\n\n          if (side === 'top' || side === 'left') {\n            visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);\n          } else {\n            visibleLabelMax = Infinity;\n          }\n        }\n      } // TODO: hide mathjax?\n\n    });\n\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      var anchorAx = isX ? plotinfo.yaxis : plotinfo.xaxis;\n\n      if (anchorAx) {\n        anchorAx['_visibleLabelMin_' + ax._id] = visibleLabelMin;\n        anchorAx['_visibleLabelMax_' + ax._id] = visibleLabelMax;\n      }\n    }\n  };\n\n  ax._hideCounterAxisInsideTickLabels = function (partialOpts) {\n    var isX = ax._id.charAt(0) === 'x';\n    var anchoredAxes = [];\n\n    for (var subplot in fullLayout._plots) {\n      var plotinfo = fullLayout._plots[subplot];\n      if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;\n      anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);\n    }\n\n    anchoredAxes.forEach(function (anchorAx, idx) {\n      if (anchorAx && insideTicklabelposition(anchorAx)) {\n        (partialOpts || [ZERO_PATH, MINORGRID_PATH, GRID_PATH, TICK_PATH, TICK_TEXT]).forEach(function (e) {\n          var isPeriodLabel = e.K === 'tick' && e.L === 'text' && ax.ticklabelmode === 'period';\n          var mainPlotinfo = fullLayout._plots[ax._mainSubplot];\n          var sel;\n          if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll('.' + ax._id + 'zl');else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll('.' + ax._id);else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll('.' + ax._id);else sel = mainPlotinfo[ax._id.charAt(0) + 'axislayer'];\n          sel.each(function () {\n            var w = d3.select(this);\n            if (e.L) w = w.selectAll(e.L);\n            w.each(function (d) {\n              var q = ax.l2p(isPeriodLabel ? getPosX(d) : d.x) + ax._offset;\n\n              var t = d3.select(this);\n\n              if (q < ax['_visibleLabelMax_' + anchorAx._id] && q > ax['_visibleLabelMin_' + anchorAx._id]) {\n                t.style('display', 'none'); // hidden\n              } else if (e.K === 'tick' && !idx) {\n                t.style('display', null); // visible\n              }\n            });\n          });\n        });\n      }\n    });\n  }; // make sure all labels are correctly positioned at their base angle\n  // the positionLabels call above is only for newly drawn labels.\n  // do this without waiting, using the last calculated angle to\n  // minimize flicker, then do it again when we know all labels are\n  // there, putting back the prescribed angle to check for overlaps.\n\n\n  positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);\n\n  function allLabelsReady() {\n    return labelsReady.length && Promise.all(labelsReady);\n  }\n\n  var autoangle = null;\n\n  function fixLabelOverlaps() {\n    positionLabels(tickLabels, tickAngle); // check for auto-angling if x labels overlap\n    // don't auto-angle at all for log axes with\n    // base and digit format\n\n    if (vals.length && axLetter === 'x' && !isNumeric(tickAngle) && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n      autoangle = 0;\n      var maxFontSize = 0;\n      var lbbArray = [];\n      var i;\n      tickLabels.each(function (d) {\n        maxFontSize = Math.max(maxFontSize, d.fontSize);\n        var x = ax.l2p(d.x);\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        lbbArray.push({\n          // ignore about y, just deal with x overlaps\n          top: 0,\n          bottom: 10,\n          height: 10,\n          left: x - bb.width / 2,\n          // impose a 2px gap\n          right: x + bb.width / 2 + 2,\n          width: bb.width + 2\n        });\n      });\n\n      if ((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n        var gap = 2;\n        if (ax.ticks) gap += ax.tickwidth / 2; // TODO should secondary labels also fall into this fix-overlap regime?\n\n        for (i = 0; i < lbbArray.length; i++) {\n          var xbnd = vals[i].xbnd;\n          var lbb = lbbArray[i];\n\n          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {\n            autoangle = 90;\n            break;\n          }\n        }\n      } else {\n        var vLen = vals.length;\n        var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n        var ticklabelposition = ax.ticklabelposition || '';\n\n        var has = function has(str) {\n          return ticklabelposition.indexOf(str) !== -1;\n        };\n\n        var isTop = has('top');\n        var isLeft = has('left');\n        var isRight = has('right');\n        var isBottom = has('bottom');\n        var isAligned = isBottom || isLeft || isTop || isRight;\n        var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;\n        var rotate90 = tickSpacing < maxFontSize * 2.5 || ax.type === 'multicategory' || ax._name === 'realaxis'; // any overlap at all - set 30 degrees or 90 degrees\n\n        for (i = 0; i < lbbArray.length - 1; i++) {\n          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {\n            autoangle = rotate90 ? 90 : 30;\n            break;\n          }\n        }\n      }\n\n      if (autoangle) {\n        positionLabels(tickLabels, autoangle);\n      }\n    }\n  }\n\n  if (ax._selections) {\n    ax._selections[cls] = tickLabels;\n  }\n\n  var seq = [allLabelsReady]; // N.B. during auto-margin redraws, if the axis fixed its label overlaps\n  // by rotating 90 degrees, do not attempt to re-fix its label overlaps\n  // as this can lead to infinite redraw loops!\n\n  if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {\n    autoangle = 90;\n    seq.push(function () {\n      positionLabels(tickLabels, prevAngle);\n    });\n  } else {\n    seq.push(fixLabelOverlaps);\n  } // save current tick angle for future redraws\n\n\n  if (ax._tickAngles) {\n    seq.push(function () {\n      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;\n    });\n  }\n\n  var anchorAx = ax._anchorAxis;\n\n  if (anchorAx && anchorAx.autorange && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {\n    if (!fullLayout._insideTickLabelsAutorange) {\n      fullLayout._insideTickLabelsAutorange = {};\n    }\n\n    fullLayout._insideTickLabelsAutorange[anchorAx._name + '.autorange'] = anchorAx.autorange;\n    seq.push(function computeFinalTickLabelBoundingBoxes() {\n      tickLabels.each(function (d, i) {\n        var thisLabel = selectTickLabel(this);\n        var mathjaxGroup = thisLabel.select('.text-math-group');\n\n        if (mathjaxGroup.empty()) {\n          ax._vals[i].bb = Drawing.bBox(thisLabel.node());\n        }\n      });\n    });\n  }\n\n  var done = Lib.syncOrAsync(seq);\n  if (done && done.then) gd._promises.push(done);\n  return done;\n};\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\n\n\nfunction drawDividers(gd, ax, opts) {\n  var cls = ax._id + 'divider';\n  var vals = opts.vals;\n  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  dividers.exit().remove();\n  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n  dividers.attr('transform', opts.transFn).attr('d', opts.path);\n}\n/**\n * Get axis position in px, that is the distance for the graph's\n * top (left) edge for x (y) axes.\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} side\n *  if anchored:\n *  - {object} _anchorAxis\n *  Otherwise:\n *  - {number} position\n * @return {number}\n */\n\n\naxes.getPxPosition = function (gd, ax) {\n  var gs = gd._fullLayout._size;\n\n  var axLetter = ax._id.charAt(0);\n\n  var side = ax.side;\n  var anchorAxis;\n\n  if (ax.anchor !== 'free') {\n    anchorAxis = ax._anchorAxis;\n  } else if (axLetter === 'x') {\n    anchorAxis = {\n      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n      _length: 0\n    };\n  } else if (axLetter === 'y') {\n    anchorAxis = {\n      _offset: gs.l + (ax.position || 0) * gs.w,\n      _length: 0\n    };\n  }\n\n  if (side === 'top' || side === 'left') {\n    return anchorAxis._offset;\n  } else if (side === 'bottom' || side === 'right') {\n    return anchorAxis._offset + anchorAxis._length;\n  }\n};\n/**\n * Approximate axis title depth (w/o computing its bounding box)\n *\n * @param {object} ax (full) axis object\n *  - {string} title.text\n *  - {number} title.font.size\n *  - {number} title.standoff\n * @return {number} (in px)\n */\n\n\nfunction approxTitleDepth(ax) {\n  var fontSize = ax.title.font.size;\n  var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;\n\n  if (ax.title.hasOwnProperty('standoff')) {\n    return extraLines ? fontSize * (CAP_SHIFT + extraLines * LINE_SPACING) : fontSize * CAP_SHIFT;\n  } else {\n    return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;\n  }\n}\n/**\n * Draw axis title, compute default standoff if necessary\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} _name\n *  - {string} side\n *  - {number} title.font.size\n *  - {object} _selections\n *\n *  - {number} _depth\n *  - {number} title.standoff\n *  OR\n *  - {number} linewidth\n *  - {boolean} showticklabels\n */\n\n\nfunction drawTitle(gd, ax) {\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var fontSize = ax.title.font.size;\n  var titleStandoff;\n\n  if (ax.title.hasOwnProperty('standoff')) {\n    titleStandoff = ax._depth + ax.title.standoff + approxTitleDepth(ax);\n  } else {\n    var isInside = insideTicklabelposition(ax);\n\n    if (ax.type === 'multicategory') {\n      titleStandoff = ax._depth;\n    } else {\n      var offsetBase = 1.5 * fontSize;\n\n      if (isInside) {\n        offsetBase = 0.5 * fontSize;\n\n        if (ax.ticks === 'outside') {\n          offsetBase += ax.ticklen;\n        }\n      }\n\n      titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n    }\n\n    if (!isInside) {\n      if (axLetter === 'x') {\n        titleStandoff += ax.side === 'top' ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);\n      } else {\n        titleStandoff += ax.side === 'right' ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);\n      }\n    }\n  }\n\n  var pos = axes.getPxPosition(gd, ax);\n  var transform, x, y;\n\n  if (axLetter === 'x') {\n    x = ax._offset + ax._length / 2;\n    y = ax.side === 'top' ? pos - titleStandoff : pos + titleStandoff;\n  } else {\n    y = ax._offset + ax._length / 2;\n    x = ax.side === 'right' ? pos + titleStandoff : pos - titleStandoff;\n    transform = {\n      rotate: '-90',\n      offset: 0\n    };\n  }\n\n  var avoid;\n\n  if (ax.type !== 'multicategory') {\n    var tickLabels = ax._selections[ax._id + 'tick'];\n    avoid = {\n      selection: tickLabels,\n      side: ax.side\n    };\n\n    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n      var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n      avoid.offsetLeft = translation.x;\n      avoid.offsetTop = translation.y;\n    }\n\n    if (ax.title.hasOwnProperty('standoff')) {\n      avoid.pad = 0;\n    }\n  }\n\n  return Titles.draw(gd, axId + 'title', {\n    propContainer: ax,\n    propName: ax._name + '.title.text',\n    placeholder: fullLayout._dfltTitle[axLetter],\n    avoid: avoid,\n    transform: transform,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    }\n  });\n}\n\naxes.shouldShowZeroLine = function (gd, ax, counterAxis) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));\n};\n\naxes.clipEnds = function (ax, vals) {\n  return vals.filter(function (d) {\n    return clipEnds(ax, d.x);\n  });\n};\n\nfunction clipEnds(ax, l) {\n  var p = ax.l2p(l);\n  return p > 1 && p < ax._length - 1;\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n  var mainCounterAxis = counterAxis._mainAxis;\n  if (!mainCounterAxis) return;\n  var fullLayout = gd._fullLayout;\n\n  var axLetter = ax._id.charAt(0);\n\n  var counterLetter = axes.counterLetter(ax._id);\n  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);\n\n  function lineNearZero(ax2) {\n    if (!ax2.showline || !ax2.linewidth) return false;\n    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n    function closeEnough(pos2) {\n      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n    }\n\n    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n      return true;\n    }\n\n    var linePositions = ax2._linepositions || {};\n\n    for (var k in linePositions) {\n      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n        return true;\n      }\n    }\n  }\n\n  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n\n  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n    return lineNearZero(counterAxis, zeroPosition);\n  }\n\n  var counterLetterAxes = axes.list(gd, counterLetter);\n\n  for (var i = 0; i < counterLetterAxes.length; i++) {\n    var counterAxis2 = counterLetterAxes[i];\n\n    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {\n      return true;\n    }\n  }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n  var fullData = gd._fullData;\n  var subplot = ax._mainSubplot;\n\n  var axLetter = ax._id.charAt(0);\n\n  for (var i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n\n    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {\n      if (Registry.traceIs(trace, 'bar-like') && trace.orientation === {\n        x: 'h',\n        y: 'v'\n      }[axLetter]) return true;\n      if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;\n    }\n  }\n\n  return false;\n}\n\nfunction selectTickLabel(gTick) {\n  var s = d3.select(gTick);\n  var mj = s.select('.text-math-group');\n  return mj.empty() ? s.select('text') : mj;\n}\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\n\n\naxes.allowAutoMargin = function (gd) {\n  var axList = axes.list(gd, '', true);\n\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n\n    if (ax.automargin) {\n      Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n\n      if (ax.mirror) {\n        Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));\n      }\n    }\n\n    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n    }\n  }\n};\n\nfunction axAutoMarginID(ax) {\n  return ax._id + '.automargin';\n}\n\nfunction axMirrorAutoMarginID(ax) {\n  return axAutoMarginID(ax) + '.mirror';\n}\n\nfunction rangeSliderAutoMarginID(ax) {\n  return ax._id + '.rangeslider';\n} // swap all the presentation attributes of the axes showing these traces\n\n\naxes.swap = function (gd, traces) {\n  var axGroups = makeAxisGroups(gd, traces);\n\n  for (var i = 0; i < axGroups.length; i++) {\n    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n  }\n};\n\nfunction makeAxisGroups(gd, traces) {\n  var groups = [];\n  var i, j;\n\n  for (i = 0; i < traces.length; i++) {\n    var groupsi = [];\n    var xi = gd._fullData[traces[i]].xaxis;\n    var yi = gd._fullData[traces[i]].yaxis;\n    if (!xi || !yi) continue; // not a 2D cartesian trace?\n\n    for (j = 0; j < groups.length; j++) {\n      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n        groupsi.push(j);\n      }\n    }\n\n    if (!groupsi.length) {\n      groups.push({\n        x: [xi],\n        y: [yi]\n      });\n      continue;\n    }\n\n    var group0 = groups[groupsi[0]];\n    var groupj;\n\n    if (groupsi.length > 1) {\n      for (j = 1; j < groupsi.length; j++) {\n        groupj = groups[groupsi[j]];\n        mergeAxisGroups(group0.x, groupj.x);\n        mergeAxisGroups(group0.y, groupj.y);\n      }\n    }\n\n    mergeAxisGroups(group0.x, [xi]);\n    mergeAxisGroups(group0.y, [yi]);\n  }\n\n  return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n  for (var i = 0; i < fromSet.length; i++) {\n    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n  }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n  var xFullAxes = [];\n  var yFullAxes = [];\n  var layout = gd.layout;\n  var i, j;\n\n  for (i = 0; i < xIds.length; i++) {\n    xFullAxes.push(axes.getFromId(gd, xIds[i]));\n  }\n\n  for (i = 0; i < yIds.length; i++) {\n    yFullAxes.push(axes.getFromId(gd, yIds[i]));\n  }\n\n  var allAxKeys = Object.keys(axAttrs);\n  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];\n  var numericTypes = ['linear', 'log'];\n\n  for (i = 0; i < allAxKeys.length; i++) {\n    var keyi = allAxKeys[i];\n    var xVal = xFullAxes[0][keyi];\n    var yVal = yFullAxes[0][keyi];\n    var allEqual = true;\n    var coerceLinearX = false;\n    var coerceLinearY = false;\n\n    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {\n      continue;\n    }\n\n    for (j = 1; j < xFullAxes.length && allEqual; j++) {\n      var xVali = xFullAxes[j][keyi];\n\n      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearX = true;\n      } else if (xVali !== xVal) allEqual = false;\n    }\n\n    for (j = 1; j < yFullAxes.length && allEqual; j++) {\n      var yVali = yFullAxes[j][keyi];\n\n      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearY = true;\n      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;\n    }\n\n    if (allEqual) {\n      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n    }\n  } // now swap x&y for any annotations anchored to these x & y\n\n\n  for (i = 0; i < gd._fullLayout.annotations.length; i++) {\n    var ann = gd._fullLayout.annotations[i];\n\n    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {\n      Lib.swapAttrs(layout.annotations[i], ['?']);\n    }\n  }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n  // in case the value is the default for either axis,\n  // look at the first axis in each list and see if\n  // this key's value is undefined\n  var np = Lib.nestedProperty;\n  var xVal = np(layout[xFullAxes[0]._name], key).get();\n  var yVal = np(layout[yFullAxes[0]._name], key).get();\n  var i;\n\n  if (key === 'title') {\n    // special handling of placeholder titles\n    if (xVal && xVal.text === dfltTitle.x) {\n      xVal.text = dfltTitle.y;\n    }\n\n    if (yVal && yVal.text === dfltTitle.y) {\n      yVal.text = dfltTitle.x;\n    }\n  }\n\n  for (i = 0; i < xFullAxes.length; i++) {\n    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n  }\n\n  for (i = 0; i < yFullAxes.length; i++) {\n    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n  }\n}\n\nfunction isAngular(ax) {\n  return ax._id === 'angularaxis';\n}\n\nfunction moveOutsideBreak(v, ax) {\n  var len = ax._rangebreaks.length;\n\n  for (var k = 0; k < len; k++) {\n    var brk = ax._rangebreaks[k];\n\n    if (v >= brk.min && v < brk.max) {\n      return brk.max;\n    }\n  }\n\n  return v;\n}\n\nfunction insideTicklabelposition(ax) {\n  return (ax.ticklabelposition || '').indexOf('inside') !== -1;\n}\n\nfunction hideCounterAxisInsideTickLabels(ax, opts) {\n  if (insideTicklabelposition(ax._anchorAxis || {})) {\n    if (ax._hideCounterAxisInsideTickLabels) {\n      ax._hideCounterAxisInsideTickLabels(opts);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}