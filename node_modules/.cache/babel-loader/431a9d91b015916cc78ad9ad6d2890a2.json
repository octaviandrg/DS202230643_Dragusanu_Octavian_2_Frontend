{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar countryRegex = require('country-regex');\n\nvar turfArea = require('@turf/area');\n\nvar turfCentroid = require('@turf/centroid');\n\nvar turfBbox = require('@turf/bbox');\n\nvar identity = require('./identity');\n\nvar loggers = require('./loggers');\n\nvar isPlainObject = require('./is_plain_object');\n\nvar nestedProperty = require('./nested_property');\n\nvar polygon = require('./polygon'); // make list of all country iso3 ids from at runtime\n\n\nvar countryIds = Object.keys(countryRegex);\nvar locationmodeToIdFinder = {\n  'ISO-3': identity,\n  'USA-states': identity,\n  'country names': countryNameToISO3\n};\n\nfunction countryNameToISO3(countryName) {\n  for (var i = 0; i < countryIds.length; i++) {\n    var iso3 = countryIds[i];\n    var regex = new RegExp(countryRegex[iso3]);\n    if (regex.test(countryName.trim().toLowerCase())) return iso3;\n  }\n\n  loggers.log('Unrecognized country name: ' + countryName + '.');\n  return false;\n}\n\nfunction locationToFeature(locationmode, location, features) {\n  if (!location || typeof location !== 'string') return false;\n  var locationId = locationmodeToIdFinder[locationmode](location);\n  var filteredFeatures;\n  var f, i;\n\n  if (locationId) {\n    if (locationmode === 'USA-states') {\n      // Filter out features out in USA\n      //\n      // This is important as the Natural Earth files\n      // include state/provinces from USA, Canada, Australia and Brazil\n      // which have some overlay in their two-letter ids. For example,\n      // 'WA' is used for both Washington state and Western Australia.\n      filteredFeatures = [];\n\n      for (i = 0; i < features.length; i++) {\n        f = features[i];\n\n        if (f.properties && f.properties.gu && f.properties.gu === 'USA') {\n          filteredFeatures.push(f);\n        }\n      }\n    } else {\n      filteredFeatures = features;\n    }\n\n    for (i = 0; i < filteredFeatures.length; i++) {\n      f = filteredFeatures[i];\n      if (f.id === locationId) return f;\n    }\n\n    loggers.log(['Location with id', locationId, 'does not have a matching topojson feature at this resolution.'].join(' '));\n  }\n\n  return false;\n}\n\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n\n    return null;\n  }\n\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function appendPolygon(_pts) {\n      var pts;\n\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n\n        for (m = 0; m < _pts.length; m++) {\n          // do not mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function appendPolygon(pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts); // polygon that do not cross anti-meridian need no special handling\n\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      } // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n\n\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      } // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n\n\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function appendPolygon(pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n\n      break;\n\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n\n      break;\n  }\n\n  return polygons;\n}\n\nfunction getTraceGeojson(trace) {\n  var g = trace.geojson;\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var geojsonIn = typeof g === 'string' ? PlotlyGeoAssets[g] : g; // This should not happen, but just in case something goes\n  // really wrong when fetching the GeoJSON\n\n  if (!isPlainObject(geojsonIn)) {\n    loggers.error('Oops ... something went wrong when fetching ' + g);\n    return false;\n  }\n\n  return geojsonIn;\n}\n\nfunction extractTraceFeature(calcTrace) {\n  var trace = calcTrace[0].trace;\n  var geojsonIn = getTraceGeojson(trace);\n  if (!geojsonIn) return false;\n  var lookup = {};\n  var featuresOut = [];\n  var i;\n\n  for (i = 0; i < trace._length; i++) {\n    var cdi = calcTrace[i];\n\n    if (cdi.loc || cdi.loc === 0) {\n      lookup[cdi.loc] = cdi;\n    }\n  }\n\n  function appendFeature(fIn) {\n    var id = nestedProperty(fIn, trace.featureidkey || 'id').get();\n    var cdi = lookup[id];\n\n    if (cdi) {\n      var geometry = fIn.geometry;\n\n      if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {\n        var fOut = {\n          type: 'Feature',\n          id: id,\n          geometry: geometry,\n          properties: {}\n        }; // Compute centroid, add it to the properties\n\n        fOut.properties.ct = findCentroid(fOut); // Mutate in in/out features into calcdata\n\n        cdi.fIn = fIn;\n        cdi.fOut = fOut;\n        featuresOut.push(fOut);\n      } else {\n        loggers.log(['Location', cdi.loc, 'does not have a valid GeoJSON geometry.', 'Traces with locationmode *geojson-id* only support', '*Polygon* and *MultiPolygon* geometries.'].join(' '));\n      }\n    } // remove key from lookup, so that we can track (if any)\n    // the locations that did not have a corresponding GeoJSON feature\n\n\n    delete lookup[id];\n  }\n\n  switch (geojsonIn.type) {\n    case 'FeatureCollection':\n      var featuresIn = geojsonIn.features;\n\n      for (i = 0; i < featuresIn.length; i++) {\n        appendFeature(featuresIn[i]);\n      }\n\n      break;\n\n    case 'Feature':\n      appendFeature(geojsonIn);\n      break;\n\n    default:\n      loggers.warn(['Invalid GeoJSON type', (geojsonIn.type || 'none') + '.', 'Traces with locationmode *geojson-id* only support', '*FeatureCollection* and *Feature* types.'].join(' '));\n      return false;\n  }\n\n  for (var loc in lookup) {\n    loggers.log(['Location *' + loc + '*', 'does not have a matching feature with id-key', '*' + trace.featureidkey + '*.'].join(' '));\n  }\n\n  return featuresOut;\n} // TODO this find the centroid of the polygon of maxArea\n// (just like we currently do for geo choropleth polygons),\n// maybe instead it would make more sense to compute the centroid\n// of each polygon and consider those on hover/select\n\n\nfunction findCentroid(feature) {\n  var geometry = feature.geometry;\n  var poly;\n\n  if (geometry.type === 'MultiPolygon') {\n    var coords = geometry.coordinates;\n    var maxArea = 0;\n\n    for (var i = 0; i < coords.length; i++) {\n      var polyi = {\n        type: 'Polygon',\n        coordinates: coords[i]\n      };\n      var area = turfArea.default(polyi);\n\n      if (area > maxArea) {\n        maxArea = area;\n        poly = polyi;\n      }\n    }\n  } else {\n    poly = geometry;\n  }\n\n  return turfCentroid.default(poly).geometry.coordinates;\n}\n\nfunction fetchTraceGeoData(calcData) {\n  var PlotlyGeoAssets = window.PlotlyGeoAssets || {};\n  var promises = [];\n\n  function fetch(url) {\n    return new Promise(function (resolve, reject) {\n      d3.json(url, function (err, d) {\n        if (err) {\n          delete PlotlyGeoAssets[url];\n          var msg = err.status === 404 ? 'GeoJSON at URL \"' + url + '\" does not exist.' : 'Unexpected error while fetching from ' + url;\n          return reject(new Error(msg));\n        }\n\n        PlotlyGeoAssets[url] = d;\n        return resolve(d);\n      });\n    });\n  }\n\n  function wait(url) {\n    return new Promise(function (resolve, reject) {\n      var cnt = 0;\n      var interval = setInterval(function () {\n        if (PlotlyGeoAssets[url] && PlotlyGeoAssets[url] !== 'pending') {\n          clearInterval(interval);\n          return resolve(PlotlyGeoAssets[url]);\n        }\n\n        if (cnt > 100) {\n          clearInterval(interval);\n          return reject('Unexpected error while fetching from ' + url);\n        }\n\n        cnt++;\n      }, 50);\n    });\n  }\n\n  for (var i = 0; i < calcData.length; i++) {\n    var trace = calcData[i][0].trace;\n    var url = trace.geojson;\n\n    if (typeof url === 'string') {\n      if (!PlotlyGeoAssets[url]) {\n        PlotlyGeoAssets[url] = 'pending';\n        promises.push(fetch(url));\n      } else if (PlotlyGeoAssets[url] === 'pending') {\n        promises.push(wait(url));\n      }\n    }\n  }\n\n  return promises;\n} // TODO `turf/bbox` gives wrong result when the input feature/geometry\n// crosses the anti-meridian. We should try to implement our own bbox logic.\n\n\nfunction computeBbox(d) {\n  return turfBbox.default(d);\n}\n\nmodule.exports = {\n  locationToFeature: locationToFeature,\n  feature2polygons: feature2polygons,\n  getTraceGeojson: getTraceGeojson,\n  extractTraceFeature: extractTraceFeature,\n  fetchTraceGeoData: fetchTraceGeoData,\n  computeBbox: computeBbox\n};","map":null,"metadata":{},"sourceType":"script"}