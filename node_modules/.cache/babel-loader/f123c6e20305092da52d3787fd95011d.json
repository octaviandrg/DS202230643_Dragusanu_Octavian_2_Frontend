{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar colorscaleCalc = require('../../components/colorscale/calc');\n\nfunction calc(gd, trace) {\n  trace._len = Math.min(trace.u.length, trace.v.length, trace.w.length, trace.x.length, trace.y.length, trace.z.length);\n  trace._u = filter(trace.u, trace._len);\n  trace._v = filter(trace.v, trace._len);\n  trace._w = filter(trace.w, trace._len);\n  trace._x = filter(trace.x, trace._len);\n  trace._y = filter(trace.y, trace._len);\n  trace._z = filter(trace.z, trace._len);\n  var grid = processGrid(trace);\n  trace._gridFill = grid.fill;\n  trace._Xs = grid.Xs;\n  trace._Ys = grid.Ys;\n  trace._Zs = grid.Zs;\n  trace._len = grid.len;\n  var slen = 0;\n  var startx, starty, startz;\n\n  if (trace.starts) {\n    startx = filter(trace.starts.x || []);\n    starty = filter(trace.starts.y || []);\n    startz = filter(trace.starts.z || []);\n    slen = Math.min(startx.length, starty.length, startz.length);\n  }\n\n  trace._startsX = startx || [];\n  trace._startsY = starty || [];\n  trace._startsZ = startz || [];\n  var normMax = 0;\n  var normMin = Infinity;\n  var i;\n\n  for (i = 0; i < trace._len; i++) {\n    var u = trace._u[i];\n    var v = trace._v[i];\n    var w = trace._w[i];\n    var norm = Math.sqrt(u * u + v * v + w * w);\n    normMax = Math.max(normMax, norm);\n    normMin = Math.min(normMin, norm);\n  }\n\n  colorscaleCalc(gd, trace, {\n    vals: [normMin, normMax],\n    containerStr: '',\n    cLetter: 'c'\n  });\n\n  for (i = 0; i < slen; i++) {\n    var sx = startx[i];\n    grid.xMax = Math.max(grid.xMax, sx);\n    grid.xMin = Math.min(grid.xMin, sx);\n    var sy = starty[i];\n    grid.yMax = Math.max(grid.yMax, sy);\n    grid.yMin = Math.min(grid.yMin, sy);\n    var sz = startz[i];\n    grid.zMax = Math.max(grid.zMax, sz);\n    grid.zMin = Math.min(grid.zMin, sz);\n  }\n\n  trace._slen = slen;\n  trace._normMax = normMax;\n  trace._xbnds = [grid.xMin, grid.xMax];\n  trace._ybnds = [grid.yMin, grid.yMax];\n  trace._zbnds = [grid.zMin, grid.zMax];\n}\n\nfunction processGrid(trace) {\n  var x = trace._x;\n  var y = trace._y;\n  var z = trace._z;\n  var len = trace._len;\n  var i, j, k;\n  var xMax = -Infinity;\n  var xMin = Infinity;\n  var yMax = -Infinity;\n  var yMin = Infinity;\n  var zMax = -Infinity;\n  var zMin = Infinity;\n  var gridFill = '';\n  var filledX;\n  var filledY;\n  var filledZ;\n  var firstX, lastX;\n  var firstY, lastY;\n  var firstZ, lastZ;\n\n  if (len) {\n    firstX = x[0];\n    firstY = y[0];\n    firstZ = z[0];\n  }\n\n  if (len > 1) {\n    lastX = x[len - 1];\n    lastY = y[len - 1];\n    lastZ = z[len - 1];\n  }\n\n  for (i = 0; i < len; i++) {\n    xMax = Math.max(xMax, x[i]);\n    xMin = Math.min(xMin, x[i]);\n    yMax = Math.max(yMax, y[i]);\n    yMin = Math.min(yMin, y[i]);\n    zMax = Math.max(zMax, z[i]);\n    zMin = Math.min(zMin, z[i]);\n\n    if (!filledX && x[i] !== firstX) {\n      filledX = true;\n      gridFill += 'x';\n    }\n\n    if (!filledY && y[i] !== firstY) {\n      filledY = true;\n      gridFill += 'y';\n    }\n\n    if (!filledZ && z[i] !== firstZ) {\n      filledZ = true;\n      gridFill += 'z';\n    }\n  } // fill if not filled - case of having dimension(s) with one item\n\n\n  if (!filledX) gridFill += 'x';\n  if (!filledY) gridFill += 'y';\n  if (!filledZ) gridFill += 'z';\n  var Xs = distinctVals(trace._x);\n  var Ys = distinctVals(trace._y);\n  var Zs = distinctVals(trace._z);\n  gridFill = gridFill.replace('x', (firstX > lastX ? '-' : '+') + 'x');\n  gridFill = gridFill.replace('y', (firstY > lastY ? '-' : '+') + 'y');\n  gridFill = gridFill.replace('z', (firstZ > lastZ ? '-' : '+') + 'z');\n\n  var empty = function empty() {\n    len = 0;\n    Xs = [];\n    Ys = [];\n    Zs = [];\n  }; // Over-specified mesh case, this would error in tube2mesh\n\n\n  if (!len || len < Xs.length * Ys.length * Zs.length) empty();\n\n  var getArray = function getArray(c) {\n    return c === 'x' ? x : c === 'y' ? y : z;\n  };\n\n  var getVals = function getVals(c) {\n    return c === 'x' ? Xs : c === 'y' ? Ys : Zs;\n  };\n\n  var getDir = function getDir(c) {\n    return c[len - 1] < c[0] ? -1 : 1;\n  };\n\n  var arrK = getArray(gridFill[1]);\n  var arrJ = getArray(gridFill[3]);\n  var arrI = getArray(gridFill[5]);\n  var nk = getVals(gridFill[1]).length;\n  var nj = getVals(gridFill[3]).length;\n  var ni = getVals(gridFill[5]).length;\n  var arbitrary = false;\n\n  var getIndex = function getIndex(_i, _j, _k) {\n    return nk * (nj * _i + _j) + _k;\n  };\n\n  var dirK = getDir(getArray(gridFill[1]));\n  var dirJ = getDir(getArray(gridFill[3]));\n  var dirI = getDir(getArray(gridFill[5]));\n\n  for (i = 0; i < ni - 1; i++) {\n    for (j = 0; j < nj - 1; j++) {\n      for (k = 0; k < nk - 1; k++) {\n        var q000 = getIndex(i, j, k);\n        var q001 = getIndex(i, j, k + 1);\n        var q010 = getIndex(i, j + 1, k);\n        var q100 = getIndex(i + 1, j, k);\n\n        if (!(arrK[q000] * dirK < arrK[q001] * dirK) || !(arrJ[q000] * dirJ < arrJ[q010] * dirJ) || !(arrI[q000] * dirI < arrI[q100] * dirI)) {\n          arbitrary = true;\n        }\n\n        if (arbitrary) break;\n      }\n\n      if (arbitrary) break;\n    }\n\n    if (arbitrary) break;\n  }\n\n  if (arbitrary) {\n    Lib.warn('Encountered arbitrary coordinates! Unable to input data grid.');\n    empty();\n  }\n\n  return {\n    xMin: xMin,\n    yMin: yMin,\n    zMin: zMin,\n    xMax: xMax,\n    yMax: yMax,\n    zMax: zMax,\n    Xs: Xs,\n    Ys: Ys,\n    Zs: Zs,\n    len: len,\n    fill: gridFill\n  };\n}\n\nfunction distinctVals(col) {\n  return Lib.distinctVals(col).vals;\n}\n\nfunction filter(arr, len) {\n  if (len === undefined) len = arr.length; // no need for casting typed arrays to numbers\n\n  if (Lib.isTypedArray(arr)) return arr.subarray(0, len);\n  var values = [];\n\n  for (var i = 0; i < len; i++) {\n    values[i] = +arr[i];\n  }\n\n  return values;\n}\n\nmodule.exports = {\n  calc: calc,\n  filter: filter,\n  processGrid: processGrid\n};","map":null,"metadata":{},"sourceType":"script"}