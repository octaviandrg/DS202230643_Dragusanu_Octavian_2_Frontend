{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.stackgl = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (_glvis_, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      } // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function getLens(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        } // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      } // base64 is 4/3 + up to two characters of the original data\n\n\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        var i;\n\n        for (i = 0; i < len; i += 4) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n        // go through the array every three bytes, we'll deal with trailing stuff later\n\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n        }\n\n        return parts.join('');\n      }\n    }, {}],\n    2: [function (_glvis_, module, exports) {}, {}],\n    3: [function (_glvis_, module, exports) {\n      (function (Buffer) {\n        (function () {\n          /*!\n           * The buffer module from node.js, for the browser.\n           *\n           * @author   Feross Aboukhadijeh <https://feross.org>\n           * @license  MIT\n           */\n\n          /* eslint-disable no-proto */\n          'use strict';\n\n          var base64 = _glvis_('base64-js');\n\n          var ieee754 = _glvis_('ieee754');\n\n          exports.Buffer = Buffer;\n          exports.SlowBuffer = SlowBuffer;\n          exports.INSPECT_MAX_BYTES = 50;\n          var K_MAX_LENGTH = 0x7fffffff;\n          exports.kMaxLength = K_MAX_LENGTH;\n          /**\n           * If `Buffer.TYPED_ARRAY_SUPPORT`:\n           *   === true    Use Uint8Array implementation (fastest)\n           *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n           *               implementation (most compatible, even IE6)\n           *\n           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n           * Opera 11.6+, iOS 4.2+.\n           *\n           * We report that the browser does not support typed arrays if the are not subclassable\n           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n           * for __proto__ and has a buggy typed array implementation.\n           */\n\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n          }\n\n          function typedArraySupport() {\n            // Can typed array instances can be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              arr.__proto__ = {\n                __proto__: Uint8Array.prototype,\n                foo: function foo() {\n                  return 42;\n                }\n              };\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          Object.defineProperty(Buffer.prototype, 'parent', {\n            enumerable: true,\n            get: function get() {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.buffer;\n            }\n          });\n          Object.defineProperty(Buffer.prototype, 'offset', {\n            enumerable: true,\n            get: function get() {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.byteOffset;\n            }\n          });\n\n          function createBuffer(length) {\n            if (length > K_MAX_LENGTH) {\n              throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n            } // Return an augmented `Uint8Array` instance\n\n\n            var buf = new Uint8Array(length);\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n          /**\n           * The Buffer constructor returns instances of `Uint8Array` that have their\n           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n           * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n           * returns a single octet.\n           *\n           * The `Uint8Array` prototype remains unmodified.\n           */\n\n\n          function Buffer(arg, encodingOrOffset, length) {\n            // Common case.\n            if (typeof arg === 'number') {\n              if (typeof encodingOrOffset === 'string') {\n                throw new TypeError('The \"string\" argument must be of type string. Received type number');\n              }\n\n              return allocUnsafe(arg);\n            }\n\n            return from(arg, encodingOrOffset, length);\n          } // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n\n\n          if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true,\n              enumerable: false,\n              writable: false\n            });\n          }\n\n          Buffer.poolSize = 8192; // not used by this implementation\n\n          function from(value, encodingOrOffset, length) {\n            if (typeof value === 'string') {\n              return fromString(value, encodingOrOffset);\n            }\n\n            if (ArrayBuffer.isView(value)) {\n              return fromArrayLike(value);\n            }\n\n            if (value == null) {\n              throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n            }\n\n            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n\n            if (typeof value === 'number') {\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            }\n\n            var valueOf = value.valueOf && value.valueOf();\n\n            if (valueOf != null && valueOf !== value) {\n              return Buffer.from(valueOf, encodingOrOffset, length);\n            }\n\n            var b = fromObject(value);\n            if (b) return b;\n\n            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n            }\n\n            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n          }\n          /**\n           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n           * if value is a number.\n           * Buffer.from(str[, encoding])\n           * Buffer.from(array)\n           * Buffer.from(buffer)\n           * Buffer.from(arrayBuffer[, byteOffset[, length]])\n           **/\n\n\n          Buffer.from = function (value, encodingOrOffset, length) {\n            return from(value, encodingOrOffset, length);\n          }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n          // https://github.com/feross/buffer/pull/148\n\n\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          function assertSize(size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('\"size\" argument must be of type number');\n            } else if (size < 0) {\n              throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n            }\n          }\n\n          function alloc(size, fill, encoding) {\n            assertSize(size);\n\n            if (size <= 0) {\n              return createBuffer(size);\n            }\n\n            if (fill !== undefined) {\n              // Only pay attention to encoding if it's a string. This\n              // prevents accidentally sending in a number that would\n              // be interpretted as a start offset.\n              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n            }\n\n            return createBuffer(size);\n          }\n          /**\n           * Creates a new filled Buffer instance.\n           * alloc(size[, fill[, encoding]])\n           **/\n\n\n          Buffer.alloc = function (size, fill, encoding) {\n            return alloc(size, fill, encoding);\n          };\n\n          function allocUnsafe(size) {\n            assertSize(size);\n            return createBuffer(size < 0 ? 0 : checked(size) | 0);\n          }\n          /**\n           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n           * */\n\n\n          Buffer.allocUnsafe = function (size) {\n            return allocUnsafe(size);\n          };\n          /**\n           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n           */\n\n\n          Buffer.allocUnsafeSlow = function (size) {\n            return allocUnsafe(size);\n          };\n\n          function fromString(string, encoding) {\n            if (typeof encoding !== 'string' || encoding === '') {\n              encoding = 'utf8';\n            }\n\n            if (!Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n\n            var length = byteLength(string, encoding) | 0;\n            var buf = createBuffer(length);\n            var actual = buf.write(string, encoding);\n\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n\n            return buf;\n          }\n\n          function fromArrayLike(array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(length);\n\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n\n            return buf;\n          }\n\n          function fromArrayBuffer(array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\"offset\" is outside of buffer bounds');\n            }\n\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\"length\" is outside of buffer bounds');\n            }\n\n            var buf;\n\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            } // Return an augmented `Uint8Array` instance\n\n\n            buf.__proto__ = Buffer.prototype;\n            return buf;\n          }\n\n          function fromObject(obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(len);\n\n              if (buf.length === 0) {\n                return buf;\n              }\n\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n\n            if (obj.length !== undefined) {\n              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n                return createBuffer(0);\n              }\n\n              return fromArrayLike(obj);\n            }\n\n            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n              return fromArrayLike(obj.data);\n            }\n          }\n\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n\n            return length | 0;\n          }\n\n          function SlowBuffer(length) {\n            if (+length != length) {\n              // eslint-disable-line eqeqeq\n              length = 0;\n            }\n\n            return Buffer.alloc(+length);\n          }\n\n          Buffer.isBuffer = function isBuffer(b) {\n            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n          };\n\n          Buffer.compare = function compare(a, b) {\n            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n              throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n            }\n\n            if (a === b) return 0;\n            var x = a.length;\n            var y = b.length;\n\n            for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n              if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n\n          Buffer.isEncoding = function isEncoding(encoding) {\n            switch (String(encoding).toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return true;\n\n              default:\n                return false;\n            }\n          };\n\n          Buffer.concat = function concat(list, length) {\n            if (!Array.isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            if (list.length === 0) {\n              return Buffer.alloc(0);\n            }\n\n            var i;\n\n            if (length === undefined) {\n              length = 0;\n\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n\n            var buffer = Buffer.allocUnsafe(length);\n            var pos = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n\n              if (isInstance(buf, Uint8Array)) {\n                buf = Buffer.from(buf);\n              }\n\n              if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              }\n\n              buf.copy(buffer, pos);\n              pos += buf.length;\n            }\n\n            return buffer;\n          };\n\n          function byteLength(string, encoding) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n\n            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n              return string.byteLength;\n            }\n\n            if (typeof string !== 'string') {\n              throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n            }\n\n            var len = string.length;\n            var mustMatch = arguments.length > 2 && arguments[2] === true;\n            if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return len;\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8ToBytes(string).length;\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return len * 2;\n\n                case 'hex':\n                  return len >>> 1;\n\n                case 'base64':\n                  return base64ToBytes(string).length;\n\n                default:\n                  if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                  }\n\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n\n          Buffer.byteLength = byteLength;\n\n          function slowToString(encoding, start, end) {\n            var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n            // property of a typed array.\n            // This behaves neither like String nor Uint8Array in that we set start/end\n            // to their upper/lower bounds if the value passed is out of range.\n            // undefined is handled specially as per ECMA-262 6th Edition,\n            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n            if (start === undefined || start < 0) {\n              start = 0;\n            } // Return early if start > this.length. Done here to prevent potential uint32\n            // coercion fail below.\n\n\n            if (start > this.length) {\n              return '';\n            }\n\n            if (end === undefined || end > this.length) {\n              end = this.length;\n            }\n\n            if (end <= 0) {\n              return '';\n            } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n            end >>>= 0;\n            start >>>= 0;\n\n            if (end <= start) {\n              return '';\n            }\n\n            if (!encoding) encoding = 'utf8';\n\n            while (true) {\n              switch (encoding) {\n                case 'hex':\n                  return hexSlice(this, start, end);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Slice(this, start, end);\n\n                case 'ascii':\n                  return asciiSlice(this, start, end);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Slice(this, start, end);\n\n                case 'base64':\n                  return base64Slice(this, start, end);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return utf16leSlice(this, start, end);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = (encoding + '').toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n          // reliably in a browserify context because there could be multiple different\n          // copies of the 'buffer' package in use. This method works even for Buffer\n          // instances that were created from another copy of the `buffer` package.\n          // See: https://github.com/feross/buffer/issues/154\n\n\n          Buffer.prototype._isBuffer = true;\n\n          function swap(b, n, m) {\n            var i = b[n];\n            b[n] = b[m];\n            b[m] = i;\n          }\n\n          Buffer.prototype.swap16 = function swap16() {\n            var len = this.length;\n\n            if (len % 2 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 16-bits');\n            }\n\n            for (var i = 0; i < len; i += 2) {\n              swap(this, i, i + 1);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap32 = function swap32() {\n            var len = this.length;\n\n            if (len % 4 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 32-bits');\n            }\n\n            for (var i = 0; i < len; i += 4) {\n              swap(this, i, i + 3);\n              swap(this, i + 1, i + 2);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap64 = function swap64() {\n            var len = this.length;\n\n            if (len % 8 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 64-bits');\n            }\n\n            for (var i = 0; i < len; i += 8) {\n              swap(this, i, i + 7);\n              swap(this, i + 1, i + 6);\n              swap(this, i + 2, i + 5);\n              swap(this, i + 3, i + 4);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.toString = function toString() {\n            var length = this.length;\n            if (length === 0) return '';\n            if (arguments.length === 0) return utf8Slice(this, 0, length);\n            return slowToString.apply(this, arguments);\n          };\n\n          Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n          Buffer.prototype.equals = function equals(b) {\n            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n            if (this === b) return true;\n            return Buffer.compare(this, b) === 0;\n          };\n\n          Buffer.prototype.inspect = function inspect() {\n            var str = '';\n            var max = exports.INSPECT_MAX_BYTES;\n            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n            if (this.length > max) str += ' ... ';\n            return '<Buffer ' + str + '>';\n          };\n\n          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n            if (isInstance(target, Uint8Array)) {\n              target = Buffer.from(target, target.offset, target.byteLength);\n            }\n\n            if (!Buffer.isBuffer(target)) {\n              throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n            }\n\n            if (start === undefined) {\n              start = 0;\n            }\n\n            if (end === undefined) {\n              end = target ? target.length : 0;\n            }\n\n            if (thisStart === undefined) {\n              thisStart = 0;\n            }\n\n            if (thisEnd === undefined) {\n              thisEnd = this.length;\n            }\n\n            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n              throw new RangeError('out of range index');\n            }\n\n            if (thisStart >= thisEnd && start >= end) {\n              return 0;\n            }\n\n            if (thisStart >= thisEnd) {\n              return -1;\n            }\n\n            if (start >= end) {\n              return 1;\n            }\n\n            start >>>= 0;\n            end >>>= 0;\n            thisStart >>>= 0;\n            thisEnd >>>= 0;\n            if (this === target) return 0;\n            var x = thisEnd - thisStart;\n            var y = end - start;\n            var len = Math.min(x, y);\n            var thisCopy = this.slice(thisStart, thisEnd);\n            var targetCopy = target.slice(start, end);\n\n            for (var i = 0; i < len; ++i) {\n              if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n          //\n          // Arguments:\n          // - buffer - a Buffer to search\n          // - val - a string, Buffer, or number\n          // - byteOffset - an index into `buffer`; will be clamped to an int32\n          // - encoding - an optional encoding, relevant is val is a string\n          // - dir - true for indexOf, false for lastIndexOf\n\n\n          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n            // Empty buffer means no match\n            if (buffer.length === 0) return -1; // Normalize byteOffset\n\n            if (typeof byteOffset === 'string') {\n              encoding = byteOffset;\n              byteOffset = 0;\n            } else if (byteOffset > 0x7fffffff) {\n              byteOffset = 0x7fffffff;\n            } else if (byteOffset < -0x80000000) {\n              byteOffset = -0x80000000;\n            }\n\n            byteOffset = +byteOffset; // Coerce to Number.\n\n            if (numberIsNaN(byteOffset)) {\n              // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n              byteOffset = dir ? 0 : buffer.length - 1;\n            } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n            if (byteOffset >= buffer.length) {\n              if (dir) return -1;else byteOffset = buffer.length - 1;\n            } else if (byteOffset < 0) {\n              if (dir) byteOffset = 0;else return -1;\n            } // Normalize val\n\n\n            if (typeof val === 'string') {\n              val = Buffer.from(val, encoding);\n            } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n            if (Buffer.isBuffer(val)) {\n              // Special case: looking for empty string/buffer always fails\n              if (val.length === 0) {\n                return -1;\n              }\n\n              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n            } else if (typeof val === 'number') {\n              val = val & 0xFF; // Search for a byte value [0-255]\n\n              if (typeof Uint8Array.prototype.indexOf === 'function') {\n                if (dir) {\n                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                } else {\n                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                }\n              }\n\n              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n            }\n\n            throw new TypeError('val must be string, number or Buffer');\n          }\n\n          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n            var indexSize = 1;\n            var arrLength = arr.length;\n            var valLength = val.length;\n\n            if (encoding !== undefined) {\n              encoding = String(encoding).toLowerCase();\n\n              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n                if (arr.length < 2 || val.length < 2) {\n                  return -1;\n                }\n\n                indexSize = 2;\n                arrLength /= 2;\n                valLength /= 2;\n                byteOffset /= 2;\n              }\n            }\n\n            function read(buf, i) {\n              if (indexSize === 1) {\n                return buf[i];\n              } else {\n                return buf.readUInt16BE(i * indexSize);\n              }\n            }\n\n            var i;\n\n            if (dir) {\n              var foundIndex = -1;\n\n              for (i = byteOffset; i < arrLength; i++) {\n                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                  if (foundIndex === -1) foundIndex = i;\n                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n                } else {\n                  if (foundIndex !== -1) i -= i - foundIndex;\n                  foundIndex = -1;\n                }\n              }\n            } else {\n              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n              for (i = byteOffset; i >= 0; i--) {\n                var found = true;\n\n                for (var j = 0; j < valLength; j++) {\n                  if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                  }\n                }\n\n                if (found) return i;\n              }\n            }\n\n            return -1;\n          }\n\n          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n            return this.indexOf(val, byteOffset, encoding) !== -1;\n          };\n\n          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n          };\n\n          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n          };\n\n          function hexWrite(buf, string, offset, length) {\n            offset = Number(offset) || 0;\n            var remaining = buf.length - offset;\n\n            if (!length) {\n              length = remaining;\n            } else {\n              length = Number(length);\n\n              if (length > remaining) {\n                length = remaining;\n              }\n            }\n\n            var strLen = string.length;\n\n            if (length > strLen / 2) {\n              length = strLen / 2;\n            }\n\n            for (var i = 0; i < length; ++i) {\n              var parsed = parseInt(string.substr(i * 2, 2), 16);\n              if (numberIsNaN(parsed)) return i;\n              buf[offset + i] = parsed;\n            }\n\n            return i;\n          }\n\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          function asciiWrite(buf, string, offset, length) {\n            return blitBuffer(asciiToBytes(string), buf, offset, length);\n          }\n\n          function latin1Write(buf, string, offset, length) {\n            return asciiWrite(buf, string, offset, length);\n          }\n\n          function base64Write(buf, string, offset, length) {\n            return blitBuffer(base64ToBytes(string), buf, offset, length);\n          }\n\n          function ucs2Write(buf, string, offset, length) {\n            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          Buffer.prototype.write = function write(string, offset, length, encoding) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              encoding = 'utf8';\n              length = this.length;\n              offset = 0; // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              encoding = offset;\n              length = this.length;\n              offset = 0; // Buffer#write(string, offset[, length][, encoding])\n            } else if (isFinite(offset)) {\n              offset = offset >>> 0;\n\n              if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined) encoding = 'utf8';\n              } else {\n                encoding = length;\n                length = undefined;\n              }\n            } else {\n              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n            }\n\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n\n            if (!encoding) encoding = 'utf8';\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'hex':\n                  return hexWrite(this, string, offset, length);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Write(this, string, offset, length);\n\n                case 'ascii':\n                  return asciiWrite(this, string, offset, length);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Write(this, string, offset, length);\n\n                case 'base64':\n                  // Warning: maxLength not taken into account in base64Write\n                  return base64Write(this, string, offset, length);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return ucs2Write(this, string, offset, length);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          };\n\n          Buffer.prototype.toJSON = function toJSON() {\n            return {\n              type: 'Buffer',\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n\n          function base64Slice(buf, start, end) {\n            if (start === 0 && end === buf.length) {\n              return base64.fromByteArray(buf);\n            } else {\n              return base64.fromByteArray(buf.slice(start, end));\n            }\n          }\n\n          function utf8Slice(buf, start, end) {\n            end = Math.min(buf.length, end);\n            var res = [];\n            var i = start;\n\n            while (i < end) {\n              var firstByte = buf[i];\n              var codePoint = null;\n              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n              if (i + bytesPerSequence <= end) {\n                var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n                switch (bytesPerSequence) {\n                  case 1:\n                    if (firstByte < 0x80) {\n                      codePoint = firstByte;\n                    }\n\n                    break;\n\n                  case 2:\n                    secondByte = buf[i + 1];\n\n                    if ((secondByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                      if (tempCodePoint > 0x7F) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                }\n              }\n\n              if (codePoint === null) {\n                // we did not generate a valid codePoint so insert a\n                // replacement char (U+FFFD) and advance only 1 byte\n                codePoint = 0xFFFD;\n                bytesPerSequence = 1;\n              } else if (codePoint > 0xFFFF) {\n                // encode to utf16 (surrogate pair dance)\n                codePoint -= 0x10000;\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n                codePoint = 0xDC00 | codePoint & 0x3FF;\n              }\n\n              res.push(codePoint);\n              i += bytesPerSequence;\n            }\n\n            return decodeCodePointsArray(res);\n          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n          // the lowest limit is Chrome, with 0x10000 args.\n          // We go 1 magnitude less, for safety\n\n\n          var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n          function decodeCodePointsArray(codePoints) {\n            var len = codePoints.length;\n\n            if (len <= MAX_ARGUMENTS_LENGTH) {\n              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n            } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n            var res = '';\n            var i = 0;\n\n            while (i < len) {\n              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n            }\n\n            return res;\n          }\n\n          function asciiSlice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i] & 0x7F);\n            }\n\n            return ret;\n          }\n\n          function latin1Slice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i]);\n            }\n\n            return ret;\n          }\n\n          function hexSlice(buf, start, end) {\n            var len = buf.length;\n            if (!start || start < 0) start = 0;\n            if (!end || end < 0 || end > len) end = len;\n            var out = '';\n\n            for (var i = start; i < end; ++i) {\n              out += toHex(buf[i]);\n            }\n\n            return out;\n          }\n\n          function utf16leSlice(buf, start, end) {\n            var bytes = buf.slice(start, end);\n            var res = '';\n\n            for (var i = 0; i < bytes.length; i += 2) {\n              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n            }\n\n            return res;\n          }\n\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n\n            if (end < start) end = start;\n            var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n            newBuf.__proto__ = Buffer.prototype;\n            return newBuf;\n          };\n          /*\n           * Need to make sure that buffer isn't trying to write out of bounds.\n           */\n\n\n          function checkOffset(offset, ext, length) {\n            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n          }\n\n          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              checkOffset(offset, byteLength, this.length);\n            }\n\n            var val = this[offset + --byteLength];\n            var mul = 1;\n\n            while (byteLength > 0 && (mul *= 0x100)) {\n              val += this[offset + --byteLength] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            return this[offset];\n          };\n\n          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] | this[offset + 1] << 8;\n          };\n\n          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] << 8 | this[offset + 1];\n          };\n\n          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n          };\n\n          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n          };\n\n          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var i = byteLength;\n            var mul = 1;\n            var val = this[offset + --i];\n\n            while (i > 0 && (mul *= 0x100)) {\n              val += this[offset + --i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            if (!(this[offset] & 0x80)) return this[offset];\n            return (0xff - this[offset] + 1) * -1;\n          };\n\n          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset] | this[offset + 1] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset + 1] | this[offset] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n          };\n\n          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n          };\n\n          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, true, 23, 4);\n          };\n\n          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, false, 23, 4);\n          };\n\n          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, true, 52, 8);\n          };\n\n          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, false, 52, 8);\n          };\n\n          function checkInt(buf, value, offset, ext, max, min) {\n            if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n            if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          }\n\n          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var mul = 1;\n            var i = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = 0;\n            var mul = 1;\n            var sub = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            var sub = 0;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n            if (value < 0) value = 0xff + value + 1;\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            if (value < 0) value = 0xffffffff + value + 1;\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          function checkIEEE754(buf, value, offset, ext, max, min) {\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n            if (offset < 0) throw new RangeError('Index out of range');\n          }\n\n          function writeFloat(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 23, 4);\n            return offset + 4;\n          }\n\n          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, false, noAssert);\n          };\n\n          function writeDouble(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 52, 8);\n            return offset + 8;\n          }\n\n          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, false, noAssert);\n          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n\n            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n            if (end > this.length) end = this.length;\n\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n\n            var len = end - start;\n\n            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n              // Use built-in when available, missing from IE11\n              this.copyWithin(targetStart, start, end);\n            } else if (this === target && start < targetStart && targetStart < end) {\n              // descending copy from end\n              for (var i = len - 1; i >= 0; --i) {\n                target[i + targetStart] = this[i + start];\n              }\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n            }\n\n            return len;\n          }; // Usage:\n          //    buffer.fill(number[, offset[, end]])\n          //    buffer.fill(buffer[, offset[, end]])\n          //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n          Buffer.prototype.fill = function fill(val, start, end, encoding) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n              }\n\n              if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n              }\n\n              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError('Unknown encoding: ' + encoding);\n              }\n\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n\n                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                  // Fast path: If `val` fits into a single byte, use that numeric value.\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            } // Invalid ranges are not set to a default, so can range check early.\n\n\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n\n            if (end <= start) {\n              return this;\n            }\n\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n              var len = bytes.length;\n\n              if (len === 0) {\n                throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n              }\n\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n\n            return this;\n          }; // HELPER FUNCTIONS\n          // ================\n\n\n          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n          function base64clean(str) {\n            // Node takes equal signs as end of the Base64 encoding\n            str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n            str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n            while (str.length % 4 !== 0) {\n              str = str + '=';\n            }\n\n            return str;\n          }\n\n          function toHex(n) {\n            if (n < 16) return '0' + n.toString(16);\n            return n.toString(16);\n          }\n\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i); // is surrogate component\n\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } // valid lead\n\n\n                  leadSurrogate = codePoint;\n                  continue;\n                } // 2 leads in a row\n\n\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                } // valid surrogate pair\n\n\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n\n              leadSurrogate = null; // encode utf8\n\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n\n            return bytes;\n          }\n\n          function asciiToBytes(str) {\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              // Node's code seems to be doing this and not & 0x7F..\n              byteArray.push(str.charCodeAt(i) & 0xFF);\n            }\n\n            return byteArray;\n          }\n\n          function utf16leToBytes(str, units) {\n            var c, hi, lo;\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              if ((units -= 2) < 0) break;\n              c = str.charCodeAt(i);\n              hi = c >> 8;\n              lo = c % 256;\n              byteArray.push(lo);\n              byteArray.push(hi);\n            }\n\n            return byteArray;\n          }\n\n          function base64ToBytes(str) {\n            return base64.toByteArray(base64clean(str));\n          }\n\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n\n            return i;\n          } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n          // the `instanceof` check but they should be treated as of that type.\n          // See: https://github.com/feross/buffer/issues/166\n\n\n          function isInstance(obj, type) {\n            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n          }\n\n          function numberIsNaN(obj) {\n            // For IE11 support\n            return obj !== obj; // eslint-disable-line no-self-compare\n          }\n        }).call(this);\n      }).call(this, _glvis_(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 1,\n      \"buffer\": 3,\n      \"ieee754\": 4\n    }],\n    4: [function (_glvis_, module, exports) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n    }, {}],\n    5: [function (_glvis_, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    6: [function (_glvis_, module, exports) {\n      module.exports = {\n        alpha_shape: _glvis_('alpha-shape'),\n        convex_hull: _glvis_('convex-hull'),\n        delaunay_triangulate: _glvis_('delaunay-triangulate'),\n        gl_cone3d: _glvis_('gl-cone3d'),\n        gl_error3d: _glvis_('gl-error3d'),\n        gl_heatmap2d: _glvis_('gl-heatmap2d'),\n        gl_line3d: _glvis_('gl-line3d'),\n        gl_mesh3d: _glvis_('gl-mesh3d'),\n        gl_plot2d: _glvis_('gl-plot2d'),\n        gl_plot3d: _glvis_('gl-plot3d'),\n        gl_pointcloud2d: _glvis_('gl-pointcloud2d'),\n        gl_scatter3d: _glvis_('gl-scatter3d'),\n        gl_select_box: _glvis_('gl-select-box'),\n        gl_spikes2d: _glvis_('gl-spikes2d'),\n        gl_streamtube3d: _glvis_('gl-streamtube3d'),\n        gl_surface3d: _glvis_('gl-surface3d'),\n        ndarray: _glvis_('ndarray'),\n        ndarray_linear_interpolate: _glvis_('ndarray-linear-interpolate')\n      };\n    }, {\n      \"alpha-shape\": 12,\n      \"convex-hull\": 58,\n      \"delaunay-triangulate\": 63,\n      \"gl-cone3d\": 79,\n      \"gl-error3d\": 84,\n      \"gl-heatmap2d\": 88,\n      \"gl-line3d\": 91,\n      \"gl-mesh3d\": 112,\n      \"gl-plot2d\": 118,\n      \"gl-plot3d\": 121,\n      \"gl-pointcloud2d\": 123,\n      \"gl-scatter3d\": 128,\n      \"gl-select-box\": 130,\n      \"gl-spikes2d\": 139,\n      \"gl-streamtube3d\": 143,\n      \"gl-surface3d\": 145,\n      \"ndarray\": 259,\n      \"ndarray-linear-interpolate\": 253\n    }],\n    7: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createViewController;\n\n      var createTurntable = _glvis_('turntable-camera-controller');\n\n      var createOrbit = _glvis_('orbit-camera-controller');\n\n      var createMatrix = _glvis_('matrix-camera-controller');\n\n      function ViewController(controllers, mode) {\n        this._controllerNames = Object.keys(controllers);\n        this._controllerList = this._controllerNames.map(function (n) {\n          return controllers[n];\n        });\n        this._mode = mode;\n        this._active = controllers[mode];\n\n        if (!this._active) {\n          this._mode = 'turntable';\n          this._active = controllers.turntable;\n        }\n\n        this.modes = this._controllerNames;\n        this.computedMatrix = this._active.computedMatrix;\n        this.computedEye = this._active.computedEye;\n        this.computedUp = this._active.computedUp;\n        this.computedCenter = this._active.computedCenter;\n        this.computedRadius = this._active.computedRadius;\n      }\n\n      var proto = ViewController.prototype;\n\n      proto.flush = function (a0) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].flush(a0);\n        }\n      };\n\n      proto.idle = function (a0) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].idle(a0);\n        }\n      };\n\n      proto.lookAt = function (a0, a1, a2, a3) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].lookAt(a0, a1, a2, a3);\n        }\n      };\n\n      proto.rotate = function (a0, a1, a2, a3) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].rotate(a0, a1, a2, a3);\n        }\n      };\n\n      proto.pan = function (a0, a1, a2, a3) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].pan(a0, a1, a2, a3);\n        }\n      };\n\n      proto.translate = function (a0, a1, a2, a3) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].translate(a0, a1, a2, a3);\n        }\n      };\n\n      proto.setMatrix = function (a0, a1) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].setMatrix(a0, a1);\n        }\n      };\n\n      proto.setDistanceLimits = function (a0, a1) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].setDistanceLimits(a0, a1);\n        }\n      };\n\n      proto.setDistance = function (a0, a1) {\n        var cc = this._controllerList;\n\n        for (var i = 0; i < cc.length; ++i) {\n          cc[i].setDistance(a0, a1);\n        }\n      };\n\n      proto.recalcMatrix = function (t) {\n        this._active.recalcMatrix(t);\n      };\n\n      proto.getDistance = function (t) {\n        return this._active.getDistance(t);\n      };\n\n      proto.getDistanceLimits = function (out) {\n        return this._active.getDistanceLimits(out);\n      };\n\n      proto.lastT = function () {\n        return this._active.lastT();\n      };\n\n      proto.setMode = function (mode) {\n        if (mode === this._mode) {\n          return;\n        }\n\n        var idx = this._controllerNames.indexOf(mode);\n\n        if (idx < 0) {\n          return;\n        }\n\n        var prev = this._active;\n        var next = this._controllerList[idx];\n        var lastT = Math.max(prev.lastT(), next.lastT());\n        prev.recalcMatrix(lastT);\n        next.setMatrix(lastT, prev.computedMatrix);\n        this._active = next;\n        this._mode = mode; //Update matrix properties\n\n        this.computedMatrix = this._active.computedMatrix;\n        this.computedEye = this._active.computedEye;\n        this.computedUp = this._active.computedUp;\n        this.computedCenter = this._active.computedCenter;\n        this.computedRadius = this._active.computedRadius;\n      };\n\n      proto.getMode = function () {\n        return this._mode;\n      };\n\n      function createViewController(options) {\n        options = options || {};\n        var eye = options.eye || [0, 0, 1];\n        var center = options.center || [0, 0, 0];\n        var up = options.up || [0, 1, 0];\n        var limits = options.distanceLimits || [0, Infinity];\n        var mode = options.mode || 'turntable';\n        var turntable = createTurntable();\n        var orbit = createOrbit();\n        var matrix = createMatrix();\n        turntable.setDistanceLimits(limits[0], limits[1]);\n        turntable.lookAt(0, eye, center, up);\n        orbit.setDistanceLimits(limits[0], limits[1]);\n        orbit.lookAt(0, eye, center, up);\n        matrix.setDistanceLimits(limits[0], limits[1]);\n        matrix.lookAt(0, eye, center, up);\n        return new ViewController({\n          turntable: turntable,\n          orbit: orbit,\n          matrix: matrix\n        }, mode);\n      }\n    }, {\n      \"matrix-camera-controller\": 245,\n      \"orbit-camera-controller\": 263,\n      \"turntable-camera-controller\": 305\n    }],\n    8: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var weakMap = typeof WeakMap === 'undefined' ? _glvis_('weak-map') : WeakMap;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var TriangleCache = new weakMap();\n\n      function createABigTriangle(gl) {\n        var triangleVAO = TriangleCache.get(gl);\n        var handle = triangleVAO && (triangleVAO._triangleBuffer.handle || triangleVAO._triangleBuffer.buffer);\n\n        if (!handle || !gl.isBuffer(handle)) {\n          var buf = createBuffer(gl, new Float32Array([-1, -1, -1, 4, 4, -1]));\n          triangleVAO = createVAO(gl, [{\n            buffer: buf,\n            type: gl.FLOAT,\n            size: 2\n          }]);\n          triangleVAO._triangleBuffer = buf;\n          TriangleCache.set(gl, triangleVAO);\n        }\n\n        triangleVAO.bind();\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\n        triangleVAO.unbind();\n      }\n\n      module.exports = createABigTriangle;\n    }, {\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150,\n      \"weak-map\": 313\n    }],\n    9: [function (_glvis_, module, exports) {\n      var padLeft = _glvis_('pad-left');\n\n      module.exports = addLineNumbers;\n\n      function addLineNumbers(string, start, delim) {\n        start = typeof start === 'number' ? start : 1;\n        delim = delim || ': ';\n        var lines = string.split(/\\r?\\n/);\n        var totalDigits = String(lines.length + start - 1).length;\n        return lines.map(function (line, i) {\n          var c = i + start;\n          var digits = String(c).length;\n          var prefix = padLeft(c, totalDigits - digits);\n          return prefix + delim + line;\n        }).join('\\n');\n      }\n    }, {\n      \"pad-left\": 264\n    }],\n    10: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = affineHull;\n\n      var orient = _glvis_('robust-orientation');\n\n      function linearlyIndependent(points, d) {\n        var nhull = new Array(d + 1);\n\n        for (var i = 0; i < points.length; ++i) {\n          nhull[i] = points[i];\n        }\n\n        for (var i = 0; i <= points.length; ++i) {\n          for (var j = points.length; j <= d; ++j) {\n            var x = new Array(d);\n\n            for (var k = 0; k < d; ++k) {\n              x[k] = Math.pow(j + 1 - i, k);\n            }\n\n            nhull[j] = x;\n          }\n\n          var o = orient.apply(void 0, nhull);\n\n          if (o) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function affineHull(points) {\n        var n = points.length;\n\n        if (n === 0) {\n          return [];\n        }\n\n        if (n === 1) {\n          return [0];\n        }\n\n        var d = points[0].length;\n        var frame = [points[0]];\n        var index = [0];\n\n        for (var i = 1; i < n; ++i) {\n          frame.push(points[i]);\n\n          if (!linearlyIndependent(frame, d)) {\n            frame.pop();\n            continue;\n          }\n\n          index.push(i);\n\n          if (index.length === d + 1) {\n            return index;\n          }\n        }\n\n        return index;\n      }\n    }, {\n      \"robust-orientation\": 284\n    }],\n    11: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = alphaComplex;\n\n      var delaunay = _glvis_('delaunay-triangulate');\n\n      var circumradius = _glvis_('circumradius');\n\n      function alphaComplex(alpha, points) {\n        return delaunay(points).filter(function (cell) {\n          var simplex = new Array(cell.length);\n\n          for (var i = 0; i < cell.length; ++i) {\n            simplex[i] = points[cell[i]];\n          }\n\n          return circumradius(simplex) * alpha < 1;\n        });\n      }\n    }, {\n      \"circumradius\": 49,\n      \"delaunay-triangulate\": 63\n    }],\n    12: [function (_glvis_, module, exports) {\n      module.exports = alphaShape;\n\n      var ac = _glvis_('alpha-complex');\n\n      var bnd = _glvis_('simplicial-complex-boundary');\n\n      function alphaShape(alpha, points) {\n        return bnd(ac(alpha, points));\n      }\n    }, {\n      \"alpha-complex\": 11,\n      \"simplicial-complex-boundary\": 290\n    }],\n    13: [function (_glvis_, module, exports) {\n      module.exports = function _atob(str) {\n        return atob(str);\n      };\n    }, {}],\n    14: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = barycentric;\n\n      var solve = _glvis_('robust-linear-solve');\n\n      function reduce(x) {\n        var r = 0;\n\n        for (var i = 0; i < x.length; ++i) {\n          r += x[i];\n        }\n\n        return r;\n      }\n\n      function barycentric(simplex, point) {\n        var d = point.length;\n        var A = new Array(d + 1);\n\n        for (var i = 0; i < d; ++i) {\n          var row = new Array(d + 1);\n\n          for (var j = 0; j <= d; ++j) {\n            row[j] = simplex[j][i];\n          }\n\n          A[i] = row;\n        }\n\n        A[d] = new Array(d + 1);\n\n        for (var i = 0; i <= d; ++i) {\n          A[d][i] = 1;\n        }\n\n        var b = new Array(d + 1);\n\n        for (var i = 0; i < d; ++i) {\n          b[i] = point[i];\n        }\n\n        b[d] = 1.0;\n        var x = solve(A, b);\n        var w = reduce(x[d + 1]);\n\n        if (w === 0) {\n          w = 1.0;\n        }\n\n        var y = new Array(d + 1);\n\n        for (var i = 0; i <= d; ++i) {\n          y[i] = reduce(x[i]) / w;\n        }\n\n        return y;\n      }\n    }, {\n      \"robust-linear-solve\": 283\n    }],\n    15: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var rationalize = _glvis_('./lib/rationalize');\n\n      module.exports = add;\n\n      function add(a, b) {\n        return rationalize(a[0].mul(b[1]).add(b[0].mul(a[1])), a[1].mul(b[1]));\n      }\n    }, {\n      \"./lib/rationalize\": 25\n    }],\n    16: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = cmp;\n\n      function cmp(a, b) {\n        return a[0].mul(b[1]).cmp(b[0].mul(a[1]));\n      }\n    }, {}],\n    17: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var rationalize = _glvis_('./lib/rationalize');\n\n      module.exports = div;\n\n      function div(a, b) {\n        return rationalize(a[0].mul(b[1]), a[1].mul(b[0]));\n      }\n    }, {\n      \"./lib/rationalize\": 25\n    }],\n    18: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var isRat = _glvis_('./is-rat');\n\n      var isBN = _glvis_('./lib/is-bn');\n\n      var num2bn = _glvis_('./lib/num-to-bn');\n\n      var str2bn = _glvis_('./lib/str-to-bn');\n\n      var rationalize = _glvis_('./lib/rationalize');\n\n      var div = _glvis_('./div');\n\n      module.exports = makeRational;\n\n      function makeRational(numer, denom) {\n        if (isRat(numer)) {\n          if (denom) {\n            return div(numer, makeRational(denom));\n          }\n\n          return [numer[0].clone(), numer[1].clone()];\n        }\n\n        var shift = 0;\n        var a, b;\n\n        if (isBN(numer)) {\n          a = numer.clone();\n        } else if (typeof numer === 'string') {\n          a = str2bn(numer);\n        } else if (numer === 0) {\n          return [num2bn(0), num2bn(1)];\n        } else if (numer === Math.floor(numer)) {\n          a = num2bn(numer);\n        } else {\n          while (numer !== Math.floor(numer)) {\n            numer = numer * Math.pow(2, 256);\n            shift -= 256;\n          }\n\n          a = num2bn(numer);\n        }\n\n        if (isRat(denom)) {\n          a.mul(denom[1]);\n          b = denom[0].clone();\n        } else if (isBN(denom)) {\n          b = denom.clone();\n        } else if (typeof denom === 'string') {\n          b = str2bn(denom);\n        } else if (!denom) {\n          b = num2bn(1);\n        } else if (denom === Math.floor(denom)) {\n          b = num2bn(denom);\n        } else {\n          while (denom !== Math.floor(denom)) {\n            denom = denom * Math.pow(2, 256);\n            shift += 256;\n          }\n\n          b = num2bn(denom);\n        }\n\n        if (shift > 0) {\n          a = a.ushln(shift);\n        } else if (shift < 0) {\n          b = b.ushln(-shift);\n        }\n\n        return rationalize(a, b);\n      }\n    }, {\n      \"./div\": 17,\n      \"./is-rat\": 19,\n      \"./lib/is-bn\": 23,\n      \"./lib/num-to-bn\": 24,\n      \"./lib/rationalize\": 25,\n      \"./lib/str-to-bn\": 26\n    }],\n    19: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var isBN = _glvis_('./lib/is-bn');\n\n      module.exports = isRat;\n\n      function isRat(x) {\n        return Array.isArray(x) && x.length === 2 && isBN(x[0]) && isBN(x[1]);\n      }\n    }, {\n      \"./lib/is-bn\": 23\n    }],\n    20: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var BN = _glvis_('bn.js');\n\n      module.exports = sign;\n\n      function sign(x) {\n        return x.cmp(new BN(0));\n      }\n    }, {\n      \"bn.js\": 33\n    }],\n    21: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var sign = _glvis_('./bn-sign');\n\n      module.exports = bn2num; //TODO: Make this better\n\n      function bn2num(b) {\n        var l = b.length;\n        var words = b.words;\n        var out = 0;\n\n        if (l === 1) {\n          out = words[0];\n        } else if (l === 2) {\n          out = words[0] + words[1] * 0x4000000;\n        } else {\n          for (var i = 0; i < l; i++) {\n            var w = words[i];\n            out += w * Math.pow(0x4000000, i);\n          }\n        }\n\n        return sign(b) * out;\n      }\n    }, {\n      \"./bn-sign\": 20\n    }],\n    22: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var db = _glvis_('double-bits');\n\n      var ctz = _glvis_('bit-twiddle').countTrailingZeros;\n\n      module.exports = ctzNumber; //Counts the number of trailing zeros\n\n      function ctzNumber(x) {\n        var l = ctz(db.lo(x));\n\n        if (l < 32) {\n          return l;\n        }\n\n        var h = ctz(db.hi(x));\n\n        if (h > 20) {\n          return 52;\n        }\n\n        return h + 32;\n      }\n    }, {\n      \"bit-twiddle\": 32,\n      \"double-bits\": 64\n    }],\n    23: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var BN = _glvis_('bn.js');\n\n      module.exports = isBN; //Test if x is a bignumber\n      //FIXME: obviously this is the wrong way to do it\n\n      function isBN(x) {\n        return x && typeof x === 'object' && Boolean(x.words);\n      }\n    }, {\n      \"bn.js\": 33\n    }],\n    24: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var BN = _glvis_('bn.js');\n\n      var db = _glvis_('double-bits');\n\n      module.exports = num2bn;\n\n      function num2bn(x) {\n        var e = db.exponent(x);\n\n        if (e < 52) {\n          return new BN(x);\n        } else {\n          return new BN(x * Math.pow(2, 52 - e)).ushln(e - 52);\n        }\n      }\n    }, {\n      \"bn.js\": 33,\n      \"double-bits\": 64\n    }],\n    25: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var num2bn = _glvis_('./num-to-bn');\n\n      var sign = _glvis_('./bn-sign');\n\n      module.exports = rationalize;\n\n      function rationalize(numer, denom) {\n        var snumer = sign(numer);\n        var sdenom = sign(denom);\n\n        if (snumer === 0) {\n          return [num2bn(0), num2bn(1)];\n        }\n\n        if (sdenom === 0) {\n          return [num2bn(0), num2bn(0)];\n        }\n\n        if (sdenom < 0) {\n          numer = numer.neg();\n          denom = denom.neg();\n        }\n\n        var d = numer.gcd(denom);\n\n        if (d.cmpn(1)) {\n          return [numer.div(d), denom.div(d)];\n        }\n\n        return [numer, denom];\n      }\n    }, {\n      \"./bn-sign\": 20,\n      \"./num-to-bn\": 24\n    }],\n    26: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var BN = _glvis_('bn.js');\n\n      module.exports = str2BN;\n\n      function str2BN(x) {\n        return new BN(x);\n      }\n    }, {\n      \"bn.js\": 33\n    }],\n    27: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var rationalize = _glvis_('./lib/rationalize');\n\n      module.exports = mul;\n\n      function mul(a, b) {\n        return rationalize(a[0].mul(b[0]), a[1].mul(b[1]));\n      }\n    }, {\n      \"./lib/rationalize\": 25\n    }],\n    28: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bnsign = _glvis_('./lib/bn-sign');\n\n      module.exports = sign;\n\n      function sign(x) {\n        return bnsign(x[0]) * bnsign(x[1]);\n      }\n    }, {\n      \"./lib/bn-sign\": 20\n    }],\n    29: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var rationalize = _glvis_('./lib/rationalize');\n\n      module.exports = sub;\n\n      function sub(a, b) {\n        return rationalize(a[0].mul(b[1]).sub(a[1].mul(b[0])), a[1].mul(b[1]));\n      }\n    }, {\n      \"./lib/rationalize\": 25\n    }],\n    30: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bn2num = _glvis_('./lib/bn-to-num');\n\n      var ctz = _glvis_('./lib/ctz');\n\n      module.exports = roundRat; // Round a rational to the closest float\n\n      function roundRat(f) {\n        var a = f[0];\n        var b = f[1];\n\n        if (a.cmpn(0) === 0) {\n          return 0;\n        }\n\n        var h = a.abs().divmod(b.abs());\n        var iv = h.div;\n        var x = bn2num(iv);\n        var ir = h.mod;\n        var sgn = a.negative !== b.negative ? -1 : 1;\n\n        if (ir.cmpn(0) === 0) {\n          return sgn * x;\n        }\n\n        if (x) {\n          var s = ctz(x) + 4;\n          var y = bn2num(ir.ushln(s).divRound(b));\n          return sgn * (x + y * Math.pow(2, -s));\n        } else {\n          var ybits = b.bitLength() - ir.bitLength() + 53;\n          var y = bn2num(ir.ushln(ybits).divRound(b));\n\n          if (ybits < 1023) {\n            return sgn * y * Math.pow(2, -ybits);\n          }\n\n          y *= Math.pow(2, -1023);\n          return sgn * y * Math.pow(2, 1023 - ybits);\n        }\n      }\n    }, {\n      \"./lib/bn-to-num\": 21,\n      \"./lib/ctz\": 22\n    }],\n    31: [function (_glvis_, module, exports) {\n      \"use strict\"; // (a, y, c, l, h) = (array, y[, cmp, lo, hi])\n\n      function _ge(a, y, c, l, h) {\n        var i = h + 1;\n\n        while (l <= h) {\n          var m = l + h >>> 1,\n              x = a[m];\n          var p = c !== undefined ? c(x, y) : x - y;\n\n          if (p >= 0) {\n            i = m;\n            h = m - 1;\n          } else {\n            l = m + 1;\n          }\n        }\n\n        return i;\n      }\n\n      ;\n\n      function _gt(a, y, c, l, h) {\n        var i = h + 1;\n\n        while (l <= h) {\n          var m = l + h >>> 1,\n              x = a[m];\n          var p = c !== undefined ? c(x, y) : x - y;\n\n          if (p > 0) {\n            i = m;\n            h = m - 1;\n          } else {\n            l = m + 1;\n          }\n        }\n\n        return i;\n      }\n\n      ;\n\n      function _lt(a, y, c, l, h) {\n        var i = l - 1;\n\n        while (l <= h) {\n          var m = l + h >>> 1,\n              x = a[m];\n          var p = c !== undefined ? c(x, y) : x - y;\n\n          if (p < 0) {\n            i = m;\n            l = m + 1;\n          } else {\n            h = m - 1;\n          }\n        }\n\n        return i;\n      }\n\n      ;\n\n      function _le(a, y, c, l, h) {\n        var i = l - 1;\n\n        while (l <= h) {\n          var m = l + h >>> 1,\n              x = a[m];\n          var p = c !== undefined ? c(x, y) : x - y;\n\n          if (p <= 0) {\n            i = m;\n            l = m + 1;\n          } else {\n            h = m - 1;\n          }\n        }\n\n        return i;\n      }\n\n      ;\n\n      function _eq(a, y, c, l, h) {\n        while (l <= h) {\n          var m = l + h >>> 1,\n              x = a[m];\n          var p = c !== undefined ? c(x, y) : x - y;\n\n          if (p === 0) {\n            return m;\n          }\n\n          if (p <= 0) {\n            l = m + 1;\n          } else {\n            h = m - 1;\n          }\n        }\n\n        return -1;\n      }\n\n      ;\n\n      function norm(a, y, c, l, h, f) {\n        if (typeof c === 'function') {\n          return f(a, y, c, l === undefined ? 0 : l | 0, h === undefined ? a.length - 1 : h | 0);\n        }\n\n        return f(a, y, undefined, c === undefined ? 0 : c | 0, l === undefined ? a.length - 1 : l | 0);\n      }\n\n      module.exports = {\n        ge: function ge(a, y, c, l, h) {\n          return norm(a, y, c, l, h, _ge);\n        },\n        gt: function gt(a, y, c, l, h) {\n          return norm(a, y, c, l, h, _gt);\n        },\n        lt: function lt(a, y, c, l, h) {\n          return norm(a, y, c, l, h, _lt);\n        },\n        le: function le(a, y, c, l, h) {\n          return norm(a, y, c, l, h, _le);\n        },\n        eq: function eq(a, y, c, l, h) {\n          return norm(a, y, c, l, h, _eq);\n        }\n      };\n    }, {}],\n    32: [function (_glvis_, module, exports) {\n      /**\n       * Bit twiddling hacks for JavaScript.\n       *\n       * Author: Mikola Lysenko\n       *\n       * Ported from Stanford bit twiddling hack library:\n       *    http://graphics.stanford.edu/~seander/bithacks.html\n       */\n      \"use strict\";\n      \"use restrict\"; //Number of bits in an integer\n\n      var INT_BITS = 32; //Constants\n\n      exports.INT_BITS = INT_BITS;\n      exports.INT_MAX = 0x7fffffff;\n      exports.INT_MIN = -1 << INT_BITS - 1; //Returns -1, 0, +1 depending on sign of x\n\n      exports.sign = function (v) {\n        return (v > 0) - (v < 0);\n      }; //Computes absolute value of integer\n\n\n      exports.abs = function (v) {\n        var mask = v >> INT_BITS - 1;\n        return (v ^ mask) - mask;\n      }; //Computes minimum of integers x and y\n\n\n      exports.min = function (x, y) {\n        return y ^ (x ^ y) & -(x < y);\n      }; //Computes maximum of integers x and y\n\n\n      exports.max = function (x, y) {\n        return x ^ (x ^ y) & -(x < y);\n      }; //Checks if a number is a power of two\n\n\n      exports.isPow2 = function (v) {\n        return !(v & v - 1) && !!v;\n      }; //Computes log base 2 of v\n\n\n      exports.log2 = function (v) {\n        var r, shift;\n        r = (v > 0xFFFF) << 4;\n        v >>>= r;\n        shift = (v > 0xFF) << 3;\n        v >>>= shift;\n        r |= shift;\n        shift = (v > 0xF) << 2;\n        v >>>= shift;\n        r |= shift;\n        shift = (v > 0x3) << 1;\n        v >>>= shift;\n        r |= shift;\n        return r | v >> 1;\n      }; //Computes log base 10 of v\n\n\n      exports.log10 = function (v) {\n        return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;\n      }; //Counts number of bits\n\n\n      exports.popCount = function (v) {\n        v = v - (v >>> 1 & 0x55555555);\n        v = (v & 0x33333333) + (v >>> 2 & 0x33333333);\n        return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;\n      }; //Counts number of trailing zeros\n\n\n      function countTrailingZeros(v) {\n        var c = 32;\n        v &= -v;\n        if (v) c--;\n        if (v & 0x0000FFFF) c -= 16;\n        if (v & 0x00FF00FF) c -= 8;\n        if (v & 0x0F0F0F0F) c -= 4;\n        if (v & 0x33333333) c -= 2;\n        if (v & 0x55555555) c -= 1;\n        return c;\n      }\n\n      exports.countTrailingZeros = countTrailingZeros; //Rounds to next power of 2\n\n      exports.nextPow2 = function (v) {\n        v += v === 0;\n        --v;\n        v |= v >>> 1;\n        v |= v >>> 2;\n        v |= v >>> 4;\n        v |= v >>> 8;\n        v |= v >>> 16;\n        return v + 1;\n      }; //Rounds down to previous power of 2\n\n\n      exports.prevPow2 = function (v) {\n        v |= v >>> 1;\n        v |= v >>> 2;\n        v |= v >>> 4;\n        v |= v >>> 8;\n        v |= v >>> 16;\n        return v - (v >>> 1);\n      }; //Computes parity of word\n\n\n      exports.parity = function (v) {\n        v ^= v >>> 16;\n        v ^= v >>> 8;\n        v ^= v >>> 4;\n        v &= 0xf;\n        return 0x6996 >>> v & 1;\n      };\n\n      var REVERSE_TABLE = new Array(256);\n\n      (function (tab) {\n        for (var i = 0; i < 256; ++i) {\n          var v = i,\n              r = i,\n              s = 7;\n\n          for (v >>>= 1; v; v >>>= 1) {\n            r <<= 1;\n            r |= v & 1;\n            --s;\n          }\n\n          tab[i] = r << s & 0xff;\n        }\n      })(REVERSE_TABLE); //Reverse bits in a 32 bit word\n\n\n      exports.reverse = function (v) {\n        return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];\n      }; //Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\n\n\n      exports.interleave2 = function (x, y) {\n        x &= 0xFFFF;\n        x = (x | x << 8) & 0x00FF00FF;\n        x = (x | x << 4) & 0x0F0F0F0F;\n        x = (x | x << 2) & 0x33333333;\n        x = (x | x << 1) & 0x55555555;\n        y &= 0xFFFF;\n        y = (y | y << 8) & 0x00FF00FF;\n        y = (y | y << 4) & 0x0F0F0F0F;\n        y = (y | y << 2) & 0x33333333;\n        y = (y | y << 1) & 0x55555555;\n        return x | y << 1;\n      }; //Extracts the nth interleaved component\n\n\n      exports.deinterleave2 = function (v, n) {\n        v = v >>> n & 0x55555555;\n        v = (v | v >>> 1) & 0x33333333;\n        v = (v | v >>> 2) & 0x0F0F0F0F;\n        v = (v | v >>> 4) & 0x00FF00FF;\n        v = (v | v >>> 16) & 0x000FFFF;\n        return v << 16 >> 16;\n      }; //Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\n\n\n      exports.interleave3 = function (x, y, z) {\n        x &= 0x3FF;\n        x = (x | x << 16) & 4278190335;\n        x = (x | x << 8) & 251719695;\n        x = (x | x << 4) & 3272356035;\n        x = (x | x << 2) & 1227133513;\n        y &= 0x3FF;\n        y = (y | y << 16) & 4278190335;\n        y = (y | y << 8) & 251719695;\n        y = (y | y << 4) & 3272356035;\n        y = (y | y << 2) & 1227133513;\n        x |= y << 1;\n        z &= 0x3FF;\n        z = (z | z << 16) & 4278190335;\n        z = (z | z << 8) & 251719695;\n        z = (z | z << 4) & 3272356035;\n        z = (z | z << 2) & 1227133513;\n        return x | z << 2;\n      }; //Extracts nth interleaved component of a 3-tuple\n\n\n      exports.deinterleave3 = function (v, n) {\n        v = v >>> n & 1227133513;\n        v = (v | v >>> 2) & 3272356035;\n        v = (v | v >>> 4) & 251719695;\n        v = (v | v >>> 8) & 4278190335;\n        v = (v | v >>> 16) & 0x3FF;\n        return v << 22 >> 22;\n      }; //Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\n\n\n      exports.nextCombination = function (v) {\n        var t = v | v - 1;\n        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;\n      };\n    }, {}],\n    33: [function (_glvis_, module, exports) {\n      (function (module, exports) {\n        'use strict'; // Utils\n\n        function assert(val, msg) {\n          if (!val) throw new Error(msg || 'Assertion failed');\n        } // Could use `inherits` module, but don't want to move from single file\n        // architecture yet.\n\n\n        function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n\n          var TempCtor = function TempCtor() {};\n\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        } // BN\n\n\n        function BN(number, base, endian) {\n          if (BN.isBN(number)) {\n            return number;\n          }\n\n          this.negative = 0;\n          this.words = null;\n          this.length = 0; // Reduction context\n\n          this.red = null;\n\n          if (number !== null) {\n            if (base === 'le' || base === 'be') {\n              endian = base;\n              base = 10;\n            }\n\n            this._init(number || 0, base || 10, endian || 'be');\n          }\n        }\n\n        if (typeof module === 'object') {\n          module.exports = BN;\n        } else {\n          exports.BN = BN;\n        }\n\n        BN.BN = BN;\n        BN.wordSize = 26;\n        var Buffer;\n\n        try {\n          if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n            Buffer = window.Buffer;\n          } else {\n            Buffer = _glvis_('buffer').Buffer;\n          }\n        } catch (e) {}\n\n        BN.isBN = function isBN(num) {\n          if (num instanceof BN) {\n            return true;\n          }\n\n          return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n        };\n\n        BN.max = function max(left, right) {\n          if (left.cmp(right) > 0) return left;\n          return right;\n        };\n\n        BN.min = function min(left, right) {\n          if (left.cmp(right) < 0) return left;\n          return right;\n        };\n\n        BN.prototype._init = function init(number, base, endian) {\n          if (typeof number === 'number') {\n            return this._initNumber(number, base, endian);\n          }\n\n          if (typeof number === 'object') {\n            return this._initArray(number, base, endian);\n          }\n\n          if (base === 'hex') {\n            base = 16;\n          }\n\n          assert(base === (base | 0) && base >= 2 && base <= 36);\n          number = number.toString().replace(/\\s+/g, '');\n          var start = 0;\n\n          if (number[0] === '-') {\n            start++;\n            this.negative = 1;\n          }\n\n          if (start < number.length) {\n            if (base === 16) {\n              this._parseHex(number, start, endian);\n            } else {\n              this._parseBase(number, base, start);\n\n              if (endian === 'le') {\n                this._initArray(this.toArray(), base, endian);\n              }\n            }\n          }\n        };\n\n        BN.prototype._initNumber = function _initNumber(number, base, endian) {\n          if (number < 0) {\n            this.negative = 1;\n            number = -number;\n          }\n\n          if (number < 0x4000000) {\n            this.words = [number & 0x3ffffff];\n            this.length = 1;\n          } else if (number < 0x10000000000000) {\n            this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];\n            this.length = 2;\n          } else {\n            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\n            this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];\n            this.length = 3;\n          }\n\n          if (endian !== 'le') return; // Reverse the bytes\n\n          this._initArray(this.toArray(), base, endian);\n        };\n\n        BN.prototype._initArray = function _initArray(number, base, endian) {\n          // Perhaps a Uint8Array\n          assert(typeof number.length === 'number');\n\n          if (number.length <= 0) {\n            this.words = [0];\n            this.length = 1;\n            return this;\n          }\n\n          this.length = Math.ceil(number.length / 3);\n          this.words = new Array(this.length);\n\n          for (var i = 0; i < this.length; i++) {\n            this.words[i] = 0;\n          }\n\n          var j, w;\n          var off = 0;\n\n          if (endian === 'be') {\n            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;\n              this.words[j] |= w << off & 0x3ffffff;\n              this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n              off += 24;\n\n              if (off >= 26) {\n                off -= 26;\n                j++;\n              }\n            }\n          } else if (endian === 'le') {\n            for (i = 0, j = 0; i < number.length; i += 3) {\n              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;\n              this.words[j] |= w << off & 0x3ffffff;\n              this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n              off += 24;\n\n              if (off >= 26) {\n                off -= 26;\n                j++;\n              }\n            }\n          }\n\n          return this.strip();\n        };\n\n        function parseHex4Bits(string, index) {\n          var c = string.charCodeAt(index); // 'A' - 'F'\n\n          if (c >= 65 && c <= 70) {\n            return c - 55; // 'a' - 'f'\n          } else if (c >= 97 && c <= 102) {\n            return c - 87; // '0' - '9'\n          } else {\n            return c - 48 & 0xf;\n          }\n        }\n\n        function parseHexByte(string, lowerBound, index) {\n          var r = parseHex4Bits(string, index);\n\n          if (index - 1 >= lowerBound) {\n            r |= parseHex4Bits(string, index - 1) << 4;\n          }\n\n          return r;\n        }\n\n        BN.prototype._parseHex = function _parseHex(number, start, endian) {\n          // Create possibly bigger array to ensure that it fits the number\n          this.length = Math.ceil((number.length - start) / 6);\n          this.words = new Array(this.length);\n\n          for (var i = 0; i < this.length; i++) {\n            this.words[i] = 0;\n          } // 24-bits chunks\n\n\n          var off = 0;\n          var j = 0;\n          var w;\n\n          if (endian === 'be') {\n            for (i = number.length - 1; i >= start; i -= 2) {\n              w = parseHexByte(number, start, i) << off;\n              this.words[j] |= w & 0x3ffffff;\n\n              if (off >= 18) {\n                off -= 18;\n                j += 1;\n                this.words[j] |= w >>> 26;\n              } else {\n                off += 8;\n              }\n            }\n          } else {\n            var parseLength = number.length - start;\n\n            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n              w = parseHexByte(number, start, i) << off;\n              this.words[j] |= w & 0x3ffffff;\n\n              if (off >= 18) {\n                off -= 18;\n                j += 1;\n                this.words[j] |= w >>> 26;\n              } else {\n                off += 8;\n              }\n            }\n          }\n\n          this.strip();\n        };\n\n        function parseBase(str, start, end, mul) {\n          var r = 0;\n          var len = Math.min(str.length, end);\n\n          for (var i = start; i < len; i++) {\n            var c = str.charCodeAt(i) - 48;\n            r *= mul; // 'a'\n\n            if (c >= 49) {\n              r += c - 49 + 0xa; // 'A'\n            } else if (c >= 17) {\n              r += c - 17 + 0xa; // '0' - '9'\n            } else {\n              r += c;\n            }\n          }\n\n          return r;\n        }\n\n        BN.prototype._parseBase = function _parseBase(number, base, start) {\n          // Initialize as zero\n          this.words = [0];\n          this.length = 1; // Find length of limb in base\n\n          for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n            limbLen++;\n          }\n\n          limbLen--;\n          limbPow = limbPow / base | 0;\n          var total = number.length - start;\n          var mod = total % limbLen;\n          var end = Math.min(total, total - mod) + start;\n          var word = 0;\n\n          for (var i = start; i < end; i += limbLen) {\n            word = parseBase(number, i, i + limbLen, base);\n            this.imuln(limbPow);\n\n            if (this.words[0] + word < 0x4000000) {\n              this.words[0] += word;\n            } else {\n              this._iaddn(word);\n            }\n          }\n\n          if (mod !== 0) {\n            var pow = 1;\n            word = parseBase(number, i, number.length, base);\n\n            for (i = 0; i < mod; i++) {\n              pow *= base;\n            }\n\n            this.imuln(pow);\n\n            if (this.words[0] + word < 0x4000000) {\n              this.words[0] += word;\n            } else {\n              this._iaddn(word);\n            }\n          }\n\n          this.strip();\n        };\n\n        BN.prototype.copy = function copy(dest) {\n          dest.words = new Array(this.length);\n\n          for (var i = 0; i < this.length; i++) {\n            dest.words[i] = this.words[i];\n          }\n\n          dest.length = this.length;\n          dest.negative = this.negative;\n          dest.red = this.red;\n        };\n\n        BN.prototype.clone = function clone() {\n          var r = new BN(null);\n          this.copy(r);\n          return r;\n        };\n\n        BN.prototype._expand = function _expand(size) {\n          while (this.length < size) {\n            this.words[this.length++] = 0;\n          }\n\n          return this;\n        }; // Remove leading `0` from `this`\n\n\n        BN.prototype.strip = function strip() {\n          while (this.length > 1 && this.words[this.length - 1] === 0) {\n            this.length--;\n          }\n\n          return this._normSign();\n        };\n\n        BN.prototype._normSign = function _normSign() {\n          // -0 = 0\n          if (this.length === 1 && this.words[0] === 0) {\n            this.negative = 0;\n          }\n\n          return this;\n        };\n\n        BN.prototype.inspect = function inspect() {\n          return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n        };\n        /*\n         var zeros = [];\n        var groupSizes = [];\n        var groupBases = [];\n         var s = '';\n        var i = -1;\n        while (++i < BN.wordSize) {\n          zeros[i] = s;\n          s += '0';\n        }\n        groupSizes[0] = 0;\n        groupSizes[1] = 0;\n        groupBases[0] = 0;\n        groupBases[1] = 0;\n        var base = 2 - 1;\n        while (++base < 36 + 1) {\n          var groupSize = 0;\n          var groupBase = 1;\n          while (groupBase < (1 << BN.wordSize) / base) {\n            groupBase *= base;\n            groupSize += 1;\n          }\n          groupSizes[base] = groupSize;\n          groupBases[base] = groupBase;\n        }\n         */\n\n\n        var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];\n        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];\n        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];\n\n        BN.prototype.toString = function toString(base, padding) {\n          base = base || 10;\n          padding = padding | 0 || 1;\n          var out;\n\n          if (base === 16 || base === 'hex') {\n            out = '';\n            var off = 0;\n            var carry = 0;\n\n            for (var i = 0; i < this.length; i++) {\n              var w = this.words[i];\n              var word = ((w << off | carry) & 0xffffff).toString(16);\n              carry = w >>> 24 - off & 0xffffff;\n\n              if (carry !== 0 || i !== this.length - 1) {\n                out = zeros[6 - word.length] + word + out;\n              } else {\n                out = word + out;\n              }\n\n              off += 2;\n\n              if (off >= 26) {\n                off -= 26;\n                i--;\n              }\n            }\n\n            if (carry !== 0) {\n              out = carry.toString(16) + out;\n            }\n\n            while (out.length % padding !== 0) {\n              out = '0' + out;\n            }\n\n            if (this.negative !== 0) {\n              out = '-' + out;\n            }\n\n            return out;\n          }\n\n          if (base === (base | 0) && base >= 2 && base <= 36) {\n            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n            var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);\n\n            var groupBase = groupBases[base];\n            out = '';\n            var c = this.clone();\n            c.negative = 0;\n\n            while (!c.isZero()) {\n              var r = c.modn(groupBase).toString(base);\n              c = c.idivn(groupBase);\n\n              if (!c.isZero()) {\n                out = zeros[groupSize - r.length] + r + out;\n              } else {\n                out = r + out;\n              }\n            }\n\n            if (this.isZero()) {\n              out = '0' + out;\n            }\n\n            while (out.length % padding !== 0) {\n              out = '0' + out;\n            }\n\n            if (this.negative !== 0) {\n              out = '-' + out;\n            }\n\n            return out;\n          }\n\n          assert(false, 'Base should be between 2 and 36');\n        };\n\n        BN.prototype.toNumber = function toNumber() {\n          var ret = this.words[0];\n\n          if (this.length === 2) {\n            ret += this.words[1] * 0x4000000;\n          } else if (this.length === 3 && this.words[2] === 0x01) {\n            // NOTE: at this stage it is known that the top bit is set\n            ret += 0x10000000000000 + this.words[1] * 0x4000000;\n          } else if (this.length > 2) {\n            assert(false, 'Number can only safely store up to 53 bits');\n          }\n\n          return this.negative !== 0 ? -ret : ret;\n        };\n\n        BN.prototype.toJSON = function toJSON() {\n          return this.toString(16);\n        };\n\n        BN.prototype.toBuffer = function toBuffer(endian, length) {\n          assert(typeof Buffer !== 'undefined');\n          return this.toArrayLike(Buffer, endian, length);\n        };\n\n        BN.prototype.toArray = function toArray(endian, length) {\n          return this.toArrayLike(Array, endian, length);\n        };\n\n        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\n          var byteLength = this.byteLength();\n          var reqLength = length || Math.max(1, byteLength);\n          assert(byteLength <= reqLength, 'byte array longer than desired length');\n          assert(reqLength > 0, 'Requested array length <= 0');\n          this.strip();\n          var littleEndian = endian === 'le';\n          var res = new ArrayType(reqLength);\n          var b, i;\n          var q = this.clone();\n\n          if (!littleEndian) {\n            // Assume big-endian\n            for (i = 0; i < reqLength - byteLength; i++) {\n              res[i] = 0;\n            }\n\n            for (i = 0; !q.isZero(); i++) {\n              b = q.andln(0xff);\n              q.iushrn(8);\n              res[reqLength - i - 1] = b;\n            }\n          } else {\n            for (i = 0; !q.isZero(); i++) {\n              b = q.andln(0xff);\n              q.iushrn(8);\n              res[i] = b;\n            }\n\n            for (; i < reqLength; i++) {\n              res[i] = 0;\n            }\n          }\n\n          return res;\n        };\n\n        if (Math.clz32) {\n          BN.prototype._countBits = function _countBits(w) {\n            return 32 - Math.clz32(w);\n          };\n        } else {\n          BN.prototype._countBits = function _countBits(w) {\n            var t = w;\n            var r = 0;\n\n            if (t >= 0x1000) {\n              r += 13;\n              t >>>= 13;\n            }\n\n            if (t >= 0x40) {\n              r += 7;\n              t >>>= 7;\n            }\n\n            if (t >= 0x8) {\n              r += 4;\n              t >>>= 4;\n            }\n\n            if (t >= 0x02) {\n              r += 2;\n              t >>>= 2;\n            }\n\n            return r + t;\n          };\n        }\n\n        BN.prototype._zeroBits = function _zeroBits(w) {\n          // Short-cut\n          if (w === 0) return 26;\n          var t = w;\n          var r = 0;\n\n          if ((t & 0x1fff) === 0) {\n            r += 13;\n            t >>>= 13;\n          }\n\n          if ((t & 0x7f) === 0) {\n            r += 7;\n            t >>>= 7;\n          }\n\n          if ((t & 0xf) === 0) {\n            r += 4;\n            t >>>= 4;\n          }\n\n          if ((t & 0x3) === 0) {\n            r += 2;\n            t >>>= 2;\n          }\n\n          if ((t & 0x1) === 0) {\n            r++;\n          }\n\n          return r;\n        }; // Return number of used bits in a BN\n\n\n        BN.prototype.bitLength = function bitLength() {\n          var w = this.words[this.length - 1];\n\n          var hi = this._countBits(w);\n\n          return (this.length - 1) * 26 + hi;\n        };\n\n        function toBitArray(num) {\n          var w = new Array(num.bitLength());\n\n          for (var bit = 0; bit < w.length; bit++) {\n            var off = bit / 26 | 0;\n            var wbit = bit % 26;\n            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;\n          }\n\n          return w;\n        } // Number of trailing zero bits\n\n\n        BN.prototype.zeroBits = function zeroBits() {\n          if (this.isZero()) return 0;\n          var r = 0;\n\n          for (var i = 0; i < this.length; i++) {\n            var b = this._zeroBits(this.words[i]);\n\n            r += b;\n            if (b !== 26) break;\n          }\n\n          return r;\n        };\n\n        BN.prototype.byteLength = function byteLength() {\n          return Math.ceil(this.bitLength() / 8);\n        };\n\n        BN.prototype.toTwos = function toTwos(width) {\n          if (this.negative !== 0) {\n            return this.abs().inotn(width).iaddn(1);\n          }\n\n          return this.clone();\n        };\n\n        BN.prototype.fromTwos = function fromTwos(width) {\n          if (this.testn(width - 1)) {\n            return this.notn(width).iaddn(1).ineg();\n          }\n\n          return this.clone();\n        };\n\n        BN.prototype.isNeg = function isNeg() {\n          return this.negative !== 0;\n        }; // Return negative clone of `this`\n\n\n        BN.prototype.neg = function neg() {\n          return this.clone().ineg();\n        };\n\n        BN.prototype.ineg = function ineg() {\n          if (!this.isZero()) {\n            this.negative ^= 1;\n          }\n\n          return this;\n        }; // Or `num` with `this` in-place\n\n\n        BN.prototype.iuor = function iuor(num) {\n          while (this.length < num.length) {\n            this.words[this.length++] = 0;\n          }\n\n          for (var i = 0; i < num.length; i++) {\n            this.words[i] = this.words[i] | num.words[i];\n          }\n\n          return this.strip();\n        };\n\n        BN.prototype.ior = function ior(num) {\n          assert((this.negative | num.negative) === 0);\n          return this.iuor(num);\n        }; // Or `num` with `this`\n\n\n        BN.prototype.or = function or(num) {\n          if (this.length > num.length) return this.clone().ior(num);\n          return num.clone().ior(this);\n        };\n\n        BN.prototype.uor = function uor(num) {\n          if (this.length > num.length) return this.clone().iuor(num);\n          return num.clone().iuor(this);\n        }; // And `num` with `this` in-place\n\n\n        BN.prototype.iuand = function iuand(num) {\n          // b = min-length(num, this)\n          var b;\n\n          if (this.length > num.length) {\n            b = num;\n          } else {\n            b = this;\n          }\n\n          for (var i = 0; i < b.length; i++) {\n            this.words[i] = this.words[i] & num.words[i];\n          }\n\n          this.length = b.length;\n          return this.strip();\n        };\n\n        BN.prototype.iand = function iand(num) {\n          assert((this.negative | num.negative) === 0);\n          return this.iuand(num);\n        }; // And `num` with `this`\n\n\n        BN.prototype.and = function and(num) {\n          if (this.length > num.length) return this.clone().iand(num);\n          return num.clone().iand(this);\n        };\n\n        BN.prototype.uand = function uand(num) {\n          if (this.length > num.length) return this.clone().iuand(num);\n          return num.clone().iuand(this);\n        }; // Xor `num` with `this` in-place\n\n\n        BN.prototype.iuxor = function iuxor(num) {\n          // a.length > b.length\n          var a;\n          var b;\n\n          if (this.length > num.length) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n\n          for (var i = 0; i < b.length; i++) {\n            this.words[i] = a.words[i] ^ b.words[i];\n          }\n\n          if (this !== a) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n\n          this.length = a.length;\n          return this.strip();\n        };\n\n        BN.prototype.ixor = function ixor(num) {\n          assert((this.negative | num.negative) === 0);\n          return this.iuxor(num);\n        }; // Xor `num` with `this`\n\n\n        BN.prototype.xor = function xor(num) {\n          if (this.length > num.length) return this.clone().ixor(num);\n          return num.clone().ixor(this);\n        };\n\n        BN.prototype.uxor = function uxor(num) {\n          if (this.length > num.length) return this.clone().iuxor(num);\n          return num.clone().iuxor(this);\n        }; // Not ``this`` with ``width`` bitwidth\n\n\n        BN.prototype.inotn = function inotn(width) {\n          assert(typeof width === 'number' && width >= 0);\n          var bytesNeeded = Math.ceil(width / 26) | 0;\n          var bitsLeft = width % 26; // Extend the buffer with leading zeroes\n\n          this._expand(bytesNeeded);\n\n          if (bitsLeft > 0) {\n            bytesNeeded--;\n          } // Handle complete words\n\n\n          for (var i = 0; i < bytesNeeded; i++) {\n            this.words[i] = ~this.words[i] & 0x3ffffff;\n          } // Handle the residue\n\n\n          if (bitsLeft > 0) {\n            this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;\n          } // And remove leading zeroes\n\n\n          return this.strip();\n        };\n\n        BN.prototype.notn = function notn(width) {\n          return this.clone().inotn(width);\n        }; // Set `bit` of `this`\n\n\n        BN.prototype.setn = function setn(bit, val) {\n          assert(typeof bit === 'number' && bit >= 0);\n          var off = bit / 26 | 0;\n          var wbit = bit % 26;\n\n          this._expand(off + 1);\n\n          if (val) {\n            this.words[off] = this.words[off] | 1 << wbit;\n          } else {\n            this.words[off] = this.words[off] & ~(1 << wbit);\n          }\n\n          return this.strip();\n        }; // Add `num` to `this` in-place\n\n\n        BN.prototype.iadd = function iadd(num) {\n          var r; // negative + positive\n\n          if (this.negative !== 0 && num.negative === 0) {\n            this.negative = 0;\n            r = this.isub(num);\n            this.negative ^= 1;\n            return this._normSign(); // positive + negative\n          } else if (this.negative === 0 && num.negative !== 0) {\n            num.negative = 0;\n            r = this.isub(num);\n            num.negative = 1;\n            return r._normSign();\n          } // a.length > b.length\n\n\n          var a, b;\n\n          if (this.length > num.length) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n\n          var carry = 0;\n\n          for (var i = 0; i < b.length; i++) {\n            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n            this.words[i] = r & 0x3ffffff;\n            carry = r >>> 26;\n          }\n\n          for (; carry !== 0 && i < a.length; i++) {\n            r = (a.words[i] | 0) + carry;\n            this.words[i] = r & 0x3ffffff;\n            carry = r >>> 26;\n          }\n\n          this.length = a.length;\n\n          if (carry !== 0) {\n            this.words[this.length] = carry;\n            this.length++; // Copy the rest of the words\n          } else if (a !== this) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n\n          return this;\n        }; // Add `num` to `this`\n\n\n        BN.prototype.add = function add(num) {\n          var res;\n\n          if (num.negative !== 0 && this.negative === 0) {\n            num.negative = 0;\n            res = this.sub(num);\n            num.negative ^= 1;\n            return res;\n          } else if (num.negative === 0 && this.negative !== 0) {\n            this.negative = 0;\n            res = num.sub(this);\n            this.negative = 1;\n            return res;\n          }\n\n          if (this.length > num.length) return this.clone().iadd(num);\n          return num.clone().iadd(this);\n        }; // Subtract `num` from `this` in-place\n\n\n        BN.prototype.isub = function isub(num) {\n          // this - (-num) = this + num\n          if (num.negative !== 0) {\n            num.negative = 0;\n            var r = this.iadd(num);\n            num.negative = 1;\n            return r._normSign(); // -this - num = -(this + num)\n          } else if (this.negative !== 0) {\n            this.negative = 0;\n            this.iadd(num);\n            this.negative = 1;\n            return this._normSign();\n          } // At this point both numbers are positive\n\n\n          var cmp = this.cmp(num); // Optimization - zeroify\n\n          if (cmp === 0) {\n            this.negative = 0;\n            this.length = 1;\n            this.words[0] = 0;\n            return this;\n          } // a > b\n\n\n          var a, b;\n\n          if (cmp > 0) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n\n          var carry = 0;\n\n          for (var i = 0; i < b.length; i++) {\n            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 0x3ffffff;\n          }\n\n          for (; carry !== 0 && i < a.length; i++) {\n            r = (a.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 0x3ffffff;\n          } // Copy rest of the words\n\n\n          if (carry === 0 && i < a.length && a !== this) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n\n          this.length = Math.max(this.length, i);\n\n          if (a !== this) {\n            this.negative = 1;\n          }\n\n          return this.strip();\n        }; // Subtract `num` from `this`\n\n\n        BN.prototype.sub = function sub(num) {\n          return this.clone().isub(num);\n        };\n\n        function smallMulTo(self, num, out) {\n          out.negative = num.negative ^ self.negative;\n          var len = self.length + num.length | 0;\n          out.length = len;\n          len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)\n\n          var a = self.words[0] | 0;\n          var b = num.words[0] | 0;\n          var r = a * b;\n          var lo = r & 0x3ffffff;\n          var carry = r / 0x4000000 | 0;\n          out.words[0] = lo;\n\n          for (var k = 1; k < len; k++) {\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n            // note that ncarry could be >= 0x3ffffff\n            var ncarry = carry >>> 26;\n            var rword = carry & 0x3ffffff;\n            var maxJ = Math.min(k, num.length - 1);\n\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n              var i = k - j | 0;\n              a = self.words[i] | 0;\n              b = num.words[j] | 0;\n              r = a * b + rword;\n              ncarry += r / 0x4000000 | 0;\n              rword = r & 0x3ffffff;\n            }\n\n            out.words[k] = rword | 0;\n            carry = ncarry | 0;\n          }\n\n          if (carry !== 0) {\n            out.words[k] = carry | 0;\n          } else {\n            out.length--;\n          }\n\n          return out.strip();\n        } // TODO(indutny): it may be reasonable to omit it for users who don't need\n        // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n        // multiplication (like elliptic secp256k1).\n\n\n        var comb10MulTo = function comb10MulTo(self, num, out) {\n          var a = self.words;\n          var b = num.words;\n          var o = out.words;\n          var c = 0;\n          var lo;\n          var mid;\n          var hi;\n          var a0 = a[0] | 0;\n          var al0 = a0 & 0x1fff;\n          var ah0 = a0 >>> 13;\n          var a1 = a[1] | 0;\n          var al1 = a1 & 0x1fff;\n          var ah1 = a1 >>> 13;\n          var a2 = a[2] | 0;\n          var al2 = a2 & 0x1fff;\n          var ah2 = a2 >>> 13;\n          var a3 = a[3] | 0;\n          var al3 = a3 & 0x1fff;\n          var ah3 = a3 >>> 13;\n          var a4 = a[4] | 0;\n          var al4 = a4 & 0x1fff;\n          var ah4 = a4 >>> 13;\n          var a5 = a[5] | 0;\n          var al5 = a5 & 0x1fff;\n          var ah5 = a5 >>> 13;\n          var a6 = a[6] | 0;\n          var al6 = a6 & 0x1fff;\n          var ah6 = a6 >>> 13;\n          var a7 = a[7] | 0;\n          var al7 = a7 & 0x1fff;\n          var ah7 = a7 >>> 13;\n          var a8 = a[8] | 0;\n          var al8 = a8 & 0x1fff;\n          var ah8 = a8 >>> 13;\n          var a9 = a[9] | 0;\n          var al9 = a9 & 0x1fff;\n          var ah9 = a9 >>> 13;\n          var b0 = b[0] | 0;\n          var bl0 = b0 & 0x1fff;\n          var bh0 = b0 >>> 13;\n          var b1 = b[1] | 0;\n          var bl1 = b1 & 0x1fff;\n          var bh1 = b1 >>> 13;\n          var b2 = b[2] | 0;\n          var bl2 = b2 & 0x1fff;\n          var bh2 = b2 >>> 13;\n          var b3 = b[3] | 0;\n          var bl3 = b3 & 0x1fff;\n          var bh3 = b3 >>> 13;\n          var b4 = b[4] | 0;\n          var bl4 = b4 & 0x1fff;\n          var bh4 = b4 >>> 13;\n          var b5 = b[5] | 0;\n          var bl5 = b5 & 0x1fff;\n          var bh5 = b5 >>> 13;\n          var b6 = b[6] | 0;\n          var bl6 = b6 & 0x1fff;\n          var bh6 = b6 >>> 13;\n          var b7 = b[7] | 0;\n          var bl7 = b7 & 0x1fff;\n          var bh7 = b7 >>> 13;\n          var b8 = b[8] | 0;\n          var bl8 = b8 & 0x1fff;\n          var bh8 = b8 >>> 13;\n          var b9 = b[9] | 0;\n          var bl9 = b9 & 0x1fff;\n          var bh9 = b9 >>> 13;\n          out.negative = self.negative ^ num.negative;\n          out.length = 19;\n          /* k = 0 */\n\n          lo = Math.imul(al0, bl0);\n          mid = Math.imul(al0, bh0);\n          mid = mid + Math.imul(ah0, bl0) | 0;\n          hi = Math.imul(ah0, bh0);\n          var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n          w0 &= 0x3ffffff;\n          /* k = 1 */\n\n          lo = Math.imul(al1, bl0);\n          mid = Math.imul(al1, bh0);\n          mid = mid + Math.imul(ah1, bl0) | 0;\n          hi = Math.imul(ah1, bh0);\n          lo = lo + Math.imul(al0, bl1) | 0;\n          mid = mid + Math.imul(al0, bh1) | 0;\n          mid = mid + Math.imul(ah0, bl1) | 0;\n          hi = hi + Math.imul(ah0, bh1) | 0;\n          var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n          w1 &= 0x3ffffff;\n          /* k = 2 */\n\n          lo = Math.imul(al2, bl0);\n          mid = Math.imul(al2, bh0);\n          mid = mid + Math.imul(ah2, bl0) | 0;\n          hi = Math.imul(ah2, bh0);\n          lo = lo + Math.imul(al1, bl1) | 0;\n          mid = mid + Math.imul(al1, bh1) | 0;\n          mid = mid + Math.imul(ah1, bl1) | 0;\n          hi = hi + Math.imul(ah1, bh1) | 0;\n          lo = lo + Math.imul(al0, bl2) | 0;\n          mid = mid + Math.imul(al0, bh2) | 0;\n          mid = mid + Math.imul(ah0, bl2) | 0;\n          hi = hi + Math.imul(ah0, bh2) | 0;\n          var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n          w2 &= 0x3ffffff;\n          /* k = 3 */\n\n          lo = Math.imul(al3, bl0);\n          mid = Math.imul(al3, bh0);\n          mid = mid + Math.imul(ah3, bl0) | 0;\n          hi = Math.imul(ah3, bh0);\n          lo = lo + Math.imul(al2, bl1) | 0;\n          mid = mid + Math.imul(al2, bh1) | 0;\n          mid = mid + Math.imul(ah2, bl1) | 0;\n          hi = hi + Math.imul(ah2, bh1) | 0;\n          lo = lo + Math.imul(al1, bl2) | 0;\n          mid = mid + Math.imul(al1, bh2) | 0;\n          mid = mid + Math.imul(ah1, bl2) | 0;\n          hi = hi + Math.imul(ah1, bh2) | 0;\n          lo = lo + Math.imul(al0, bl3) | 0;\n          mid = mid + Math.imul(al0, bh3) | 0;\n          mid = mid + Math.imul(ah0, bl3) | 0;\n          hi = hi + Math.imul(ah0, bh3) | 0;\n          var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n          w3 &= 0x3ffffff;\n          /* k = 4 */\n\n          lo = Math.imul(al4, bl0);\n          mid = Math.imul(al4, bh0);\n          mid = mid + Math.imul(ah4, bl0) | 0;\n          hi = Math.imul(ah4, bh0);\n          lo = lo + Math.imul(al3, bl1) | 0;\n          mid = mid + Math.imul(al3, bh1) | 0;\n          mid = mid + Math.imul(ah3, bl1) | 0;\n          hi = hi + Math.imul(ah3, bh1) | 0;\n          lo = lo + Math.imul(al2, bl2) | 0;\n          mid = mid + Math.imul(al2, bh2) | 0;\n          mid = mid + Math.imul(ah2, bl2) | 0;\n          hi = hi + Math.imul(ah2, bh2) | 0;\n          lo = lo + Math.imul(al1, bl3) | 0;\n          mid = mid + Math.imul(al1, bh3) | 0;\n          mid = mid + Math.imul(ah1, bl3) | 0;\n          hi = hi + Math.imul(ah1, bh3) | 0;\n          lo = lo + Math.imul(al0, bl4) | 0;\n          mid = mid + Math.imul(al0, bh4) | 0;\n          mid = mid + Math.imul(ah0, bl4) | 0;\n          hi = hi + Math.imul(ah0, bh4) | 0;\n          var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n          w4 &= 0x3ffffff;\n          /* k = 5 */\n\n          lo = Math.imul(al5, bl0);\n          mid = Math.imul(al5, bh0);\n          mid = mid + Math.imul(ah5, bl0) | 0;\n          hi = Math.imul(ah5, bh0);\n          lo = lo + Math.imul(al4, bl1) | 0;\n          mid = mid + Math.imul(al4, bh1) | 0;\n          mid = mid + Math.imul(ah4, bl1) | 0;\n          hi = hi + Math.imul(ah4, bh1) | 0;\n          lo = lo + Math.imul(al3, bl2) | 0;\n          mid = mid + Math.imul(al3, bh2) | 0;\n          mid = mid + Math.imul(ah3, bl2) | 0;\n          hi = hi + Math.imul(ah3, bh2) | 0;\n          lo = lo + Math.imul(al2, bl3) | 0;\n          mid = mid + Math.imul(al2, bh3) | 0;\n          mid = mid + Math.imul(ah2, bl3) | 0;\n          hi = hi + Math.imul(ah2, bh3) | 0;\n          lo = lo + Math.imul(al1, bl4) | 0;\n          mid = mid + Math.imul(al1, bh4) | 0;\n          mid = mid + Math.imul(ah1, bl4) | 0;\n          hi = hi + Math.imul(ah1, bh4) | 0;\n          lo = lo + Math.imul(al0, bl5) | 0;\n          mid = mid + Math.imul(al0, bh5) | 0;\n          mid = mid + Math.imul(ah0, bl5) | 0;\n          hi = hi + Math.imul(ah0, bh5) | 0;\n          var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n          w5 &= 0x3ffffff;\n          /* k = 6 */\n\n          lo = Math.imul(al6, bl0);\n          mid = Math.imul(al6, bh0);\n          mid = mid + Math.imul(ah6, bl0) | 0;\n          hi = Math.imul(ah6, bh0);\n          lo = lo + Math.imul(al5, bl1) | 0;\n          mid = mid + Math.imul(al5, bh1) | 0;\n          mid = mid + Math.imul(ah5, bl1) | 0;\n          hi = hi + Math.imul(ah5, bh1) | 0;\n          lo = lo + Math.imul(al4, bl2) | 0;\n          mid = mid + Math.imul(al4, bh2) | 0;\n          mid = mid + Math.imul(ah4, bl2) | 0;\n          hi = hi + Math.imul(ah4, bh2) | 0;\n          lo = lo + Math.imul(al3, bl3) | 0;\n          mid = mid + Math.imul(al3, bh3) | 0;\n          mid = mid + Math.imul(ah3, bl3) | 0;\n          hi = hi + Math.imul(ah3, bh3) | 0;\n          lo = lo + Math.imul(al2, bl4) | 0;\n          mid = mid + Math.imul(al2, bh4) | 0;\n          mid = mid + Math.imul(ah2, bl4) | 0;\n          hi = hi + Math.imul(ah2, bh4) | 0;\n          lo = lo + Math.imul(al1, bl5) | 0;\n          mid = mid + Math.imul(al1, bh5) | 0;\n          mid = mid + Math.imul(ah1, bl5) | 0;\n          hi = hi + Math.imul(ah1, bh5) | 0;\n          lo = lo + Math.imul(al0, bl6) | 0;\n          mid = mid + Math.imul(al0, bh6) | 0;\n          mid = mid + Math.imul(ah0, bl6) | 0;\n          hi = hi + Math.imul(ah0, bh6) | 0;\n          var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n          w6 &= 0x3ffffff;\n          /* k = 7 */\n\n          lo = Math.imul(al7, bl0);\n          mid = Math.imul(al7, bh0);\n          mid = mid + Math.imul(ah7, bl0) | 0;\n          hi = Math.imul(ah7, bh0);\n          lo = lo + Math.imul(al6, bl1) | 0;\n          mid = mid + Math.imul(al6, bh1) | 0;\n          mid = mid + Math.imul(ah6, bl1) | 0;\n          hi = hi + Math.imul(ah6, bh1) | 0;\n          lo = lo + Math.imul(al5, bl2) | 0;\n          mid = mid + Math.imul(al5, bh2) | 0;\n          mid = mid + Math.imul(ah5, bl2) | 0;\n          hi = hi + Math.imul(ah5, bh2) | 0;\n          lo = lo + Math.imul(al4, bl3) | 0;\n          mid = mid + Math.imul(al4, bh3) | 0;\n          mid = mid + Math.imul(ah4, bl3) | 0;\n          hi = hi + Math.imul(ah4, bh3) | 0;\n          lo = lo + Math.imul(al3, bl4) | 0;\n          mid = mid + Math.imul(al3, bh4) | 0;\n          mid = mid + Math.imul(ah3, bl4) | 0;\n          hi = hi + Math.imul(ah3, bh4) | 0;\n          lo = lo + Math.imul(al2, bl5) | 0;\n          mid = mid + Math.imul(al2, bh5) | 0;\n          mid = mid + Math.imul(ah2, bl5) | 0;\n          hi = hi + Math.imul(ah2, bh5) | 0;\n          lo = lo + Math.imul(al1, bl6) | 0;\n          mid = mid + Math.imul(al1, bh6) | 0;\n          mid = mid + Math.imul(ah1, bl6) | 0;\n          hi = hi + Math.imul(ah1, bh6) | 0;\n          lo = lo + Math.imul(al0, bl7) | 0;\n          mid = mid + Math.imul(al0, bh7) | 0;\n          mid = mid + Math.imul(ah0, bl7) | 0;\n          hi = hi + Math.imul(ah0, bh7) | 0;\n          var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n          w7 &= 0x3ffffff;\n          /* k = 8 */\n\n          lo = Math.imul(al8, bl0);\n          mid = Math.imul(al8, bh0);\n          mid = mid + Math.imul(ah8, bl0) | 0;\n          hi = Math.imul(ah8, bh0);\n          lo = lo + Math.imul(al7, bl1) | 0;\n          mid = mid + Math.imul(al7, bh1) | 0;\n          mid = mid + Math.imul(ah7, bl1) | 0;\n          hi = hi + Math.imul(ah7, bh1) | 0;\n          lo = lo + Math.imul(al6, bl2) | 0;\n          mid = mid + Math.imul(al6, bh2) | 0;\n          mid = mid + Math.imul(ah6, bl2) | 0;\n          hi = hi + Math.imul(ah6, bh2) | 0;\n          lo = lo + Math.imul(al5, bl3) | 0;\n          mid = mid + Math.imul(al5, bh3) | 0;\n          mid = mid + Math.imul(ah5, bl3) | 0;\n          hi = hi + Math.imul(ah5, bh3) | 0;\n          lo = lo + Math.imul(al4, bl4) | 0;\n          mid = mid + Math.imul(al4, bh4) | 0;\n          mid = mid + Math.imul(ah4, bl4) | 0;\n          hi = hi + Math.imul(ah4, bh4) | 0;\n          lo = lo + Math.imul(al3, bl5) | 0;\n          mid = mid + Math.imul(al3, bh5) | 0;\n          mid = mid + Math.imul(ah3, bl5) | 0;\n          hi = hi + Math.imul(ah3, bh5) | 0;\n          lo = lo + Math.imul(al2, bl6) | 0;\n          mid = mid + Math.imul(al2, bh6) | 0;\n          mid = mid + Math.imul(ah2, bl6) | 0;\n          hi = hi + Math.imul(ah2, bh6) | 0;\n          lo = lo + Math.imul(al1, bl7) | 0;\n          mid = mid + Math.imul(al1, bh7) | 0;\n          mid = mid + Math.imul(ah1, bl7) | 0;\n          hi = hi + Math.imul(ah1, bh7) | 0;\n          lo = lo + Math.imul(al0, bl8) | 0;\n          mid = mid + Math.imul(al0, bh8) | 0;\n          mid = mid + Math.imul(ah0, bl8) | 0;\n          hi = hi + Math.imul(ah0, bh8) | 0;\n          var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n          w8 &= 0x3ffffff;\n          /* k = 9 */\n\n          lo = Math.imul(al9, bl0);\n          mid = Math.imul(al9, bh0);\n          mid = mid + Math.imul(ah9, bl0) | 0;\n          hi = Math.imul(ah9, bh0);\n          lo = lo + Math.imul(al8, bl1) | 0;\n          mid = mid + Math.imul(al8, bh1) | 0;\n          mid = mid + Math.imul(ah8, bl1) | 0;\n          hi = hi + Math.imul(ah8, bh1) | 0;\n          lo = lo + Math.imul(al7, bl2) | 0;\n          mid = mid + Math.imul(al7, bh2) | 0;\n          mid = mid + Math.imul(ah7, bl2) | 0;\n          hi = hi + Math.imul(ah7, bh2) | 0;\n          lo = lo + Math.imul(al6, bl3) | 0;\n          mid = mid + Math.imul(al6, bh3) | 0;\n          mid = mid + Math.imul(ah6, bl3) | 0;\n          hi = hi + Math.imul(ah6, bh3) | 0;\n          lo = lo + Math.imul(al5, bl4) | 0;\n          mid = mid + Math.imul(al5, bh4) | 0;\n          mid = mid + Math.imul(ah5, bl4) | 0;\n          hi = hi + Math.imul(ah5, bh4) | 0;\n          lo = lo + Math.imul(al4, bl5) | 0;\n          mid = mid + Math.imul(al4, bh5) | 0;\n          mid = mid + Math.imul(ah4, bl5) | 0;\n          hi = hi + Math.imul(ah4, bh5) | 0;\n          lo = lo + Math.imul(al3, bl6) | 0;\n          mid = mid + Math.imul(al3, bh6) | 0;\n          mid = mid + Math.imul(ah3, bl6) | 0;\n          hi = hi + Math.imul(ah3, bh6) | 0;\n          lo = lo + Math.imul(al2, bl7) | 0;\n          mid = mid + Math.imul(al2, bh7) | 0;\n          mid = mid + Math.imul(ah2, bl7) | 0;\n          hi = hi + Math.imul(ah2, bh7) | 0;\n          lo = lo + Math.imul(al1, bl8) | 0;\n          mid = mid + Math.imul(al1, bh8) | 0;\n          mid = mid + Math.imul(ah1, bl8) | 0;\n          hi = hi + Math.imul(ah1, bh8) | 0;\n          lo = lo + Math.imul(al0, bl9) | 0;\n          mid = mid + Math.imul(al0, bh9) | 0;\n          mid = mid + Math.imul(ah0, bl9) | 0;\n          hi = hi + Math.imul(ah0, bh9) | 0;\n          var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n          w9 &= 0x3ffffff;\n          /* k = 10 */\n\n          lo = Math.imul(al9, bl1);\n          mid = Math.imul(al9, bh1);\n          mid = mid + Math.imul(ah9, bl1) | 0;\n          hi = Math.imul(ah9, bh1);\n          lo = lo + Math.imul(al8, bl2) | 0;\n          mid = mid + Math.imul(al8, bh2) | 0;\n          mid = mid + Math.imul(ah8, bl2) | 0;\n          hi = hi + Math.imul(ah8, bh2) | 0;\n          lo = lo + Math.imul(al7, bl3) | 0;\n          mid = mid + Math.imul(al7, bh3) | 0;\n          mid = mid + Math.imul(ah7, bl3) | 0;\n          hi = hi + Math.imul(ah7, bh3) | 0;\n          lo = lo + Math.imul(al6, bl4) | 0;\n          mid = mid + Math.imul(al6, bh4) | 0;\n          mid = mid + Math.imul(ah6, bl4) | 0;\n          hi = hi + Math.imul(ah6, bh4) | 0;\n          lo = lo + Math.imul(al5, bl5) | 0;\n          mid = mid + Math.imul(al5, bh5) | 0;\n          mid = mid + Math.imul(ah5, bl5) | 0;\n          hi = hi + Math.imul(ah5, bh5) | 0;\n          lo = lo + Math.imul(al4, bl6) | 0;\n          mid = mid + Math.imul(al4, bh6) | 0;\n          mid = mid + Math.imul(ah4, bl6) | 0;\n          hi = hi + Math.imul(ah4, bh6) | 0;\n          lo = lo + Math.imul(al3, bl7) | 0;\n          mid = mid + Math.imul(al3, bh7) | 0;\n          mid = mid + Math.imul(ah3, bl7) | 0;\n          hi = hi + Math.imul(ah3, bh7) | 0;\n          lo = lo + Math.imul(al2, bl8) | 0;\n          mid = mid + Math.imul(al2, bh8) | 0;\n          mid = mid + Math.imul(ah2, bl8) | 0;\n          hi = hi + Math.imul(ah2, bh8) | 0;\n          lo = lo + Math.imul(al1, bl9) | 0;\n          mid = mid + Math.imul(al1, bh9) | 0;\n          mid = mid + Math.imul(ah1, bl9) | 0;\n          hi = hi + Math.imul(ah1, bh9) | 0;\n          var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n          w10 &= 0x3ffffff;\n          /* k = 11 */\n\n          lo = Math.imul(al9, bl2);\n          mid = Math.imul(al9, bh2);\n          mid = mid + Math.imul(ah9, bl2) | 0;\n          hi = Math.imul(ah9, bh2);\n          lo = lo + Math.imul(al8, bl3) | 0;\n          mid = mid + Math.imul(al8, bh3) | 0;\n          mid = mid + Math.imul(ah8, bl3) | 0;\n          hi = hi + Math.imul(ah8, bh3) | 0;\n          lo = lo + Math.imul(al7, bl4) | 0;\n          mid = mid + Math.imul(al7, bh4) | 0;\n          mid = mid + Math.imul(ah7, bl4) | 0;\n          hi = hi + Math.imul(ah7, bh4) | 0;\n          lo = lo + Math.imul(al6, bl5) | 0;\n          mid = mid + Math.imul(al6, bh5) | 0;\n          mid = mid + Math.imul(ah6, bl5) | 0;\n          hi = hi + Math.imul(ah6, bh5) | 0;\n          lo = lo + Math.imul(al5, bl6) | 0;\n          mid = mid + Math.imul(al5, bh6) | 0;\n          mid = mid + Math.imul(ah5, bl6) | 0;\n          hi = hi + Math.imul(ah5, bh6) | 0;\n          lo = lo + Math.imul(al4, bl7) | 0;\n          mid = mid + Math.imul(al4, bh7) | 0;\n          mid = mid + Math.imul(ah4, bl7) | 0;\n          hi = hi + Math.imul(ah4, bh7) | 0;\n          lo = lo + Math.imul(al3, bl8) | 0;\n          mid = mid + Math.imul(al3, bh8) | 0;\n          mid = mid + Math.imul(ah3, bl8) | 0;\n          hi = hi + Math.imul(ah3, bh8) | 0;\n          lo = lo + Math.imul(al2, bl9) | 0;\n          mid = mid + Math.imul(al2, bh9) | 0;\n          mid = mid + Math.imul(ah2, bl9) | 0;\n          hi = hi + Math.imul(ah2, bh9) | 0;\n          var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n          w11 &= 0x3ffffff;\n          /* k = 12 */\n\n          lo = Math.imul(al9, bl3);\n          mid = Math.imul(al9, bh3);\n          mid = mid + Math.imul(ah9, bl3) | 0;\n          hi = Math.imul(ah9, bh3);\n          lo = lo + Math.imul(al8, bl4) | 0;\n          mid = mid + Math.imul(al8, bh4) | 0;\n          mid = mid + Math.imul(ah8, bl4) | 0;\n          hi = hi + Math.imul(ah8, bh4) | 0;\n          lo = lo + Math.imul(al7, bl5) | 0;\n          mid = mid + Math.imul(al7, bh5) | 0;\n          mid = mid + Math.imul(ah7, bl5) | 0;\n          hi = hi + Math.imul(ah7, bh5) | 0;\n          lo = lo + Math.imul(al6, bl6) | 0;\n          mid = mid + Math.imul(al6, bh6) | 0;\n          mid = mid + Math.imul(ah6, bl6) | 0;\n          hi = hi + Math.imul(ah6, bh6) | 0;\n          lo = lo + Math.imul(al5, bl7) | 0;\n          mid = mid + Math.imul(al5, bh7) | 0;\n          mid = mid + Math.imul(ah5, bl7) | 0;\n          hi = hi + Math.imul(ah5, bh7) | 0;\n          lo = lo + Math.imul(al4, bl8) | 0;\n          mid = mid + Math.imul(al4, bh8) | 0;\n          mid = mid + Math.imul(ah4, bl8) | 0;\n          hi = hi + Math.imul(ah4, bh8) | 0;\n          lo = lo + Math.imul(al3, bl9) | 0;\n          mid = mid + Math.imul(al3, bh9) | 0;\n          mid = mid + Math.imul(ah3, bl9) | 0;\n          hi = hi + Math.imul(ah3, bh9) | 0;\n          var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n          w12 &= 0x3ffffff;\n          /* k = 13 */\n\n          lo = Math.imul(al9, bl4);\n          mid = Math.imul(al9, bh4);\n          mid = mid + Math.imul(ah9, bl4) | 0;\n          hi = Math.imul(ah9, bh4);\n          lo = lo + Math.imul(al8, bl5) | 0;\n          mid = mid + Math.imul(al8, bh5) | 0;\n          mid = mid + Math.imul(ah8, bl5) | 0;\n          hi = hi + Math.imul(ah8, bh5) | 0;\n          lo = lo + Math.imul(al7, bl6) | 0;\n          mid = mid + Math.imul(al7, bh6) | 0;\n          mid = mid + Math.imul(ah7, bl6) | 0;\n          hi = hi + Math.imul(ah7, bh6) | 0;\n          lo = lo + Math.imul(al6, bl7) | 0;\n          mid = mid + Math.imul(al6, bh7) | 0;\n          mid = mid + Math.imul(ah6, bl7) | 0;\n          hi = hi + Math.imul(ah6, bh7) | 0;\n          lo = lo + Math.imul(al5, bl8) | 0;\n          mid = mid + Math.imul(al5, bh8) | 0;\n          mid = mid + Math.imul(ah5, bl8) | 0;\n          hi = hi + Math.imul(ah5, bh8) | 0;\n          lo = lo + Math.imul(al4, bl9) | 0;\n          mid = mid + Math.imul(al4, bh9) | 0;\n          mid = mid + Math.imul(ah4, bl9) | 0;\n          hi = hi + Math.imul(ah4, bh9) | 0;\n          var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n          w13 &= 0x3ffffff;\n          /* k = 14 */\n\n          lo = Math.imul(al9, bl5);\n          mid = Math.imul(al9, bh5);\n          mid = mid + Math.imul(ah9, bl5) | 0;\n          hi = Math.imul(ah9, bh5);\n          lo = lo + Math.imul(al8, bl6) | 0;\n          mid = mid + Math.imul(al8, bh6) | 0;\n          mid = mid + Math.imul(ah8, bl6) | 0;\n          hi = hi + Math.imul(ah8, bh6) | 0;\n          lo = lo + Math.imul(al7, bl7) | 0;\n          mid = mid + Math.imul(al7, bh7) | 0;\n          mid = mid + Math.imul(ah7, bl7) | 0;\n          hi = hi + Math.imul(ah7, bh7) | 0;\n          lo = lo + Math.imul(al6, bl8) | 0;\n          mid = mid + Math.imul(al6, bh8) | 0;\n          mid = mid + Math.imul(ah6, bl8) | 0;\n          hi = hi + Math.imul(ah6, bh8) | 0;\n          lo = lo + Math.imul(al5, bl9) | 0;\n          mid = mid + Math.imul(al5, bh9) | 0;\n          mid = mid + Math.imul(ah5, bl9) | 0;\n          hi = hi + Math.imul(ah5, bh9) | 0;\n          var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n          w14 &= 0x3ffffff;\n          /* k = 15 */\n\n          lo = Math.imul(al9, bl6);\n          mid = Math.imul(al9, bh6);\n          mid = mid + Math.imul(ah9, bl6) | 0;\n          hi = Math.imul(ah9, bh6);\n          lo = lo + Math.imul(al8, bl7) | 0;\n          mid = mid + Math.imul(al8, bh7) | 0;\n          mid = mid + Math.imul(ah8, bl7) | 0;\n          hi = hi + Math.imul(ah8, bh7) | 0;\n          lo = lo + Math.imul(al7, bl8) | 0;\n          mid = mid + Math.imul(al7, bh8) | 0;\n          mid = mid + Math.imul(ah7, bl8) | 0;\n          hi = hi + Math.imul(ah7, bh8) | 0;\n          lo = lo + Math.imul(al6, bl9) | 0;\n          mid = mid + Math.imul(al6, bh9) | 0;\n          mid = mid + Math.imul(ah6, bl9) | 0;\n          hi = hi + Math.imul(ah6, bh9) | 0;\n          var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n          w15 &= 0x3ffffff;\n          /* k = 16 */\n\n          lo = Math.imul(al9, bl7);\n          mid = Math.imul(al9, bh7);\n          mid = mid + Math.imul(ah9, bl7) | 0;\n          hi = Math.imul(ah9, bh7);\n          lo = lo + Math.imul(al8, bl8) | 0;\n          mid = mid + Math.imul(al8, bh8) | 0;\n          mid = mid + Math.imul(ah8, bl8) | 0;\n          hi = hi + Math.imul(ah8, bh8) | 0;\n          lo = lo + Math.imul(al7, bl9) | 0;\n          mid = mid + Math.imul(al7, bh9) | 0;\n          mid = mid + Math.imul(ah7, bl9) | 0;\n          hi = hi + Math.imul(ah7, bh9) | 0;\n          var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n          w16 &= 0x3ffffff;\n          /* k = 17 */\n\n          lo = Math.imul(al9, bl8);\n          mid = Math.imul(al9, bh8);\n          mid = mid + Math.imul(ah9, bl8) | 0;\n          hi = Math.imul(ah9, bh8);\n          lo = lo + Math.imul(al8, bl9) | 0;\n          mid = mid + Math.imul(al8, bh9) | 0;\n          mid = mid + Math.imul(ah8, bl9) | 0;\n          hi = hi + Math.imul(ah8, bh9) | 0;\n          var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n          w17 &= 0x3ffffff;\n          /* k = 18 */\n\n          lo = Math.imul(al9, bl9);\n          mid = Math.imul(al9, bh9);\n          mid = mid + Math.imul(ah9, bl9) | 0;\n          hi = Math.imul(ah9, bh9);\n          var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n          w18 &= 0x3ffffff;\n          o[0] = w0;\n          o[1] = w1;\n          o[2] = w2;\n          o[3] = w3;\n          o[4] = w4;\n          o[5] = w5;\n          o[6] = w6;\n          o[7] = w7;\n          o[8] = w8;\n          o[9] = w9;\n          o[10] = w10;\n          o[11] = w11;\n          o[12] = w12;\n          o[13] = w13;\n          o[14] = w14;\n          o[15] = w15;\n          o[16] = w16;\n          o[17] = w17;\n          o[18] = w18;\n\n          if (c !== 0) {\n            o[19] = c;\n            out.length++;\n          }\n\n          return out;\n        }; // Polyfill comb\n\n\n        if (!Math.imul) {\n          comb10MulTo = smallMulTo;\n        }\n\n        function bigMulTo(self, num, out) {\n          out.negative = num.negative ^ self.negative;\n          out.length = self.length + num.length;\n          var carry = 0;\n          var hncarry = 0;\n\n          for (var k = 0; k < out.length - 1; k++) {\n            // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n            // note that ncarry could be >= 0x3ffffff\n            var ncarry = hncarry;\n            hncarry = 0;\n            var rword = carry & 0x3ffffff;\n            var maxJ = Math.min(k, num.length - 1);\n\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n              var i = k - j;\n              var a = self.words[i] | 0;\n              var b = num.words[j] | 0;\n              var r = a * b;\n              var lo = r & 0x3ffffff;\n              ncarry = ncarry + (r / 0x4000000 | 0) | 0;\n              lo = lo + rword | 0;\n              rword = lo & 0x3ffffff;\n              ncarry = ncarry + (lo >>> 26) | 0;\n              hncarry += ncarry >>> 26;\n              ncarry &= 0x3ffffff;\n            }\n\n            out.words[k] = rword;\n            carry = ncarry;\n            ncarry = hncarry;\n          }\n\n          if (carry !== 0) {\n            out.words[k] = carry;\n          } else {\n            out.length--;\n          }\n\n          return out.strip();\n        }\n\n        function jumboMulTo(self, num, out) {\n          var fftm = new FFTM();\n          return fftm.mulp(self, num, out);\n        }\n\n        BN.prototype.mulTo = function mulTo(num, out) {\n          var res;\n          var len = this.length + num.length;\n\n          if (this.length === 10 && num.length === 10) {\n            res = comb10MulTo(this, num, out);\n          } else if (len < 63) {\n            res = smallMulTo(this, num, out);\n          } else if (len < 1024) {\n            res = bigMulTo(this, num, out);\n          } else {\n            res = jumboMulTo(this, num, out);\n          }\n\n          return res;\n        }; // Cooley-Tukey algorithm for FFT\n        // slightly revisited to rely on looping instead of recursion\n\n\n        function FFTM(x, y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        FFTM.prototype.makeRBT = function makeRBT(N) {\n          var t = new Array(N);\n          var l = BN.prototype._countBits(N) - 1;\n\n          for (var i = 0; i < N; i++) {\n            t[i] = this.revBin(i, l, N);\n          }\n\n          return t;\n        }; // Returns binary-reversed representation of `x`\n\n\n        FFTM.prototype.revBin = function revBin(x, l, N) {\n          if (x === 0 || x === N - 1) return x;\n          var rb = 0;\n\n          for (var i = 0; i < l; i++) {\n            rb |= (x & 1) << l - i - 1;\n            x >>= 1;\n          }\n\n          return rb;\n        }; // Performs \"tweedling\" phase, therefore 'emulating'\n        // behaviour of the recursive algorithm\n\n\n        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\n          for (var i = 0; i < N; i++) {\n            rtws[i] = rws[rbt[i]];\n            itws[i] = iws[rbt[i]];\n          }\n        };\n\n        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\n          this.permute(rbt, rws, iws, rtws, itws, N);\n\n          for (var s = 1; s < N; s <<= 1) {\n            var l = s << 1;\n            var rtwdf = Math.cos(2 * Math.PI / l);\n            var itwdf = Math.sin(2 * Math.PI / l);\n\n            for (var p = 0; p < N; p += l) {\n              var rtwdf_ = rtwdf;\n              var itwdf_ = itwdf;\n\n              for (var j = 0; j < s; j++) {\n                var re = rtws[p + j];\n                var ie = itws[p + j];\n                var ro = rtws[p + j + s];\n                var io = itws[p + j + s];\n                var rx = rtwdf_ * ro - itwdf_ * io;\n                io = rtwdf_ * io + itwdf_ * ro;\n                ro = rx;\n                rtws[p + j] = re + ro;\n                itws[p + j] = ie + io;\n                rtws[p + j + s] = re - ro;\n                itws[p + j + s] = ie - io;\n                /* jshint maxdepth : false */\n\n                if (j !== l) {\n                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n                  rtwdf_ = rx;\n                }\n              }\n            }\n          }\n        };\n\n        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\n          var N = Math.max(m, n) | 1;\n          var odd = N & 1;\n          var i = 0;\n\n          for (N = N / 2 | 0; N; N = N >>> 1) {\n            i++;\n          }\n\n          return 1 << i + 1 + odd;\n        };\n\n        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\n          if (N <= 1) return;\n\n          for (var i = 0; i < N / 2; i++) {\n            var t = rws[i];\n            rws[i] = rws[N - i - 1];\n            rws[N - i - 1] = t;\n            t = iws[i];\n            iws[i] = -iws[N - i - 1];\n            iws[N - i - 1] = -t;\n          }\n        };\n\n        FFTM.prototype.normalize13b = function normalize13b(ws, N) {\n          var carry = 0;\n\n          for (var i = 0; i < N / 2; i++) {\n            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;\n            ws[i] = w & 0x3ffffff;\n\n            if (w < 0x4000000) {\n              carry = 0;\n            } else {\n              carry = w / 0x4000000 | 0;\n            }\n          }\n\n          return ws;\n        };\n\n        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\n          var carry = 0;\n\n          for (var i = 0; i < len; i++) {\n            carry = carry + (ws[i] | 0);\n            rws[2 * i] = carry & 0x1fff;\n            carry = carry >>> 13;\n            rws[2 * i + 1] = carry & 0x1fff;\n            carry = carry >>> 13;\n          } // Pad with zeroes\n\n\n          for (i = 2 * len; i < N; ++i) {\n            rws[i] = 0;\n          }\n\n          assert(carry === 0);\n          assert((carry & ~0x1fff) === 0);\n        };\n\n        FFTM.prototype.stub = function stub(N) {\n          var ph = new Array(N);\n\n          for (var i = 0; i < N; i++) {\n            ph[i] = 0;\n          }\n\n          return ph;\n        };\n\n        FFTM.prototype.mulp = function mulp(x, y, out) {\n          var N = 2 * this.guessLen13b(x.length, y.length);\n          var rbt = this.makeRBT(N);\n\n          var _ = this.stub(N);\n\n          var rws = new Array(N);\n          var rwst = new Array(N);\n          var iwst = new Array(N);\n          var nrws = new Array(N);\n          var nrwst = new Array(N);\n          var niwst = new Array(N);\n          var rmws = out.words;\n          rmws.length = N;\n          this.convert13b(x.words, x.length, rws, N);\n          this.convert13b(y.words, y.length, nrws, N);\n          this.transform(rws, _, rwst, iwst, N, rbt);\n          this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n          for (var i = 0; i < N; i++) {\n            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n            rwst[i] = rx;\n          }\n\n          this.conjugate(rwst, iwst, N);\n          this.transform(rwst, iwst, rmws, _, N, rbt);\n          this.conjugate(rmws, _, N);\n          this.normalize13b(rmws, N);\n          out.negative = x.negative ^ y.negative;\n          out.length = x.length + y.length;\n          return out.strip();\n        }; // Multiply `this` by `num`\n\n\n        BN.prototype.mul = function mul(num) {\n          var out = new BN(null);\n          out.words = new Array(this.length + num.length);\n          return this.mulTo(num, out);\n        }; // Multiply employing FFT\n\n\n        BN.prototype.mulf = function mulf(num) {\n          var out = new BN(null);\n          out.words = new Array(this.length + num.length);\n          return jumboMulTo(this, num, out);\n        }; // In-place Multiplication\n\n\n        BN.prototype.imul = function imul(num) {\n          return this.clone().mulTo(num, this);\n        };\n\n        BN.prototype.imuln = function imuln(num) {\n          assert(typeof num === 'number');\n          assert(num < 0x4000000); // Carry\n\n          var carry = 0;\n\n          for (var i = 0; i < this.length; i++) {\n            var w = (this.words[i] | 0) * num;\n            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n            carry >>= 26;\n            carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum\n\n            carry += lo >>> 26;\n            this.words[i] = lo & 0x3ffffff;\n          }\n\n          if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n          }\n\n          return this;\n        };\n\n        BN.prototype.muln = function muln(num) {\n          return this.clone().imuln(num);\n        }; // `this` * `this`\n\n\n        BN.prototype.sqr = function sqr() {\n          return this.mul(this);\n        }; // `this` * `this` in-place\n\n\n        BN.prototype.isqr = function isqr() {\n          return this.imul(this.clone());\n        }; // Math.pow(`this`, `num`)\n\n\n        BN.prototype.pow = function pow(num) {\n          var w = toBitArray(num);\n          if (w.length === 0) return new BN(1); // Skip leading zeroes\n\n          var res = this;\n\n          for (var i = 0; i < w.length; i++, res = res.sqr()) {\n            if (w[i] !== 0) break;\n          }\n\n          if (++i < w.length) {\n            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n              if (w[i] === 0) continue;\n              res = res.mul(q);\n            }\n          }\n\n          return res;\n        }; // Shift-left in-place\n\n\n        BN.prototype.iushln = function iushln(bits) {\n          assert(typeof bits === 'number' && bits >= 0);\n          var r = bits % 26;\n          var s = (bits - r) / 26;\n          var carryMask = 0x3ffffff >>> 26 - r << 26 - r;\n          var i;\n\n          if (r !== 0) {\n            var carry = 0;\n\n            for (i = 0; i < this.length; i++) {\n              var newCarry = this.words[i] & carryMask;\n              var c = (this.words[i] | 0) - newCarry << r;\n              this.words[i] = c | carry;\n              carry = newCarry >>> 26 - r;\n            }\n\n            if (carry) {\n              this.words[i] = carry;\n              this.length++;\n            }\n          }\n\n          if (s !== 0) {\n            for (i = this.length - 1; i >= 0; i--) {\n              this.words[i + s] = this.words[i];\n            }\n\n            for (i = 0; i < s; i++) {\n              this.words[i] = 0;\n            }\n\n            this.length += s;\n          }\n\n          return this.strip();\n        };\n\n        BN.prototype.ishln = function ishln(bits) {\n          // TODO(indutny): implement me\n          assert(this.negative === 0);\n          return this.iushln(bits);\n        }; // Shift-right in-place\n        // NOTE: `hint` is a lowest bit before trailing zeroes\n        // NOTE: if `extended` is present - it will be filled with destroyed bits\n\n\n        BN.prototype.iushrn = function iushrn(bits, hint, extended) {\n          assert(typeof bits === 'number' && bits >= 0);\n          var h;\n\n          if (hint) {\n            h = (hint - hint % 26) / 26;\n          } else {\n            h = 0;\n          }\n\n          var r = bits % 26;\n          var s = Math.min((bits - r) / 26, this.length);\n          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n          var maskedWords = extended;\n          h -= s;\n          h = Math.max(0, h); // Extended mode, copy masked part\n\n          if (maskedWords) {\n            for (var i = 0; i < s; i++) {\n              maskedWords.words[i] = this.words[i];\n            }\n\n            maskedWords.length = s;\n          }\n\n          if (s === 0) {// No-op, we should not move anything at all\n          } else if (this.length > s) {\n            this.length -= s;\n\n            for (i = 0; i < this.length; i++) {\n              this.words[i] = this.words[i + s];\n            }\n          } else {\n            this.words[0] = 0;\n            this.length = 1;\n          }\n\n          var carry = 0;\n\n          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n            var word = this.words[i] | 0;\n            this.words[i] = carry << 26 - r | word >>> r;\n            carry = word & mask;\n          } // Push carried bits as a mask\n\n\n          if (maskedWords && carry !== 0) {\n            maskedWords.words[maskedWords.length++] = carry;\n          }\n\n          if (this.length === 0) {\n            this.words[0] = 0;\n            this.length = 1;\n          }\n\n          return this.strip();\n        };\n\n        BN.prototype.ishrn = function ishrn(bits, hint, extended) {\n          // TODO(indutny): implement me\n          assert(this.negative === 0);\n          return this.iushrn(bits, hint, extended);\n        }; // Shift-left\n\n\n        BN.prototype.shln = function shln(bits) {\n          return this.clone().ishln(bits);\n        };\n\n        BN.prototype.ushln = function ushln(bits) {\n          return this.clone().iushln(bits);\n        }; // Shift-right\n\n\n        BN.prototype.shrn = function shrn(bits) {\n          return this.clone().ishrn(bits);\n        };\n\n        BN.prototype.ushrn = function ushrn(bits) {\n          return this.clone().iushrn(bits);\n        }; // Test if n bit is set\n\n\n        BN.prototype.testn = function testn(bit) {\n          assert(typeof bit === 'number' && bit >= 0);\n          var r = bit % 26;\n          var s = (bit - r) / 26;\n          var q = 1 << r; // Fast case: bit is much higher than all existing words\n\n          if (this.length <= s) return false; // Check bit and return\n\n          var w = this.words[s];\n          return !!(w & q);\n        }; // Return only lowers bits of number (in-place)\n\n\n        BN.prototype.imaskn = function imaskn(bits) {\n          assert(typeof bits === 'number' && bits >= 0);\n          var r = bits % 26;\n          var s = (bits - r) / 26;\n          assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n          if (this.length <= s) {\n            return this;\n          }\n\n          if (r !== 0) {\n            s++;\n          }\n\n          this.length = Math.min(s, this.length);\n\n          if (r !== 0) {\n            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;\n            this.words[this.length - 1] &= mask;\n          }\n\n          return this.strip();\n        }; // Return only lowers bits of number\n\n\n        BN.prototype.maskn = function maskn(bits) {\n          return this.clone().imaskn(bits);\n        }; // Add plain number `num` to `this`\n\n\n        BN.prototype.iaddn = function iaddn(num) {\n          assert(typeof num === 'number');\n          assert(num < 0x4000000);\n          if (num < 0) return this.isubn(-num); // Possible sign change\n\n          if (this.negative !== 0) {\n            if (this.length === 1 && (this.words[0] | 0) < num) {\n              this.words[0] = num - (this.words[0] | 0);\n              this.negative = 0;\n              return this;\n            }\n\n            this.negative = 0;\n            this.isubn(num);\n            this.negative = 1;\n            return this;\n          } // Add without checks\n\n\n          return this._iaddn(num);\n        };\n\n        BN.prototype._iaddn = function _iaddn(num) {\n          this.words[0] += num; // Carry\n\n          for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n            this.words[i] -= 0x4000000;\n\n            if (i === this.length - 1) {\n              this.words[i + 1] = 1;\n            } else {\n              this.words[i + 1]++;\n            }\n          }\n\n          this.length = Math.max(this.length, i + 1);\n          return this;\n        }; // Subtract plain number `num` from `this`\n\n\n        BN.prototype.isubn = function isubn(num) {\n          assert(typeof num === 'number');\n          assert(num < 0x4000000);\n          if (num < 0) return this.iaddn(-num);\n\n          if (this.negative !== 0) {\n            this.negative = 0;\n            this.iaddn(num);\n            this.negative = 1;\n            return this;\n          }\n\n          this.words[0] -= num;\n\n          if (this.length === 1 && this.words[0] < 0) {\n            this.words[0] = -this.words[0];\n            this.negative = 1;\n          } else {\n            // Carry\n            for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n              this.words[i] += 0x4000000;\n              this.words[i + 1] -= 1;\n            }\n          }\n\n          return this.strip();\n        };\n\n        BN.prototype.addn = function addn(num) {\n          return this.clone().iaddn(num);\n        };\n\n        BN.prototype.subn = function subn(num) {\n          return this.clone().isubn(num);\n        };\n\n        BN.prototype.iabs = function iabs() {\n          this.negative = 0;\n          return this;\n        };\n\n        BN.prototype.abs = function abs() {\n          return this.clone().iabs();\n        };\n\n        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\n          var len = num.length + shift;\n          var i;\n\n          this._expand(len);\n\n          var w;\n          var carry = 0;\n\n          for (i = 0; i < num.length; i++) {\n            w = (this.words[i + shift] | 0) + carry;\n            var right = (num.words[i] | 0) * mul;\n            w -= right & 0x3ffffff;\n            carry = (w >> 26) - (right / 0x4000000 | 0);\n            this.words[i + shift] = w & 0x3ffffff;\n          }\n\n          for (; i < this.length - shift; i++) {\n            w = (this.words[i + shift] | 0) + carry;\n            carry = w >> 26;\n            this.words[i + shift] = w & 0x3ffffff;\n          }\n\n          if (carry === 0) return this.strip(); // Subtraction overflow\n\n          assert(carry === -1);\n          carry = 0;\n\n          for (i = 0; i < this.length; i++) {\n            w = -(this.words[i] | 0) + carry;\n            carry = w >> 26;\n            this.words[i] = w & 0x3ffffff;\n          }\n\n          this.negative = 1;\n          return this.strip();\n        };\n\n        BN.prototype._wordDiv = function _wordDiv(num, mode) {\n          var shift = this.length - num.length;\n          var a = this.clone();\n          var b = num; // Normalize\n\n          var bhi = b.words[b.length - 1] | 0;\n\n          var bhiBits = this._countBits(bhi);\n\n          shift = 26 - bhiBits;\n\n          if (shift !== 0) {\n            b = b.ushln(shift);\n            a.iushln(shift);\n            bhi = b.words[b.length - 1] | 0;\n          } // Initialize quotient\n\n\n          var m = a.length - b.length;\n          var q;\n\n          if (mode !== 'mod') {\n            q = new BN(null);\n            q.length = m + 1;\n            q.words = new Array(q.length);\n\n            for (var i = 0; i < q.length; i++) {\n              q.words[i] = 0;\n            }\n          }\n\n          var diff = a.clone()._ishlnsubmul(b, 1, m);\n\n          if (diff.negative === 0) {\n            a = diff;\n\n            if (q) {\n              q.words[m] = 1;\n            }\n          }\n\n          for (var j = m - 1; j >= 0; j--) {\n            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n            // (0x7ffffff)\n\n            qj = Math.min(qj / bhi | 0, 0x3ffffff);\n\n            a._ishlnsubmul(b, qj, j);\n\n            while (a.negative !== 0) {\n              qj--;\n              a.negative = 0;\n\n              a._ishlnsubmul(b, 1, j);\n\n              if (!a.isZero()) {\n                a.negative ^= 1;\n              }\n            }\n\n            if (q) {\n              q.words[j] = qj;\n            }\n          }\n\n          if (q) {\n            q.strip();\n          }\n\n          a.strip(); // Denormalize\n\n          if (mode !== 'div' && shift !== 0) {\n            a.iushrn(shift);\n          }\n\n          return {\n            div: q || null,\n            mod: a\n          };\n        }; // NOTE: 1) `mode` can be set to `mod` to request mod only,\n        //       to `div` to request div only, or be absent to\n        //       request both div & mod\n        //       2) `positive` is true if unsigned mod is requested\n\n\n        BN.prototype.divmod = function divmod(num, mode, positive) {\n          assert(!num.isZero());\n\n          if (this.isZero()) {\n            return {\n              div: new BN(0),\n              mod: new BN(0)\n            };\n          }\n\n          var div, mod, res;\n\n          if (this.negative !== 0 && num.negative === 0) {\n            res = this.neg().divmod(num, mode);\n\n            if (mode !== 'mod') {\n              div = res.div.neg();\n            }\n\n            if (mode !== 'div') {\n              mod = res.mod.neg();\n\n              if (positive && mod.negative !== 0) {\n                mod.iadd(num);\n              }\n            }\n\n            return {\n              div: div,\n              mod: mod\n            };\n          }\n\n          if (this.negative === 0 && num.negative !== 0) {\n            res = this.divmod(num.neg(), mode);\n\n            if (mode !== 'mod') {\n              div = res.div.neg();\n            }\n\n            return {\n              div: div,\n              mod: res.mod\n            };\n          }\n\n          if ((this.negative & num.negative) !== 0) {\n            res = this.neg().divmod(num.neg(), mode);\n\n            if (mode !== 'div') {\n              mod = res.mod.neg();\n\n              if (positive && mod.negative !== 0) {\n                mod.isub(num);\n              }\n            }\n\n            return {\n              div: res.div,\n              mod: mod\n            };\n          } // Both numbers are positive at this point\n          // Strip both numbers to approximate shift value\n\n\n          if (num.length > this.length || this.cmp(num) < 0) {\n            return {\n              div: new BN(0),\n              mod: this\n            };\n          } // Very short reduction\n\n\n          if (num.length === 1) {\n            if (mode === 'div') {\n              return {\n                div: this.divn(num.words[0]),\n                mod: null\n              };\n            }\n\n            if (mode === 'mod') {\n              return {\n                div: null,\n                mod: new BN(this.modn(num.words[0]))\n              };\n            }\n\n            return {\n              div: this.divn(num.words[0]),\n              mod: new BN(this.modn(num.words[0]))\n            };\n          }\n\n          return this._wordDiv(num, mode);\n        }; // Find `this` / `num`\n\n\n        BN.prototype.div = function div(num) {\n          return this.divmod(num, 'div', false).div;\n        }; // Find `this` % `num`\n\n\n        BN.prototype.mod = function mod(num) {\n          return this.divmod(num, 'mod', false).mod;\n        };\n\n        BN.prototype.umod = function umod(num) {\n          return this.divmod(num, 'mod', true).mod;\n        }; // Find Round(`this` / `num`)\n\n\n        BN.prototype.divRound = function divRound(num) {\n          var dm = this.divmod(num); // Fast case - exact division\n\n          if (dm.mod.isZero()) return dm.div;\n          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n          var half = num.ushrn(1);\n          var r2 = num.andln(1);\n          var cmp = mod.cmp(half); // Round down\n\n          if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up\n\n          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n        };\n\n        BN.prototype.modn = function modn(num) {\n          assert(num <= 0x3ffffff);\n          var p = (1 << 26) % num;\n          var acc = 0;\n\n          for (var i = this.length - 1; i >= 0; i--) {\n            acc = (p * acc + (this.words[i] | 0)) % num;\n          }\n\n          return acc;\n        }; // In-place division by number\n\n\n        BN.prototype.idivn = function idivn(num) {\n          assert(num <= 0x3ffffff);\n          var carry = 0;\n\n          for (var i = this.length - 1; i >= 0; i--) {\n            var w = (this.words[i] | 0) + carry * 0x4000000;\n            this.words[i] = w / num | 0;\n            carry = w % num;\n          }\n\n          return this.strip();\n        };\n\n        BN.prototype.divn = function divn(num) {\n          return this.clone().idivn(num);\n        };\n\n        BN.prototype.egcd = function egcd(p) {\n          assert(p.negative === 0);\n          assert(!p.isZero());\n          var x = this;\n          var y = p.clone();\n\n          if (x.negative !== 0) {\n            x = x.umod(p);\n          } else {\n            x = x.clone();\n          } // A * x + B * y = x\n\n\n          var A = new BN(1);\n          var B = new BN(0); // C * x + D * y = y\n\n          var C = new BN(0);\n          var D = new BN(1);\n          var g = 0;\n\n          while (x.isEven() && y.isEven()) {\n            x.iushrn(1);\n            y.iushrn(1);\n            ++g;\n          }\n\n          var yp = y.clone();\n          var xp = x.clone();\n\n          while (!x.isZero()) {\n            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {\n              ;\n            }\n\n            if (i > 0) {\n              x.iushrn(i);\n\n              while (i-- > 0) {\n                if (A.isOdd() || B.isOdd()) {\n                  A.iadd(yp);\n                  B.isub(xp);\n                }\n\n                A.iushrn(1);\n                B.iushrn(1);\n              }\n            }\n\n            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {\n              ;\n            }\n\n            if (j > 0) {\n              y.iushrn(j);\n\n              while (j-- > 0) {\n                if (C.isOdd() || D.isOdd()) {\n                  C.iadd(yp);\n                  D.isub(xp);\n                }\n\n                C.iushrn(1);\n                D.iushrn(1);\n              }\n            }\n\n            if (x.cmp(y) >= 0) {\n              x.isub(y);\n              A.isub(C);\n              B.isub(D);\n            } else {\n              y.isub(x);\n              C.isub(A);\n              D.isub(B);\n            }\n          }\n\n          return {\n            a: C,\n            b: D,\n            gcd: y.iushln(g)\n          };\n        }; // This is reduced incarnation of the binary EEA\n        // above, designated to invert members of the\n        // _prime_ fields F(p) at a maximal speed\n\n\n        BN.prototype._invmp = function _invmp(p) {\n          assert(p.negative === 0);\n          assert(!p.isZero());\n          var a = this;\n          var b = p.clone();\n\n          if (a.negative !== 0) {\n            a = a.umod(p);\n          } else {\n            a = a.clone();\n          }\n\n          var x1 = new BN(1);\n          var x2 = new BN(0);\n          var delta = b.clone();\n\n          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {\n              ;\n            }\n\n            if (i > 0) {\n              a.iushrn(i);\n\n              while (i-- > 0) {\n                if (x1.isOdd()) {\n                  x1.iadd(delta);\n                }\n\n                x1.iushrn(1);\n              }\n            }\n\n            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {\n              ;\n            }\n\n            if (j > 0) {\n              b.iushrn(j);\n\n              while (j-- > 0) {\n                if (x2.isOdd()) {\n                  x2.iadd(delta);\n                }\n\n                x2.iushrn(1);\n              }\n            }\n\n            if (a.cmp(b) >= 0) {\n              a.isub(b);\n              x1.isub(x2);\n            } else {\n              b.isub(a);\n              x2.isub(x1);\n            }\n          }\n\n          var res;\n\n          if (a.cmpn(1) === 0) {\n            res = x1;\n          } else {\n            res = x2;\n          }\n\n          if (res.cmpn(0) < 0) {\n            res.iadd(p);\n          }\n\n          return res;\n        };\n\n        BN.prototype.gcd = function gcd(num) {\n          if (this.isZero()) return num.abs();\n          if (num.isZero()) return this.abs();\n          var a = this.clone();\n          var b = num.clone();\n          a.negative = 0;\n          b.negative = 0; // Remove common factor of two\n\n          for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n            a.iushrn(1);\n            b.iushrn(1);\n          }\n\n          do {\n            while (a.isEven()) {\n              a.iushrn(1);\n            }\n\n            while (b.isEven()) {\n              b.iushrn(1);\n            }\n\n            var r = a.cmp(b);\n\n            if (r < 0) {\n              // Swap `a` and `b` to make `a` always bigger than `b`\n              var t = a;\n              a = b;\n              b = t;\n            } else if (r === 0 || b.cmpn(1) === 0) {\n              break;\n            }\n\n            a.isub(b);\n          } while (true);\n\n          return b.iushln(shift);\n        }; // Invert number in the field F(num)\n\n\n        BN.prototype.invm = function invm(num) {\n          return this.egcd(num).a.umod(num);\n        };\n\n        BN.prototype.isEven = function isEven() {\n          return (this.words[0] & 1) === 0;\n        };\n\n        BN.prototype.isOdd = function isOdd() {\n          return (this.words[0] & 1) === 1;\n        }; // And first word and num\n\n\n        BN.prototype.andln = function andln(num) {\n          return this.words[0] & num;\n        }; // Increment at the bit position in-line\n\n\n        BN.prototype.bincn = function bincn(bit) {\n          assert(typeof bit === 'number');\n          var r = bit % 26;\n          var s = (bit - r) / 26;\n          var q = 1 << r; // Fast case: bit is much higher than all existing words\n\n          if (this.length <= s) {\n            this._expand(s + 1);\n\n            this.words[s] |= q;\n            return this;\n          } // Add bit and propagate, if needed\n\n\n          var carry = q;\n\n          for (var i = s; carry !== 0 && i < this.length; i++) {\n            var w = this.words[i] | 0;\n            w += carry;\n            carry = w >>> 26;\n            w &= 0x3ffffff;\n            this.words[i] = w;\n          }\n\n          if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n          }\n\n          return this;\n        };\n\n        BN.prototype.isZero = function isZero() {\n          return this.length === 1 && this.words[0] === 0;\n        };\n\n        BN.prototype.cmpn = function cmpn(num) {\n          var negative = num < 0;\n          if (this.negative !== 0 && !negative) return -1;\n          if (this.negative === 0 && negative) return 1;\n          this.strip();\n          var res;\n\n          if (this.length > 1) {\n            res = 1;\n          } else {\n            if (negative) {\n              num = -num;\n            }\n\n            assert(num <= 0x3ffffff, 'Number is too big');\n            var w = this.words[0] | 0;\n            res = w === num ? 0 : w < num ? -1 : 1;\n          }\n\n          if (this.negative !== 0) return -res | 0;\n          return res;\n        }; // Compare two numbers and return:\n        // 1 - if `this` > `num`\n        // 0 - if `this` == `num`\n        // -1 - if `this` < `num`\n\n\n        BN.prototype.cmp = function cmp(num) {\n          if (this.negative !== 0 && num.negative === 0) return -1;\n          if (this.negative === 0 && num.negative !== 0) return 1;\n          var res = this.ucmp(num);\n          if (this.negative !== 0) return -res | 0;\n          return res;\n        }; // Unsigned comparison\n\n\n        BN.prototype.ucmp = function ucmp(num) {\n          // At this point both numbers have the same sign\n          if (this.length > num.length) return 1;\n          if (this.length < num.length) return -1;\n          var res = 0;\n\n          for (var i = this.length - 1; i >= 0; i--) {\n            var a = this.words[i] | 0;\n            var b = num.words[i] | 0;\n            if (a === b) continue;\n\n            if (a < b) {\n              res = -1;\n            } else if (a > b) {\n              res = 1;\n            }\n\n            break;\n          }\n\n          return res;\n        };\n\n        BN.prototype.gtn = function gtn(num) {\n          return this.cmpn(num) === 1;\n        };\n\n        BN.prototype.gt = function gt(num) {\n          return this.cmp(num) === 1;\n        };\n\n        BN.prototype.gten = function gten(num) {\n          return this.cmpn(num) >= 0;\n        };\n\n        BN.prototype.gte = function gte(num) {\n          return this.cmp(num) >= 0;\n        };\n\n        BN.prototype.ltn = function ltn(num) {\n          return this.cmpn(num) === -1;\n        };\n\n        BN.prototype.lt = function lt(num) {\n          return this.cmp(num) === -1;\n        };\n\n        BN.prototype.lten = function lten(num) {\n          return this.cmpn(num) <= 0;\n        };\n\n        BN.prototype.lte = function lte(num) {\n          return this.cmp(num) <= 0;\n        };\n\n        BN.prototype.eqn = function eqn(num) {\n          return this.cmpn(num) === 0;\n        };\n\n        BN.prototype.eq = function eq(num) {\n          return this.cmp(num) === 0;\n        }; //\n        // A reduce context, could be using montgomery or something better, depending\n        // on the `m` itself.\n        //\n\n\n        BN.red = function red(num) {\n          return new Red(num);\n        };\n\n        BN.prototype.toRed = function toRed(ctx) {\n          assert(!this.red, 'Already a number in reduction context');\n          assert(this.negative === 0, 'red works only with positives');\n          return ctx.convertTo(this)._forceRed(ctx);\n        };\n\n        BN.prototype.fromRed = function fromRed() {\n          assert(this.red, 'fromRed works only with numbers in reduction context');\n          return this.red.convertFrom(this);\n        };\n\n        BN.prototype._forceRed = function _forceRed(ctx) {\n          this.red = ctx;\n          return this;\n        };\n\n        BN.prototype.forceRed = function forceRed(ctx) {\n          assert(!this.red, 'Already a number in reduction context');\n          return this._forceRed(ctx);\n        };\n\n        BN.prototype.redAdd = function redAdd(num) {\n          assert(this.red, 'redAdd works only with red numbers');\n          return this.red.add(this, num);\n        };\n\n        BN.prototype.redIAdd = function redIAdd(num) {\n          assert(this.red, 'redIAdd works only with red numbers');\n          return this.red.iadd(this, num);\n        };\n\n        BN.prototype.redSub = function redSub(num) {\n          assert(this.red, 'redSub works only with red numbers');\n          return this.red.sub(this, num);\n        };\n\n        BN.prototype.redISub = function redISub(num) {\n          assert(this.red, 'redISub works only with red numbers');\n          return this.red.isub(this, num);\n        };\n\n        BN.prototype.redShl = function redShl(num) {\n          assert(this.red, 'redShl works only with red numbers');\n          return this.red.shl(this, num);\n        };\n\n        BN.prototype.redMul = function redMul(num) {\n          assert(this.red, 'redMul works only with red numbers');\n\n          this.red._verify2(this, num);\n\n          return this.red.mul(this, num);\n        };\n\n        BN.prototype.redIMul = function redIMul(num) {\n          assert(this.red, 'redMul works only with red numbers');\n\n          this.red._verify2(this, num);\n\n          return this.red.imul(this, num);\n        };\n\n        BN.prototype.redSqr = function redSqr() {\n          assert(this.red, 'redSqr works only with red numbers');\n\n          this.red._verify1(this);\n\n          return this.red.sqr(this);\n        };\n\n        BN.prototype.redISqr = function redISqr() {\n          assert(this.red, 'redISqr works only with red numbers');\n\n          this.red._verify1(this);\n\n          return this.red.isqr(this);\n        }; // Square root over p\n\n\n        BN.prototype.redSqrt = function redSqrt() {\n          assert(this.red, 'redSqrt works only with red numbers');\n\n          this.red._verify1(this);\n\n          return this.red.sqrt(this);\n        };\n\n        BN.prototype.redInvm = function redInvm() {\n          assert(this.red, 'redInvm works only with red numbers');\n\n          this.red._verify1(this);\n\n          return this.red.invm(this);\n        }; // Return negative clone of `this` % `red modulo`\n\n\n        BN.prototype.redNeg = function redNeg() {\n          assert(this.red, 'redNeg works only with red numbers');\n\n          this.red._verify1(this);\n\n          return this.red.neg(this);\n        };\n\n        BN.prototype.redPow = function redPow(num) {\n          assert(this.red && !num.red, 'redPow(normalNum)');\n\n          this.red._verify1(this);\n\n          return this.red.pow(this, num);\n        }; // Prime numbers with efficient reduction\n\n\n        var primes = {\n          k256: null,\n          p224: null,\n          p192: null,\n          p25519: null\n        }; // Pseudo-Mersenne prime\n\n        function MPrime(name, p) {\n          // P = 2 ^ N - K\n          this.name = name;\n          this.p = new BN(p, 16);\n          this.n = this.p.bitLength();\n          this.k = new BN(1).iushln(this.n).isub(this.p);\n          this.tmp = this._tmp();\n        }\n\n        MPrime.prototype._tmp = function _tmp() {\n          var tmp = new BN(null);\n          tmp.words = new Array(Math.ceil(this.n / 13));\n          return tmp;\n        };\n\n        MPrime.prototype.ireduce = function ireduce(num) {\n          // Assumes that `num` is less than `P^2`\n          // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n          var r = num;\n          var rlen;\n\n          do {\n            this.split(r, this.tmp);\n            r = this.imulK(r);\n            r = r.iadd(this.tmp);\n            rlen = r.bitLength();\n          } while (rlen > this.n);\n\n          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\n          if (cmp === 0) {\n            r.words[0] = 0;\n            r.length = 1;\n          } else if (cmp > 0) {\n            r.isub(this.p);\n          } else {\n            if (r.strip !== undefined) {\n              // r is BN v4 instance\n              r.strip();\n            } else {\n              // r is BN v5 instance\n              r._strip();\n            }\n          }\n\n          return r;\n        };\n\n        MPrime.prototype.split = function split(input, out) {\n          input.iushrn(this.n, 0, out);\n        };\n\n        MPrime.prototype.imulK = function imulK(num) {\n          return num.imul(this.k);\n        };\n\n        function K256() {\n          MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n        }\n\n        inherits(K256, MPrime);\n\n        K256.prototype.split = function split(input, output) {\n          // 256 = 9 * 26 + 22\n          var mask = 0x3fffff;\n          var outLen = Math.min(input.length, 9);\n\n          for (var i = 0; i < outLen; i++) {\n            output.words[i] = input.words[i];\n          }\n\n          output.length = outLen;\n\n          if (input.length <= 9) {\n            input.words[0] = 0;\n            input.length = 1;\n            return;\n          } // Shift by 9 limbs\n\n\n          var prev = input.words[9];\n          output.words[output.length++] = prev & mask;\n\n          for (i = 10; i < input.length; i++) {\n            var next = input.words[i] | 0;\n            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n            prev = next;\n          }\n\n          prev >>>= 22;\n          input.words[i - 10] = prev;\n\n          if (prev === 0 && input.length > 10) {\n            input.length -= 10;\n          } else {\n            input.length -= 9;\n          }\n        };\n\n        K256.prototype.imulK = function imulK(num) {\n          // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n          num.words[num.length] = 0;\n          num.words[num.length + 1] = 0;\n          num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\n          var lo = 0;\n\n          for (var i = 0; i < num.length; i++) {\n            var w = num.words[i] | 0;\n            lo += w * 0x3d1;\n            num.words[i] = lo & 0x3ffffff;\n            lo = w * 0x40 + (lo / 0x4000000 | 0);\n          } // Fast length reduction\n\n\n          if (num.words[num.length - 1] === 0) {\n            num.length--;\n\n            if (num.words[num.length - 1] === 0) {\n              num.length--;\n            }\n          }\n\n          return num;\n        };\n\n        function P224() {\n          MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n        }\n\n        inherits(P224, MPrime);\n\n        function P192() {\n          MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n        }\n\n        inherits(P192, MPrime);\n\n        function P25519() {\n          // 2 ^ 255 - 19\n          MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n        }\n\n        inherits(P25519, MPrime);\n\n        P25519.prototype.imulK = function imulK(num) {\n          // K = 0x13\n          var carry = 0;\n\n          for (var i = 0; i < num.length; i++) {\n            var hi = (num.words[i] | 0) * 0x13 + carry;\n            var lo = hi & 0x3ffffff;\n            hi >>>= 26;\n            num.words[i] = lo;\n            carry = hi;\n          }\n\n          if (carry !== 0) {\n            num.words[num.length++] = carry;\n          }\n\n          return num;\n        }; // Exported mostly for testing purposes, use plain name instead\n\n\n        BN._prime = function prime(name) {\n          // Cached version of prime\n          if (primes[name]) return primes[name];\n          var prime;\n\n          if (name === 'k256') {\n            prime = new K256();\n          } else if (name === 'p224') {\n            prime = new P224();\n          } else if (name === 'p192') {\n            prime = new P192();\n          } else if (name === 'p25519') {\n            prime = new P25519();\n          } else {\n            throw new Error('Unknown prime ' + name);\n          }\n\n          primes[name] = prime;\n          return prime;\n        }; //\n        // Base reduction engine\n        //\n\n\n        function Red(m) {\n          if (typeof m === 'string') {\n            var prime = BN._prime(m);\n\n            this.m = prime.p;\n            this.prime = prime;\n          } else {\n            assert(m.gtn(1), 'modulus must be greater than 1');\n            this.m = m;\n            this.prime = null;\n          }\n        }\n\n        Red.prototype._verify1 = function _verify1(a) {\n          assert(a.negative === 0, 'red works only with positives');\n          assert(a.red, 'red works only with red numbers');\n        };\n\n        Red.prototype._verify2 = function _verify2(a, b) {\n          assert((a.negative | b.negative) === 0, 'red works only with positives');\n          assert(a.red && a.red === b.red, 'red works only with red numbers');\n        };\n\n        Red.prototype.imod = function imod(a) {\n          if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n          return a.umod(this.m)._forceRed(this);\n        };\n\n        Red.prototype.neg = function neg(a) {\n          if (a.isZero()) {\n            return a.clone();\n          }\n\n          return this.m.sub(a)._forceRed(this);\n        };\n\n        Red.prototype.add = function add(a, b) {\n          this._verify2(a, b);\n\n          var res = a.add(b);\n\n          if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n          }\n\n          return res._forceRed(this);\n        };\n\n        Red.prototype.iadd = function iadd(a, b) {\n          this._verify2(a, b);\n\n          var res = a.iadd(b);\n\n          if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n          }\n\n          return res;\n        };\n\n        Red.prototype.sub = function sub(a, b) {\n          this._verify2(a, b);\n\n          var res = a.sub(b);\n\n          if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n          }\n\n          return res._forceRed(this);\n        };\n\n        Red.prototype.isub = function isub(a, b) {\n          this._verify2(a, b);\n\n          var res = a.isub(b);\n\n          if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n          }\n\n          return res;\n        };\n\n        Red.prototype.shl = function shl(a, num) {\n          this._verify1(a);\n\n          return this.imod(a.ushln(num));\n        };\n\n        Red.prototype.imul = function imul(a, b) {\n          this._verify2(a, b);\n\n          return this.imod(a.imul(b));\n        };\n\n        Red.prototype.mul = function mul(a, b) {\n          this._verify2(a, b);\n\n          return this.imod(a.mul(b));\n        };\n\n        Red.prototype.isqr = function isqr(a) {\n          return this.imul(a, a.clone());\n        };\n\n        Red.prototype.sqr = function sqr(a) {\n          return this.mul(a, a);\n        };\n\n        Red.prototype.sqrt = function sqrt(a) {\n          if (a.isZero()) return a.clone();\n          var mod3 = this.m.andln(3);\n          assert(mod3 % 2 === 1); // Fast case\n\n          if (mod3 === 3) {\n            var pow = this.m.add(new BN(1)).iushrn(2);\n            return this.pow(a, pow);\n          } // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n          //\n          // Find Q and S, that Q * 2 ^ S = (P - 1)\n\n\n          var q = this.m.subn(1);\n          var s = 0;\n\n          while (!q.isZero() && q.andln(1) === 0) {\n            s++;\n            q.iushrn(1);\n          }\n\n          assert(!q.isZero());\n          var one = new BN(1).toRed(this);\n          var nOne = one.redNeg(); // Find quadratic non-residue\n          // NOTE: Max is such because of generalized Riemann hypothesis.\n\n          var lpow = this.m.subn(1).iushrn(1);\n          var z = this.m.bitLength();\n          z = new BN(2 * z * z).toRed(this);\n\n          while (this.pow(z, lpow).cmp(nOne) !== 0) {\n            z.redIAdd(nOne);\n          }\n\n          var c = this.pow(z, q);\n          var r = this.pow(a, q.addn(1).iushrn(1));\n          var t = this.pow(a, q);\n          var m = s;\n\n          while (t.cmp(one) !== 0) {\n            var tmp = t;\n\n            for (var i = 0; tmp.cmp(one) !== 0; i++) {\n              tmp = tmp.redSqr();\n            }\n\n            assert(i < m);\n            var b = this.pow(c, new BN(1).iushln(m - i - 1));\n            r = r.redMul(b);\n            c = b.redSqr();\n            t = t.redMul(c);\n            m = i;\n          }\n\n          return r;\n        };\n\n        Red.prototype.invm = function invm(a) {\n          var inv = a._invmp(this.m);\n\n          if (inv.negative !== 0) {\n            inv.negative = 0;\n            return this.imod(inv).redNeg();\n          } else {\n            return this.imod(inv);\n          }\n        };\n\n        Red.prototype.pow = function pow(a, num) {\n          if (num.isZero()) return new BN(1).toRed(this);\n          if (num.cmpn(1) === 0) return a.clone();\n          var windowSize = 4;\n          var wnd = new Array(1 << windowSize);\n          wnd[0] = new BN(1).toRed(this);\n          wnd[1] = a;\n\n          for (var i = 2; i < wnd.length; i++) {\n            wnd[i] = this.mul(wnd[i - 1], a);\n          }\n\n          var res = wnd[0];\n          var current = 0;\n          var currentLen = 0;\n          var start = num.bitLength() % 26;\n\n          if (start === 0) {\n            start = 26;\n          }\n\n          for (i = num.length - 1; i >= 0; i--) {\n            var word = num.words[i];\n\n            for (var j = start - 1; j >= 0; j--) {\n              var bit = word >> j & 1;\n\n              if (res !== wnd[0]) {\n                res = this.sqr(res);\n              }\n\n              if (bit === 0 && current === 0) {\n                currentLen = 0;\n                continue;\n              }\n\n              current <<= 1;\n              current |= bit;\n              currentLen++;\n              if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n              res = this.mul(res, wnd[current]);\n              currentLen = 0;\n              current = 0;\n            }\n\n            start = 26;\n          }\n\n          return res;\n        };\n\n        Red.prototype.convertTo = function convertTo(num) {\n          var r = num.umod(this.m);\n          return r === num ? r.clone() : r;\n        };\n\n        Red.prototype.convertFrom = function convertFrom(num) {\n          var res = num.clone();\n          res.red = null;\n          return res;\n        }; //\n        // Montgomery method engine\n        //\n\n\n        BN.mont = function mont(num) {\n          return new Mont(num);\n        };\n\n        function Mont(m) {\n          Red.call(this, m);\n          this.shift = this.m.bitLength();\n\n          if (this.shift % 26 !== 0) {\n            this.shift += 26 - this.shift % 26;\n          }\n\n          this.r = new BN(1).iushln(this.shift);\n          this.r2 = this.imod(this.r.sqr());\n          this.rinv = this.r._invmp(this.m);\n          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n          this.minv = this.minv.umod(this.r);\n          this.minv = this.r.sub(this.minv);\n        }\n\n        inherits(Mont, Red);\n\n        Mont.prototype.convertTo = function convertTo(num) {\n          return this.imod(num.ushln(this.shift));\n        };\n\n        Mont.prototype.convertFrom = function convertFrom(num) {\n          var r = this.imod(num.mul(this.rinv));\n          r.red = null;\n          return r;\n        };\n\n        Mont.prototype.imul = function imul(a, b) {\n          if (a.isZero() || b.isZero()) {\n            a.words[0] = 0;\n            a.length = 1;\n            return a;\n          }\n\n          var t = a.imul(b);\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n          var u = t.isub(c).iushrn(this.shift);\n          var res = u;\n\n          if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n          } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n          }\n\n          return res._forceRed(this);\n        };\n\n        Mont.prototype.mul = function mul(a, b) {\n          if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n          var t = a.mul(b);\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n          var u = t.isub(c).iushrn(this.shift);\n          var res = u;\n\n          if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n          } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n          }\n\n          return res._forceRed(this);\n        };\n\n        Mont.prototype.invm = function invm(a) {\n          // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n          var res = this.imod(a._invmp(this.m).mul(this.r2));\n          return res._forceRed(this);\n        };\n      })(typeof module === 'undefined' || module, this);\n    }, {\n      \"buffer\": 2\n    }],\n    34: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = boundary;\n\n      function boundary(cells) {\n        var i, j, k;\n        var n = cells.length;\n        var sz = 0;\n\n        for (i = 0; i < n; ++i) {\n          sz += cells[i].length;\n        }\n\n        var result = new Array(sz);\n        var ptr = 0;\n\n        for (i = 0; i < n; ++i) {\n          var c = cells[i];\n          var d = c.length;\n\n          for (j = 0; j < d; ++j) {\n            var b = result[ptr++] = new Array(d - 1);\n            var p = 0;\n\n            for (k = 0; k < d; ++k) {\n              if (k === j) {\n                continue;\n              }\n\n              b[p++] = c[k];\n            }\n\n            if (j & 1) {\n              var tmp = b[1];\n              b[1] = b[0];\n              b[0] = tmp;\n            }\n          }\n        }\n\n        return result;\n      }\n    }, {}],\n    35: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = boxIntersectWrapper;\n\n      var pool = _glvis_('typedarray-pool');\n\n      var sweep = _glvis_('./lib/sweep');\n\n      var boxIntersectIter = _glvis_('./lib/intersect');\n\n      function boxEmpty(d, box) {\n        for (var j = 0; j < d; ++j) {\n          if (!(box[j] <= box[j + d])) {\n            return true;\n          }\n        }\n\n        return false;\n      } //Unpack boxes into a flat typed array, remove empty boxes\n\n\n      function convertBoxes(boxes, d, data, ids) {\n        var ptr = 0;\n        var count = 0;\n\n        for (var i = 0, n = boxes.length; i < n; ++i) {\n          var b = boxes[i];\n\n          if (boxEmpty(d, b)) {\n            continue;\n          }\n\n          for (var j = 0; j < 2 * d; ++j) {\n            data[ptr++] = b[j];\n          }\n\n          ids[count++] = i;\n        }\n\n        return count;\n      } //Perform type conversions, check bounds\n\n\n      function boxIntersect(red, blue, visit, full) {\n        var n = red.length;\n        var m = blue.length; //If either array is empty, then we can skip this whole thing\n\n        if (n <= 0 || m <= 0) {\n          return;\n        } //Compute dimension, if it is 0 then we skip\n\n\n        var d = red[0].length >>> 1;\n\n        if (d <= 0) {\n          return;\n        }\n\n        var retval; //Convert red boxes\n\n        var redList = pool.mallocDouble(2 * d * n);\n        var redIds = pool.mallocInt32(n);\n        n = convertBoxes(red, d, redList, redIds);\n\n        if (n > 0) {\n          if (d === 1 && full) {\n            //Special case: 1d complete\n            sweep.init(n);\n            retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);\n          } else {\n            //Convert blue boxes\n            var blueList = pool.mallocDouble(2 * d * m);\n            var blueIds = pool.mallocInt32(m);\n            m = convertBoxes(blue, d, blueList, blueIds);\n\n            if (m > 0) {\n              sweep.init(n + m);\n\n              if (d === 1) {\n                //Special case: 1d bipartite\n                retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);\n              } else {\n                //General case:  d>1\n                retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);\n              }\n\n              pool.free(blueList);\n              pool.free(blueIds);\n            }\n          }\n\n          pool.free(redList);\n          pool.free(redIds);\n        }\n\n        return retval;\n      }\n\n      var RESULT;\n\n      function appendItem(i, j) {\n        RESULT.push([i, j]);\n      }\n\n      function intersectFullArray(x) {\n        RESULT = [];\n        boxIntersect(x, x, appendItem, true);\n        return RESULT;\n      }\n\n      function intersectBipartiteArray(x, y) {\n        RESULT = [];\n        boxIntersect(x, y, appendItem, false);\n        return RESULT;\n      } //User-friendly wrapper, handle full input and no-visitor cases\n\n\n      function boxIntersectWrapper(arg0, arg1, arg2) {\n        switch (arguments.length) {\n          case 1:\n            return intersectFullArray(arg0);\n\n          case 2:\n            if (typeof arg1 === 'function') {\n              return boxIntersect(arg0, arg0, arg1, true);\n            } else {\n              return intersectBipartiteArray(arg0, arg1);\n            }\n\n          case 3:\n            return boxIntersect(arg0, arg1, arg2, false);\n\n          default:\n            throw new Error('box-intersect: Invalid arguments');\n        }\n      }\n    }, {\n      \"./lib/intersect\": 37,\n      \"./lib/sweep\": 41,\n      \"typedarray-pool\": 308\n    }],\n    36: [function (_glvis_, module, exports) {\n      'use strict';\n\n      function full() {\n        function bruteForceRedFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n            var x0 = rb[ax + rp],\n                x1 = rb[ax + rp + d],\n                xi = ri[i];\n\n            Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n              var y0 = bb[ax + bp],\n                  y1 = bb[ax + bp + d],\n                  yi = bi[j];\n              if (y1 < x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(xi, yi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForceBlueFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n            var y0 = bb[ax + bp],\n                y1 = bb[ax + bp + d],\n                yi = bi[j];\n\n            Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n              var x0 = rb[ax + rp],\n                  x1 = rb[ax + rp + d],\n                  xi = ri[i];\n              if (y1 < x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(xi, yi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForceFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          if (re - rs > be - bs) {\n            return bruteForceRedFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n          } else {\n            return bruteForceBlueFull(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n          }\n        }\n\n        return bruteForceFull;\n      }\n\n      function partial() {\n        function bruteForceRedFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n            var x0 = rb[ax + rp],\n                x1 = rb[ax + rp + d],\n                xi = ri[i];\n\n            Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n              var y0 = bb[ax + bp],\n                  yi = bi[j];\n              if (y0 <= x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(yi, xi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForceRed(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n            var x0 = rb[ax + rp],\n                x1 = rb[ax + rp + d],\n                xi = ri[i];\n\n            Q: for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n              var y0 = bb[ax + bp],\n                  yi = bi[j];\n              if (y0 < x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(xi, yi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForceBlueFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n            var y0 = bb[ax + bp],\n                yi = bi[j];\n\n            Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n              var x0 = rb[ax + rp],\n                  x1 = rb[ax + rp + d],\n                  xi = ri[i];\n              if (y0 <= x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(yi, xi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForceBlue(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi) {\n          var es = 2 * d;\n\n          for (var j = bs, bp = es * bs; j < be; ++j, bp += es) {\n            var y0 = bb[ax + bp],\n                yi = bi[j];\n\n            Q: for (var i = rs, rp = es * rs; i < re; ++i, rp += es) {\n              var x0 = rb[ax + rp],\n                  x1 = rb[ax + rp + d],\n                  xi = ri[i];\n              if (y0 < x0 || x1 < y0) continue;\n\n              for (var k = ax + 1; k < d; ++k) {\n                var r0 = rb[k + rp],\n                    r1 = rb[k + d + rp],\n                    b0 = bb[k + bp],\n                    b1 = bb[k + d + bp];\n                if (r1 < b0 || b1 < r0) continue Q;\n              }\n\n              var rv = vv(xi, yi);\n              if (rv !== void 0) return rv;\n            }\n          }\n        }\n\n        function bruteForcePartial(d, ax, vv, fp, rs, re, rb, ri, bs, be, bb, bi) {\n          if (re - rs > be - bs) {\n            if (fp) {\n              return bruteForceRedFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n            } else {\n              return bruteForceRed(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n            }\n          } else {\n            if (fp) {\n              return bruteForceBlueFlip(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n            } else {\n              return bruteForceBlue(d, ax, vv, rs, re, rb, ri, bs, be, bb, bi);\n            }\n          }\n        }\n\n        return bruteForcePartial;\n      }\n\n      function bruteForcePlanner(isFull) {\n        return isFull ? full() : partial();\n      }\n\n      exports.partial = bruteForcePlanner(false);\n      exports.full = bruteForcePlanner(true);\n    }, {}],\n    37: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = boxIntersectIter;\n\n      var pool = _glvis_('typedarray-pool');\n\n      var bits = _glvis_('bit-twiddle');\n\n      var bruteForce = _glvis_('./brute');\n\n      var bruteForcePartial = bruteForce.partial;\n      var bruteForceFull = bruteForce.full;\n\n      var sweep = _glvis_('./sweep');\n\n      var findMedian = _glvis_('./median');\n\n      var genPartition = _glvis_('./partition'); //Twiddle parameters\n\n\n      var BRUTE_FORCE_CUTOFF = 128; //Cut off for brute force search\n\n      var SCAN_CUTOFF = 1 << 22; //Cut off for two way scan\n\n      var SCAN_COMPLETE_CUTOFF = 1 << 22; //Partition functions\n\n      var partitionInteriorContainsInterval = genPartition('!(lo>=p0)&&!(p1>=hi)');\n      var partitionStartEqual = genPartition('lo===p0');\n      var partitionStartLessThan = genPartition('lo<p0');\n      var partitionEndLessThanEqual = genPartition('hi<=p0');\n      var partitionContainsPoint = genPartition('lo<=p0&&p0<=hi');\n      var partitionContainsPointProper = genPartition('lo<p0&&p0<=hi'); //Frame size for iterative loop\n\n      var IFRAME_SIZE = 6;\n      var DFRAME_SIZE = 2; //Data for box statck\n\n      var INIT_CAPACITY = 1024;\n      var BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);\n      var BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY); //Initialize iterative loop queue\n\n      function iterInit(d, count) {\n        var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;\n        var maxInts = bits.nextPow2(IFRAME_SIZE * levels);\n\n        if (BOX_ISTACK.length < maxInts) {\n          pool.free(BOX_ISTACK);\n          BOX_ISTACK = pool.mallocInt32(maxInts);\n        }\n\n        var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);\n\n        if (BOX_DSTACK.length < maxDoubles) {\n          pool.free(BOX_DSTACK);\n          BOX_DSTACK = pool.mallocDouble(maxDoubles);\n        }\n      } //Append item to queue\n\n\n      function iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {\n        var iptr = IFRAME_SIZE * ptr;\n        BOX_ISTACK[iptr] = axis;\n        BOX_ISTACK[iptr + 1] = redStart;\n        BOX_ISTACK[iptr + 2] = redEnd;\n        BOX_ISTACK[iptr + 3] = blueStart;\n        BOX_ISTACK[iptr + 4] = blueEnd;\n        BOX_ISTACK[iptr + 5] = state;\n        var dptr = DFRAME_SIZE * ptr;\n        BOX_DSTACK[dptr] = lo;\n        BOX_DSTACK[dptr + 1] = hi;\n      } //Special case:  Intersect single point with list of intervals\n\n\n      function onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n        var elemSize = 2 * d;\n        var bluePtr = blueOffset * elemSize;\n        var blueX = blue[bluePtr + axis];\n\n        red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n          var r0 = red[redPtr + axis];\n          var r1 = red[redPtr + axis + d];\n\n          if (blueX < r0 || r1 < blueX) {\n            continue;\n          }\n\n          if (flip && blueX === r0) {\n            continue;\n          }\n\n          var redId = redIndex[i];\n\n          for (var j = axis + 1; j < d; ++j) {\n            var r0 = red[redPtr + j];\n            var r1 = red[redPtr + j + d];\n            var b0 = blue[bluePtr + j];\n            var b1 = blue[bluePtr + j + d];\n\n            if (r1 < b0 || b1 < r0) {\n              continue red_loop;\n            }\n          }\n\n          var retval;\n\n          if (flip) {\n            retval = visit(blueId, redId);\n          } else {\n            retval = visit(redId, blueId);\n          }\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      } //Special case:  Intersect one point with list of intervals\n\n\n      function onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n        var elemSize = 2 * d;\n        var bluePtr = blueOffset * elemSize;\n        var blueX = blue[bluePtr + axis];\n\n        red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n          var redId = redIndex[i];\n\n          if (redId === blueId) {\n            continue;\n          }\n\n          var r0 = red[redPtr + axis];\n          var r1 = red[redPtr + axis + d];\n\n          if (blueX < r0 || r1 < blueX) {\n            continue;\n          }\n\n          for (var j = axis + 1; j < d; ++j) {\n            var r0 = red[redPtr + j];\n            var r1 = red[redPtr + j + d];\n            var b0 = blue[bluePtr + j];\n            var b1 = blue[bluePtr + j + d];\n\n            if (r1 < b0 || b1 < r0) {\n              continue red_loop;\n            }\n          }\n\n          var retval = visit(redId, blueId);\n\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      } //The main box intersection routine\n\n\n      function boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {\n        //Reserve memory for stack\n        iterInit(d, xSize + ySize);\n        var top = 0;\n        var elemSize = 2 * d;\n        var retval;\n        iterPush(top++, 0, 0, xSize, 0, ySize, initFull ? 16 : 0, -Infinity, Infinity);\n\n        if (!initFull) {\n          iterPush(top++, 0, 0, ySize, 0, xSize, 1, -Infinity, Infinity);\n        }\n\n        while (top > 0) {\n          top -= 1;\n          var iptr = top * IFRAME_SIZE;\n          var axis = BOX_ISTACK[iptr];\n          var redStart = BOX_ISTACK[iptr + 1];\n          var redEnd = BOX_ISTACK[iptr + 2];\n          var blueStart = BOX_ISTACK[iptr + 3];\n          var blueEnd = BOX_ISTACK[iptr + 4];\n          var state = BOX_ISTACK[iptr + 5];\n          var dptr = top * DFRAME_SIZE;\n          var lo = BOX_DSTACK[dptr];\n          var hi = BOX_DSTACK[dptr + 1]; //Unpack state info\n\n          var flip = state & 1;\n          var full = !!(state & 16); //Unpack indices\n\n          var red = xBoxes;\n          var redIndex = xIndex;\n          var blue = yBoxes;\n          var blueIndex = yIndex;\n\n          if (flip) {\n            red = yBoxes;\n            redIndex = yIndex;\n            blue = xBoxes;\n            blueIndex = xIndex;\n          }\n\n          if (state & 2) {\n            redEnd = partitionStartLessThan(d, axis, redStart, redEnd, red, redIndex, hi);\n\n            if (redStart >= redEnd) {\n              continue;\n            }\n          }\n\n          if (state & 4) {\n            redStart = partitionEndLessThanEqual(d, axis, redStart, redEnd, red, redIndex, lo);\n\n            if (redStart >= redEnd) {\n              continue;\n            }\n          }\n\n          var redCount = redEnd - redStart;\n          var blueCount = blueEnd - blueStart;\n\n          if (full) {\n            if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n              retval = sweep.scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n\n              continue;\n            }\n          } else {\n            if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n              //If input small, then use brute force\n              retval = bruteForcePartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n\n              continue;\n            } else if (d * redCount * blueCount < SCAN_CUTOFF) {\n              //If input medium sized, then use sweep and prune\n              retval = sweep.scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n\n              continue;\n            }\n          } //First, find all red intervals whose interior contains (lo,hi)\n\n\n          var red0 = partitionInteriorContainsInterval(d, axis, redStart, redEnd, red, redIndex, lo, hi); //Lower dimensional case\n\n          if (redStart < red0) {\n            if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n              //Special case for small inputs: use brute force\n              retval = bruteForceFull(d, axis + 1, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            } else if (axis === d - 2) {\n              if (flip) {\n                retval = sweep.sweepBipartite(d, visit, blueStart, blueEnd, blue, blueIndex, redStart, red0, red, redIndex);\n              } else {\n                retval = sweep.sweepBipartite(d, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n              }\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            } else {\n              iterPush(top++, axis + 1, redStart, red0, blueStart, blueEnd, flip, -Infinity, Infinity);\n              iterPush(top++, axis + 1, blueStart, blueEnd, redStart, red0, flip ^ 1, -Infinity, Infinity);\n            }\n          } //Divide and conquer phase\n\n\n          if (red0 < redEnd) {\n            //Cut blue into 3 parts:\n            //\n            //  Points < mid point\n            //  Points = mid point\n            //  Points > mid point\n            //\n            var blue0 = findMedian(d, axis, blueStart, blueEnd, blue, blueIndex);\n            var mid = blue[elemSize * blue0 + axis];\n            var blue1 = partitionStartEqual(d, axis, blue0, blueEnd, blue, blueIndex, mid); //Right case\n\n            if (blue1 < blueEnd) {\n              iterPush(top++, axis, red0, redEnd, blue1, blueEnd, (flip | 4) + (full ? 16 : 0), mid, hi);\n            } //Left case\n\n\n            if (blueStart < blue0) {\n              iterPush(top++, axis, red0, redEnd, blueStart, blue0, (flip | 2) + (full ? 16 : 0), lo, mid);\n            } //Center case (the hard part)\n\n\n            if (blue0 + 1 === blue1) {\n              //Optimization: Range with exactly 1 point, use a brute force scan\n              if (full) {\n                retval = onePointFull(d, axis, visit, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n              } else {\n                retval = onePointPartial(d, axis, visit, flip, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n              }\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            } else if (blue0 < blue1) {\n              var red1;\n\n              if (full) {\n                //If full intersection, need to handle special case\n                red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n\n                if (red0 < red1) {\n                  var redX = partitionStartEqual(d, axis, red0, red1, red, redIndex, mid);\n\n                  if (axis === d - 2) {\n                    //Degenerate sweep intersection:\n                    //  [red0, redX] with [blue0, blue1]\n                    if (red0 < redX) {\n                      retval = sweep.sweepComplete(d, visit, red0, redX, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                      if (retval !== void 0) {\n                        return retval;\n                      }\n                    } //Normal sweep intersection:\n                    //  [redX, red1] with [blue0, blue1]\n\n\n                    if (redX < red1) {\n                      retval = sweep.sweepBipartite(d, visit, redX, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n\n                      if (retval !== void 0) {\n                        return retval;\n                      }\n                    }\n                  } else {\n                    if (red0 < redX) {\n                      iterPush(top++, axis + 1, red0, redX, blue0, blue1, 16, -Infinity, Infinity);\n                    }\n\n                    if (redX < red1) {\n                      iterPush(top++, axis + 1, redX, red1, blue0, blue1, 0, -Infinity, Infinity);\n                      iterPush(top++, axis + 1, blue0, blue1, redX, red1, 1, -Infinity, Infinity);\n                    }\n                  }\n                }\n              } else {\n                if (flip) {\n                  red1 = partitionContainsPointProper(d, axis, red0, redEnd, red, redIndex, mid);\n                } else {\n                  red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n                }\n\n                if (red0 < red1) {\n                  if (axis === d - 2) {\n                    if (flip) {\n                      retval = sweep.sweepBipartite(d, visit, blue0, blue1, blue, blueIndex, red0, red1, red, redIndex);\n                    } else {\n                      retval = sweep.sweepBipartite(d, visit, red0, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n                    }\n                  } else {\n                    iterPush(top++, axis + 1, red0, red1, blue0, blue1, flip, -Infinity, Infinity);\n                    iterPush(top++, axis + 1, blue0, blue1, red0, red1, flip ^ 1, -Infinity, Infinity);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }, {\n      \"./brute\": 36,\n      \"./median\": 38,\n      \"./partition\": 39,\n      \"./sweep\": 41,\n      \"bit-twiddle\": 32,\n      \"typedarray-pool\": 308\n    }],\n    38: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = findMedian;\n\n      var genPartition = _glvis_('./partition');\n\n      var partitionStartLessThan = genPartition('lo<p0');\n      var PARTITION_THRESHOLD = 8; //Cut off for using insertion sort in findMedian\n      //Base case for median finding:  Use insertion sort\n\n      function insertionSort(d, axis, start, end, boxes, ids) {\n        var elemSize = 2 * d;\n        var boxPtr = elemSize * (start + 1) + axis;\n\n        for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {\n          var x = boxes[boxPtr];\n\n          for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {\n            //Swap\n            var aPtr = ptr;\n            var bPtr = ptr + elemSize;\n\n            for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {\n              var y = boxes[aPtr];\n              boxes[aPtr] = boxes[bPtr];\n              boxes[bPtr] = y;\n            }\n\n            var tmp = ids[j];\n            ids[j] = ids[j - 1];\n            ids[j - 1] = tmp;\n          }\n        }\n      } //Find median using quick select algorithm\n      //  takes O(n) time with high probability\n\n\n      function findMedian(d, axis, start, end, boxes, ids) {\n        if (end <= start + 1) {\n          return start;\n        }\n\n        var lo = start;\n        var hi = end;\n        var mid = end + start >>> 1;\n        var elemSize = 2 * d;\n        var pivot = mid;\n        var value = boxes[elemSize * mid + axis];\n\n        while (lo < hi) {\n          if (hi - lo < PARTITION_THRESHOLD) {\n            insertionSort(d, axis, lo, hi, boxes, ids);\n            value = boxes[elemSize * mid + axis];\n            break;\n          } //Select pivot using median-of-3\n\n\n          var count = hi - lo;\n          var pivot0 = Math.random() * count + lo | 0;\n          var value0 = boxes[elemSize * pivot0 + axis];\n          var pivot1 = Math.random() * count + lo | 0;\n          var value1 = boxes[elemSize * pivot1 + axis];\n          var pivot2 = Math.random() * count + lo | 0;\n          var value2 = boxes[elemSize * pivot2 + axis];\n\n          if (value0 <= value1) {\n            if (value2 >= value1) {\n              pivot = pivot1;\n              value = value1;\n            } else if (value0 >= value2) {\n              pivot = pivot0;\n              value = value0;\n            } else {\n              pivot = pivot2;\n              value = value2;\n            }\n          } else {\n            if (value1 >= value2) {\n              pivot = pivot1;\n              value = value1;\n            } else if (value2 >= value0) {\n              pivot = pivot0;\n              value = value0;\n            } else {\n              pivot = pivot2;\n              value = value2;\n            }\n          } //Swap pivot to end of array\n\n\n          var aPtr = elemSize * (hi - 1);\n          var bPtr = elemSize * pivot;\n\n          for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n            var x = boxes[aPtr];\n            boxes[aPtr] = boxes[bPtr];\n            boxes[bPtr] = x;\n          }\n\n          var y = ids[hi - 1];\n          ids[hi - 1] = ids[pivot];\n          ids[pivot] = y; //Partition using pivot\n\n          pivot = partitionStartLessThan(d, axis, lo, hi - 1, boxes, ids, value); //Swap pivot back\n\n          var aPtr = elemSize * (hi - 1);\n          var bPtr = elemSize * pivot;\n\n          for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {\n            var x = boxes[aPtr];\n            boxes[aPtr] = boxes[bPtr];\n            boxes[bPtr] = x;\n          }\n\n          var y = ids[hi - 1];\n          ids[hi - 1] = ids[pivot];\n          ids[pivot] = y; //Swap pivot to last pivot\n\n          if (mid < pivot) {\n            hi = pivot - 1;\n\n            while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {\n              hi -= 1;\n            }\n\n            hi += 1;\n          } else if (pivot < mid) {\n            lo = pivot + 1;\n\n            while (lo < hi && boxes[elemSize * lo + axis] === value) {\n              lo += 1;\n            }\n          } else {\n            break;\n          }\n        } //Make sure pivot is at start\n\n\n        return partitionStartLessThan(d, axis, start, mid, boxes, ids, boxes[elemSize * mid + axis]);\n      }\n    }, {\n      \"./partition\": 39\n    }],\n    39: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = genPartition;\n      var P2F = {\n        'lo===p0': lo_equal_p0,\n        'lo<p0': lo_lessThan_p0,\n        'lo<=p0': lo_lessOrEqual_p0,\n        'hi<=p0': hi_lessOrEqual_p0,\n        'lo<p0&&p0<=hi': lo_lessThan_p0_and_p0_lessOrEqual_hi,\n        'lo<=p0&&p0<=hi': lo_lassOrEqual_p0_and_p0_lessOrEqual_hi,\n        '!(lo>=p0)&&!(p1>=hi)': lo_lessThan_p0_and_p1_lessThan_hi\n      };\n\n      function genPartition(predicate) {\n        return P2F[predicate];\n      } // lo===p0\n\n\n      function lo_equal_p0(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var lo = e[k + n];\n          if (lo === p0) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // lo<p0\n\n\n      function lo_lessThan_p0(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var lo = e[k + n];\n          if (lo < p0) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // lo<=p0\n\n\n      function lo_lessOrEqual_p0(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var hi = e[k + o];\n          if (hi <= p0) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // hi<=p0\n\n\n      function hi_lessOrEqual_p0(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var hi = e[k + o];\n          if (hi <= p0) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // lo<=p0&&p0<=hi\n\n\n      function lo_lassOrEqual_p0_and_p0_lessOrEqual_hi(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var lo = e[k + n],\n              hi = e[k + o];\n          if (lo <= p0 && p0 <= hi) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // lo<p0&&p0<=hi\n\n\n      function lo_lessThan_p0_and_p0_lessOrEqual_hi(a, b, c, d, e, f, p0) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var lo = e[k + n],\n              hi = e[k + o];\n          if (lo < p0 && p0 <= hi) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      } // !(lo>=p0)&&!(p1>=hi)\n\n\n      function lo_lessThan_p0_and_p1_lessThan_hi(a, b, c, d, e, f, p0, p1) {\n        for (var j = 2 * a, k = j * c, l = k, m = c, n = b, o = a + b, p = c; d > p; ++p, k += j) {\n          var lo = e[k + n],\n              hi = e[k + o];\n          if (!(lo >= p0) && !(p1 >= hi)) if (m === p) m += 1, l += j;else {\n            for (var s = 0; j > s; ++s) {\n              var t = e[k + s];\n              e[k + s] = e[l], e[l++] = t;\n            }\n\n            var u = f[p];\n            f[p] = f[m], f[m++] = u;\n          }\n        }\n\n        return m;\n      }\n    }, {}],\n    40: [function (_glvis_, module, exports) {\n      'use strict'; //This code is extracted from ndarray-sort\n      //It is inlined here as a temporary workaround\n\n      module.exports = wrapper;\n      var INSERT_SORT_CUTOFF = 32;\n\n      function wrapper(data, n0) {\n        if (n0 <= 4 * INSERT_SORT_CUTOFF) {\n          insertionSort(0, n0 - 1, data);\n        } else {\n          quickSort(0, n0 - 1, data);\n        }\n      }\n\n      function insertionSort(left, right, data) {\n        var ptr = 2 * (left + 1);\n\n        for (var i = left + 1; i <= right; ++i) {\n          var a = data[ptr++];\n          var b = data[ptr++];\n          var j = i;\n          var jptr = ptr - 2;\n\n          while (j-- > left) {\n            var x = data[jptr - 2];\n            var y = data[jptr - 1];\n\n            if (x < a) {\n              break;\n            } else if (x === a && y < b) {\n              break;\n            }\n\n            data[jptr] = x;\n            data[jptr + 1] = y;\n            jptr -= 2;\n          }\n\n          data[jptr] = a;\n          data[jptr + 1] = b;\n        }\n      }\n\n      function swap(i, j, data) {\n        i *= 2;\n        j *= 2;\n        var x = data[i];\n        var y = data[i + 1];\n        data[i] = data[j];\n        data[i + 1] = data[j + 1];\n        data[j] = x;\n        data[j + 1] = y;\n      }\n\n      function move(i, j, data) {\n        i *= 2;\n        j *= 2;\n        data[i] = data[j];\n        data[i + 1] = data[j + 1];\n      }\n\n      function rotate(i, j, k, data) {\n        i *= 2;\n        j *= 2;\n        k *= 2;\n        var x = data[i];\n        var y = data[i + 1];\n        data[i] = data[j];\n        data[i + 1] = data[j + 1];\n        data[j] = data[k];\n        data[j + 1] = data[k + 1];\n        data[k] = x;\n        data[k + 1] = y;\n      }\n\n      function shufflePivot(i, j, px, py, data) {\n        i *= 2;\n        j *= 2;\n        data[i] = data[j];\n        data[j] = px;\n        data[i + 1] = data[j + 1];\n        data[j + 1] = py;\n      }\n\n      function compare(i, j, data) {\n        i *= 2;\n        j *= 2;\n        var x = data[i],\n            y = data[j];\n\n        if (x < y) {\n          return false;\n        } else if (x === y) {\n          return data[i + 1] > data[j + 1];\n        }\n\n        return true;\n      }\n\n      function comparePivot(i, y, b, data) {\n        i *= 2;\n        var x = data[i];\n\n        if (x < y) {\n          return true;\n        } else if (x === y) {\n          return data[i + 1] < b;\n        }\n\n        return false;\n      }\n\n      function quickSort(left, right, data) {\n        var sixth = (right - left + 1) / 6 | 0,\n            index1 = left + sixth,\n            index5 = right - sixth,\n            index3 = left + right >> 1,\n            index2 = index3 - sixth,\n            index4 = index3 + sixth,\n            el1 = index1,\n            el2 = index2,\n            el3 = index3,\n            el4 = index4,\n            el5 = index5,\n            less = left + 1,\n            great = right - 1,\n            tmp = 0;\n\n        if (compare(el1, el2, data)) {\n          tmp = el1;\n          el1 = el2;\n          el2 = tmp;\n        }\n\n        if (compare(el4, el5, data)) {\n          tmp = el4;\n          el4 = el5;\n          el5 = tmp;\n        }\n\n        if (compare(el1, el3, data)) {\n          tmp = el1;\n          el1 = el3;\n          el3 = tmp;\n        }\n\n        if (compare(el2, el3, data)) {\n          tmp = el2;\n          el2 = el3;\n          el3 = tmp;\n        }\n\n        if (compare(el1, el4, data)) {\n          tmp = el1;\n          el1 = el4;\n          el4 = tmp;\n        }\n\n        if (compare(el3, el4, data)) {\n          tmp = el3;\n          el3 = el4;\n          el4 = tmp;\n        }\n\n        if (compare(el2, el5, data)) {\n          tmp = el2;\n          el2 = el5;\n          el5 = tmp;\n        }\n\n        if (compare(el2, el3, data)) {\n          tmp = el2;\n          el2 = el3;\n          el3 = tmp;\n        }\n\n        if (compare(el4, el5, data)) {\n          tmp = el4;\n          el4 = el5;\n          el5 = tmp;\n        }\n\n        var pivot1X = data[2 * el2];\n        var pivot1Y = data[2 * el2 + 1];\n        var pivot2X = data[2 * el4];\n        var pivot2Y = data[2 * el4 + 1];\n        var ptr0 = 2 * el1;\n        var ptr2 = 2 * el3;\n        var ptr4 = 2 * el5;\n        var ptr5 = 2 * index1;\n        var ptr6 = 2 * index3;\n        var ptr7 = 2 * index5;\n\n        for (var i1 = 0; i1 < 2; ++i1) {\n          var x = data[ptr0 + i1];\n          var y = data[ptr2 + i1];\n          var z = data[ptr4 + i1];\n          data[ptr5 + i1] = x;\n          data[ptr6 + i1] = y;\n          data[ptr7 + i1] = z;\n        }\n\n        move(index2, left, data);\n        move(index4, right, data);\n\n        for (var k = less; k <= great; ++k) {\n          if (comparePivot(k, pivot1X, pivot1Y, data)) {\n            if (k !== less) {\n              swap(k, less, data);\n            }\n\n            ++less;\n          } else {\n            if (!comparePivot(k, pivot2X, pivot2Y, data)) {\n              while (true) {\n                if (!comparePivot(great, pivot2X, pivot2Y, data)) {\n                  if (--great < k) {\n                    break;\n                  }\n\n                  continue;\n                } else {\n                  if (comparePivot(great, pivot1X, pivot1Y, data)) {\n                    rotate(k, less, great, data);\n                    ++less;\n                    --great;\n                  } else {\n                    swap(k, great, data);\n                    --great;\n                  }\n\n                  break;\n                }\n              }\n            }\n          }\n        }\n\n        shufflePivot(left, less - 1, pivot1X, pivot1Y, data);\n        shufflePivot(right, great + 1, pivot2X, pivot2Y, data);\n\n        if (less - 2 - left <= INSERT_SORT_CUTOFF) {\n          insertionSort(left, less - 2, data);\n        } else {\n          quickSort(left, less - 2, data);\n        }\n\n        if (right - (great + 2) <= INSERT_SORT_CUTOFF) {\n          insertionSort(great + 2, right, data);\n        } else {\n          quickSort(great + 2, right, data);\n        }\n\n        if (great - less <= INSERT_SORT_CUTOFF) {\n          insertionSort(less, great, data);\n        } else {\n          quickSort(less, great, data);\n        }\n      }\n    }, {}],\n    41: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = {\n        init: sqInit,\n        sweepBipartite: sweepBipartite,\n        sweepComplete: sweepComplete,\n        scanBipartite: scanBipartite,\n        scanComplete: scanComplete\n      };\n\n      var pool = _glvis_('typedarray-pool');\n\n      var bits = _glvis_('bit-twiddle');\n\n      var isort = _glvis_('./sort'); //Flag for blue\n\n\n      var BLUE_FLAG = 1 << 28; //1D sweep event queue stuff (use pool to save space)\n\n      var INIT_CAPACITY = 1024;\n      var RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\n      var RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\n      var BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\n      var BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\n      var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\n      var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\n      var SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8); //Reserves memory for the 1D sweep data structures\n\n      function sqInit(count) {\n        var rcount = bits.nextPow2(count);\n\n        if (RED_SWEEP_QUEUE.length < rcount) {\n          pool.free(RED_SWEEP_QUEUE);\n          RED_SWEEP_QUEUE = pool.mallocInt32(rcount);\n        }\n\n        if (RED_SWEEP_INDEX.length < rcount) {\n          pool.free(RED_SWEEP_INDEX);\n          RED_SWEEP_INDEX = pool.mallocInt32(rcount);\n        }\n\n        if (BLUE_SWEEP_QUEUE.length < rcount) {\n          pool.free(BLUE_SWEEP_QUEUE);\n          BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);\n        }\n\n        if (BLUE_SWEEP_INDEX.length < rcount) {\n          pool.free(BLUE_SWEEP_INDEX);\n          BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);\n        }\n\n        if (COMMON_SWEEP_QUEUE.length < rcount) {\n          pool.free(COMMON_SWEEP_QUEUE);\n          COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);\n        }\n\n        if (COMMON_SWEEP_INDEX.length < rcount) {\n          pool.free(COMMON_SWEEP_INDEX);\n          COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);\n        }\n\n        var eventLength = 8 * rcount;\n\n        if (SWEEP_EVENTS.length < eventLength) {\n          pool.free(SWEEP_EVENTS);\n          SWEEP_EVENTS = pool.mallocDouble(eventLength);\n        }\n      } //Remove an item from the active queue in O(1)\n\n\n      function sqPop(queue, index, count, item) {\n        var idx = index[item];\n        var top = queue[count - 1];\n        queue[idx] = top;\n        index[top] = idx;\n      } //Insert an item into the active queue in O(1)\n\n\n      function sqPush(queue, index, count, item) {\n        queue[count] = item;\n        index[item] = count;\n      } //Recursion base case: use 1D sweep algorithm\n\n\n      function sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n        //store events as pairs [coordinate, idx]\n        //\n        //  red create:  -(idx+1)\n        //  red destroy: idx\n        //  blue create: -(idx+BLUE_FLAG)\n        //  blue destroy: idx+BLUE_FLAG\n        //\n        var ptr = 0;\n        var elemSize = 2 * d;\n        var istart = d - 1;\n        var iend = elemSize - 1;\n\n        for (var i = redStart; i < redEnd; ++i) {\n          var idx = redIndex[i];\n          var redOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n          SWEEP_EVENTS[ptr++] = -(idx + 1);\n          SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx;\n        }\n\n        for (var i = blueStart; i < blueEnd; ++i) {\n          var idx = blueIndex[i] + BLUE_FLAG;\n          var blueOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx;\n        } //process events from left->right\n\n\n        var n = ptr >>> 1;\n        isort(SWEEP_EVENTS, n);\n        var redActive = 0;\n        var blueActive = 0;\n\n        for (var i = 0; i < n; ++i) {\n          var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n          if (e >= BLUE_FLAG) {\n            //blue destroy event\n            e = e - BLUE_FLAG | 0;\n            sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);\n          } else if (e >= 0) {\n            //red destroy event\n            sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);\n          } else if (e <= -BLUE_FLAG) {\n            //blue create event\n            e = -e - BLUE_FLAG | 0;\n\n            for (var j = 0; j < redActive; ++j) {\n              var retval = visit(RED_SWEEP_QUEUE[j], e);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            }\n\n            sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);\n          } else {\n            //red create event\n            e = -e - 1 | 0;\n\n            for (var j = 0; j < blueActive; ++j) {\n              var retval = visit(e, BLUE_SWEEP_QUEUE[j]);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            }\n\n            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);\n          }\n        }\n      } //Complete sweep\n\n\n      function sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n        var ptr = 0;\n        var elemSize = 2 * d;\n        var istart = d - 1;\n        var iend = elemSize - 1;\n\n        for (var i = redStart; i < redEnd; ++i) {\n          var idx = redIndex[i] + 1 << 1;\n          var redOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n          SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx;\n        }\n\n        for (var i = blueStart; i < blueEnd; ++i) {\n          var idx = blueIndex[i] + 1 << 1;\n          var blueOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx | 1;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx | 1;\n        } //process events from left->right\n\n\n        var n = ptr >>> 1;\n        isort(SWEEP_EVENTS, n);\n        var redActive = 0;\n        var blueActive = 0;\n        var commonActive = 0;\n\n        for (var i = 0; i < n; ++i) {\n          var e = SWEEP_EVENTS[2 * i + 1] | 0;\n          var color = e & 1;\n\n          if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {\n            color = 2;\n            i += 1;\n          }\n\n          if (e < 0) {\n            //Create event\n            var id = -(e >> 1) - 1; //Intersect with common\n\n            for (var j = 0; j < commonActive; ++j) {\n              var retval = visit(COMMON_SWEEP_QUEUE[j], id);\n\n              if (retval !== void 0) {\n                return retval;\n              }\n            }\n\n            if (color !== 0) {\n              //Intersect with red\n              for (var j = 0; j < redActive; ++j) {\n                var retval = visit(RED_SWEEP_QUEUE[j], id);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            }\n\n            if (color !== 1) {\n              //Intersect with blue\n              for (var j = 0; j < blueActive; ++j) {\n                var retval = visit(BLUE_SWEEP_QUEUE[j], id);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            }\n\n            if (color === 0) {\n              //Red\n              sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);\n            } else if (color === 1) {\n              //Blue\n              sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);\n            } else if (color === 2) {\n              //Both\n              sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);\n            }\n          } else {\n            //Destroy event\n            var id = (e >> 1) - 1;\n\n            if (color === 0) {\n              //Red\n              sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);\n            } else if (color === 1) {\n              //Blue\n              sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);\n            } else if (color === 2) {\n              //Both\n              sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);\n            }\n          }\n        }\n      } //Sweep and prune/scanline algorithm:\n      //  Scan along axis, detect intersections\n      //  Brute force all boxes along axis\n\n\n      function scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n        var ptr = 0;\n        var elemSize = 2 * d;\n        var istart = axis;\n        var iend = axis + d;\n        var redShift = 1;\n        var blueShift = 1;\n\n        if (flip) {\n          blueShift = BLUE_FLAG;\n        } else {\n          redShift = BLUE_FLAG;\n        }\n\n        for (var i = redStart; i < redEnd; ++i) {\n          var idx = i + redShift;\n          var redOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n          SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx;\n        }\n\n        for (var i = blueStart; i < blueEnd; ++i) {\n          var idx = i + blueShift;\n          var blueOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n        } //process events from left->right\n\n\n        var n = ptr >>> 1;\n        isort(SWEEP_EVENTS, n);\n        var redActive = 0;\n\n        for (var i = 0; i < n; ++i) {\n          var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n          if (e < 0) {\n            var idx = -e;\n            var isRed = false;\n\n            if (idx >= BLUE_FLAG) {\n              isRed = !flip;\n              idx -= BLUE_FLAG;\n            } else {\n              isRed = !!flip;\n              idx -= 1;\n            }\n\n            if (isRed) {\n              sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);\n            } else {\n              var blueId = blueIndex[idx];\n              var bluePtr = elemSize * idx;\n              var b0 = blue[bluePtr + axis + 1];\n              var b1 = blue[bluePtr + axis + 1 + d];\n\n              red_loop: for (var j = 0; j < redActive; ++j) {\n                var oidx = RED_SWEEP_QUEUE[j];\n                var redPtr = elemSize * oidx;\n\n                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n                  continue;\n                }\n\n                for (var k = axis + 2; k < d; ++k) {\n                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n                    continue red_loop;\n                  }\n                }\n\n                var redId = redIndex[oidx];\n                var retval;\n\n                if (flip) {\n                  retval = visit(blueId, redId);\n                } else {\n                  retval = visit(redId, blueId);\n                }\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            }\n          } else {\n            sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);\n          }\n        }\n      }\n\n      function scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n        var ptr = 0;\n        var elemSize = 2 * d;\n        var istart = axis;\n        var iend = axis + d;\n\n        for (var i = redStart; i < redEnd; ++i) {\n          var idx = i + BLUE_FLAG;\n          var redOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n          SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n          SWEEP_EVENTS[ptr++] = idx;\n        }\n\n        for (var i = blueStart; i < blueEnd; ++i) {\n          var idx = i + 1;\n          var blueOffset = elemSize * i;\n          SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n          SWEEP_EVENTS[ptr++] = -idx;\n        } //process events from left->right\n\n\n        var n = ptr >>> 1;\n        isort(SWEEP_EVENTS, n);\n        var redActive = 0;\n\n        for (var i = 0; i < n; ++i) {\n          var e = SWEEP_EVENTS[2 * i + 1] | 0;\n\n          if (e < 0) {\n            var idx = -e;\n\n            if (idx >= BLUE_FLAG) {\n              RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;\n            } else {\n              idx -= 1;\n              var blueId = blueIndex[idx];\n              var bluePtr = elemSize * idx;\n              var b0 = blue[bluePtr + axis + 1];\n              var b1 = blue[bluePtr + axis + 1 + d];\n\n              red_loop: for (var j = 0; j < redActive; ++j) {\n                var oidx = RED_SWEEP_QUEUE[j];\n                var redId = redIndex[oidx];\n\n                if (redId === blueId) {\n                  break;\n                }\n\n                var redPtr = elemSize * oidx;\n\n                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n                  continue;\n                }\n\n                for (var k = axis + 2; k < d; ++k) {\n                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n                    continue red_loop;\n                  }\n                }\n\n                var retval = visit(redId, blueId);\n\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            }\n          } else {\n            var idx = e - BLUE_FLAG;\n\n            for (var j = redActive - 1; j >= 0; --j) {\n              if (RED_SWEEP_QUEUE[j] === idx) {\n                for (var k = j + 1; k < redActive; ++k) {\n                  RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];\n                }\n\n                break;\n              }\n            }\n\n            --redActive;\n          }\n        }\n      }\n    }, {\n      \"./sort\": 40,\n      \"bit-twiddle\": 32,\n      \"typedarray-pool\": 308\n    }],\n    42: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var monotoneTriangulate = _glvis_('./lib/monotone');\n\n      var makeIndex = _glvis_('./lib/triangulation');\n\n      var delaunayFlip = _glvis_('./lib/delaunay');\n\n      var filterTriangulation = _glvis_('./lib/filter');\n\n      module.exports = cdt2d;\n\n      function canonicalizeEdge(e) {\n        return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];\n      }\n\n      function compareEdge(a, b) {\n        return a[0] - b[0] || a[1] - b[1];\n      }\n\n      function canonicalizeEdges(edges) {\n        return edges.map(canonicalizeEdge).sort(compareEdge);\n      }\n\n      function getDefault(options, property, dflt) {\n        if (property in options) {\n          return options[property];\n        }\n\n        return dflt;\n      }\n\n      function cdt2d(points, edges, options) {\n        if (!Array.isArray(edges)) {\n          options = edges || {};\n          edges = [];\n        } else {\n          options = options || {};\n          edges = edges || [];\n        } //Parse out options\n\n\n        var delaunay = !!getDefault(options, 'delaunay', true);\n        var interior = !!getDefault(options, 'interior', true);\n        var exterior = !!getDefault(options, 'exterior', true);\n        var infinity = !!getDefault(options, 'infinity', false); //Handle trivial case\n\n        if (!interior && !exterior || points.length === 0) {\n          return [];\n        } //Construct initial triangulation\n\n\n        var cells = monotoneTriangulate(points, edges); //If delaunay refinement needed, then improve quality by edge flipping\n\n        if (delaunay || interior !== exterior || infinity) {\n          //Index all of the cells to support fast neighborhood queries\n          var triangulation = makeIndex(points.length, canonicalizeEdges(edges));\n\n          for (var i = 0; i < cells.length; ++i) {\n            var f = cells[i];\n            triangulation.addTriangle(f[0], f[1], f[2]);\n          } //Run edge flipping\n\n\n          if (delaunay) {\n            delaunayFlip(points, triangulation);\n          } //Filter points\n\n\n          if (!exterior) {\n            return filterTriangulation(triangulation, -1);\n          } else if (!interior) {\n            return filterTriangulation(triangulation, 1, infinity);\n          } else if (infinity) {\n            return filterTriangulation(triangulation, 0, infinity);\n          } else {\n            return triangulation.cells();\n          }\n        } else {\n          return cells;\n        }\n      }\n    }, {\n      \"./lib/delaunay\": 43,\n      \"./lib/filter\": 44,\n      \"./lib/monotone\": 45,\n      \"./lib/triangulation\": 46\n    }],\n    43: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var inCircle = _glvis_('robust-in-sphere')[4];\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      module.exports = delaunayRefine;\n\n      function testFlip(points, triangulation, stack, a, b, x) {\n        var y = triangulation.opposite(a, b); //Test boundary edge\n\n        if (y < 0) {\n          return;\n        } //Swap edge if order flipped\n\n\n        if (b < a) {\n          var tmp = a;\n          a = b;\n          b = tmp;\n          tmp = x;\n          x = y;\n          y = tmp;\n        } //Test if edge is constrained\n\n\n        if (triangulation.isConstraint(a, b)) {\n          return;\n        } //Test if edge is delaunay\n\n\n        if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n          stack.push(a, b);\n        }\n      } //Assume edges are sorted lexicographically\n\n\n      function delaunayRefine(points, triangulation) {\n        var stack = [];\n        var numPoints = points.length;\n        var stars = triangulation.stars;\n\n        for (var a = 0; a < numPoints; ++a) {\n          var star = stars[a];\n\n          for (var j = 1; j < star.length; j += 2) {\n            var b = star[j]; //If order is not consistent, then skip edge\n\n            if (b < a) {\n              continue;\n            } //Check if edge is constrained\n\n\n            if (triangulation.isConstraint(a, b)) {\n              continue;\n            } //Find opposite edge\n\n\n            var x = star[j - 1],\n                y = -1;\n\n            for (var k = 1; k < star.length; k += 2) {\n              if (star[k - 1] === b) {\n                y = star[k];\n                break;\n              }\n            } //If this is a boundary edge, don't flip it\n\n\n            if (y < 0) {\n              continue;\n            } //If edge is in circle, flip it\n\n\n            if (inCircle(points[a], points[b], points[x], points[y]) < 0) {\n              stack.push(a, b);\n            }\n          }\n        }\n\n        while (stack.length > 0) {\n          var b = stack.pop();\n          var a = stack.pop(); //Find opposite pairs\n\n          var x = -1,\n              y = -1;\n          var star = stars[a];\n\n          for (var i = 1; i < star.length; i += 2) {\n            var s = star[i - 1];\n            var t = star[i];\n\n            if (s === b) {\n              y = t;\n            } else if (t === b) {\n              x = s;\n            }\n          } //If x/y are both valid then skip edge\n\n\n          if (x < 0 || y < 0) {\n            continue;\n          } //If edge is now delaunay, then don't flip it\n\n\n          if (inCircle(points[a], points[b], points[x], points[y]) >= 0) {\n            continue;\n          } //Flip the edge\n\n\n          triangulation.flip(a, b); //Test flipping neighboring edges\n\n          testFlip(points, triangulation, stack, x, a, y);\n          testFlip(points, triangulation, stack, a, y, x);\n          testFlip(points, triangulation, stack, y, b, x);\n          testFlip(points, triangulation, stack, b, x, y);\n        }\n      }\n    }, {\n      \"binary-search-bounds\": 31,\n      \"robust-in-sphere\": 282\n    }],\n    44: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      module.exports = classifyFaces;\n\n      function FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n        this.cells = cells;\n        this.neighbor = neighbor;\n        this.flags = flags;\n        this.constraint = constraint;\n        this.active = active;\n        this.next = next;\n        this.boundary = boundary;\n      }\n\n      var proto = FaceIndex.prototype;\n\n      function compareCell(a, b) {\n        return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];\n      }\n\n      proto.locate = function () {\n        var key = [0, 0, 0];\n        return function (a, b, c) {\n          var x = a,\n              y = b,\n              z = c;\n\n          if (b < c) {\n            if (b < a) {\n              x = b;\n              y = c;\n              z = a;\n            }\n          } else if (c < a) {\n            x = c;\n            y = a;\n            z = b;\n          }\n\n          if (x < 0) {\n            return -1;\n          }\n\n          key[0] = x;\n          key[1] = y;\n          key[2] = z;\n          return bsearch.eq(this.cells, key, compareCell);\n        };\n      }();\n\n      function indexCells(triangulation, infinity) {\n        //First get cells and canonicalize\n        var cells = triangulation.cells();\n        var nc = cells.length;\n\n        for (var i = 0; i < nc; ++i) {\n          var c = cells[i];\n          var x = c[0],\n              y = c[1],\n              z = c[2];\n\n          if (y < z) {\n            if (y < x) {\n              c[0] = y;\n              c[1] = z;\n              c[2] = x;\n            }\n          } else if (z < x) {\n            c[0] = z;\n            c[1] = x;\n            c[2] = y;\n          }\n        }\n\n        cells.sort(compareCell); //Initialize flag array\n\n        var flags = new Array(nc);\n\n        for (var i = 0; i < flags.length; ++i) {\n          flags[i] = 0;\n        } //Build neighbor index, initialize queues\n\n\n        var active = [];\n        var next = [];\n        var neighbor = new Array(3 * nc);\n        var constraint = new Array(3 * nc);\n        var boundary = null;\n\n        if (infinity) {\n          boundary = [];\n        }\n\n        var index = new FaceIndex(cells, neighbor, constraint, flags, active, next, boundary);\n\n        for (var i = 0; i < nc; ++i) {\n          var c = cells[i];\n\n          for (var j = 0; j < 3; ++j) {\n            var x = c[j],\n                y = c[(j + 1) % 3];\n            var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));\n            var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);\n\n            if (a < 0) {\n              if (b) {\n                next.push(i);\n              } else {\n                active.push(i);\n                flags[i] = 1;\n              }\n\n              if (infinity) {\n                boundary.push([y, x, -1]);\n              }\n            }\n          }\n        }\n\n        return index;\n      }\n\n      function filterCells(cells, flags, target) {\n        var ptr = 0;\n\n        for (var i = 0; i < cells.length; ++i) {\n          if (flags[i] === target) {\n            cells[ptr++] = cells[i];\n          }\n        }\n\n        cells.length = ptr;\n        return cells;\n      }\n\n      function classifyFaces(triangulation, target, infinity) {\n        var index = indexCells(triangulation, infinity);\n\n        if (target === 0) {\n          if (infinity) {\n            return index.cells.concat(index.boundary);\n          } else {\n            return index.cells;\n          }\n        }\n\n        var side = 1;\n        var active = index.active;\n        var next = index.next;\n        var flags = index.flags;\n        var cells = index.cells;\n        var constraint = index.constraint;\n        var neighbor = index.neighbor;\n\n        while (active.length > 0 || next.length > 0) {\n          while (active.length > 0) {\n            var t = active.pop();\n\n            if (flags[t] === -side) {\n              continue;\n            }\n\n            flags[t] = side;\n            var c = cells[t];\n\n            for (var j = 0; j < 3; ++j) {\n              var f = neighbor[3 * t + j];\n\n              if (f >= 0 && flags[f] === 0) {\n                if (constraint[3 * t + j]) {\n                  next.push(f);\n                } else {\n                  active.push(f);\n                  flags[f] = side;\n                }\n              }\n            }\n          } //Swap arrays and loop\n\n\n          var tmp = next;\n          next = active;\n          active = tmp;\n          next.length = 0;\n          side = -side;\n        }\n\n        var result = filterCells(cells, flags, target);\n\n        if (infinity) {\n          return result.concat(index.boundary);\n        }\n\n        return result;\n      }\n    }, {\n      \"binary-search-bounds\": 31\n    }],\n    45: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var orient = _glvis_('robust-orientation')[3];\n\n      var EVENT_POINT = 0;\n      var EVENT_END = 1;\n      var EVENT_START = 2;\n      module.exports = monotoneTriangulate; //A partial convex hull fragment, made of two unimonotone polygons\n\n      function PartialHull(a, b, idx, lowerIds, upperIds) {\n        this.a = a;\n        this.b = b;\n        this.idx = idx;\n        this.lowerIds = lowerIds;\n        this.upperIds = upperIds;\n      } //An event in the sweep line procedure\n\n\n      function Event(a, b, type, idx) {\n        this.a = a;\n        this.b = b;\n        this.type = type;\n        this.idx = idx;\n      } //This is used to compare events for the sweep line procedure\n      // Points are:\n      //  1. sorted lexicographically\n      //  2. sorted by type  (point < end < start)\n      //  3. segments sorted by winding order\n      //  4. sorted by index\n\n\n      function compareEvent(a, b) {\n        var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;\n\n        if (d) {\n          return d;\n        }\n\n        if (a.type !== EVENT_POINT) {\n          d = orient(a.a, a.b, b.b);\n\n          if (d) {\n            return d;\n          }\n        }\n\n        return a.idx - b.idx;\n      }\n\n      function testPoint(hull, p) {\n        return orient(hull.a, hull.b, p);\n      }\n\n      function addPoint(cells, hulls, points, p, idx) {\n        var lo = bsearch.lt(hulls, p, testPoint);\n        var hi = bsearch.gt(hulls, p, testPoint);\n\n        for (var i = lo; i < hi; ++i) {\n          var hull = hulls[i]; //Insert p into lower hull\n\n          var lowerIds = hull.lowerIds;\n          var m = lowerIds.length;\n\n          while (m > 1 && orient(points[lowerIds[m - 2]], points[lowerIds[m - 1]], p) > 0) {\n            cells.push([lowerIds[m - 1], lowerIds[m - 2], idx]);\n            m -= 1;\n          }\n\n          lowerIds.length = m;\n          lowerIds.push(idx); //Insert p into upper hull\n\n          var upperIds = hull.upperIds;\n          var m = upperIds.length;\n\n          while (m > 1 && orient(points[upperIds[m - 2]], points[upperIds[m - 1]], p) < 0) {\n            cells.push([upperIds[m - 2], upperIds[m - 1], idx]);\n            m -= 1;\n          }\n\n          upperIds.length = m;\n          upperIds.push(idx);\n        }\n      }\n\n      function findSplit(hull, edge) {\n        var d;\n\n        if (hull.a[0] < edge.a[0]) {\n          d = orient(hull.a, hull.b, edge.a);\n        } else {\n          d = orient(edge.b, edge.a, hull.a);\n        }\n\n        if (d) {\n          return d;\n        }\n\n        if (edge.b[0] < hull.b[0]) {\n          d = orient(hull.a, hull.b, edge.b);\n        } else {\n          d = orient(edge.b, edge.a, hull.b);\n        }\n\n        return d || hull.idx - edge.idx;\n      }\n\n      function splitHulls(hulls, points, event) {\n        var splitIdx = bsearch.le(hulls, event, findSplit);\n        var hull = hulls[splitIdx];\n        var upperIds = hull.upperIds;\n        var x = upperIds[upperIds.length - 1];\n        hull.upperIds = [x];\n        hulls.splice(splitIdx + 1, 0, new PartialHull(event.a, event.b, event.idx, [x], upperIds));\n      }\n\n      function mergeHulls(hulls, points, event) {\n        //Swap pointers for merge search\n        var tmp = event.a;\n        event.a = event.b;\n        event.b = tmp;\n        var mergeIdx = bsearch.eq(hulls, event, findSplit);\n        var upper = hulls[mergeIdx];\n        var lower = hulls[mergeIdx - 1];\n        lower.upperIds = upper.upperIds;\n        hulls.splice(mergeIdx, 1);\n      }\n\n      function monotoneTriangulate(points, edges) {\n        var numPoints = points.length;\n        var numEdges = edges.length;\n        var events = []; //Create point events\n\n        for (var i = 0; i < numPoints; ++i) {\n          events.push(new Event(points[i], null, EVENT_POINT, i));\n        } //Create edge events\n\n\n        for (var i = 0; i < numEdges; ++i) {\n          var e = edges[i];\n          var a = points[e[0]];\n          var b = points[e[1]];\n\n          if (a[0] < b[0]) {\n            events.push(new Event(a, b, EVENT_START, i), new Event(b, a, EVENT_END, i));\n          } else if (a[0] > b[0]) {\n            events.push(new Event(b, a, EVENT_START, i), new Event(a, b, EVENT_END, i));\n          }\n        } //Sort events\n\n\n        events.sort(compareEvent); //Initialize hull\n\n        var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);\n        var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])]; //Process events in order\n\n        var cells = [];\n\n        for (var i = 0, numEvents = events.length; i < numEvents; ++i) {\n          var event = events[i];\n          var type = event.type;\n\n          if (type === EVENT_POINT) {\n            addPoint(cells, hull, points, event.a, event.idx);\n          } else if (type === EVENT_START) {\n            splitHulls(hull, points, event);\n          } else {\n            mergeHulls(hull, points, event);\n          }\n        } //Return triangulation\n\n\n        return cells;\n      }\n    }, {\n      \"binary-search-bounds\": 31,\n      \"robust-orientation\": 284\n    }],\n    46: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      module.exports = createTriangulation;\n\n      function Triangulation(stars, edges) {\n        this.stars = stars;\n        this.edges = edges;\n      }\n\n      var proto = Triangulation.prototype;\n\n      function removePair(list, j, k) {\n        for (var i = 1, n = list.length; i < n; i += 2) {\n          if (list[i - 1] === j && list[i] === k) {\n            list[i - 1] = list[n - 2];\n            list[i] = list[n - 1];\n            list.length = n - 2;\n            return;\n          }\n        }\n      }\n\n      proto.isConstraint = function () {\n        var e = [0, 0];\n\n        function compareLex(a, b) {\n          return a[0] - b[0] || a[1] - b[1];\n        }\n\n        return function (i, j) {\n          e[0] = Math.min(i, j);\n          e[1] = Math.max(i, j);\n          return bsearch.eq(this.edges, e, compareLex) >= 0;\n        };\n      }();\n\n      proto.removeTriangle = function (i, j, k) {\n        var stars = this.stars;\n        removePair(stars[i], j, k);\n        removePair(stars[j], k, i);\n        removePair(stars[k], i, j);\n      };\n\n      proto.addTriangle = function (i, j, k) {\n        var stars = this.stars;\n        stars[i].push(j, k);\n        stars[j].push(k, i);\n        stars[k].push(i, j);\n      };\n\n      proto.opposite = function (j, i) {\n        var list = this.stars[i];\n\n        for (var k = 1, n = list.length; k < n; k += 2) {\n          if (list[k] === j) {\n            return list[k - 1];\n          }\n        }\n\n        return -1;\n      };\n\n      proto.flip = function (i, j) {\n        var a = this.opposite(i, j);\n        var b = this.opposite(j, i);\n        this.removeTriangle(i, j, a);\n        this.removeTriangle(j, i, b);\n        this.addTriangle(i, b, a);\n        this.addTriangle(j, a, b);\n      };\n\n      proto.edges = function () {\n        var stars = this.stars;\n        var result = [];\n\n        for (var i = 0, n = stars.length; i < n; ++i) {\n          var list = stars[i];\n\n          for (var j = 0, m = list.length; j < m; j += 2) {\n            result.push([list[j], list[j + 1]]);\n          }\n        }\n\n        return result;\n      };\n\n      proto.cells = function () {\n        var stars = this.stars;\n        var result = [];\n\n        for (var i = 0, n = stars.length; i < n; ++i) {\n          var list = stars[i];\n\n          for (var j = 0, m = list.length; j < m; j += 2) {\n            var s = list[j];\n            var t = list[j + 1];\n\n            if (i < Math.min(s, t)) {\n              result.push([i, s, t]);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      function createTriangulation(numVerts, edges) {\n        var stars = new Array(numVerts);\n\n        for (var i = 0; i < numVerts; ++i) {\n          stars[i] = [];\n        }\n\n        return new Triangulation(stars, edges);\n      }\n    }, {\n      \"binary-search-bounds\": 31\n    }],\n    47: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = orientation;\n\n      function orientation(s) {\n        var p = 1;\n\n        for (var i = 1; i < s.length; ++i) {\n          for (var j = 0; j < i; ++j) {\n            if (s[i] < s[j]) {\n              p = -p;\n            } else if (s[j] === s[i]) {\n              return 0;\n            }\n          }\n        }\n\n        return p;\n      }\n    }, {}],\n    48: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var dup = _glvis_(\"dup\");\n\n      var solve = _glvis_(\"robust-linear-solve\");\n\n      function dot(a, b) {\n        var s = 0.0;\n        var d = a.length;\n\n        for (var i = 0; i < d; ++i) {\n          s += a[i] * b[i];\n        }\n\n        return s;\n      }\n\n      function barycentricCircumcenter(points) {\n        var N = points.length;\n\n        if (N === 0) {\n          return [];\n        }\n\n        var D = points[0].length;\n        var A = dup([points.length + 1, points.length + 1], 1.0);\n        var b = dup([points.length + 1], 1.0);\n        A[N][N] = 0.0;\n\n        for (var i = 0; i < N; ++i) {\n          for (var j = 0; j <= i; ++j) {\n            A[j][i] = A[i][j] = 2.0 * dot(points[i], points[j]);\n          }\n\n          b[i] = dot(points[i], points[i]);\n        }\n\n        var x = solve(A, b);\n        var denom = 0.0;\n        var h = x[N + 1];\n\n        for (var i = 0; i < h.length; ++i) {\n          denom += h[i];\n        }\n\n        var y = new Array(N);\n\n        for (var i = 0; i < N; ++i) {\n          var h = x[i];\n          var numer = 0.0;\n\n          for (var j = 0; j < h.length; ++j) {\n            numer += h[j];\n          }\n\n          y[i] = numer / denom;\n        }\n\n        return y;\n      }\n\n      function circumcenter(points) {\n        if (points.length === 0) {\n          return [];\n        }\n\n        var D = points[0].length;\n        var result = dup([D]);\n        var weights = barycentricCircumcenter(points);\n\n        for (var i = 0; i < points.length; ++i) {\n          for (var j = 0; j < D; ++j) {\n            result[j] += points[i][j] * weights[i];\n          }\n        }\n\n        return result;\n      }\n\n      circumcenter.barycenetric = barycentricCircumcenter;\n      module.exports = circumcenter;\n    }, {\n      \"dup\": 65,\n      \"robust-linear-solve\": 283\n    }],\n    49: [function (_glvis_, module, exports) {\n      module.exports = circumradius;\n\n      var circumcenter = _glvis_('circumcenter');\n\n      function circumradius(points) {\n        var center = circumcenter(points);\n        var avgDist = 0.0;\n\n        for (var i = 0; i < points.length; ++i) {\n          var p = points[i];\n\n          for (var j = 0; j < center.length; ++j) {\n            avgDist += Math.pow(p[j] - center[j], 2);\n          }\n        }\n\n        return Math.sqrt(avgDist / points.length);\n      }\n    }, {\n      \"circumcenter\": 48\n    }],\n    50: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = cleanPSLG;\n\n      var UnionFind = _glvis_('union-find');\n\n      var boxIntersect = _glvis_('box-intersect');\n\n      var segseg = _glvis_('robust-segment-intersect');\n\n      var rat = _glvis_('big-rat');\n\n      var ratCmp = _glvis_('big-rat/cmp');\n\n      var ratToFloat = _glvis_('big-rat/to-float');\n\n      var ratVec = _glvis_('rat-vec');\n\n      var nextafter = _glvis_('nextafter');\n\n      var solveIntersection = _glvis_('./lib/rat-seg-intersect'); // Bounds on a rational number when rounded to a float\n\n\n      function boundRat(r) {\n        var f = ratToFloat(r);\n        return [nextafter(f, -Infinity), nextafter(f, Infinity)];\n      } // Convert a list of edges in a pslg to bounding boxes\n\n\n      function boundEdges(points, edges) {\n        var bounds = new Array(edges.length);\n\n        for (var i = 0; i < edges.length; ++i) {\n          var e = edges[i];\n          var a = points[e[0]];\n          var b = points[e[1]];\n          bounds[i] = [nextafter(Math.min(a[0], b[0]), -Infinity), nextafter(Math.min(a[1], b[1]), -Infinity), nextafter(Math.max(a[0], b[0]), Infinity), nextafter(Math.max(a[1], b[1]), Infinity)];\n        }\n\n        return bounds;\n      } // Convert a list of points into bounding boxes by duplicating coords\n\n\n      function boundPoints(points) {\n        var bounds = new Array(points.length);\n\n        for (var i = 0; i < points.length; ++i) {\n          var p = points[i];\n          bounds[i] = [nextafter(p[0], -Infinity), nextafter(p[1], -Infinity), nextafter(p[0], Infinity), nextafter(p[1], Infinity)];\n        }\n\n        return bounds;\n      } // Find all pairs of crossing edges in a pslg (given edge bounds)\n\n\n      function getCrossings(points, edges, edgeBounds) {\n        var result = [];\n        boxIntersect(edgeBounds, function (i, j) {\n          var e = edges[i];\n          var f = edges[j];\n\n          if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {\n            return;\n          }\n\n          var a = points[e[0]];\n          var b = points[e[1]];\n          var c = points[f[0]];\n          var d = points[f[1]];\n\n          if (segseg(a, b, c, d)) {\n            result.push([i, j]);\n          }\n        });\n        return result;\n      } // Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\n\n\n      function getTJunctions(points, edges, edgeBounds, vertBounds) {\n        var result = [];\n        boxIntersect(edgeBounds, vertBounds, function (i, v) {\n          var e = edges[i];\n\n          if (e[0] === v || e[1] === v) {\n            return;\n          }\n\n          var p = points[v];\n          var a = points[e[0]];\n          var b = points[e[1]];\n\n          if (segseg(a, b, p, p)) {\n            result.push([i, v]);\n          }\n        });\n        return result;\n      } // Cut edges along crossings/tjunctions\n\n\n      function cutEdges(floatPoints, edges, crossings, junctions, useColor) {\n        var i, e; // Convert crossings into tjunctions by constructing rational points\n\n        var ratPoints = floatPoints.map(function (p) {\n          return [rat(p[0]), rat(p[1])];\n        });\n\n        for (i = 0; i < crossings.length; ++i) {\n          var crossing = crossings[i];\n          e = crossing[0];\n          var f = crossing[1];\n          var ee = edges[e];\n          var ef = edges[f];\n          var x = solveIntersection(ratVec(floatPoints[ee[0]]), ratVec(floatPoints[ee[1]]), ratVec(floatPoints[ef[0]]), ratVec(floatPoints[ef[1]]));\n\n          if (!x) {\n            // Segments are parallel, should already be handled by t-junctions\n            continue;\n          }\n\n          var idx = floatPoints.length;\n          floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);\n          ratPoints.push(x);\n          junctions.push([e, idx], [f, idx]);\n        } // Sort tjunctions\n\n\n        junctions.sort(function (a, b) {\n          if (a[0] !== b[0]) {\n            return a[0] - b[0];\n          }\n\n          var u = ratPoints[a[1]];\n          var v = ratPoints[b[1]];\n          return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);\n        }); // Split edges along junctions\n\n        for (i = junctions.length - 1; i >= 0; --i) {\n          var junction = junctions[i];\n          e = junction[0];\n          var edge = edges[e];\n          var s = edge[0];\n          var t = edge[1]; // Check if edge is not lexicographically sorted\n\n          var a = floatPoints[s];\n          var b = floatPoints[t];\n\n          if ((a[0] - b[0] || a[1] - b[1]) < 0) {\n            var tmp = s;\n            s = t;\n            t = tmp;\n          } // Split leading edge\n\n\n          edge[0] = s;\n          var last = edge[1] = junction[1]; // If we are grouping edges by color, remember to track data\n\n          var color;\n\n          if (useColor) {\n            color = edge[2];\n          } // Split other edges\n\n\n          while (i > 0 && junctions[i - 1][0] === e) {\n            var junction = junctions[--i];\n            var next = junction[1];\n\n            if (useColor) {\n              edges.push([last, next, color]);\n            } else {\n              edges.push([last, next]);\n            }\n\n            last = next;\n          } // Add final edge\n\n\n          if (useColor) {\n            edges.push([last, t, color]);\n          } else {\n            edges.push([last, t]);\n          }\n        } // Return constructed rational points\n\n\n        return ratPoints;\n      } // Merge overlapping points\n\n\n      function dedupPoints(floatPoints, ratPoints, floatBounds) {\n        var numPoints = ratPoints.length;\n        var uf = new UnionFind(numPoints); // Compute rational bounds\n\n        var bounds = [];\n\n        for (var i = 0; i < ratPoints.length; ++i) {\n          var p = ratPoints[i];\n          var xb = boundRat(p[0]);\n          var yb = boundRat(p[1]);\n          bounds.push([nextafter(xb[0], -Infinity), nextafter(yb[0], -Infinity), nextafter(xb[1], Infinity), nextafter(yb[1], Infinity)]);\n        } // Link all points with over lapping boxes\n\n\n        boxIntersect(bounds, function (i, j) {\n          uf.link(i, j);\n        }); // Do 1 pass over points to combine points in label sets\n\n        var noDupes = true;\n        var labels = new Array(numPoints);\n\n        for (var i = 0; i < numPoints; ++i) {\n          var j = uf.find(i);\n\n          if (j !== i) {\n            // Clear no-dupes flag, zero out label\n            noDupes = false; // Make each point the top-left point from its cell\n\n            floatPoints[j] = [Math.min(floatPoints[i][0], floatPoints[j][0]), Math.min(floatPoints[i][1], floatPoints[j][1])];\n          }\n        } // If no duplicates, return null to signal termination\n\n\n        if (noDupes) {\n          return null;\n        }\n\n        var ptr = 0;\n\n        for (var i = 0; i < numPoints; ++i) {\n          var j = uf.find(i);\n\n          if (j === i) {\n            labels[i] = ptr;\n            floatPoints[ptr++] = floatPoints[i];\n          } else {\n            labels[i] = -1;\n          }\n        }\n\n        floatPoints.length = ptr; // Do a second pass to fix up missing labels\n\n        for (var i = 0; i < numPoints; ++i) {\n          if (labels[i] < 0) {\n            labels[i] = labels[uf.find(i)];\n          }\n        } // Return resulting union-find data structure\n\n\n        return labels;\n      }\n\n      function compareLex2(a, b) {\n        return a[0] - b[0] || a[1] - b[1];\n      }\n\n      function compareLex3(a, b) {\n        var d = a[0] - b[0] || a[1] - b[1];\n\n        if (d) {\n          return d;\n        }\n\n        if (a[2] < b[2]) {\n          return -1;\n        } else if (a[2] > b[2]) {\n          return 1;\n        }\n\n        return 0;\n      } // Remove duplicate edge labels\n\n\n      function dedupEdges(edges, labels, useColor) {\n        if (edges.length === 0) {\n          return;\n        }\n\n        if (labels) {\n          for (var i = 0; i < edges.length; ++i) {\n            var e = edges[i];\n            var a = labels[e[0]];\n            var b = labels[e[1]];\n            e[0] = Math.min(a, b);\n            e[1] = Math.max(a, b);\n          }\n        } else {\n          for (var i = 0; i < edges.length; ++i) {\n            var e = edges[i];\n            var a = e[0];\n            var b = e[1];\n            e[0] = Math.min(a, b);\n            e[1] = Math.max(a, b);\n          }\n        }\n\n        if (useColor) {\n          edges.sort(compareLex3);\n        } else {\n          edges.sort(compareLex2);\n        }\n\n        var ptr = 1;\n\n        for (var i = 1; i < edges.length; ++i) {\n          var prev = edges[i - 1];\n          var next = edges[i];\n\n          if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {\n            continue;\n          }\n\n          edges[ptr++] = next;\n        }\n\n        edges.length = ptr;\n      }\n\n      function preRound(points, edges, useColor) {\n        var labels = dedupPoints(points, [], boundPoints(points));\n        dedupEdges(edges, labels, useColor);\n        return !!labels;\n      } // Repeat until convergence\n\n\n      function snapRound(points, edges, useColor) {\n        // 1. find edge crossings\n        var edgeBounds = boundEdges(points, edges);\n        var crossings = getCrossings(points, edges, edgeBounds); // 2. find t-junctions\n\n        var vertBounds = boundPoints(points);\n        var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds); // 3. cut edges, construct rational points\n\n        var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor); // 4. dedupe verts\n\n        var labels = dedupPoints(points, ratPoints, vertBounds); // 5. dedupe edges\n\n        dedupEdges(edges, labels, useColor); // 6. check termination\n\n        if (!labels) {\n          return crossings.length > 0 || tjunctions.length > 0;\n        } // More iterations necessary\n\n\n        return true;\n      } // Main loop, runs PSLG clean up until completion\n\n\n      function cleanPSLG(points, edges, colors) {\n        // If using colors, augment edges with color data\n        var prevEdges;\n\n        if (colors) {\n          prevEdges = edges;\n          var augEdges = new Array(edges.length);\n\n          for (var i = 0; i < edges.length; ++i) {\n            var e = edges[i];\n            augEdges[i] = [e[0], e[1], colors[i]];\n          }\n\n          edges = augEdges;\n        } // First round: remove duplicate edges and points\n\n\n        var modified = preRound(points, edges, !!colors); // Run snap rounding until convergence\n\n        while (snapRound(points, edges, !!colors)) {\n          modified = true;\n        } // Strip color tags\n\n\n        if (!!colors && modified) {\n          prevEdges.length = 0;\n          colors.length = 0;\n\n          for (var i = 0; i < edges.length; ++i) {\n            var e = edges[i];\n            prevEdges.push([e[0], e[1]]);\n            colors.push(e[2]);\n          }\n        }\n\n        return modified;\n      }\n    }, {\n      \"./lib/rat-seg-intersect\": 51,\n      \"big-rat\": 18,\n      \"big-rat/cmp\": 16,\n      \"big-rat/to-float\": 30,\n      \"box-intersect\": 35,\n      \"nextafter\": 260,\n      \"rat-vec\": 273,\n      \"robust-segment-intersect\": 287,\n      \"union-find\": 309\n    }],\n    51: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = solveIntersection;\n\n      var ratMul = _glvis_('big-rat/mul');\n\n      var ratDiv = _glvis_('big-rat/div');\n\n      var ratSub = _glvis_('big-rat/sub');\n\n      var ratSign = _glvis_('big-rat/sign');\n\n      var rvSub = _glvis_('rat-vec/sub');\n\n      var rvAdd = _glvis_('rat-vec/add');\n\n      var rvMuls = _glvis_('rat-vec/muls');\n\n      function ratPerp(a, b) {\n        return ratSub(ratMul(a[0], b[1]), ratMul(a[1], b[0]));\n      } // Solve for intersection\n      //  x = a + t (b-a)\n      //  (x - c) ^ (d-c) = 0\n      //  (t * (b-a) + (a-c) ) ^ (d-c) = 0\n      //  t * (b-a)^(d-c) = (d-c)^(a-c)\n      //  t = (d-c)^(a-c) / (b-a)^(d-c)\n\n\n      function solveIntersection(a, b, c, d) {\n        var ba = rvSub(b, a);\n        var dc = rvSub(d, c);\n        var baXdc = ratPerp(ba, dc);\n\n        if (ratSign(baXdc) === 0) {\n          return null;\n        }\n\n        var ac = rvSub(a, c);\n        var dcXac = ratPerp(dc, ac);\n        var t = ratDiv(dcXac, baXdc);\n        var s = rvMuls(ba, t);\n        var r = rvAdd(a, s);\n        return r;\n      }\n    }, {\n      \"big-rat/div\": 17,\n      \"big-rat/mul\": 27,\n      \"big-rat/sign\": 28,\n      \"big-rat/sub\": 29,\n      \"rat-vec/add\": 272,\n      \"rat-vec/muls\": 274,\n      \"rat-vec/sub\": 275\n    }],\n    52: [function (_glvis_, module, exports) {\n      module.exports = {\n        \"jet\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 131]\n        }, {\n          \"index\": 0.125,\n          \"rgb\": [0, 60, 170]\n        }, {\n          \"index\": 0.375,\n          \"rgb\": [5, 255, 255]\n        }, {\n          \"index\": 0.625,\n          \"rgb\": [255, 255, 0]\n        }, {\n          \"index\": 0.875,\n          \"rgb\": [250, 0, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [128, 0, 0]\n        }],\n        \"hsv\": [{\n          \"index\": 0,\n          \"rgb\": [255, 0, 0]\n        }, {\n          \"index\": 0.169,\n          \"rgb\": [253, 255, 2]\n        }, {\n          \"index\": 0.173,\n          \"rgb\": [247, 255, 2]\n        }, {\n          \"index\": 0.337,\n          \"rgb\": [0, 252, 4]\n        }, {\n          \"index\": 0.341,\n          \"rgb\": [0, 252, 10]\n        }, {\n          \"index\": 0.506,\n          \"rgb\": [1, 249, 255]\n        }, {\n          \"index\": 0.671,\n          \"rgb\": [2, 0, 253]\n        }, {\n          \"index\": 0.675,\n          \"rgb\": [8, 0, 253]\n        }, {\n          \"index\": 0.839,\n          \"rgb\": [255, 0, 251]\n        }, {\n          \"index\": 0.843,\n          \"rgb\": [255, 0, 245]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 0, 6]\n        }],\n        \"hot\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.3,\n          \"rgb\": [230, 0, 0]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [255, 210, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 255]\n        }],\n        \"spring\": [{\n          \"index\": 0,\n          \"rgb\": [255, 0, 255]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 0]\n        }],\n        \"summer\": [{\n          \"index\": 0,\n          \"rgb\": [0, 128, 102]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 102]\n        }],\n        \"autumn\": [{\n          \"index\": 0,\n          \"rgb\": [255, 0, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 0]\n        }],\n        \"winter\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 255]\n        }, {\n          \"index\": 1,\n          \"rgb\": [0, 255, 128]\n        }],\n        \"bone\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.376,\n          \"rgb\": [84, 84, 116]\n        }, {\n          \"index\": 0.753,\n          \"rgb\": [169, 200, 200]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 255]\n        }],\n        \"copper\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.804,\n          \"rgb\": [255, 160, 102]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 199, 127]\n        }],\n        \"greys\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 255]\n        }],\n        \"yignbu\": [{\n          \"index\": 0,\n          \"rgb\": [8, 29, 88]\n        }, {\n          \"index\": 0.125,\n          \"rgb\": [37, 52, 148]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [34, 94, 168]\n        }, {\n          \"index\": 0.375,\n          \"rgb\": [29, 145, 192]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [65, 182, 196]\n        }, {\n          \"index\": 0.625,\n          \"rgb\": [127, 205, 187]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [199, 233, 180]\n        }, {\n          \"index\": 0.875,\n          \"rgb\": [237, 248, 217]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 217]\n        }],\n        \"greens\": [{\n          \"index\": 0,\n          \"rgb\": [0, 68, 27]\n        }, {\n          \"index\": 0.125,\n          \"rgb\": [0, 109, 44]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [35, 139, 69]\n        }, {\n          \"index\": 0.375,\n          \"rgb\": [65, 171, 93]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [116, 196, 118]\n        }, {\n          \"index\": 0.625,\n          \"rgb\": [161, 217, 155]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [199, 233, 192]\n        }, {\n          \"index\": 0.875,\n          \"rgb\": [229, 245, 224]\n        }, {\n          \"index\": 1,\n          \"rgb\": [247, 252, 245]\n        }],\n        \"yiorrd\": [{\n          \"index\": 0,\n          \"rgb\": [128, 0, 38]\n        }, {\n          \"index\": 0.125,\n          \"rgb\": [189, 0, 38]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [227, 26, 28]\n        }, {\n          \"index\": 0.375,\n          \"rgb\": [252, 78, 42]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [253, 141, 60]\n        }, {\n          \"index\": 0.625,\n          \"rgb\": [254, 178, 76]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [254, 217, 118]\n        }, {\n          \"index\": 0.875,\n          \"rgb\": [255, 237, 160]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 204]\n        }],\n        \"bluered\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 255]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 0, 0]\n        }],\n        \"rdbu\": [{\n          \"index\": 0,\n          \"rgb\": [5, 10, 172]\n        }, {\n          \"index\": 0.35,\n          \"rgb\": [106, 137, 247]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [190, 190, 190]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [220, 170, 132]\n        }, {\n          \"index\": 0.7,\n          \"rgb\": [230, 145, 90]\n        }, {\n          \"index\": 1,\n          \"rgb\": [178, 10, 28]\n        }],\n        \"picnic\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 255]\n        }, {\n          \"index\": 0.1,\n          \"rgb\": [51, 153, 255]\n        }, {\n          \"index\": 0.2,\n          \"rgb\": [102, 204, 255]\n        }, {\n          \"index\": 0.3,\n          \"rgb\": [153, 204, 255]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [204, 204, 255]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [255, 255, 255]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [255, 204, 255]\n        }, {\n          \"index\": 0.7,\n          \"rgb\": [255, 153, 255]\n        }, {\n          \"index\": 0.8,\n          \"rgb\": [255, 102, 204]\n        }, {\n          \"index\": 0.9,\n          \"rgb\": [255, 102, 102]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 0, 0]\n        }],\n        \"rainbow\": [{\n          \"index\": 0,\n          \"rgb\": [150, 0, 90]\n        }, {\n          \"index\": 0.125,\n          \"rgb\": [0, 0, 200]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [0, 25, 255]\n        }, {\n          \"index\": 0.375,\n          \"rgb\": [0, 152, 255]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [44, 255, 150]\n        }, {\n          \"index\": 0.625,\n          \"rgb\": [151, 255, 0]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [255, 234, 0]\n        }, {\n          \"index\": 0.875,\n          \"rgb\": [255, 111, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 0, 0]\n        }],\n        \"portland\": [{\n          \"index\": 0,\n          \"rgb\": [12, 51, 131]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [10, 136, 186]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [242, 211, 56]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [242, 143, 56]\n        }, {\n          \"index\": 1,\n          \"rgb\": [217, 30, 30]\n        }],\n        \"blackbody\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.2,\n          \"rgb\": [230, 0, 0]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [230, 210, 0]\n        }, {\n          \"index\": 0.7,\n          \"rgb\": [255, 255, 255]\n        }, {\n          \"index\": 1,\n          \"rgb\": [160, 200, 255]\n        }],\n        \"earth\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 130]\n        }, {\n          \"index\": 0.1,\n          \"rgb\": [0, 180, 180]\n        }, {\n          \"index\": 0.2,\n          \"rgb\": [40, 210, 40]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [230, 230, 50]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [120, 70, 20]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 255]\n        }],\n        \"electric\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.15,\n          \"rgb\": [30, 0, 100]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [120, 0, 100]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [160, 90, 0]\n        }, {\n          \"index\": 0.8,\n          \"rgb\": [230, 200, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 250, 220]\n        }],\n        \"alpha\": [{\n          \"index\": 0,\n          \"rgb\": [255, 255, 255, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 255, 255, 1]\n        }],\n        \"viridis\": [{\n          \"index\": 0,\n          \"rgb\": [68, 1, 84]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [71, 44, 122]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [59, 81, 139]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [44, 113, 142]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [33, 144, 141]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [39, 173, 129]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [92, 200, 99]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [170, 220, 50]\n        }, {\n          \"index\": 1,\n          \"rgb\": [253, 231, 37]\n        }],\n        \"inferno\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 4]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [31, 12, 72]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [85, 15, 109]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [136, 34, 106]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [186, 54, 85]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [227, 89, 51]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [249, 140, 10]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [249, 201, 50]\n        }, {\n          \"index\": 1,\n          \"rgb\": [252, 255, 164]\n        }],\n        \"magma\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 4]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [28, 16, 68]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [79, 18, 123]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [129, 37, 129]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [181, 54, 122]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [229, 80, 100]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [251, 135, 97]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [254, 194, 135]\n        }, {\n          \"index\": 1,\n          \"rgb\": [252, 253, 191]\n        }],\n        \"plasma\": [{\n          \"index\": 0,\n          \"rgb\": [13, 8, 135]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [75, 3, 161]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [125, 3, 168]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [168, 34, 150]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [203, 70, 121]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [229, 107, 93]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [248, 148, 65]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [253, 195, 40]\n        }, {\n          \"index\": 1,\n          \"rgb\": [240, 249, 33]\n        }],\n        \"warm\": [{\n          \"index\": 0,\n          \"rgb\": [125, 0, 179]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [172, 0, 187]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [219, 0, 170]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [255, 0, 130]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [255, 63, 74]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [255, 123, 0]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [234, 176, 0]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [190, 228, 0]\n        }, {\n          \"index\": 1,\n          \"rgb\": [147, 255, 0]\n        }],\n        \"cool\": [{\n          \"index\": 0,\n          \"rgb\": [125, 0, 179]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [116, 0, 218]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [98, 74, 237]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [68, 146, 231]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [0, 204, 197]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [0, 247, 146]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [0, 255, 88]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [40, 255, 8]\n        }, {\n          \"index\": 1,\n          \"rgb\": [147, 255, 0]\n        }],\n        \"rainbow-soft\": [{\n          \"index\": 0,\n          \"rgb\": [125, 0, 179]\n        }, {\n          \"index\": 0.1,\n          \"rgb\": [199, 0, 180]\n        }, {\n          \"index\": 0.2,\n          \"rgb\": [255, 0, 121]\n        }, {\n          \"index\": 0.3,\n          \"rgb\": [255, 108, 0]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [222, 194, 0]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [150, 255, 0]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [0, 255, 55]\n        }, {\n          \"index\": 0.7,\n          \"rgb\": [0, 246, 150]\n        }, {\n          \"index\": 0.8,\n          \"rgb\": [50, 167, 222]\n        }, {\n          \"index\": 0.9,\n          \"rgb\": [103, 51, 235]\n        }, {\n          \"index\": 1,\n          \"rgb\": [124, 0, 186]\n        }],\n        \"bathymetry\": [{\n          \"index\": 0,\n          \"rgb\": [40, 26, 44]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [59, 49, 90]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [64, 76, 139]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [63, 110, 151]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [72, 142, 158]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [85, 174, 163]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [120, 206, 163]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [187, 230, 172]\n        }, {\n          \"index\": 1,\n          \"rgb\": [253, 254, 204]\n        }],\n        \"cdom\": [{\n          \"index\": 0,\n          \"rgb\": [47, 15, 62]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [87, 23, 86]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [130, 28, 99]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [171, 41, 96]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [206, 67, 86]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [230, 106, 84]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [242, 149, 103]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [249, 193, 135]\n        }, {\n          \"index\": 1,\n          \"rgb\": [254, 237, 176]\n        }],\n        \"chlorophyll\": [{\n          \"index\": 0,\n          \"rgb\": [18, 36, 20]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [25, 63, 41]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [24, 91, 59]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [13, 119, 72]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [18, 148, 80]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [80, 173, 89]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [132, 196, 122]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [175, 221, 162]\n        }, {\n          \"index\": 1,\n          \"rgb\": [215, 249, 208]\n        }],\n        \"density\": [{\n          \"index\": 0,\n          \"rgb\": [54, 14, 36]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [89, 23, 80]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [110, 45, 132]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [120, 77, 178]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [120, 113, 213]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [115, 151, 228]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [134, 185, 227]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [177, 214, 227]\n        }, {\n          \"index\": 1,\n          \"rgb\": [230, 241, 241]\n        }],\n        \"freesurface-blue\": [{\n          \"index\": 0,\n          \"rgb\": [30, 4, 110]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [47, 14, 176]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [41, 45, 236]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [25, 99, 212]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [68, 131, 200]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [114, 156, 197]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [157, 181, 203]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [200, 208, 216]\n        }, {\n          \"index\": 1,\n          \"rgb\": [241, 237, 236]\n        }],\n        \"freesurface-red\": [{\n          \"index\": 0,\n          \"rgb\": [60, 9, 18]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [100, 17, 27]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [142, 20, 29]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [177, 43, 27]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [192, 87, 63]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [205, 125, 105]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [216, 162, 148]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [227, 199, 193]\n        }, {\n          \"index\": 1,\n          \"rgb\": [241, 237, 236]\n        }],\n        \"oxygen\": [{\n          \"index\": 0,\n          \"rgb\": [64, 5, 5]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [106, 6, 15]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [144, 26, 7]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [168, 64, 3]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [188, 100, 4]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [206, 136, 11]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [220, 174, 25]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [231, 215, 44]\n        }, {\n          \"index\": 1,\n          \"rgb\": [248, 254, 105]\n        }],\n        \"par\": [{\n          \"index\": 0,\n          \"rgb\": [51, 20, 24]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [90, 32, 35]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [129, 44, 34]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [159, 68, 25]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [182, 99, 19]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [199, 134, 22]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [212, 171, 35]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [221, 210, 54]\n        }, {\n          \"index\": 1,\n          \"rgb\": [225, 253, 75]\n        }],\n        \"phase\": [{\n          \"index\": 0,\n          \"rgb\": [145, 105, 18]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [184, 71, 38]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [186, 58, 115]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [160, 71, 185]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [110, 97, 218]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [50, 123, 164]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [31, 131, 110]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [77, 129, 34]\n        }, {\n          \"index\": 1,\n          \"rgb\": [145, 105, 18]\n        }],\n        \"salinity\": [{\n          \"index\": 0,\n          \"rgb\": [42, 24, 108]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [33, 50, 162]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [15, 90, 145]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [40, 118, 137]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [59, 146, 135]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [79, 175, 126]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [120, 203, 104]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [193, 221, 100]\n        }, {\n          \"index\": 1,\n          \"rgb\": [253, 239, 154]\n        }],\n        \"temperature\": [{\n          \"index\": 0,\n          \"rgb\": [4, 35, 51]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [23, 51, 122]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [85, 59, 157]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [129, 79, 143]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [175, 95, 130]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [222, 112, 101]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [249, 146, 66]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [249, 196, 65]\n        }, {\n          \"index\": 1,\n          \"rgb\": [232, 250, 91]\n        }],\n        \"turbidity\": [{\n          \"index\": 0,\n          \"rgb\": [34, 31, 27]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [65, 50, 41]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [98, 69, 52]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [131, 89, 57]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [161, 112, 59]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [185, 140, 66]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [202, 174, 88]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [216, 209, 126]\n        }, {\n          \"index\": 1,\n          \"rgb\": [233, 246, 171]\n        }],\n        \"velocity-blue\": [{\n          \"index\": 0,\n          \"rgb\": [17, 32, 64]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [35, 52, 116]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [29, 81, 156]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [31, 113, 162]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [50, 144, 169]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [87, 173, 176]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [149, 196, 189]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [203, 221, 211]\n        }, {\n          \"index\": 1,\n          \"rgb\": [254, 251, 230]\n        }],\n        \"velocity-green\": [{\n          \"index\": 0,\n          \"rgb\": [23, 35, 19]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [24, 64, 38]\n        }, {\n          \"index\": 0.25,\n          \"rgb\": [11, 95, 45]\n        }, {\n          \"index\": 0.38,\n          \"rgb\": [39, 123, 35]\n        }, {\n          \"index\": 0.5,\n          \"rgb\": [95, 146, 12]\n        }, {\n          \"index\": 0.63,\n          \"rgb\": [152, 165, 18]\n        }, {\n          \"index\": 0.75,\n          \"rgb\": [201, 186, 69]\n        }, {\n          \"index\": 0.88,\n          \"rgb\": [233, 216, 137]\n        }, {\n          \"index\": 1,\n          \"rgb\": [255, 253, 205]\n        }],\n        \"cubehelix\": [{\n          \"index\": 0,\n          \"rgb\": [0, 0, 0]\n        }, {\n          \"index\": 0.07,\n          \"rgb\": [22, 5, 59]\n        }, {\n          \"index\": 0.13,\n          \"rgb\": [60, 4, 105]\n        }, {\n          \"index\": 0.2,\n          \"rgb\": [109, 1, 135]\n        }, {\n          \"index\": 0.27,\n          \"rgb\": [161, 0, 147]\n        }, {\n          \"index\": 0.33,\n          \"rgb\": [210, 2, 142]\n        }, {\n          \"index\": 0.4,\n          \"rgb\": [251, 11, 123]\n        }, {\n          \"index\": 0.47,\n          \"rgb\": [255, 29, 97]\n        }, {\n          \"index\": 0.53,\n          \"rgb\": [255, 54, 69]\n        }, {\n          \"index\": 0.6,\n          \"rgb\": [255, 85, 46]\n        }, {\n          \"index\": 0.67,\n          \"rgb\": [255, 120, 34]\n        }, {\n          \"index\": 0.73,\n          \"rgb\": [255, 157, 37]\n        }, {\n          \"index\": 0.8,\n          \"rgb\": [241, 191, 57]\n        }, {\n          \"index\": 0.87,\n          \"rgb\": [224, 220, 93]\n        }, {\n          \"index\": 0.93,\n          \"rgb\": [218, 241, 142]\n        }, {\n          \"index\": 1,\n          \"rgb\": [227, 253, 198]\n        }]\n      };\n    }, {}],\n    53: [function (_glvis_, module, exports) {\n      /*\n       * Ben Postlethwaite\n       * January 2013\n       * License MIT\n       */\n      'use strict';\n\n      var colorScale = _glvis_('./colorScale');\n\n      var lerp = _glvis_('lerp');\n\n      module.exports = createColormap;\n\n      function createColormap(spec) {\n        /*\n         * Default Options\n         */\n        var indicies, fromrgba, torgba, nsteps, cmap, colormap, format, nshades, colors, alpha, i;\n        if (!spec) spec = {};\n        nshades = (spec.nshades || 72) - 1;\n        format = spec.format || 'hex';\n        colormap = spec.colormap;\n        if (!colormap) colormap = 'jet';\n\n        if (typeof colormap === 'string') {\n          colormap = colormap.toLowerCase();\n\n          if (!colorScale[colormap]) {\n            throw Error(colormap + ' not a supported colorscale');\n          }\n\n          cmap = colorScale[colormap];\n        } else if (Array.isArray(colormap)) {\n          cmap = colormap.slice();\n        } else {\n          throw Error('unsupported colormap option', colormap);\n        }\n\n        if (cmap.length > nshades + 1) {\n          throw new Error(colormap + ' map requires nshades to be at least size ' + cmap.length);\n        }\n\n        if (!Array.isArray(spec.alpha)) {\n          if (typeof spec.alpha === 'number') {\n            alpha = [spec.alpha, spec.alpha];\n          } else {\n            alpha = [1, 1];\n          }\n        } else if (spec.alpha.length !== 2) {\n          alpha = [1, 1];\n        } else {\n          alpha = spec.alpha.slice();\n        } // map index points from 0..1 to 0..n-1\n\n\n        indicies = cmap.map(function (c) {\n          return Math.round(c.index * nshades);\n        }); // Add alpha channel to the map\n\n        alpha[0] = Math.min(Math.max(alpha[0], 0), 1);\n        alpha[1] = Math.min(Math.max(alpha[1], 0), 1);\n        var steps = cmap.map(function (c, i) {\n          var index = cmap[i].index;\n          var rgba = cmap[i].rgb.slice(); // if user supplies their own map use it\n\n          if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {\n            return rgba;\n          }\n\n          rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;\n          return rgba;\n        });\n        /*\n         * map increasing linear values between indicies to\n         * linear steps in colorvalues\n         */\n\n        var colors = [];\n\n        for (i = 0; i < indicies.length - 1; ++i) {\n          nsteps = indicies[i + 1] - indicies[i];\n          fromrgba = steps[i];\n          torgba = steps[i + 1];\n\n          for (var j = 0; j < nsteps; j++) {\n            var amt = j / nsteps;\n            colors.push([Math.round(lerp(fromrgba[0], torgba[0], amt)), Math.round(lerp(fromrgba[1], torgba[1], amt)), Math.round(lerp(fromrgba[2], torgba[2], amt)), lerp(fromrgba[3], torgba[3], amt)]);\n          }\n        } //add 1 step as last value\n\n\n        colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));\n        if (format === 'hex') colors = colors.map(rgb2hex);else if (format === 'rgbaString') colors = colors.map(rgbaStr);else if (format === 'float') colors = colors.map(rgb2float);\n        return colors;\n      }\n\n      ;\n\n      function rgb2float(rgba) {\n        return [rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, rgba[3]];\n      }\n\n      function rgb2hex(rgba) {\n        var dig,\n            hex = '#';\n\n        for (var i = 0; i < 3; ++i) {\n          dig = rgba[i];\n          dig = dig.toString(16);\n          hex += ('00' + dig).substr(dig.length);\n        }\n\n        return hex;\n      }\n\n      function rgbaStr(rgba) {\n        return 'rgba(' + rgba.join(',') + ')';\n      }\n    }, {\n      \"./colorScale\": 52,\n      \"lerp\": 240\n    }],\n    54: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = compareAngle;\n\n      var orient = _glvis_(\"robust-orientation\");\n\n      var sgn = _glvis_(\"signum\");\n\n      var twoSum = _glvis_(\"two-sum\");\n\n      var robustProduct = _glvis_(\"robust-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      function testInterior(a, b, c) {\n        var x0 = twoSum(a[0], -b[0]);\n        var y0 = twoSum(a[1], -b[1]);\n        var x1 = twoSum(c[0], -b[0]);\n        var y1 = twoSum(c[1], -b[1]);\n        var d = robustSum(robustProduct(x0, x1), robustProduct(y0, y1));\n        return d[d.length - 1] >= 0;\n      }\n\n      function compareAngle(a, b, c, d) {\n        var bcd = orient(b, c, d);\n\n        if (bcd === 0) {\n          //Handle degenerate cases\n          var sabc = sgn(orient(a, b, c));\n          var sabd = sgn(orient(a, b, d));\n\n          if (sabc === sabd) {\n            if (sabc === 0) {\n              var ic = testInterior(a, b, c);\n              var id = testInterior(a, b, d);\n\n              if (ic === id) {\n                return 0;\n              } else if (ic) {\n                return 1;\n              } else {\n                return -1;\n              }\n            }\n\n            return 0;\n          } else if (sabd === 0) {\n            if (sabc > 0) {\n              return -1;\n            } else if (testInterior(a, b, d)) {\n              return -1;\n            } else {\n              return 1;\n            }\n          } else if (sabc === 0) {\n            if (sabd > 0) {\n              return 1;\n            } else if (testInterior(a, b, c)) {\n              return 1;\n            } else {\n              return -1;\n            }\n          }\n\n          return sgn(sabd - sabc);\n        }\n\n        var abc = orient(a, b, c);\n\n        if (abc > 0) {\n          if (bcd > 0 && orient(a, b, d) > 0) {\n            return 1;\n          }\n\n          return -1;\n        } else if (abc < 0) {\n          if (bcd > 0 || orient(a, b, d) > 0) {\n            return 1;\n          }\n\n          return -1;\n        } else {\n          var abd = orient(a, b, d);\n\n          if (abd > 0) {\n            return 1;\n          } else {\n            if (testInterior(a, b, c)) {\n              return 1;\n            } else {\n              return -1;\n            }\n          }\n        }\n      }\n    }, {\n      \"robust-orientation\": 284,\n      \"robust-product\": 285,\n      \"robust-sum\": 289,\n      \"signum\": 55,\n      \"two-sum\": 307\n    }],\n    55: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = function signum(x) {\n        if (x < 0) {\n          return -1;\n        }\n\n        if (x > 0) {\n          return 1;\n        }\n\n        return 0.0;\n      };\n    }, {}],\n    56: [function (_glvis_, module, exports) {\n      module.exports = compareCells;\n      var min = Math.min;\n\n      function compareInt(a, b) {\n        return a - b;\n      }\n\n      function compareCells(a, b) {\n        var n = a.length,\n            t = a.length - b.length;\n\n        if (t) {\n          return t;\n        }\n\n        switch (n) {\n          case 0:\n            return 0;\n\n          case 1:\n            return a[0] - b[0];\n\n          case 2:\n            return a[0] + a[1] - b[0] - b[1] || min(a[0], a[1]) - min(b[0], b[1]);\n\n          case 3:\n            var l1 = a[0] + a[1],\n                m1 = b[0] + b[1];\n            t = l1 + a[2] - (m1 + b[2]);\n\n            if (t) {\n              return t;\n            }\n\n            var l0 = min(a[0], a[1]),\n                m0 = min(b[0], b[1]);\n            return min(l0, a[2]) - min(m0, b[2]) || min(l0 + a[2], l1) - min(m0 + b[2], m1);\n\n          case 4:\n            var aw = a[0],\n                ax = a[1],\n                ay = a[2],\n                az = a[3],\n                bw = b[0],\n                bx = b[1],\n                by = b[2],\n                bz = b[3];\n            return aw + ax + ay + az - (bw + bx + by + bz) || min(aw, ax, ay, az) - min(bw, bx, by, bz, bw) || min(aw + ax, aw + ay, aw + az, ax + ay, ax + az, ay + az) - min(bw + bx, bw + by, bw + bz, bx + by, bx + bz, by + bz) || min(aw + ax + ay, aw + ax + az, aw + ay + az, ax + ay + az) - min(bw + bx + by, bw + bx + bz, bw + by + bz, bx + by + bz);\n\n          default:\n            var as = a.slice().sort(compareInt);\n            var bs = b.slice().sort(compareInt);\n\n            for (var i = 0; i < n; ++i) {\n              t = as[i] - bs[i];\n\n              if (t) {\n                return t;\n              }\n            }\n\n            return 0;\n        }\n      }\n    }, {}],\n    57: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var compareCells = _glvis_('compare-cell');\n\n      var parity = _glvis_('cell-orientation');\n\n      module.exports = compareOrientedCells;\n\n      function compareOrientedCells(a, b) {\n        return compareCells(a, b) || parity(a) - parity(b);\n      }\n    }, {\n      \"cell-orientation\": 47,\n      \"compare-cell\": 56\n    }],\n    58: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var convexHull1d = _glvis_('./lib/ch1d');\n\n      var convexHull2d = _glvis_('./lib/ch2d');\n\n      var convexHullnd = _glvis_('./lib/chnd');\n\n      module.exports = convexHull;\n\n      function convexHull(points) {\n        var n = points.length;\n\n        if (n === 0) {\n          return [];\n        } else if (n === 1) {\n          return [[0]];\n        }\n\n        var d = points[0].length;\n\n        if (d === 0) {\n          return [];\n        } else if (d === 1) {\n          return convexHull1d(points);\n        } else if (d === 2) {\n          return convexHull2d(points);\n        }\n\n        return convexHullnd(points, d);\n      }\n    }, {\n      \"./lib/ch1d\": 59,\n      \"./lib/ch2d\": 60,\n      \"./lib/chnd\": 61\n    }],\n    59: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = convexHull1d;\n\n      function convexHull1d(points) {\n        var lo = 0;\n        var hi = 0;\n\n        for (var i = 1; i < points.length; ++i) {\n          if (points[i][0] < points[lo][0]) {\n            lo = i;\n          }\n\n          if (points[i][0] > points[hi][0]) {\n            hi = i;\n          }\n        }\n\n        if (lo < hi) {\n          return [[lo], [hi]];\n        } else if (lo > hi) {\n          return [[hi], [lo]];\n        } else {\n          return [[lo]];\n        }\n      }\n    }, {}],\n    60: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = convexHull2D;\n\n      var monotoneHull = _glvis_('monotone-convex-hull-2d');\n\n      function convexHull2D(points) {\n        var hull = monotoneHull(points);\n        var h = hull.length;\n\n        if (h <= 2) {\n          return [];\n        }\n\n        var edges = new Array(h);\n        var a = hull[h - 1];\n\n        for (var i = 0; i < h; ++i) {\n          var b = hull[i];\n          edges[i] = [a, b];\n          a = b;\n        }\n\n        return edges;\n      }\n    }, {\n      \"monotone-convex-hull-2d\": 246\n    }],\n    61: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = convexHullnD;\n\n      var ich = _glvis_('incremental-convex-hull');\n\n      var aff = _glvis_('affine-hull');\n\n      function permute(points, front) {\n        var n = points.length;\n        var npoints = new Array(n);\n\n        for (var i = 0; i < front.length; ++i) {\n          npoints[i] = points[front[i]];\n        }\n\n        var ptr = front.length;\n\n        for (var i = 0; i < n; ++i) {\n          if (front.indexOf(i) < 0) {\n            npoints[ptr++] = points[i];\n          }\n        }\n\n        return npoints;\n      }\n\n      function invPermute(cells, front) {\n        var nc = cells.length;\n        var nf = front.length;\n\n        for (var i = 0; i < nc; ++i) {\n          var c = cells[i];\n\n          for (var j = 0; j < c.length; ++j) {\n            var x = c[j];\n\n            if (x < nf) {\n              c[j] = front[x];\n            } else {\n              x = x - nf;\n\n              for (var k = 0; k < nf; ++k) {\n                if (x >= front[k]) {\n                  x += 1;\n                }\n              }\n\n              c[j] = x;\n            }\n          }\n        }\n\n        return cells;\n      }\n\n      function convexHullnD(points, d) {\n        try {\n          return ich(points, true);\n        } catch (e) {\n          //If point set is degenerate, try to find a basis and rerun it\n          var ah = aff(points);\n\n          if (ah.length <= d) {\n            //No basis, no try\n            return [];\n          }\n\n          var npoints = permute(points, ah);\n          var nhull = ich(npoints, true);\n          return invPermute(nhull, ah);\n        }\n      }\n    }, {\n      \"affine-hull\": 10,\n      \"incremental-convex-hull\": 233\n    }],\n    62: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function dcubicHermite(p0, v0, p1, v1, t, f) {\n        var dh00 = 6 * t * t - 6 * t,\n            dh10 = 3 * t * t - 4 * t + 1,\n            dh01 = -6 * t * t + 6 * t,\n            dh11 = 3 * t * t - 2 * t;\n\n        if (p0.length) {\n          if (!f) {\n            f = new Array(p0.length);\n          }\n\n          for (var i = p0.length - 1; i >= 0; --i) {\n            f[i] = dh00 * p0[i] + dh10 * v0[i] + dh01 * p1[i] + dh11 * v1[i];\n          }\n\n          return f;\n        }\n\n        return dh00 * p0 + dh10 * v0 + dh01 * p1[i] + dh11 * v1;\n      }\n\n      function cubicHermite(p0, v0, p1, v1, t, f) {\n        var ti = t - 1,\n            t2 = t * t,\n            ti2 = ti * ti,\n            h00 = (1 + 2 * t) * ti2,\n            h10 = t * ti2,\n            h01 = t2 * (3 - 2 * t),\n            h11 = t2 * ti;\n\n        if (p0.length) {\n          if (!f) {\n            f = new Array(p0.length);\n          }\n\n          for (var i = p0.length - 1; i >= 0; --i) {\n            f[i] = h00 * p0[i] + h10 * v0[i] + h01 * p1[i] + h11 * v1[i];\n          }\n\n          return f;\n        }\n\n        return h00 * p0 + h10 * v0 + h01 * p1 + h11 * v1;\n      }\n\n      module.exports = cubicHermite;\n      module.exports.derivative = dcubicHermite;\n    }, {}],\n    63: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var ch = _glvis_(\"incremental-convex-hull\");\n\n      var uniq = _glvis_(\"uniq\");\n\n      module.exports = triangulate;\n\n      function LiftedPoint(p, i) {\n        this.point = p;\n        this.index = i;\n      }\n\n      function compareLifted(a, b) {\n        var ap = a.point;\n        var bp = b.point;\n        var d = ap.length;\n\n        for (var i = 0; i < d; ++i) {\n          var s = bp[i] - ap[i];\n\n          if (s) {\n            return s;\n          }\n        }\n\n        return 0;\n      }\n\n      function triangulate1D(n, points, includePointAtInfinity) {\n        if (n === 1) {\n          if (includePointAtInfinity) {\n            return [[-1, 0]];\n          } else {\n            return [];\n          }\n        }\n\n        var lifted = points.map(function (p, i) {\n          return [p[0], i];\n        });\n        lifted.sort(function (a, b) {\n          return a[0] - b[0];\n        });\n        var cells = new Array(n - 1);\n\n        for (var i = 1; i < n; ++i) {\n          var a = lifted[i - 1];\n          var b = lifted[i];\n          cells[i - 1] = [a[1], b[1]];\n        }\n\n        if (includePointAtInfinity) {\n          cells.push([-1, cells[0][1]], [cells[n - 1][1], -1]);\n        }\n\n        return cells;\n      }\n\n      function triangulate(points, includePointAtInfinity) {\n        var n = points.length;\n\n        if (n === 0) {\n          return [];\n        }\n\n        var d = points[0].length;\n\n        if (d < 1) {\n          return [];\n        } //Special case:  For 1D we can just sort the points\n\n\n        if (d === 1) {\n          return triangulate1D(n, points, includePointAtInfinity);\n        } //Lift points, sort\n\n\n        var lifted = new Array(n);\n        var upper = 1.0;\n\n        for (var i = 0; i < n; ++i) {\n          var p = points[i];\n          var x = new Array(d + 1);\n          var l = 0.0;\n\n          for (var j = 0; j < d; ++j) {\n            var v = p[j];\n            x[j] = v;\n            l += v * v;\n          }\n\n          x[d] = l;\n          lifted[i] = new LiftedPoint(x, i);\n          upper = Math.max(l, upper);\n        }\n\n        uniq(lifted, compareLifted); //Double points\n\n        n = lifted.length; //Create new list of points\n\n        var dpoints = new Array(n + d + 1);\n        var dindex = new Array(n + d + 1); //Add steiner points at top\n\n        var u = (d + 1) * (d + 1) * upper;\n        var y = new Array(d + 1);\n\n        for (var i = 0; i <= d; ++i) {\n          y[i] = 0.0;\n        }\n\n        y[d] = u;\n        dpoints[0] = y.slice();\n        dindex[0] = -1;\n\n        for (var i = 0; i <= d; ++i) {\n          var x = y.slice();\n          x[i] = 1;\n          dpoints[i + 1] = x;\n          dindex[i + 1] = -1;\n        } //Copy rest of the points over\n\n\n        for (var i = 0; i < n; ++i) {\n          var h = lifted[i];\n          dpoints[i + d + 1] = h.point;\n          dindex[i + d + 1] = h.index;\n        } //Construct convex hull\n\n\n        var hull = ch(dpoints, false);\n\n        if (includePointAtInfinity) {\n          hull = hull.filter(function (cell) {\n            var count = 0;\n\n            for (var j = 0; j <= d; ++j) {\n              var v = dindex[cell[j]];\n\n              if (v < 0) {\n                if (++count >= 2) {\n                  return false;\n                }\n              }\n\n              cell[j] = v;\n            }\n\n            return true;\n          });\n        } else {\n          hull = hull.filter(function (cell) {\n            for (var i = 0; i <= d; ++i) {\n              var v = dindex[cell[i]];\n\n              if (v < 0) {\n                return false;\n              }\n\n              cell[i] = v;\n            }\n\n            return true;\n          });\n        }\n\n        if (d & 1) {\n          for (var i = 0; i < hull.length; ++i) {\n            var h = hull[i];\n            var x = h[0];\n            h[0] = h[1];\n            h[1] = x;\n          }\n        }\n\n        return hull;\n      }\n    }, {\n      \"incremental-convex-hull\": 233,\n      \"uniq\": 310\n    }],\n    64: [function (_glvis_, module, exports) {\n      (function (Buffer) {\n        (function () {\n          var hasTypedArrays = false;\n\n          if (typeof Float64Array !== \"undefined\") {\n            var DOUBLE_VIEW = new Float64Array(1),\n                UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);\n            DOUBLE_VIEW[0] = 1.0;\n            hasTypedArrays = true;\n\n            if (UINT_VIEW[1] === 0x3ff00000) {\n              var toDoubleLE = function toDoubleLE(lo, hi) {\n                UINT_VIEW[0] = lo;\n                UINT_VIEW[1] = hi;\n                return DOUBLE_VIEW[0];\n              };\n\n              var lowUintLE = function lowUintLE(n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[0];\n              };\n\n              var highUintLE = function highUintLE(n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[1];\n              };\n\n              //Use little endian\n              module.exports = function doubleBitsLE(n) {\n                DOUBLE_VIEW[0] = n;\n                return [UINT_VIEW[0], UINT_VIEW[1]];\n              };\n\n              module.exports.pack = toDoubleLE;\n              module.exports.lo = lowUintLE;\n              module.exports.hi = highUintLE;\n            } else if (UINT_VIEW[0] === 0x3ff00000) {\n              var toDoubleBE = function toDoubleBE(lo, hi) {\n                UINT_VIEW[1] = lo;\n                UINT_VIEW[0] = hi;\n                return DOUBLE_VIEW[0];\n              };\n\n              var lowUintBE = function lowUintBE(n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[1];\n              };\n\n              var highUintBE = function highUintBE(n) {\n                DOUBLE_VIEW[0] = n;\n                return UINT_VIEW[0];\n              };\n\n              //Use big endian\n              module.exports = function doubleBitsBE(n) {\n                DOUBLE_VIEW[0] = n;\n                return [UINT_VIEW[1], UINT_VIEW[0]];\n              };\n\n              module.exports.pack = toDoubleBE;\n              module.exports.lo = lowUintBE;\n              module.exports.hi = highUintBE;\n            } else {\n              hasTypedArrays = false;\n            }\n          }\n\n          if (!hasTypedArrays) {\n            var toDouble = function toDouble(lo, hi) {\n              buffer.writeUInt32LE(lo, 0, true);\n              buffer.writeUInt32LE(hi, 4, true);\n              return buffer.readDoubleLE(0, true);\n            };\n\n            var lowUint = function lowUint(n) {\n              buffer.writeDoubleLE(n, 0, true);\n              return buffer.readUInt32LE(0, true);\n            };\n\n            var highUint = function highUint(n) {\n              buffer.writeDoubleLE(n, 0, true);\n              return buffer.readUInt32LE(4, true);\n            };\n\n            var buffer = new Buffer(8);\n\n            module.exports = function doubleBits(n) {\n              buffer.writeDoubleLE(n, 0, true);\n              return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];\n            };\n\n            module.exports.pack = toDouble;\n            module.exports.lo = lowUint;\n            module.exports.hi = highUint;\n          }\n\n          module.exports.sign = function (n) {\n            return module.exports.hi(n) >>> 31;\n          };\n\n          module.exports.exponent = function (n) {\n            var b = module.exports.hi(n);\n            return (b << 1 >>> 21) - 1023;\n          };\n\n          module.exports.fraction = function (n) {\n            var lo = module.exports.lo(n);\n            var hi = module.exports.hi(n);\n            var b = hi & (1 << 20) - 1;\n\n            if (hi & 0x7ff00000) {\n              b += 1 << 20;\n            }\n\n            return [lo, b];\n          };\n\n          module.exports.denormalized = function (n) {\n            var hi = module.exports.hi(n);\n            return !(hi & 0x7ff00000);\n          };\n        }).call(this);\n      }).call(this, _glvis_(\"buffer\").Buffer);\n    }, {\n      \"buffer\": 3\n    }],\n    65: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function dupe_array(count, value, i) {\n        var c = count[i] | 0;\n\n        if (c <= 0) {\n          return [];\n        }\n\n        var result = new Array(c),\n            j;\n\n        if (i === count.length - 1) {\n          for (j = 0; j < c; ++j) {\n            result[j] = value;\n          }\n        } else {\n          for (j = 0; j < c; ++j) {\n            result[j] = dupe_array(count, value, i + 1);\n          }\n        }\n\n        return result;\n      }\n\n      function dupe_number(count, value) {\n        var result, i;\n        result = new Array(count);\n\n        for (i = 0; i < count; ++i) {\n          result[i] = value;\n        }\n\n        return result;\n      }\n\n      function dupe(count, value) {\n        if (typeof value === \"undefined\") {\n          value = 0;\n        }\n\n        switch (typeof count) {\n          case \"number\":\n            if (count > 0) {\n              return dupe_number(count | 0, value);\n            }\n\n            break;\n\n          case \"object\":\n            if (typeof count.length === \"number\") {\n              return dupe_array(count, value, 0);\n            }\n\n            break;\n        }\n\n        return [];\n      }\n\n      module.exports = dupe;\n    }, {}],\n    66: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = edgeToAdjacency;\n\n      var uniq = _glvis_(\"uniq\");\n\n      function edgeToAdjacency(edges, numVertices) {\n        var numEdges = edges.length;\n\n        if (typeof numVertices !== \"number\") {\n          numVertices = 0;\n\n          for (var i = 0; i < numEdges; ++i) {\n            var e = edges[i];\n            numVertices = Math.max(numVertices, e[0], e[1]);\n          }\n\n          numVertices = (numVertices | 0) + 1;\n        }\n\n        numVertices = numVertices | 0;\n        var adj = new Array(numVertices);\n\n        for (var i = 0; i < numVertices; ++i) {\n          adj[i] = [];\n        }\n\n        for (var i = 0; i < numEdges; ++i) {\n          var e = edges[i];\n          adj[e[0]].push(e[1]);\n          adj[e[1]].push(e[0]);\n        }\n\n        for (var j = 0; j < numVertices; ++j) {\n          uniq(adj[j], function (a, b) {\n            return a - b;\n          });\n        }\n\n        return adj;\n      }\n    }, {\n      \"uniq\": 310\n    }],\n    67: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = extractPlanes;\n\n      function extractPlanes(M, zNear, zFar) {\n        var z = zNear || 0.0;\n        var zf = zFar || 1.0;\n        return [[M[12] + M[0], M[13] + M[1], M[14] + M[2], M[15] + M[3]], [M[12] - M[0], M[13] - M[1], M[14] - M[2], M[15] - M[3]], [M[12] + M[4], M[13] + M[5], M[14] + M[6], M[15] + M[7]], [M[12] - M[4], M[13] - M[5], M[14] - M[6], M[15] - M[7]], [z * M[12] + M[8], z * M[13] + M[9], z * M[14] + M[10], z * M[15] + M[11]], [zf * M[12] - M[8], zf * M[13] - M[9], zf * M[14] - M[10], zf * M[15] - M[11]]];\n      }\n    }, {}],\n    68: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createFilteredVector;\n\n      var cubicHermite = _glvis_('cubic-hermite');\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      function clamp(lo, hi, x) {\n        return Math.min(hi, Math.max(lo, x));\n      }\n\n      function FilteredVector(state0, velocity0, t0) {\n        this.dimension = state0.length;\n        this.bounds = [new Array(this.dimension), new Array(this.dimension)];\n\n        for (var i = 0; i < this.dimension; ++i) {\n          this.bounds[0][i] = -Infinity;\n          this.bounds[1][i] = Infinity;\n        }\n\n        this._state = state0.slice().reverse();\n        this._velocity = velocity0.slice().reverse();\n        this._time = [t0];\n        this._scratch = [state0.slice(), state0.slice(), state0.slice(), state0.slice(), state0.slice()];\n      }\n\n      var proto = FilteredVector.prototype;\n\n      proto.flush = function (t) {\n        var idx = bsearch.gt(this._time, t) - 1;\n\n        if (idx <= 0) {\n          return;\n        }\n\n        this._time.splice(0, idx);\n\n        this._state.splice(0, idx * this.dimension);\n\n        this._velocity.splice(0, idx * this.dimension);\n      };\n\n      proto.curve = function (t) {\n        var time = this._time;\n        var n = time.length;\n        var idx = bsearch.le(time, t);\n        var result = this._scratch[0];\n        var state = this._state;\n        var velocity = this._velocity;\n        var d = this.dimension;\n        var bounds = this.bounds;\n\n        if (idx < 0) {\n          var ptr = d - 1;\n\n          for (var i = 0; i < d; ++i, --ptr) {\n            result[i] = state[ptr];\n          }\n        } else if (idx >= n - 1) {\n          var ptr = state.length - 1;\n          var tf = t - time[n - 1];\n\n          for (var i = 0; i < d; ++i, --ptr) {\n            result[i] = state[ptr] + tf * velocity[ptr];\n          }\n        } else {\n          var ptr = d * (idx + 1) - 1;\n          var t0 = time[idx];\n          var t1 = time[idx + 1];\n          var dt = t1 - t0 || 1.0;\n          var x0 = this._scratch[1];\n          var x1 = this._scratch[2];\n          var v0 = this._scratch[3];\n          var v1 = this._scratch[4];\n          var steady = true;\n\n          for (var i = 0; i < d; ++i, --ptr) {\n            x0[i] = state[ptr];\n            v0[i] = velocity[ptr] * dt;\n            x1[i] = state[ptr + d];\n            v1[i] = velocity[ptr + d] * dt;\n            steady = steady && x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0.0;\n          }\n\n          if (steady) {\n            for (var i = 0; i < d; ++i) {\n              result[i] = x0[i];\n            }\n          } else {\n            cubicHermite(x0, v0, x1, v1, (t - t0) / dt, result);\n          }\n        }\n\n        var lo = bounds[0];\n        var hi = bounds[1];\n\n        for (var i = 0; i < d; ++i) {\n          result[i] = clamp(lo[i], hi[i], result[i]);\n        }\n\n        return result;\n      };\n\n      proto.dcurve = function (t) {\n        var time = this._time;\n        var n = time.length;\n        var idx = bsearch.le(time, t);\n        var result = this._scratch[0];\n        var state = this._state;\n        var velocity = this._velocity;\n        var d = this.dimension;\n\n        if (idx >= n - 1) {\n          var ptr = state.length - 1;\n          var tf = t - time[n - 1];\n\n          for (var i = 0; i < d; ++i, --ptr) {\n            result[i] = velocity[ptr];\n          }\n        } else {\n          var ptr = d * (idx + 1) - 1;\n          var t0 = time[idx];\n          var t1 = time[idx + 1];\n          var dt = t1 - t0 || 1.0;\n          var x0 = this._scratch[1];\n          var x1 = this._scratch[2];\n          var v0 = this._scratch[3];\n          var v1 = this._scratch[4];\n          var steady = true;\n\n          for (var i = 0; i < d; ++i, --ptr) {\n            x0[i] = state[ptr];\n            v0[i] = velocity[ptr] * dt;\n            x1[i] = state[ptr + d];\n            v1[i] = velocity[ptr + d] * dt;\n            steady = steady && x0[i] === x1[i] && v0[i] === v1[i] && v0[i] === 0.0;\n          }\n\n          if (steady) {\n            for (var i = 0; i < d; ++i) {\n              result[i] = 0.0;\n            }\n          } else {\n            cubicHermite.derivative(x0, v0, x1, v1, (t - t0) / dt, result);\n\n            for (var i = 0; i < d; ++i) {\n              result[i] /= dt;\n            }\n          }\n        }\n\n        return result;\n      };\n\n      proto.lastT = function () {\n        var time = this._time;\n        return time[time.length - 1];\n      };\n\n      proto.stable = function () {\n        var velocity = this._velocity;\n        var ptr = velocity.length;\n\n        for (var i = this.dimension - 1; i >= 0; --i) {\n          if (velocity[--ptr]) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      proto.jump = function (t) {\n        var t0 = this.lastT();\n        var d = this.dimension;\n\n        if (t < t0 || arguments.length !== d + 1) {\n          return;\n        }\n\n        var state = this._state;\n        var velocity = this._velocity;\n        var ptr = state.length - this.dimension;\n        var bounds = this.bounds;\n        var lo = bounds[0];\n        var hi = bounds[1];\n\n        this._time.push(t0, t);\n\n        for (var j = 0; j < 2; ++j) {\n          for (var i = 0; i < d; ++i) {\n            state.push(state[ptr++]);\n            velocity.push(0);\n          }\n        }\n\n        this._time.push(t);\n\n        for (var i = d; i > 0; --i) {\n          state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));\n          velocity.push(0);\n        }\n      };\n\n      proto.push = function (t) {\n        var t0 = this.lastT();\n        var d = this.dimension;\n\n        if (t < t0 || arguments.length !== d + 1) {\n          return;\n        }\n\n        var state = this._state;\n        var velocity = this._velocity;\n        var ptr = state.length - this.dimension;\n        var dt = t - t0;\n        var bounds = this.bounds;\n        var lo = bounds[0];\n        var hi = bounds[1];\n        var sf = dt > 1e-6 ? 1 / dt : 0;\n\n        this._time.push(t);\n\n        for (var i = d; i > 0; --i) {\n          var xc = clamp(lo[i - 1], hi[i - 1], arguments[i]);\n          state.push(xc);\n          velocity.push((xc - state[ptr++]) * sf);\n        }\n      };\n\n      proto.set = function (t) {\n        var d = this.dimension;\n\n        if (t < this.lastT() || arguments.length !== d + 1) {\n          return;\n        }\n\n        var state = this._state;\n        var velocity = this._velocity;\n        var bounds = this.bounds;\n        var lo = bounds[0];\n        var hi = bounds[1];\n\n        this._time.push(t);\n\n        for (var i = d; i > 0; --i) {\n          state.push(clamp(lo[i - 1], hi[i - 1], arguments[i]));\n          velocity.push(0);\n        }\n      };\n\n      proto.move = function (t) {\n        var t0 = this.lastT();\n        var d = this.dimension;\n\n        if (t <= t0 || arguments.length !== d + 1) {\n          return;\n        }\n\n        var state = this._state;\n        var velocity = this._velocity;\n        var statePtr = state.length - this.dimension;\n        var bounds = this.bounds;\n        var lo = bounds[0];\n        var hi = bounds[1];\n        var dt = t - t0;\n        var sf = dt > 1e-6 ? 1 / dt : 0.0;\n\n        this._time.push(t);\n\n        for (var i = d; i > 0; --i) {\n          var dx = arguments[i];\n          state.push(clamp(lo[i - 1], hi[i - 1], state[statePtr++] + dx));\n          velocity.push(dx * sf);\n        }\n      };\n\n      proto.idle = function (t) {\n        var t0 = this.lastT();\n\n        if (t < t0) {\n          return;\n        }\n\n        var d = this.dimension;\n        var state = this._state;\n        var velocity = this._velocity;\n        var statePtr = state.length - d;\n        var bounds = this.bounds;\n        var lo = bounds[0];\n        var hi = bounds[1];\n        var dt = t - t0;\n\n        this._time.push(t);\n\n        for (var i = d - 1; i >= 0; --i) {\n          state.push(clamp(lo[i], hi[i], state[statePtr] + dt * velocity[statePtr]));\n          velocity.push(0);\n          statePtr += 1;\n        }\n      };\n\n      function getZero(d) {\n        var result = new Array(d);\n\n        for (var i = 0; i < d; ++i) {\n          result[i] = 0.0;\n        }\n\n        return result;\n      }\n\n      function createFilteredVector(initState, initVelocity, initTime) {\n        switch (arguments.length) {\n          case 0:\n            return new FilteredVector([0], [0], 0);\n\n          case 1:\n            if (typeof initState === 'number') {\n              var zero = getZero(initState);\n              return new FilteredVector(zero, zero, 0);\n            } else {\n              return new FilteredVector(initState, getZero(initState.length), 0);\n            }\n\n          case 2:\n            if (typeof initVelocity === 'number') {\n              var zero = getZero(initState.length);\n              return new FilteredVector(initState, zero, +initVelocity);\n            } else {\n              initTime = 0;\n            }\n\n          case 3:\n            if (initState.length !== initVelocity.length) {\n              throw new Error('state and velocity lengths must match');\n            }\n\n            return new FilteredVector(initState, initVelocity, initTime);\n        }\n      }\n    }, {\n      \"binary-search-bounds\": 31,\n      \"cubic-hermite\": 62\n    }],\n    69: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = createRBTree;\n      var RED = 0;\n      var BLACK = 1;\n\n      function RBNode(color, key, value, left, right, count) {\n        this._color = color;\n        this.key = key;\n        this.value = value;\n        this.left = left;\n        this.right = right;\n        this._count = count;\n      }\n\n      function cloneNode(node) {\n        return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);\n      }\n\n      function repaint(color, node) {\n        return new RBNode(color, node.key, node.value, node.left, node.right, node._count);\n      }\n\n      function recount(node) {\n        node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);\n      }\n\n      function RedBlackTree(compare, root) {\n        this._compare = compare;\n        this.root = root;\n      }\n\n      var proto = RedBlackTree.prototype;\n      Object.defineProperty(proto, \"keys\", {\n        get: function get() {\n          var result = [];\n          this.forEach(function (k, v) {\n            result.push(k);\n          });\n          return result;\n        }\n      });\n      Object.defineProperty(proto, \"values\", {\n        get: function get() {\n          var result = [];\n          this.forEach(function (k, v) {\n            result.push(v);\n          });\n          return result;\n        }\n      }); //Returns the number of nodes in the tree\n\n      Object.defineProperty(proto, \"length\", {\n        get: function get() {\n          if (this.root) {\n            return this.root._count;\n          }\n\n          return 0;\n        }\n      }); //Insert a new item into the tree\n\n      proto.insert = function (key, value) {\n        var cmp = this._compare; //Find point to insert new node at\n\n        var n = this.root;\n        var n_stack = [];\n        var d_stack = [];\n\n        while (n) {\n          var d = cmp(key, n.key);\n          n_stack.push(n);\n          d_stack.push(d);\n\n          if (d <= 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        } //Rebuild path to leaf node\n\n\n        n_stack.push(new RBNode(RED, key, value, null, null, 1));\n\n        for (var s = n_stack.length - 2; s >= 0; --s) {\n          var n = n_stack[s];\n\n          if (d_stack[s] <= 0) {\n            n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);\n          } else {\n            n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);\n          }\n        } //Rebalance tree using rotations\n        //console.log(\"start insert\", key, d_stack)\n\n\n        for (var s = n_stack.length - 1; s > 1; --s) {\n          var p = n_stack[s - 1];\n          var n = n_stack[s];\n\n          if (p._color === BLACK || n._color === BLACK) {\n            break;\n          }\n\n          var pp = n_stack[s - 2];\n\n          if (pp.left === p) {\n            if (p.left === n) {\n              var y = pp.right;\n\n              if (y && y._color === RED) {\n                //console.log(\"LLr\")\n                p._color = BLACK;\n                pp.right = repaint(BLACK, y);\n                pp._color = RED;\n                s -= 1;\n              } else {\n                //console.log(\"LLb\")\n                pp._color = RED;\n                pp.left = p.right;\n                p._color = BLACK;\n                p.right = pp;\n                n_stack[s - 2] = p;\n                n_stack[s - 1] = n;\n                recount(pp);\n                recount(p);\n\n                if (s >= 3) {\n                  var ppp = n_stack[s - 3];\n\n                  if (ppp.left === pp) {\n                    ppp.left = p;\n                  } else {\n                    ppp.right = p;\n                  }\n                }\n\n                break;\n              }\n            } else {\n              var y = pp.right;\n\n              if (y && y._color === RED) {\n                //console.log(\"LRr\")\n                p._color = BLACK;\n                pp.right = repaint(BLACK, y);\n                pp._color = RED;\n                s -= 1;\n              } else {\n                //console.log(\"LRb\")\n                p.right = n.left;\n                pp._color = RED;\n                pp.left = n.right;\n                n._color = BLACK;\n                n.left = p;\n                n.right = pp;\n                n_stack[s - 2] = n;\n                n_stack[s - 1] = p;\n                recount(pp);\n                recount(p);\n                recount(n);\n\n                if (s >= 3) {\n                  var ppp = n_stack[s - 3];\n\n                  if (ppp.left === pp) {\n                    ppp.left = n;\n                  } else {\n                    ppp.right = n;\n                  }\n                }\n\n                break;\n              }\n            }\n          } else {\n            if (p.right === n) {\n              var y = pp.left;\n\n              if (y && y._color === RED) {\n                //console.log(\"RRr\", y.key)\n                p._color = BLACK;\n                pp.left = repaint(BLACK, y);\n                pp._color = RED;\n                s -= 1;\n              } else {\n                //console.log(\"RRb\")\n                pp._color = RED;\n                pp.right = p.left;\n                p._color = BLACK;\n                p.left = pp;\n                n_stack[s - 2] = p;\n                n_stack[s - 1] = n;\n                recount(pp);\n                recount(p);\n\n                if (s >= 3) {\n                  var ppp = n_stack[s - 3];\n\n                  if (ppp.right === pp) {\n                    ppp.right = p;\n                  } else {\n                    ppp.left = p;\n                  }\n                }\n\n                break;\n              }\n            } else {\n              var y = pp.left;\n\n              if (y && y._color === RED) {\n                //console.log(\"RLr\")\n                p._color = BLACK;\n                pp.left = repaint(BLACK, y);\n                pp._color = RED;\n                s -= 1;\n              } else {\n                //console.log(\"RLb\")\n                p.left = n.right;\n                pp._color = RED;\n                pp.right = n.left;\n                n._color = BLACK;\n                n.right = p;\n                n.left = pp;\n                n_stack[s - 2] = n;\n                n_stack[s - 1] = p;\n                recount(pp);\n                recount(p);\n                recount(n);\n\n                if (s >= 3) {\n                  var ppp = n_stack[s - 3];\n\n                  if (ppp.right === pp) {\n                    ppp.right = n;\n                  } else {\n                    ppp.left = n;\n                  }\n                }\n\n                break;\n              }\n            }\n          }\n        } //Return new tree\n\n\n        n_stack[0]._color = BLACK;\n        return new RedBlackTree(cmp, n_stack[0]);\n      }; //Visit all nodes inorder\n\n\n      function doVisitFull(visit, node) {\n        if (node.left) {\n          var v = doVisitFull(visit, node.left);\n\n          if (v) {\n            return v;\n          }\n        }\n\n        var v = visit(node.key, node.value);\n\n        if (v) {\n          return v;\n        }\n\n        if (node.right) {\n          return doVisitFull(visit, node.right);\n        }\n      } //Visit half nodes in order\n\n\n      function doVisitHalf(lo, compare, visit, node) {\n        var l = compare(lo, node.key);\n\n        if (l <= 0) {\n          if (node.left) {\n            var v = doVisitHalf(lo, compare, visit, node.left);\n\n            if (v) {\n              return v;\n            }\n          }\n\n          var v = visit(node.key, node.value);\n\n          if (v) {\n            return v;\n          }\n        }\n\n        if (node.right) {\n          return doVisitHalf(lo, compare, visit, node.right);\n        }\n      } //Visit all nodes within a range\n\n\n      function doVisit(lo, hi, compare, visit, node) {\n        var l = compare(lo, node.key);\n        var h = compare(hi, node.key);\n        var v;\n\n        if (l <= 0) {\n          if (node.left) {\n            v = doVisit(lo, hi, compare, visit, node.left);\n\n            if (v) {\n              return v;\n            }\n          }\n\n          if (h > 0) {\n            v = visit(node.key, node.value);\n\n            if (v) {\n              return v;\n            }\n          }\n        }\n\n        if (h > 0 && node.right) {\n          return doVisit(lo, hi, compare, visit, node.right);\n        }\n      }\n\n      proto.forEach = function rbTreeForEach(visit, lo, hi) {\n        if (!this.root) {\n          return;\n        }\n\n        switch (arguments.length) {\n          case 1:\n            return doVisitFull(visit, this.root);\n            break;\n\n          case 2:\n            return doVisitHalf(lo, this._compare, visit, this.root);\n            break;\n\n          case 3:\n            if (this._compare(lo, hi) >= 0) {\n              return;\n            }\n\n            return doVisit(lo, hi, this._compare, visit, this.root);\n            break;\n        }\n      }; //First item in list\n\n\n      Object.defineProperty(proto, \"begin\", {\n        get: function get() {\n          var stack = [];\n          var n = this.root;\n\n          while (n) {\n            stack.push(n);\n            n = n.left;\n          }\n\n          return new RedBlackTreeIterator(this, stack);\n        }\n      }); //Last item in list\n\n      Object.defineProperty(proto, \"end\", {\n        get: function get() {\n          var stack = [];\n          var n = this.root;\n\n          while (n) {\n            stack.push(n);\n            n = n.right;\n          }\n\n          return new RedBlackTreeIterator(this, stack);\n        }\n      }); //Find the ith item in the tree\n\n      proto.at = function (idx) {\n        if (idx < 0) {\n          return new RedBlackTreeIterator(this, []);\n        }\n\n        var n = this.root;\n        var stack = [];\n\n        while (true) {\n          stack.push(n);\n\n          if (n.left) {\n            if (idx < n.left._count) {\n              n = n.left;\n              continue;\n            }\n\n            idx -= n.left._count;\n          }\n\n          if (!idx) {\n            return new RedBlackTreeIterator(this, stack);\n          }\n\n          idx -= 1;\n\n          if (n.right) {\n            if (idx >= n.right._count) {\n              break;\n            }\n\n            n = n.right;\n          } else {\n            break;\n          }\n        }\n\n        return new RedBlackTreeIterator(this, []);\n      };\n\n      proto.ge = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n        var stack = [];\n        var last_ptr = 0;\n\n        while (n) {\n          var d = cmp(key, n.key);\n          stack.push(n);\n\n          if (d <= 0) {\n            last_ptr = stack.length;\n          }\n\n          if (d <= 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        stack.length = last_ptr;\n        return new RedBlackTreeIterator(this, stack);\n      };\n\n      proto.gt = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n        var stack = [];\n        var last_ptr = 0;\n\n        while (n) {\n          var d = cmp(key, n.key);\n          stack.push(n);\n\n          if (d < 0) {\n            last_ptr = stack.length;\n          }\n\n          if (d < 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        stack.length = last_ptr;\n        return new RedBlackTreeIterator(this, stack);\n      };\n\n      proto.lt = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n        var stack = [];\n        var last_ptr = 0;\n\n        while (n) {\n          var d = cmp(key, n.key);\n          stack.push(n);\n\n          if (d > 0) {\n            last_ptr = stack.length;\n          }\n\n          if (d <= 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        stack.length = last_ptr;\n        return new RedBlackTreeIterator(this, stack);\n      };\n\n      proto.le = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n        var stack = [];\n        var last_ptr = 0;\n\n        while (n) {\n          var d = cmp(key, n.key);\n          stack.push(n);\n\n          if (d >= 0) {\n            last_ptr = stack.length;\n          }\n\n          if (d < 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        stack.length = last_ptr;\n        return new RedBlackTreeIterator(this, stack);\n      }; //Finds the item with key if it exists\n\n\n      proto.find = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n        var stack = [];\n\n        while (n) {\n          var d = cmp(key, n.key);\n          stack.push(n);\n\n          if (d === 0) {\n            return new RedBlackTreeIterator(this, stack);\n          }\n\n          if (d <= 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        return new RedBlackTreeIterator(this, []);\n      }; //Removes item with key from tree\n\n\n      proto.remove = function (key) {\n        var iter = this.find(key);\n\n        if (iter) {\n          return iter.remove();\n        }\n\n        return this;\n      }; //Returns the item at `key`\n\n\n      proto.get = function (key) {\n        var cmp = this._compare;\n        var n = this.root;\n\n        while (n) {\n          var d = cmp(key, n.key);\n\n          if (d === 0) {\n            return n.value;\n          }\n\n          if (d <= 0) {\n            n = n.left;\n          } else {\n            n = n.right;\n          }\n        }\n\n        return;\n      }; //Iterator for red black tree\n\n\n      function RedBlackTreeIterator(tree, stack) {\n        this.tree = tree;\n        this._stack = stack;\n      }\n\n      var iproto = RedBlackTreeIterator.prototype; //Test if iterator is valid\n\n      Object.defineProperty(iproto, \"valid\", {\n        get: function get() {\n          return this._stack.length > 0;\n        }\n      }); //Node of the iterator\n\n      Object.defineProperty(iproto, \"node\", {\n        get: function get() {\n          if (this._stack.length > 0) {\n            return this._stack[this._stack.length - 1];\n          }\n\n          return null;\n        },\n        enumerable: true\n      }); //Makes a copy of an iterator\n\n      iproto.clone = function () {\n        return new RedBlackTreeIterator(this.tree, this._stack.slice());\n      }; //Swaps two nodes\n\n\n      function swapNode(n, v) {\n        n.key = v.key;\n        n.value = v.value;\n        n.left = v.left;\n        n.right = v.right;\n        n._color = v._color;\n        n._count = v._count;\n      } //Fix up a double black node in a tree\n\n\n      function fixDoubleBlack(stack) {\n        var n, p, s, z;\n\n        for (var i = stack.length - 1; i >= 0; --i) {\n          n = stack[i];\n\n          if (i === 0) {\n            n._color = BLACK;\n            return;\n          } //console.log(\"visit node:\", n.key, i, stack[i].key, stack[i-1].key)\n\n\n          p = stack[i - 1];\n\n          if (p.left === n) {\n            //console.log(\"left child\")\n            s = p.right;\n\n            if (s.right && s.right._color === RED) {\n              //console.log(\"case 1: right sibling child red\")\n              s = p.right = cloneNode(s);\n              z = s.right = cloneNode(s.right);\n              p.right = s.left;\n              s.left = p;\n              s.right = z;\n              s._color = p._color;\n              n._color = BLACK;\n              p._color = BLACK;\n              z._color = BLACK;\n              recount(p);\n              recount(s);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.left === p) {\n                  pp.left = s;\n                } else {\n                  pp.right = s;\n                }\n              }\n\n              stack[i - 1] = s;\n              return;\n            } else if (s.left && s.left._color === RED) {\n              //console.log(\"case 1: left sibling child red\")\n              s = p.right = cloneNode(s);\n              z = s.left = cloneNode(s.left);\n              p.right = z.left;\n              s.left = z.right;\n              z.left = p;\n              z.right = s;\n              z._color = p._color;\n              p._color = BLACK;\n              s._color = BLACK;\n              n._color = BLACK;\n              recount(p);\n              recount(s);\n              recount(z);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.left === p) {\n                  pp.left = z;\n                } else {\n                  pp.right = z;\n                }\n              }\n\n              stack[i - 1] = z;\n              return;\n            }\n\n            if (s._color === BLACK) {\n              if (p._color === RED) {\n                //console.log(\"case 2: black sibling, red parent\", p.right.value)\n                p._color = BLACK;\n                p.right = repaint(RED, s);\n                return;\n              } else {\n                //console.log(\"case 2: black sibling, black parent\", p.right.value)\n                p.right = repaint(RED, s);\n                continue;\n              }\n            } else {\n              //console.log(\"case 3: red sibling\")\n              s = cloneNode(s);\n              p.right = s.left;\n              s.left = p;\n              s._color = p._color;\n              p._color = RED;\n              recount(p);\n              recount(s);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.left === p) {\n                  pp.left = s;\n                } else {\n                  pp.right = s;\n                }\n              }\n\n              stack[i - 1] = s;\n              stack[i] = p;\n\n              if (i + 1 < stack.length) {\n                stack[i + 1] = n;\n              } else {\n                stack.push(n);\n              }\n\n              i = i + 2;\n            }\n          } else {\n            //console.log(\"right child\")\n            s = p.left;\n\n            if (s.left && s.left._color === RED) {\n              //console.log(\"case 1: left sibling child red\", p.value, p._color)\n              s = p.left = cloneNode(s);\n              z = s.left = cloneNode(s.left);\n              p.left = s.right;\n              s.right = p;\n              s.left = z;\n              s._color = p._color;\n              n._color = BLACK;\n              p._color = BLACK;\n              z._color = BLACK;\n              recount(p);\n              recount(s);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.right === p) {\n                  pp.right = s;\n                } else {\n                  pp.left = s;\n                }\n              }\n\n              stack[i - 1] = s;\n              return;\n            } else if (s.right && s.right._color === RED) {\n              //console.log(\"case 1: right sibling child red\")\n              s = p.left = cloneNode(s);\n              z = s.right = cloneNode(s.right);\n              p.left = z.right;\n              s.right = z.left;\n              z.right = p;\n              z.left = s;\n              z._color = p._color;\n              p._color = BLACK;\n              s._color = BLACK;\n              n._color = BLACK;\n              recount(p);\n              recount(s);\n              recount(z);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.right === p) {\n                  pp.right = z;\n                } else {\n                  pp.left = z;\n                }\n              }\n\n              stack[i - 1] = z;\n              return;\n            }\n\n            if (s._color === BLACK) {\n              if (p._color === RED) {\n                //console.log(\"case 2: black sibling, red parent\")\n                p._color = BLACK;\n                p.left = repaint(RED, s);\n                return;\n              } else {\n                //console.log(\"case 2: black sibling, black parent\")\n                p.left = repaint(RED, s);\n                continue;\n              }\n            } else {\n              //console.log(\"case 3: red sibling\")\n              s = cloneNode(s);\n              p.left = s.right;\n              s.right = p;\n              s._color = p._color;\n              p._color = RED;\n              recount(p);\n              recount(s);\n\n              if (i > 1) {\n                var pp = stack[i - 2];\n\n                if (pp.right === p) {\n                  pp.right = s;\n                } else {\n                  pp.left = s;\n                }\n              }\n\n              stack[i - 1] = s;\n              stack[i] = p;\n\n              if (i + 1 < stack.length) {\n                stack[i + 1] = n;\n              } else {\n                stack.push(n);\n              }\n\n              i = i + 2;\n            }\n          }\n        }\n      } //Removes item at iterator from tree\n\n\n      iproto.remove = function () {\n        var stack = this._stack;\n\n        if (stack.length === 0) {\n          return this.tree;\n        } //First copy path to node\n\n\n        var cstack = new Array(stack.length);\n        var n = stack[stack.length - 1];\n        cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);\n\n        for (var i = stack.length - 2; i >= 0; --i) {\n          var n = stack[i];\n\n          if (n.left === stack[i + 1]) {\n            cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);\n          } else {\n            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n          }\n        } //Get node\n\n\n        n = cstack[cstack.length - 1]; //console.log(\"start remove: \", n.value)\n        //If not leaf, then swap with previous node\n\n        if (n.left && n.right) {\n          //console.log(\"moving to leaf\")\n          //First walk to previous leaf\n          var split = cstack.length;\n          n = n.left;\n\n          while (n.right) {\n            cstack.push(n);\n            n = n.right;\n          } //Copy path to leaf\n\n\n          var v = cstack[split - 1];\n          cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));\n          cstack[split - 1].key = n.key;\n          cstack[split - 1].value = n.value; //Fix up stack\n\n          for (var i = cstack.length - 2; i >= split; --i) {\n            n = cstack[i];\n            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n          }\n\n          cstack[split - 1].left = cstack[split];\n        } //console.log(\"stack=\", cstack.map(function(v) { return v.value }))\n        //Remove leaf node\n\n\n        n = cstack[cstack.length - 1];\n\n        if (n._color === RED) {\n          //Easy case: removing red leaf\n          //console.log(\"RED leaf\")\n          var p = cstack[cstack.length - 2];\n\n          if (p.left === n) {\n            p.left = null;\n          } else if (p.right === n) {\n            p.right = null;\n          }\n\n          cstack.pop();\n\n          for (var i = 0; i < cstack.length; ++i) {\n            cstack[i]._count--;\n          }\n\n          return new RedBlackTree(this.tree._compare, cstack[0]);\n        } else {\n          if (n.left || n.right) {\n            //Second easy case:  Single child black parent\n            //console.log(\"BLACK single child\")\n            if (n.left) {\n              swapNode(n, n.left);\n            } else if (n.right) {\n              swapNode(n, n.right);\n            } //Child must be red, so repaint it black to balance color\n\n\n            n._color = BLACK;\n\n            for (var i = 0; i < cstack.length - 1; ++i) {\n              cstack[i]._count--;\n            }\n\n            return new RedBlackTree(this.tree._compare, cstack[0]);\n          } else if (cstack.length === 1) {\n            //Third easy case: root\n            //console.log(\"ROOT\")\n            return new RedBlackTree(this.tree._compare, null);\n          } else {\n            //Hard case: Repaint n, and then do some nasty stuff\n            //console.log(\"BLACK leaf no children\")\n            for (var i = 0; i < cstack.length; ++i) {\n              cstack[i]._count--;\n            }\n\n            var parent = cstack[cstack.length - 2];\n            fixDoubleBlack(cstack); //Fix up links\n\n            if (parent.left === n) {\n              parent.left = null;\n            } else {\n              parent.right = null;\n            }\n          }\n        }\n\n        return new RedBlackTree(this.tree._compare, cstack[0]);\n      }; //Returns key\n\n\n      Object.defineProperty(iproto, \"key\", {\n        get: function get() {\n          if (this._stack.length > 0) {\n            return this._stack[this._stack.length - 1].key;\n          }\n\n          return;\n        },\n        enumerable: true\n      }); //Returns value\n\n      Object.defineProperty(iproto, \"value\", {\n        get: function get() {\n          if (this._stack.length > 0) {\n            return this._stack[this._stack.length - 1].value;\n          }\n\n          return;\n        },\n        enumerable: true\n      }); //Returns the position of this iterator in the sorted list\n\n      Object.defineProperty(iproto, \"index\", {\n        get: function get() {\n          var idx = 0;\n          var stack = this._stack;\n\n          if (stack.length === 0) {\n            var r = this.tree.root;\n\n            if (r) {\n              return r._count;\n            }\n\n            return 0;\n          } else if (stack[stack.length - 1].left) {\n            idx = stack[stack.length - 1].left._count;\n          }\n\n          for (var s = stack.length - 2; s >= 0; --s) {\n            if (stack[s + 1] === stack[s].right) {\n              ++idx;\n\n              if (stack[s].left) {\n                idx += stack[s].left._count;\n              }\n            }\n          }\n\n          return idx;\n        },\n        enumerable: true\n      }); //Advances iterator to next element in list\n\n      iproto.next = function () {\n        var stack = this._stack;\n\n        if (stack.length === 0) {\n          return;\n        }\n\n        var n = stack[stack.length - 1];\n\n        if (n.right) {\n          n = n.right;\n\n          while (n) {\n            stack.push(n);\n            n = n.left;\n          }\n        } else {\n          stack.pop();\n\n          while (stack.length > 0 && stack[stack.length - 1].right === n) {\n            n = stack[stack.length - 1];\n            stack.pop();\n          }\n        }\n      }; //Checks if iterator is at end of tree\n\n\n      Object.defineProperty(iproto, \"hasNext\", {\n        get: function get() {\n          var stack = this._stack;\n\n          if (stack.length === 0) {\n            return false;\n          }\n\n          if (stack[stack.length - 1].right) {\n            return true;\n          }\n\n          for (var s = stack.length - 1; s > 0; --s) {\n            if (stack[s - 1].left === stack[s]) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n      }); //Update value\n\n      iproto.update = function (value) {\n        var stack = this._stack;\n\n        if (stack.length === 0) {\n          throw new Error(\"Can't update empty node!\");\n        }\n\n        var cstack = new Array(stack.length);\n        var n = stack[stack.length - 1];\n        cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);\n\n        for (var i = stack.length - 2; i >= 0; --i) {\n          n = stack[i];\n\n          if (n.left === stack[i + 1]) {\n            cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);\n          } else {\n            cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);\n          }\n        }\n\n        return new RedBlackTree(this.tree._compare, cstack[0]);\n      }; //Moves iterator backward one element\n\n\n      iproto.prev = function () {\n        var stack = this._stack;\n\n        if (stack.length === 0) {\n          return;\n        }\n\n        var n = stack[stack.length - 1];\n\n        if (n.left) {\n          n = n.left;\n\n          while (n) {\n            stack.push(n);\n            n = n.right;\n          }\n        } else {\n          stack.pop();\n\n          while (stack.length > 0 && stack[stack.length - 1].left === n) {\n            n = stack[stack.length - 1];\n            stack.pop();\n          }\n        }\n      }; //Checks if iterator is at start of tree\n\n\n      Object.defineProperty(iproto, \"hasPrev\", {\n        get: function get() {\n          var stack = this._stack;\n\n          if (stack.length === 0) {\n            return false;\n          }\n\n          if (stack[stack.length - 1].left) {\n            return true;\n          }\n\n          for (var s = stack.length - 1; s > 0; --s) {\n            if (stack[s - 1].right === stack[s]) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n      }); //Default comparison function\n\n      function defaultCompare(a, b) {\n        if (a < b) {\n          return -1;\n        }\n\n        if (a > b) {\n          return 1;\n        }\n\n        return 0;\n      } //Build a tree\n\n\n      function createRBTree(compare) {\n        return new RedBlackTree(compare || defaultCompare, null);\n      }\n    }, {}],\n    70: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createAxes;\n\n      var createText = _glvis_('./lib/text.js');\n\n      var createLines = _glvis_('./lib/lines.js');\n\n      var createBackground = _glvis_('./lib/background.js');\n\n      var getCubeProperties = _glvis_('./lib/cube.js');\n\n      var Ticks = _glvis_('./lib/ticks.js');\n\n      var identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n\n      function copyVec3(a, b) {\n        a[0] = b[0];\n        a[1] = b[1];\n        a[2] = b[2];\n        return a;\n      }\n\n      function Axes(gl) {\n        this.gl = gl;\n        this.pixelRatio = 1;\n        this.bounds = [[-10, -10, -10], [10, 10, 10]];\n        this.ticks = [[], [], []];\n        this.autoTicks = true;\n        this.tickSpacing = [1, 1, 1];\n        this.tickEnable = [true, true, true];\n        this.tickFont = ['sans-serif', 'sans-serif', 'sans-serif'];\n        this.tickSize = [12, 12, 12];\n        this.tickAngle = [0, 0, 0];\n        this.tickAlign = ['auto', 'auto', 'auto'];\n        this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.tickPad = [10, 10, 10];\n        this.lastCubeProps = {\n          cubeEdges: [0, 0, 0],\n          axis: [0, 0, 0]\n        };\n        this.labels = ['x', 'y', 'z'];\n        this.labelEnable = [true, true, true];\n        this.labelFont = 'sans-serif';\n        this.labelSize = [20, 20, 20];\n        this.labelAngle = [0, 0, 0];\n        this.labelAlign = ['auto', 'auto', 'auto'];\n        this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.labelPad = [10, 10, 10];\n        this.lineEnable = [true, true, true];\n        this.lineMirror = [false, false, false];\n        this.lineWidth = [1, 1, 1];\n        this.lineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.lineTickEnable = [true, true, true];\n        this.lineTickMirror = [false, false, false];\n        this.lineTickLength = [0, 0, 0];\n        this.lineTickWidth = [1, 1, 1];\n        this.lineTickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.gridEnable = [true, true, true];\n        this.gridWidth = [1, 1, 1];\n        this.gridColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.zeroEnable = [true, true, true];\n        this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.zeroLineWidth = [2, 2, 2];\n        this.backgroundEnable = [false, false, false];\n        this.backgroundColor = [[0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5], [0.8, 0.8, 0.8, 0.5]];\n        this._firstInit = true;\n        this._text = null;\n        this._lines = null;\n        this._background = createBackground(gl);\n      }\n\n      var proto = Axes.prototype;\n\n      proto.update = function (options) {\n        options = options || {}; //Option parsing helper functions\n\n        function parseOption(nest, cons, name) {\n          if (name in options) {\n            var opt = options[name];\n            var prev = this[name];\n            var next;\n\n            if (nest ? Array.isArray(opt) && Array.isArray(opt[0]) : Array.isArray(opt)) {\n              this[name] = next = [cons(opt[0]), cons(opt[1]), cons(opt[2])];\n            } else {\n              this[name] = next = [cons(opt), cons(opt), cons(opt)];\n            }\n\n            for (var i = 0; i < 3; ++i) {\n              if (next[i] !== prev[i]) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        }\n\n        var NUMBER = parseOption.bind(this, false, Number);\n        var BOOLEAN = parseOption.bind(this, false, Boolean);\n        var STRING = parseOption.bind(this, false, String);\n        var COLOR = parseOption.bind(this, true, function (v) {\n          if (Array.isArray(v)) {\n            if (v.length === 3) {\n              return [+v[0], +v[1], +v[2], 1.0];\n            } else if (v.length === 4) {\n              return [+v[0], +v[1], +v[2], +v[3]];\n            }\n          }\n\n          return [0, 0, 0, 1];\n        }); //Tick marks and bounds\n\n        var nextTicks;\n        var ticksUpdate = false;\n        var boundsChanged = false;\n\n        if ('bounds' in options) {\n          var bounds = options.bounds;\n\n          i_loop: for (var i = 0; i < 2; ++i) {\n            for (var j = 0; j < 3; ++j) {\n              if (bounds[i][j] !== this.bounds[i][j]) {\n                boundsChanged = true;\n              }\n\n              this.bounds[i][j] = bounds[i][j];\n            }\n          }\n        }\n\n        if ('ticks' in options) {\n          nextTicks = options.ticks;\n          ticksUpdate = true;\n          this.autoTicks = false;\n\n          for (var i = 0; i < 3; ++i) {\n            this.tickSpacing[i] = 0.0;\n          }\n        } else if (NUMBER('tickSpacing')) {\n          this.autoTicks = true;\n          boundsChanged = true;\n        }\n\n        if (this._firstInit) {\n          if (!('ticks' in options || 'tickSpacing' in options)) {\n            this.autoTicks = true;\n          } //Force tick recomputation on first update\n\n\n          boundsChanged = true;\n          ticksUpdate = true;\n          this._firstInit = false;\n        }\n\n        if (boundsChanged && this.autoTicks) {\n          nextTicks = Ticks.create(this.bounds, this.tickSpacing);\n          ticksUpdate = true;\n        } //Compare next ticks to previous ticks, only update if needed\n\n\n        if (ticksUpdate) {\n          for (var i = 0; i < 3; ++i) {\n            nextTicks[i].sort(function (a, b) {\n              return a.x - b.x;\n            });\n          }\n\n          if (Ticks.equal(nextTicks, this.ticks)) {\n            ticksUpdate = false;\n          } else {\n            this.ticks = nextTicks;\n          }\n        } //Parse tick properties\n\n\n        BOOLEAN('tickEnable');\n\n        if (STRING('tickFont')) {\n          ticksUpdate = true; //If font changes, must rebuild vbo\n        }\n\n        NUMBER('tickSize');\n        NUMBER('tickAngle');\n        NUMBER('tickPad');\n        COLOR('tickColor'); //Axis labels\n\n        var labelUpdate = STRING('labels');\n\n        if (STRING('labelFont')) {\n          labelUpdate = true;\n        }\n\n        BOOLEAN('labelEnable');\n        NUMBER('labelSize');\n        NUMBER('labelPad');\n        COLOR('labelColor'); //Axis lines\n\n        BOOLEAN('lineEnable');\n        BOOLEAN('lineMirror');\n        NUMBER('lineWidth');\n        COLOR('lineColor'); //Axis line ticks\n\n        BOOLEAN('lineTickEnable');\n        BOOLEAN('lineTickMirror');\n        NUMBER('lineTickLength');\n        NUMBER('lineTickWidth');\n        COLOR('lineTickColor'); //Grid lines\n\n        BOOLEAN('gridEnable');\n        NUMBER('gridWidth');\n        COLOR('gridColor'); //Zero line\n\n        BOOLEAN('zeroEnable');\n        COLOR('zeroLineColor');\n        NUMBER('zeroLineWidth'); //Background\n\n        BOOLEAN('backgroundEnable');\n        COLOR('backgroundColor'); //Update text if necessary\n\n        if (!this._text) {\n          this._text = createText(this.gl, this.bounds, this.labels, this.labelFont, this.ticks, this.tickFont);\n        } else if (this._text && (labelUpdate || ticksUpdate)) {\n          this._text.update(this.bounds, this.labels, this.labelFont, this.ticks, this.tickFont);\n        } //Update lines if necessary\n\n\n        if (this._lines && ticksUpdate) {\n          this._lines.dispose();\n\n          this._lines = null;\n        }\n\n        if (!this._lines) {\n          this._lines = createLines(this.gl, this.bounds, this.ticks);\n        }\n      };\n\n      function OffsetInfo() {\n        this.primalOffset = [0, 0, 0];\n        this.primalMinor = [0, 0, 0];\n        this.mirrorOffset = [0, 0, 0];\n        this.mirrorMinor = [0, 0, 0];\n      }\n\n      var LINE_OFFSET = [new OffsetInfo(), new OffsetInfo(), new OffsetInfo()];\n\n      function computeLineOffset(result, i, bounds, cubeEdges, cubeAxis) {\n        var primalOffset = result.primalOffset;\n        var primalMinor = result.primalMinor;\n        var dualOffset = result.mirrorOffset;\n        var dualMinor = result.mirrorMinor;\n        var e = cubeEdges[i]; //Calculate offsets\n\n        for (var j = 0; j < 3; ++j) {\n          if (i === j) {\n            continue;\n          }\n\n          var a = primalOffset,\n              b = dualOffset,\n              c = primalMinor,\n              d = dualMinor;\n\n          if (e & 1 << j) {\n            a = dualOffset;\n            b = primalOffset;\n            c = dualMinor;\n            d = primalMinor;\n          }\n\n          a[j] = bounds[0][j];\n          b[j] = bounds[1][j];\n\n          if (cubeAxis[j] > 0) {\n            c[j] = -1;\n            d[j] = 0;\n          } else {\n            c[j] = 0;\n            d[j] = +1;\n          }\n        }\n      }\n\n      var CUBE_ENABLE = [0, 0, 0];\n      var DEFAULT_PARAMS = {\n        model: identity,\n        view: identity,\n        projection: identity,\n        _ortho: false\n      };\n\n      proto.isOpaque = function () {\n        return true;\n      };\n\n      proto.isTransparent = function () {\n        return false;\n      };\n\n      proto.drawTransparent = function (params) {};\n\n      var ALIGN_OPTION_AUTO = 0; // i.e. as defined in the shader the text would rotate to stay upwards range: [-90,90]\n\n      var PRIMAL_MINOR = [0, 0, 0];\n      var MIRROR_MINOR = [0, 0, 0];\n      var PRIMAL_OFFSET = [0, 0, 0];\n\n      proto.draw = function (params) {\n        params = params || DEFAULT_PARAMS;\n        var gl = this.gl; //Geometry for camera and axes\n\n        var model = params.model || identity;\n        var view = params.view || identity;\n        var projection = params.projection || identity;\n        var bounds = this.bounds;\n        var isOrtho = params._ortho || false; //Unpack axis info\n\n        var cubeParams = getCubeProperties(model, view, projection, bounds, isOrtho);\n        var cubeEdges = cubeParams.cubeEdges;\n        var cubeAxis = cubeParams.axis;\n        var cx = view[12];\n        var cy = view[13];\n        var cz = view[14];\n        var cw = view[15];\n        var orthoFix = isOrtho ? 2 : 1; // double up padding for orthographic ticks & labels\n\n        var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl.drawingBufferHeight;\n\n        for (var i = 0; i < 3; ++i) {\n          this.lastCubeProps.cubeEdges[i] = cubeEdges[i];\n          this.lastCubeProps.axis[i] = cubeAxis[i];\n        } //Compute axis info\n\n\n        var lineOffset = LINE_OFFSET;\n\n        for (var i = 0; i < 3; ++i) {\n          computeLineOffset(LINE_OFFSET[i], i, this.bounds, cubeEdges, cubeAxis);\n        } //Set up state parameters\n\n\n        var gl = this.gl; //Draw background first\n\n        var cubeEnable = CUBE_ENABLE;\n\n        for (var i = 0; i < 3; ++i) {\n          if (this.backgroundEnable[i]) {\n            cubeEnable[i] = cubeAxis[i];\n          } else {\n            cubeEnable[i] = 0;\n          }\n        }\n\n        this._background.draw(model, view, projection, bounds, cubeEnable, this.backgroundColor); //Draw lines\n\n\n        this._lines.bind(model, view, projection, this); //First draw grid lines and zero lines\n\n\n        for (var i = 0; i < 3; ++i) {\n          var x = [0, 0, 0];\n\n          if (cubeAxis[i] > 0) {\n            x[i] = bounds[1][i];\n          } else {\n            x[i] = bounds[0][i];\n          } //Draw grid lines\n\n\n          for (var j = 0; j < 2; ++j) {\n            var u = (i + 1 + j) % 3;\n            var v = (i + 1 + (j ^ 1)) % 3;\n\n            if (this.gridEnable[u]) {\n              this._lines.drawGrid(u, v, this.bounds, x, this.gridColor[u], this.gridWidth[u] * this.pixelRatio);\n            }\n          } //Draw zero lines (need to do this AFTER all grid lines are drawn)\n\n\n          for (var j = 0; j < 2; ++j) {\n            var u = (i + 1 + j) % 3;\n            var v = (i + 1 + (j ^ 1)) % 3;\n\n            if (this.zeroEnable[v]) {\n              //Check if zero line in bounds\n              if (Math.min(bounds[0][v], bounds[1][v]) <= 0 && Math.max(bounds[0][v], bounds[1][v]) >= 0) {\n                this._lines.drawZero(u, v, this.bounds, x, this.zeroLineColor[v], this.zeroLineWidth[v] * this.pixelRatio);\n              }\n            }\n          }\n        } //Then draw axis lines and tick marks\n\n\n        for (var i = 0; i < 3; ++i) {\n          //Draw axis lines\n          if (this.lineEnable[i]) {\n            this._lines.drawAxisLine(i, this.bounds, lineOffset[i].primalOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);\n          }\n\n          if (this.lineMirror[i]) {\n            this._lines.drawAxisLine(i, this.bounds, lineOffset[i].mirrorOffset, this.lineColor[i], this.lineWidth[i] * this.pixelRatio);\n          } //Compute minor axes\n\n\n          var primalMinor = copyVec3(PRIMAL_MINOR, lineOffset[i].primalMinor);\n          var mirrorMinor = copyVec3(MIRROR_MINOR, lineOffset[i].mirrorMinor);\n          var tickLength = this.lineTickLength;\n\n          for (var j = 0; j < 3; ++j) {\n            var scaleFactor = pixelScaleF / model[5 * j];\n            primalMinor[j] *= tickLength[j] * scaleFactor;\n            mirrorMinor[j] *= tickLength[j] * scaleFactor;\n          } //Draw axis line ticks\n\n\n          if (this.lineTickEnable[i]) {\n            this._lines.drawAxisTicks(i, lineOffset[i].primalOffset, primalMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);\n          }\n\n          if (this.lineTickMirror[i]) {\n            this._lines.drawAxisTicks(i, lineOffset[i].mirrorOffset, mirrorMinor, this.lineTickColor[i], this.lineTickWidth[i] * this.pixelRatio);\n          }\n        }\n\n        this._lines.unbind(); //Draw text sprites\n\n\n        this._text.bind(model, view, projection, this.pixelRatio);\n\n        var alignOpt; // options in shader are from this list {-1, 0, 1, 2, 3, ..., n}\n        // -1: backward compatible\n        //  0: raw data\n        //  1: auto align, free angles\n        //  2: auto align, horizontal or vertical\n        //3-n: auto align, round to n directions e.g. 12 -> round to angles with 30-degree steps\n\n        var hv_ratio = 0.5; // can have an effect on the ratio between horizontals and verticals when using option 2\n\n        var enableAlign;\n        var alignDir;\n\n        function alignTo(i) {\n          alignDir = [0, 0, 0];\n          alignDir[i] = 1;\n        }\n\n        function solveTickAlignments(i, minor, major) {\n          var i1 = (i + 1) % 3;\n          var i2 = (i + 2) % 3;\n          var A = minor[i1];\n          var B = minor[i2];\n          var C = major[i1];\n          var D = major[i2];\n\n          if (A > 0 && D > 0) {\n            alignTo(i1);\n            return;\n          } else if (A > 0 && D < 0) {\n            alignTo(i1);\n            return;\n          } else if (A < 0 && D > 0) {\n            alignTo(i1);\n            return;\n          } else if (A < 0 && D < 0) {\n            alignTo(i1);\n            return;\n          } else if (B > 0 && C > 0) {\n            alignTo(i2);\n            return;\n          } else if (B > 0 && C < 0) {\n            alignTo(i2);\n            return;\n          } else if (B < 0 && C > 0) {\n            alignTo(i2);\n            return;\n          } else if (B < 0 && C < 0) {\n            alignTo(i2);\n            return;\n          }\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          var minor = lineOffset[i].primalMinor;\n          var major = lineOffset[i].mirrorMinor;\n          var offset = copyVec3(PRIMAL_OFFSET, lineOffset[i].primalOffset);\n\n          for (var j = 0; j < 3; ++j) {\n            if (this.lineTickEnable[i]) {\n              offset[j] += pixelScaleF * minor[j] * Math.max(this.lineTickLength[j], 0) / model[5 * j];\n            }\n          }\n\n          var axis = [0, 0, 0];\n          axis[i] = 1; //Draw tick text\n\n          if (this.tickEnable[i]) {\n            if (this.tickAngle[i] === -3600) {\n              this.tickAngle[i] = 0;\n              this.tickAlign[i] = 'auto';\n            } else {\n              this.tickAlign[i] = -1;\n            }\n\n            enableAlign = 1;\n            alignOpt = [this.tickAlign[i], hv_ratio, enableAlign];\n            if (alignOpt[0] === 'auto') alignOpt[0] = ALIGN_OPTION_AUTO;else alignOpt[0] = parseInt('' + alignOpt[0]);\n            alignDir = [0, 0, 0];\n            solveTickAlignments(i, minor, major); //Add tick padding\n\n            for (var j = 0; j < 3; ++j) {\n              offset[j] += pixelScaleF * minor[j] * this.tickPad[j] / model[5 * j];\n            } //Draw axis\n\n\n            this._text.drawTicks(i, this.tickSize[i], this.tickAngle[i], offset, this.tickColor[i], axis, alignDir, alignOpt);\n          } //Draw labels\n\n\n          if (this.labelEnable[i]) {\n            enableAlign = 0;\n            alignDir = [0, 0, 0];\n\n            if (this.labels[i].length > 4) {\n              // for large label axis enable alignDir to axis\n              alignTo(i);\n              enableAlign = 1;\n            }\n\n            alignOpt = [this.labelAlign[i], hv_ratio, enableAlign];\n            if (alignOpt[0] === 'auto') alignOpt[0] = ALIGN_OPTION_AUTO;else alignOpt[0] = parseInt('' + alignOpt[0]); //Add label padding\n\n            for (var j = 0; j < 3; ++j) {\n              offset[j] += pixelScaleF * minor[j] * this.labelPad[j] / model[5 * j];\n            }\n\n            offset[i] += 0.5 * (bounds[0][i] + bounds[1][i]); //Draw axis\n\n            this._text.drawLabel(i, this.labelSize[i], this.labelAngle[i], offset, this.labelColor[i], [0, 0, 0], alignDir, alignOpt);\n          }\n        }\n\n        this._text.unbind();\n      };\n\n      proto.dispose = function () {\n        this._text.dispose();\n\n        this._lines.dispose();\n\n        this._background.dispose();\n\n        this._lines = null;\n        this._text = null;\n        this._background = null;\n        this.gl = null;\n      };\n\n      function createAxes(gl, options) {\n        var axes = new Axes(gl);\n        axes.update(options);\n        return axes;\n      }\n    }, {\n      \"./lib/background.js\": 71,\n      \"./lib/cube.js\": 72,\n      \"./lib/lines.js\": 73,\n      \"./lib/text.js\": 75,\n      \"./lib/ticks.js\": 76\n    }],\n    71: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createBackgroundCube;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createShader = _glvis_('./shaders').bg;\n\n      function BackgroundCube(gl, buffer, vao, shader) {\n        this.gl = gl;\n        this.buffer = buffer;\n        this.vao = vao;\n        this.shader = shader;\n      }\n\n      var proto = BackgroundCube.prototype;\n\n      proto.draw = function (model, view, projection, bounds, enable, colors) {\n        var needsBG = false;\n\n        for (var i = 0; i < 3; ++i) {\n          needsBG = needsBG || enable[i];\n        }\n\n        if (!needsBG) {\n          return;\n        }\n\n        var gl = this.gl;\n        gl.enable(gl.POLYGON_OFFSET_FILL);\n        gl.polygonOffset(1, 2);\n        this.shader.bind();\n        this.shader.uniforms = {\n          model: model,\n          view: view,\n          projection: projection,\n          bounds: bounds,\n          enable: enable,\n          colors: colors\n        };\n        this.vao.bind();\n        this.vao.draw(this.gl.TRIANGLES, 36);\n        this.vao.unbind();\n        gl.disable(gl.POLYGON_OFFSET_FILL);\n      };\n\n      proto.dispose = function () {\n        this.vao.dispose();\n        this.buffer.dispose();\n        this.shader.dispose();\n      };\n\n      function createBackgroundCube(gl) {\n        //Create cube vertices\n        var vertices = [];\n        var indices = [];\n        var ptr = 0;\n\n        for (var d = 0; d < 3; ++d) {\n          var u = (d + 1) % 3;\n          var v = (d + 2) % 3;\n          var x = [0, 0, 0];\n          var c = [0, 0, 0];\n\n          for (var s = -1; s <= 1; s += 2) {\n            indices.push(ptr, ptr + 2, ptr + 1, ptr + 1, ptr + 2, ptr + 3);\n            x[d] = s;\n            c[d] = s;\n\n            for (var i = -1; i <= 1; i += 2) {\n              x[u] = i;\n\n              for (var j = -1; j <= 1; j += 2) {\n                x[v] = j;\n                vertices.push(x[0], x[1], x[2], c[0], c[1], c[2]);\n                ptr += 1;\n              }\n            } //Swap u and v\n\n\n            var tt = u;\n            u = v;\n            v = tt;\n          }\n        } //Allocate buffer and vertex array\n\n\n        var buffer = createBuffer(gl, new Float32Array(vertices));\n        var elements = createBuffer(gl, new Uint16Array(indices), gl.ELEMENT_ARRAY_BUFFER);\n        var vao = createVAO(gl, [{\n          buffer: buffer,\n          type: gl.FLOAT,\n          size: 3,\n          offset: 0,\n          stride: 24\n        }, {\n          buffer: buffer,\n          type: gl.FLOAT,\n          size: 3,\n          offset: 12,\n          stride: 24\n        }], elements); //Create shader object\n\n        var shader = createShader(gl);\n        shader.attributes.position.location = 0;\n        shader.attributes.normal.location = 1;\n        return new BackgroundCube(gl, buffer, vao, shader);\n      }\n    }, {\n      \"./shaders\": 74,\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150\n    }],\n    72: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = getCubeEdges;\n\n      var bits = _glvis_('bit-twiddle');\n\n      var multiply = _glvis_('gl-mat4/multiply');\n\n      var splitPoly = _glvis_('split-polygon');\n\n      var orient = _glvis_('robust-orientation');\n\n      var mvp = new Array(16);\n      var pCubeVerts = new Array(8);\n      var cubeVerts = new Array(8);\n      var x = new Array(3);\n      var zero3 = [0, 0, 0];\n\n      (function () {\n        for (var i = 0; i < 8; ++i) {\n          pCubeVerts[i] = [1, 1, 1, 1];\n          cubeVerts[i] = [1, 1, 1];\n        }\n      })();\n\n      function transformHg(result, x, mat) {\n        for (var i = 0; i < 4; ++i) {\n          result[i] = mat[12 + i];\n\n          for (var j = 0; j < 3; ++j) {\n            result[i] += x[j] * mat[4 * j + i];\n          }\n        }\n      }\n\n      var FRUSTUM_PLANES = [[0, 0, 1, 0, 0], [0, 0, -1, 1, 0], [0, -1, 0, 1, 0], [0, 1, 0, 1, 0], [-1, 0, 0, 1, 0], [1, 0, 0, 1, 0]];\n\n      function polygonArea(p) {\n        for (var i = 0; i < FRUSTUM_PLANES.length; ++i) {\n          p = splitPoly.positive(p, FRUSTUM_PLANES[i]);\n\n          if (p.length < 3) {\n            return 0;\n          }\n        }\n\n        var base = p[0];\n        var ax = base[0] / base[3];\n        var ay = base[1] / base[3];\n        var area = 0.0;\n\n        for (var i = 1; i + 1 < p.length; ++i) {\n          var b = p[i];\n          var c = p[i + 1];\n          var bx = b[0] / b[3];\n          var by = b[1] / b[3];\n          var cx = c[0] / c[3];\n          var cy = c[1] / c[3];\n          var ux = bx - ax;\n          var uy = by - ay;\n          var vx = cx - ax;\n          var vy = cy - ay;\n          area += Math.abs(ux * vy - uy * vx);\n        }\n\n        return area;\n      }\n\n      var CUBE_EDGES = [1, 1, 1];\n      var CUBE_AXIS = [0, 0, 0];\n      var CUBE_RESULT = {\n        cubeEdges: CUBE_EDGES,\n        axis: CUBE_AXIS\n      };\n\n      function getCubeEdges(model, view, projection, bounds, ortho) {\n        //Concatenate matrices\n        multiply(mvp, view, model);\n        multiply(mvp, projection, mvp); //First project cube vertices\n\n        var ptr = 0;\n\n        for (var i = 0; i < 2; ++i) {\n          x[2] = bounds[i][2];\n\n          for (var j = 0; j < 2; ++j) {\n            x[1] = bounds[j][1];\n\n            for (var k = 0; k < 2; ++k) {\n              x[0] = bounds[k][0];\n              transformHg(pCubeVerts[ptr], x, mvp);\n              ptr += 1;\n            }\n          }\n        } //Classify camera against cube faces\n\n\n        var closest = -1;\n\n        for (var i = 0; i < 8; ++i) {\n          var w = pCubeVerts[i][3];\n\n          for (var l = 0; l < 3; ++l) {\n            cubeVerts[i][l] = pCubeVerts[i][l] / w;\n          }\n\n          if (ortho) cubeVerts[i][2] *= -1;\n\n          if (w < 0) {\n            if (closest < 0) {\n              closest = i;\n            } else if (cubeVerts[i][2] < cubeVerts[closest][2]) {\n              closest = i;\n            }\n          }\n        }\n\n        if (closest < 0) {\n          closest = 0;\n\n          for (var d = 0; d < 3; ++d) {\n            var u = (d + 2) % 3;\n            var v = (d + 1) % 3;\n            var o0 = -1;\n            var o1 = -1;\n\n            for (var s = 0; s < 2; ++s) {\n              var f0 = s << d;\n              var f1 = f0 + (s << u) + (1 - s << v);\n              var f2 = f0 + (1 - s << u) + (s << v);\n\n              if (orient(cubeVerts[f0], cubeVerts[f1], cubeVerts[f2], zero3) < 0) {\n                continue;\n              }\n\n              if (s) {\n                o0 = 1;\n              } else {\n                o1 = 1;\n              }\n            }\n\n            if (o0 < 0 || o1 < 0) {\n              if (o1 > o0) {\n                closest |= 1 << d;\n              }\n\n              continue;\n            }\n\n            for (var s = 0; s < 2; ++s) {\n              var f0 = s << d;\n              var f1 = f0 + (s << u) + (1 - s << v);\n              var f2 = f0 + (1 - s << u) + (s << v);\n              var o = polygonArea([pCubeVerts[f0], pCubeVerts[f1], pCubeVerts[f2], pCubeVerts[f0 + (1 << u) + (1 << v)]]);\n\n              if (s) {\n                o0 = o;\n              } else {\n                o1 = o;\n              }\n            }\n\n            if (o1 > o0) {\n              closest |= 1 << d;\n              continue;\n            }\n          }\n        }\n\n        var farthest = 7 ^ closest; //Find lowest vertex which is not closest closest\n\n        var bottom = -1;\n\n        for (var i = 0; i < 8; ++i) {\n          if (i === closest || i === farthest) {\n            continue;\n          }\n\n          if (bottom < 0) {\n            bottom = i;\n          } else if (cubeVerts[bottom][1] > cubeVerts[i][1]) {\n            bottom = i;\n          }\n        } //Find left/right neighbors of bottom vertex\n\n\n        var left = -1;\n\n        for (var i = 0; i < 3; ++i) {\n          var idx = bottom ^ 1 << i;\n\n          if (idx === closest || idx === farthest) {\n            continue;\n          }\n\n          if (left < 0) {\n            left = idx;\n          }\n\n          var v = cubeVerts[idx];\n\n          if (v[0] < cubeVerts[left][0]) {\n            left = idx;\n          }\n        }\n\n        var right = -1;\n\n        for (var i = 0; i < 3; ++i) {\n          var idx = bottom ^ 1 << i;\n\n          if (idx === closest || idx === farthest || idx === left) {\n            continue;\n          }\n\n          if (right < 0) {\n            right = idx;\n          }\n\n          var v = cubeVerts[idx];\n\n          if (v[0] > cubeVerts[right][0]) {\n            right = idx;\n          }\n        } //Determine edge axis coordinates\n\n\n        var cubeEdges = CUBE_EDGES;\n        cubeEdges[0] = cubeEdges[1] = cubeEdges[2] = 0;\n        cubeEdges[bits.log2(left ^ bottom)] = bottom & left;\n        cubeEdges[bits.log2(bottom ^ right)] = bottom & right;\n        var top = right ^ 7;\n\n        if (top === closest || top === farthest) {\n          top = left ^ 7;\n          cubeEdges[bits.log2(right ^ top)] = top & right;\n        } else {\n          cubeEdges[bits.log2(left ^ top)] = top & left;\n        } //Determine visible faces\n\n\n        var axis = CUBE_AXIS;\n        var cutCorner = closest;\n\n        for (var d = 0; d < 3; ++d) {\n          if (cutCorner & 1 << d) {\n            axis[d] = -1;\n          } else {\n            axis[d] = 1;\n          }\n        } //Return result\n\n\n        return CUBE_RESULT;\n      }\n    }, {\n      \"bit-twiddle\": 32,\n      \"gl-mat4/multiply\": 100,\n      \"robust-orientation\": 284,\n      \"split-polygon\": 300\n    }],\n    73: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createLines;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createShader = _glvis_('./shaders').line;\n\n      var MAJOR_AXIS = [0, 0, 0];\n      var MINOR_AXIS = [0, 0, 0];\n      var SCREEN_AXIS = [0, 0, 0];\n      var OFFSET_VEC = [0, 0, 0];\n      var SHAPE = [1, 1];\n\n      function zeroVec(a) {\n        a[0] = a[1] = a[2] = 0;\n        return a;\n      }\n\n      function copyVec(a, b) {\n        a[0] = b[0];\n        a[1] = b[1];\n        a[2] = b[2];\n        return a;\n      }\n\n      function Lines(gl, vertBuffer, vao, shader, tickCount, tickOffset, gridCount, gridOffset) {\n        this.gl = gl;\n        this.vertBuffer = vertBuffer;\n        this.vao = vao;\n        this.shader = shader;\n        this.tickCount = tickCount;\n        this.tickOffset = tickOffset;\n        this.gridCount = gridCount;\n        this.gridOffset = gridOffset;\n      }\n\n      var proto = Lines.prototype;\n\n      proto.bind = function (model, view, projection) {\n        this.shader.bind();\n        this.shader.uniforms.model = model;\n        this.shader.uniforms.view = view;\n        this.shader.uniforms.projection = projection;\n        SHAPE[0] = this.gl.drawingBufferWidth;\n        SHAPE[1] = this.gl.drawingBufferHeight;\n        this.shader.uniforms.screenShape = SHAPE;\n        this.vao.bind();\n      };\n\n      proto.unbind = function () {\n        this.vao.unbind();\n      };\n\n      proto.drawAxisLine = function (j, bounds, offset, color, lineWidth) {\n        var minorAxis = zeroVec(MINOR_AXIS);\n        this.shader.uniforms.majorAxis = MINOR_AXIS;\n        minorAxis[j] = bounds[1][j] - bounds[0][j];\n        this.shader.uniforms.minorAxis = minorAxis;\n        var noffset = copyVec(OFFSET_VEC, offset);\n        noffset[j] += bounds[0][j];\n        this.shader.uniforms.offset = noffset;\n        this.shader.uniforms.lineWidth = lineWidth;\n        this.shader.uniforms.color = color;\n        var screenAxis = zeroVec(SCREEN_AXIS);\n        screenAxis[(j + 2) % 3] = 1;\n        this.shader.uniforms.screenAxis = screenAxis;\n        this.vao.draw(this.gl.TRIANGLES, 6);\n        var screenAxis = zeroVec(SCREEN_AXIS);\n        screenAxis[(j + 1) % 3] = 1;\n        this.shader.uniforms.screenAxis = screenAxis;\n        this.vao.draw(this.gl.TRIANGLES, 6);\n      };\n\n      proto.drawAxisTicks = function (j, offset, minorAxis, color, lineWidth) {\n        if (!this.tickCount[j]) {\n          return;\n        }\n\n        var majorAxis = zeroVec(MAJOR_AXIS);\n        majorAxis[j] = 1;\n        this.shader.uniforms.majorAxis = majorAxis;\n        this.shader.uniforms.offset = offset;\n        this.shader.uniforms.minorAxis = minorAxis;\n        this.shader.uniforms.color = color;\n        this.shader.uniforms.lineWidth = lineWidth;\n        var screenAxis = zeroVec(SCREEN_AXIS);\n        screenAxis[j] = 1;\n        this.shader.uniforms.screenAxis = screenAxis;\n        this.vao.draw(this.gl.TRIANGLES, this.tickCount[j], this.tickOffset[j]);\n      };\n\n      proto.drawGrid = function (i, j, bounds, offset, color, lineWidth) {\n        if (!this.gridCount[i]) {\n          return;\n        }\n\n        var minorAxis = zeroVec(MINOR_AXIS);\n        minorAxis[j] = bounds[1][j] - bounds[0][j];\n        this.shader.uniforms.minorAxis = minorAxis;\n        var noffset = copyVec(OFFSET_VEC, offset);\n        noffset[j] += bounds[0][j];\n        this.shader.uniforms.offset = noffset;\n        var majorAxis = zeroVec(MAJOR_AXIS);\n        majorAxis[i] = 1;\n        this.shader.uniforms.majorAxis = majorAxis;\n        var screenAxis = zeroVec(SCREEN_AXIS);\n        screenAxis[i] = 1;\n        this.shader.uniforms.screenAxis = screenAxis;\n        this.shader.uniforms.lineWidth = lineWidth;\n        this.shader.uniforms.color = color;\n        this.vao.draw(this.gl.TRIANGLES, this.gridCount[i], this.gridOffset[i]);\n      };\n\n      proto.drawZero = function (j, i, bounds, offset, color, lineWidth) {\n        var minorAxis = zeroVec(MINOR_AXIS);\n        this.shader.uniforms.majorAxis = minorAxis;\n        minorAxis[j] = bounds[1][j] - bounds[0][j];\n        this.shader.uniforms.minorAxis = minorAxis;\n        var noffset = copyVec(OFFSET_VEC, offset);\n        noffset[j] += bounds[0][j];\n        this.shader.uniforms.offset = noffset;\n        var screenAxis = zeroVec(SCREEN_AXIS);\n        screenAxis[i] = 1;\n        this.shader.uniforms.screenAxis = screenAxis;\n        this.shader.uniforms.lineWidth = lineWidth;\n        this.shader.uniforms.color = color;\n        this.vao.draw(this.gl.TRIANGLES, 6);\n      };\n\n      proto.dispose = function () {\n        this.vao.dispose();\n        this.vertBuffer.dispose();\n        this.shader.dispose();\n      };\n\n      function createLines(gl, bounds, ticks) {\n        var vertices = [];\n        var tickOffset = [0, 0, 0];\n        var tickCount = [0, 0, 0]; //Create grid lines for each axis/direction\n\n        var gridOffset = [0, 0, 0];\n        var gridCount = [0, 0, 0]; //Add zero line\n\n        vertices.push(0, 0, 1, 0, 1, 1, 0, 0, -1, 0, 0, -1, 0, 1, 1, 0, 1, -1);\n\n        for (var i = 0; i < 3; ++i) {\n          //Axis tick marks\n          var start = vertices.length / 3 | 0;\n\n          for (var j = 0; j < ticks[i].length; ++j) {\n            var x = +ticks[i][j].x;\n            vertices.push(x, 0, 1, x, 1, 1, x, 0, -1, x, 0, -1, x, 1, 1, x, 1, -1);\n          }\n\n          var end = vertices.length / 3 | 0;\n          tickOffset[i] = start;\n          tickCount[i] = end - start; //Grid lines\n\n          var start = vertices.length / 3 | 0;\n\n          for (var k = 0; k < ticks[i].length; ++k) {\n            var x = +ticks[i][k].x;\n            vertices.push(x, 0, 1, x, 1, 1, x, 0, -1, x, 0, -1, x, 1, 1, x, 1, -1);\n          }\n\n          var end = vertices.length / 3 | 0;\n          gridOffset[i] = start;\n          gridCount[i] = end - start;\n        } //Create cube VAO\n\n\n        var vertBuf = createBuffer(gl, new Float32Array(vertices));\n        var vao = createVAO(gl, [{\n          \"buffer\": vertBuf,\n          \"type\": gl.FLOAT,\n          \"size\": 3,\n          \"stride\": 0,\n          \"offset\": 0\n        }]);\n        var shader = createShader(gl);\n        shader.attributes.position.location = 0;\n        return new Lines(gl, vertBuf, vao, shader, tickCount, tickOffset, gridCount, gridOffset);\n      }\n    }, {\n      \"./shaders\": 74,\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150\n    }],\n    74: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      var createShader = _glvis_('gl-shader');\n\n      var lineVert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 offset, majorAxis, minorAxis, screenAxis;\\nuniform float lineWidth;\\nuniform vec2 screenShape;\\n\\nvec3 project(vec3 p) {\\n  vec4 pp = projection * view * model * vec4(p, 1.0);\\n  return pp.xyz / max(pp.w, 0.0001);\\n}\\n\\nvoid main() {\\n  vec3 major = position.x * majorAxis;\\n  vec3 minor = position.y * minorAxis;\\n\\n  vec3 vPosition = major + minor + offset;\\n  vec3 pPosition = project(vPosition);\\n  vec3 offset = project(vPosition + screenAxis * position.z);\\n\\n  vec2 screen = normalize((offset - pPosition).xy * screenShape) / screenShape;\\n\\n  gl_Position = vec4(pPosition + vec3(0.5 * screen * lineWidth, 0), 1.0);\\n}\\n\"]);\n      var lineFrag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color;\\nvoid main() {\\n  gl_FragColor = color;\\n}\"]);\n\n      exports.line = function (gl) {\n        return createShader(gl, lineVert, lineFrag, null, [{\n          name: 'position',\n          type: 'vec3'\n        }]);\n      };\n\n      var textVert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 offset, axis, alignDir, alignOpt;\\nuniform float scale, angle, pixelScale;\\nuniform vec2 resolution;\\n\\nvec3 project(vec3 p) {\\n  vec4 pp = projection * view * model * vec4(p, 1.0);\\n  return pp.xyz / max(pp.w, 0.0001);\\n}\\n\\nfloat computeViewAngle(vec3 a, vec3 b) {\\n  vec3 A = project(a);\\n  vec3 B = project(b);\\n\\n  return atan(\\n    (B.y - A.y) * resolution.y,\\n    (B.x - A.x) * resolution.x\\n  );\\n}\\n\\nconst float PI = 3.141592;\\nconst float TWO_PI = 2.0 * PI;\\nconst float HALF_PI = 0.5 * PI;\\nconst float ONE_AND_HALF_PI = 1.5 * PI;\\n\\nint option = int(floor(alignOpt.x + 0.001));\\nfloat hv_ratio =       alignOpt.y;\\nbool enableAlign =    (alignOpt.z != 0.0);\\n\\nfloat mod_angle(float a) {\\n  return mod(a, PI);\\n}\\n\\nfloat positive_angle(float a) {\\n  return mod_angle((a < 0.0) ?\\n    a + TWO_PI :\\n    a\\n  );\\n}\\n\\nfloat look_upwards(float a) {\\n  float b = positive_angle(a);\\n  return ((b > HALF_PI) && (b <= ONE_AND_HALF_PI)) ?\\n    b - PI :\\n    b;\\n}\\n\\nfloat look_horizontal_or_vertical(float a, float ratio) {\\n  // ratio controls the ratio between being horizontal to (vertical + horizontal)\\n  // if ratio is set to 0.5 then it is 50%, 50%.\\n  // when using a higher ratio e.g. 0.75 the result would\\n  // likely be more horizontal than vertical.\\n\\n  float b = positive_angle(a);\\n\\n  return\\n    (b < (      ratio) * HALF_PI) ? 0.0 :\\n    (b < (2.0 - ratio) * HALF_PI) ? -HALF_PI :\\n    (b < (2.0 + ratio) * HALF_PI) ? 0.0 :\\n    (b < (4.0 - ratio) * HALF_PI) ? HALF_PI :\\n                                    0.0;\\n}\\n\\nfloat roundTo(float a, float b) {\\n  return float(b * floor((a + 0.5 * b) / b));\\n}\\n\\nfloat look_round_n_directions(float a, int n) {\\n  float b = positive_angle(a);\\n  float div = TWO_PI / float(n);\\n  float c = roundTo(b, div);\\n  return look_upwards(c);\\n}\\n\\nfloat applyAlignOption(float rawAngle, float delta) {\\n  return\\n    (option >  2) ? look_round_n_directions(rawAngle + delta, option) :       // option 3-n: round to n directions\\n    (option == 2) ? look_horizontal_or_vertical(rawAngle + delta, hv_ratio) : // horizontal or vertical\\n    (option == 1) ? rawAngle + delta :       // use free angle, and flip to align with one direction of the axis\\n    (option == 0) ? look_upwards(rawAngle) : // use free angle, and stay upwards\\n    (option ==-1) ? 0.0 :                    // useful for backward compatibility, all texts remains horizontal\\n                    rawAngle;                // otherwise return back raw input angle\\n}\\n\\nbool isAxisTitle = (axis.x == 0.0) &&\\n                   (axis.y == 0.0) &&\\n                   (axis.z == 0.0);\\n\\nvoid main() {\\n  //Compute world offset\\n  float axisDistance = position.z;\\n  vec3 dataPosition = axisDistance * axis + offset;\\n\\n  float beta = angle; // i.e. user defined attributes for each tick\\n\\n  float axisAngle;\\n  float clipAngle;\\n  float flip;\\n\\n  if (enableAlign) {\\n    axisAngle = (isAxisTitle) ? HALF_PI :\\n                      computeViewAngle(dataPosition, dataPosition + axis);\\n    clipAngle = computeViewAngle(dataPosition, dataPosition + alignDir);\\n\\n    axisAngle += (sin(axisAngle) < 0.0) ? PI : 0.0;\\n    clipAngle += (sin(clipAngle) < 0.0) ? PI : 0.0;\\n\\n    flip = (dot(vec2(cos(axisAngle), sin(axisAngle)),\\n                vec2(sin(clipAngle),-cos(clipAngle))) > 0.0) ? 1.0 : 0.0;\\n\\n    beta += applyAlignOption(clipAngle, flip * PI);\\n  }\\n\\n  //Compute plane offset\\n  vec2 planeCoord = position.xy * pixelScale;\\n\\n  mat2 planeXform = scale * mat2(\\n     cos(beta), sin(beta),\\n    -sin(beta), cos(beta)\\n  );\\n\\n  vec2 viewOffset = 2.0 * planeXform * planeCoord / resolution;\\n\\n  //Compute clip position\\n  vec3 clipPosition = project(dataPosition);\\n\\n  //Apply text offset in clip coordinates\\n  clipPosition += vec3(viewOffset, 0.0);\\n\\n  //Done\\n  gl_Position = vec4(clipPosition, 1.0);\\n}\"]);\n      var textFrag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color;\\nvoid main() {\\n  gl_FragColor = color;\\n}\"]);\n\n      exports.text = function (gl) {\n        return createShader(gl, textVert, textFrag, null, [{\n          name: 'position',\n          type: 'vec3'\n        }]);\n      };\n\n      var bgVert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 enable;\\nuniform vec3 bounds[2];\\n\\nvarying vec3 colorChannel;\\n\\nvoid main() {\\n\\n  vec3 signAxis = sign(bounds[1] - bounds[0]);\\n\\n  vec3 realNormal = signAxis * normal;\\n\\n  if(dot(realNormal, enable) > 0.0) {\\n    vec3 minRange = min(bounds[0], bounds[1]);\\n    vec3 maxRange = max(bounds[0], bounds[1]);\\n    vec3 nPosition = mix(minRange, maxRange, 0.5 * (position + 1.0));\\n    gl_Position = projection * view * model * vec4(nPosition, 1.0);\\n  } else {\\n    gl_Position = vec4(0,0,0,0);\\n  }\\n\\n  colorChannel = abs(realNormal);\\n}\"]);\n      var bgFrag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform vec4 colors[3];\\n\\nvarying vec3 colorChannel;\\n\\nvoid main() {\\n  gl_FragColor = colorChannel.x * colors[0] +\\n                 colorChannel.y * colors[1] +\\n                 colorChannel.z * colors[2];\\n}\"]);\n\n      exports.bg = function (gl) {\n        return createShader(gl, bgVert, bgFrag, null, [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'normal',\n          type: 'vec3'\n        }]);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    75: [function (_glvis_, module, exports) {\n      (function (process) {\n        (function () {\n          \"use strict\";\n\n          module.exports = createTextSprites;\n\n          var createBuffer = _glvis_('gl-buffer');\n\n          var createVAO = _glvis_('gl-vao');\n\n          var vectorizeText = _glvis_('vectorize-text');\n\n          var createShader = _glvis_('./shaders').text;\n\n          var globals = window || process.global || {};\n\n          var __TEXT_CACHE = globals.__TEXT_CACHE || {};\n\n          globals.__TEXT_CACHE = {}; //Vertex buffer format for text is:\n          //\n          /// [x,y,z] = Spatial coordinate\n          //\n\n          var VERTEX_SIZE = 3;\n\n          function TextSprites(gl, shader, buffer, vao) {\n            this.gl = gl;\n            this.shader = shader;\n            this.buffer = buffer;\n            this.vao = vao;\n            this.tickOffset = this.tickCount = this.labelOffset = this.labelCount = null;\n          }\n\n          var proto = TextSprites.prototype; //Bind textures for rendering\n\n          var SHAPE = [0, 0];\n\n          proto.bind = function (model, view, projection, pixelScale) {\n            this.vao.bind();\n            this.shader.bind();\n            var uniforms = this.shader.uniforms;\n            uniforms.model = model;\n            uniforms.view = view;\n            uniforms.projection = projection;\n            uniforms.pixelScale = pixelScale;\n            SHAPE[0] = this.gl.drawingBufferWidth;\n            SHAPE[1] = this.gl.drawingBufferHeight;\n            this.shader.uniforms.resolution = SHAPE;\n          };\n\n          proto.unbind = function () {\n            this.vao.unbind();\n          };\n\n          proto.update = function (bounds, labels, labelFont, ticks, tickFont) {\n            var data = [];\n\n            function addItem(t, text, font, size, lineSpacing, styletags) {\n              var fontcache = __TEXT_CACHE[font];\n\n              if (!fontcache) {\n                fontcache = __TEXT_CACHE[font] = {};\n              }\n\n              var mesh = fontcache[text];\n\n              if (!mesh) {\n                mesh = fontcache[text] = tryVectorizeText(text, {\n                  triangles: true,\n                  font: font,\n                  textAlign: 'center',\n                  textBaseline: 'middle',\n                  lineSpacing: lineSpacing,\n                  styletags: styletags\n                });\n              }\n\n              var scale = (size || 12) / 12;\n              var positions = mesh.positions;\n              var cells = mesh.cells;\n\n              for (var i = 0, nc = cells.length; i < nc; ++i) {\n                var c = cells[i];\n\n                for (var j = 2; j >= 0; --j) {\n                  var p = positions[c[j]];\n                  data.push(scale * p[0], -scale * p[1], t);\n                }\n              }\n            } //Generate sprites for all 3 axes, store data in texture atlases\n\n\n            var tickOffset = [0, 0, 0];\n            var tickCount = [0, 0, 0];\n            var labelOffset = [0, 0, 0];\n            var labelCount = [0, 0, 0];\n            var lineSpacing = 1.25;\n            var styletags = {\n              breaklines: true,\n              bolds: true,\n              italics: true,\n              subscripts: true,\n              superscripts: true\n            };\n\n            for (var d = 0; d < 3; ++d) {\n              //Generate label\n              labelOffset[d] = data.length / VERTEX_SIZE | 0;\n              addItem(0.5 * (bounds[0][d] + bounds[1][d]), labels[d], labelFont[d], 12, // labelFontSize\n              lineSpacing, styletags);\n              labelCount[d] = (data.length / VERTEX_SIZE | 0) - labelOffset[d]; //Generate sprites for tick marks\n\n              tickOffset[d] = data.length / VERTEX_SIZE | 0;\n\n              for (var i = 0; i < ticks[d].length; ++i) {\n                if (!ticks[d][i].text) {\n                  continue;\n                }\n\n                addItem(ticks[d][i].x, ticks[d][i].text, ticks[d][i].font || tickFont, ticks[d][i].fontSize || 12, lineSpacing, styletags);\n              }\n\n              tickCount[d] = (data.length / VERTEX_SIZE | 0) - tickOffset[d];\n            }\n\n            this.buffer.update(data);\n            this.tickOffset = tickOffset;\n            this.tickCount = tickCount;\n            this.labelOffset = labelOffset;\n            this.labelCount = labelCount;\n          }; //Draws the tick marks for an axis\n\n\n          proto.drawTicks = function (d, scale, angle, offset, color, axis, alignDir, alignOpt) {\n            if (!this.tickCount[d]) {\n              return;\n            }\n\n            this.shader.uniforms.axis = axis;\n            this.shader.uniforms.color = color;\n            this.shader.uniforms.angle = angle;\n            this.shader.uniforms.scale = scale;\n            this.shader.uniforms.offset = offset;\n            this.shader.uniforms.alignDir = alignDir;\n            this.shader.uniforms.alignOpt = alignOpt;\n            this.vao.draw(this.gl.TRIANGLES, this.tickCount[d], this.tickOffset[d]);\n          }; //Draws the text label for an axis\n\n\n          proto.drawLabel = function (d, scale, angle, offset, color, axis, alignDir, alignOpt) {\n            if (!this.labelCount[d]) {\n              return;\n            }\n\n            this.shader.uniforms.axis = axis;\n            this.shader.uniforms.color = color;\n            this.shader.uniforms.angle = angle;\n            this.shader.uniforms.scale = scale;\n            this.shader.uniforms.offset = offset;\n            this.shader.uniforms.alignDir = alignDir;\n            this.shader.uniforms.alignOpt = alignOpt;\n            this.vao.draw(this.gl.TRIANGLES, this.labelCount[d], this.labelOffset[d]);\n          }; //Releases all resources attached to this object\n\n\n          proto.dispose = function () {\n            this.shader.dispose();\n            this.vao.dispose();\n            this.buffer.dispose();\n          };\n\n          function tryVectorizeText(text, options) {\n            try {\n              return vectorizeText(text, options);\n            } catch (e) {\n              console.warn('error vectorizing text:\"' + text + '\" error:', e);\n              return {\n                cells: [],\n                positions: []\n              };\n            }\n          }\n\n          function createTextSprites(gl, bounds, labels, labelFont, ticks, tickFont) {\n            var buffer = createBuffer(gl);\n            var vao = createVAO(gl, [{\n              \"buffer\": buffer,\n              \"size\": 3\n            }]);\n            var shader = createShader(gl);\n            shader.attributes.position.location = 0;\n            var result = new TextSprites(gl, shader, buffer, vao);\n            result.update(bounds, labels, labelFont, ticks, tickFont);\n            return result;\n          }\n        }).call(this);\n      }).call(this, _glvis_('_process'));\n    }, {\n      \"./shaders\": 74,\n      \"_process\": 5,\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150,\n      \"vectorize-text\": 311\n    }],\n    76: [function (_glvis_, module, exports) {\n      'use strict';\n\n      exports.create = defaultTicks;\n      exports.equal = ticksEqual;\n\n      function prettyPrint(spacing, i) {\n        var stepStr = spacing + \"\";\n        var u = stepStr.indexOf(\".\");\n        var sigFigs = 0;\n\n        if (u >= 0) {\n          sigFigs = stepStr.length - u - 1;\n        }\n\n        var shift = Math.pow(10, sigFigs);\n        var x = Math.round(spacing * i * shift);\n        var xstr = x + \"\";\n\n        if (xstr.indexOf(\"e\") >= 0) {\n          return xstr;\n        }\n\n        var xi = x / shift,\n            xf = x % shift;\n\n        if (x < 0) {\n          xi = -Math.ceil(xi) | 0;\n          xf = -xf | 0;\n        } else {\n          xi = Math.floor(xi) | 0;\n          xf = xf | 0;\n        }\n\n        var xis = \"\" + xi;\n\n        if (x < 0) {\n          xis = \"-\" + xis;\n        }\n\n        if (sigFigs) {\n          var xs = \"\" + xf;\n\n          while (xs.length < sigFigs) {\n            xs = \"0\" + xs;\n          }\n\n          return xis + \".\" + xs;\n        } else {\n          return xis;\n        }\n      }\n\n      function defaultTicks(bounds, tickSpacing) {\n        var array = [];\n\n        for (var d = 0; d < 3; ++d) {\n          var ticks = [];\n          var m = 0.5 * (bounds[0][d] + bounds[1][d]);\n\n          for (var t = 0; t * tickSpacing[d] <= bounds[1][d]; ++t) {\n            ticks.push({\n              x: t * tickSpacing[d],\n              text: prettyPrint(tickSpacing[d], t)\n            });\n          }\n\n          for (var t = -1; t * tickSpacing[d] >= bounds[0][d]; --t) {\n            ticks.push({\n              x: t * tickSpacing[d],\n              text: prettyPrint(tickSpacing[d], t)\n            });\n          }\n\n          array.push(ticks);\n        }\n\n        return array;\n      }\n\n      function ticksEqual(ticksA, ticksB) {\n        for (var i = 0; i < 3; ++i) {\n          if (ticksA[i].length !== ticksB[i].length) {\n            return false;\n          }\n\n          for (var j = 0; j < ticksA[i].length; ++j) {\n            var a = ticksA[i][j];\n            var b = ticksB[i][j];\n\n            if (a.x !== b.x || a.text !== b.text || a.font !== b.font || a.fontColor !== b.fontColor || a.fontSize !== b.fontSize || a.dx !== b.dx || a.dy !== b.dy) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      }\n    }, {}],\n    77: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = axesProperties;\n\n      var getPlanes = _glvis_(\"extract-frustum-planes\");\n\n      var splitPoly = _glvis_(\"split-polygon\");\n\n      var cubeParams = _glvis_(\"./lib/cube.js\");\n\n      var m4mul = _glvis_(\"gl-mat4/multiply\");\n\n      var m4transpose = _glvis_(\"gl-mat4/transpose\");\n\n      var v4transformMat4 = _glvis_(\"gl-vec4/transformMat4\");\n\n      var identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n      var mvp = new Float32Array(16);\n\n      function AxesRange3D(lo, hi, pixelsPerDataUnit) {\n        this.lo = lo;\n        this.hi = hi;\n        this.pixelsPerDataUnit = pixelsPerDataUnit;\n      }\n\n      var SCRATCH_P = [0, 0, 0, 1];\n      var SCRATCH_Q = [0, 0, 0, 1];\n\n      function gradient(result, M, v, width, height) {\n        for (var i = 0; i < 3; ++i) {\n          var p = SCRATCH_P;\n          var q = SCRATCH_Q;\n\n          for (var j = 0; j < 3; ++j) {\n            q[j] = p[j] = v[j];\n          }\n\n          q[3] = p[3] = 1;\n          q[i] += 1;\n          v4transformMat4(q, q, M);\n\n          if (q[3] < 0) {\n            result[i] = Infinity;\n          }\n\n          p[i] -= 1;\n          v4transformMat4(p, p, M);\n\n          if (p[3] < 0) {\n            result[i] = Infinity;\n          }\n\n          var dx = (p[0] / p[3] - q[0] / q[3]) * width;\n          var dy = (p[1] / p[3] - q[1] / q[3]) * height;\n          result[i] = 0.25 * Math.sqrt(dx * dx + dy * dy);\n        }\n\n        return result;\n      }\n\n      var RANGES = [new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity)];\n      var SCRATCH_X = [0, 0, 0];\n\n      function axesProperties(axes, camera, width, height, params) {\n        var model = camera.model || identity;\n        var view = camera.view || identity;\n        var projection = camera.projection || identity;\n        var isOrtho = camera._ortho || false;\n        var bounds = axes.bounds;\n        var params = params || cubeParams(model, view, projection, bounds, isOrtho);\n        var axis = params.axis;\n        m4mul(mvp, view, model);\n        m4mul(mvp, projection, mvp); //Calculate the following properties for each axis:\n        //\n        // * lo - start of visible range for each axis in tick coordinates\n        // * hi - end of visible range for each axis in tick coordinates\n        // * ticksPerPixel - pixel density of tick marks for the axis\n        //\n\n        var ranges = RANGES;\n\n        for (var i = 0; i < 3; ++i) {\n          ranges[i].lo = Infinity;\n          ranges[i].hi = -Infinity;\n          ranges[i].pixelsPerDataUnit = Infinity;\n        } //Compute frustum planes, intersect with box\n\n\n        var frustum = getPlanes(m4transpose(mvp, mvp));\n        m4transpose(mvp, mvp); //Loop over vertices of viewable box\n\n        for (var d = 0; d < 3; ++d) {\n          var u = (d + 1) % 3;\n          var v = (d + 2) % 3;\n          var x = SCRATCH_X;\n\n          i_loop: for (var i = 0; i < 2; ++i) {\n            var poly = [];\n\n            if (axis[d] < 0 === !!i) {\n              continue;\n            }\n\n            x[d] = bounds[i][d];\n\n            for (var j = 0; j < 2; ++j) {\n              x[u] = bounds[j ^ i][u];\n\n              for (var k = 0; k < 2; ++k) {\n                x[v] = bounds[k ^ j ^ i][v];\n                poly.push(x.slice());\n              }\n            }\n\n            var Q = isOrtho ? 5 : 4;\n\n            for (var j = Q; j === Q; ++j) {\n              // Note: using only near plane here (& for orthographic projection we use the far).\n              if (poly.length === 0) {\n                continue i_loop;\n              }\n\n              poly = splitPoly.positive(poly, frustum[j]);\n            } //Loop over vertices of polygon to find extremal points\n\n\n            for (var j = 0; j < poly.length; ++j) {\n              var v = poly[j];\n              var grad = gradient(SCRATCH_X, mvp, v, width, height);\n\n              for (var k = 0; k < 3; ++k) {\n                ranges[k].lo = Math.min(ranges[k].lo, v[k]);\n                ranges[k].hi = Math.max(ranges[k].hi, v[k]);\n\n                if (k !== d) {\n                  ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]));\n                }\n              }\n            }\n          }\n        }\n\n        return ranges;\n      }\n    }, {\n      \"./lib/cube.js\": 72,\n      \"extract-frustum-planes\": 67,\n      \"gl-mat4/multiply\": 100,\n      \"gl-mat4/transpose\": 109,\n      \"gl-vec4/transformMat4\": 221,\n      \"split-polygon\": 300\n    }],\n    78: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var pool = _glvis_(\"typedarray-pool\");\n\n      var ops = _glvis_(\"ndarray-ops\");\n\n      var ndarray = _glvis_(\"ndarray\");\n\n      var SUPPORTED_TYPES = [\"uint8\", \"uint8_clamped\", \"uint16\", \"uint32\", \"int8\", \"int16\", \"int32\", \"float32\"];\n\n      function GLBuffer(gl, type, handle, length, usage) {\n        this.gl = gl;\n        this.type = type;\n        this.handle = handle;\n        this.length = length;\n        this.usage = usage;\n      }\n\n      var proto = GLBuffer.prototype;\n\n      proto.bind = function () {\n        this.gl.bindBuffer(this.type, this.handle);\n      };\n\n      proto.unbind = function () {\n        this.gl.bindBuffer(this.type, null);\n      };\n\n      proto.dispose = function () {\n        this.gl.deleteBuffer(this.handle);\n      };\n\n      function updateTypeArray(gl, type, len, usage, data, offset) {\n        var dataLen = data.length * data.BYTES_PER_ELEMENT;\n\n        if (offset < 0) {\n          gl.bufferData(type, data, usage);\n          return dataLen;\n        }\n\n        if (dataLen + offset > len) {\n          throw new Error(\"gl-buffer: If resizing buffer, must not specify offset\");\n        }\n\n        gl.bufferSubData(type, offset, data);\n        return len;\n      }\n\n      function makeScratchTypeArray(array, dtype) {\n        var res = pool.malloc(array.length, dtype);\n        var n = array.length;\n\n        for (var i = 0; i < n; ++i) {\n          res[i] = array[i];\n        }\n\n        return res;\n      }\n\n      function isPacked(shape, stride) {\n        var n = 1;\n\n        for (var i = stride.length - 1; i >= 0; --i) {\n          if (stride[i] !== n) {\n            return false;\n          }\n\n          n *= shape[i];\n        }\n\n        return true;\n      }\n\n      proto.update = function (array, offset) {\n        if (typeof offset !== \"number\") {\n          offset = -1;\n        }\n\n        this.bind();\n\n        if (typeof array === \"object\" && typeof array.shape !== \"undefined\") {\n          //ndarray\n          var dtype = array.dtype;\n\n          if (SUPPORTED_TYPES.indexOf(dtype) < 0) {\n            dtype = \"float32\";\n          }\n\n          if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {\n            var ext = gl.getExtension('OES_element_index_uint');\n\n            if (ext && dtype !== \"uint16\") {\n              dtype = \"uint32\";\n            } else {\n              dtype = \"uint16\";\n            }\n          }\n\n          if (dtype === array.dtype && isPacked(array.shape, array.stride)) {\n            if (array.offset === 0 && array.data.length === array.shape[0]) {\n              this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data, offset);\n            } else {\n              this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array.data.subarray(array.offset, array.shape[0]), offset);\n            }\n          } else {\n            var tmp = pool.malloc(array.size, dtype);\n            var ndt = ndarray(tmp, array.shape);\n            ops.assign(ndt, array);\n\n            if (offset < 0) {\n              this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp, offset);\n            } else {\n              this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, tmp.subarray(0, array.size), offset);\n            }\n\n            pool.free(tmp);\n          }\n        } else if (Array.isArray(array)) {\n          //Vanilla array\n          var t;\n\n          if (this.type === this.gl.ELEMENT_ARRAY_BUFFER) {\n            t = makeScratchTypeArray(array, \"uint16\");\n          } else {\n            t = makeScratchTypeArray(array, \"float32\");\n          }\n\n          if (offset < 0) {\n            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t, offset);\n          } else {\n            this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, t.subarray(0, array.length), offset);\n          }\n\n          pool.free(t);\n        } else if (typeof array === \"object\" && typeof array.length === \"number\") {\n          //Typed array\n          this.length = updateTypeArray(this.gl, this.type, this.length, this.usage, array, offset);\n        } else if (typeof array === \"number\" || array === undefined) {\n          //Number/default\n          if (offset >= 0) {\n            throw new Error(\"gl-buffer: Cannot specify offset when resizing buffer\");\n          }\n\n          array = array | 0;\n\n          if (array <= 0) {\n            array = 1;\n          }\n\n          this.gl.bufferData(this.type, array | 0, this.usage);\n          this.length = array;\n        } else {\n          //Error, case should not happen\n          throw new Error(\"gl-buffer: Invalid data type\");\n        }\n      };\n\n      function createBuffer(gl, data, type, usage) {\n        type = type || gl.ARRAY_BUFFER;\n        usage = usage || gl.DYNAMIC_DRAW;\n\n        if (type !== gl.ARRAY_BUFFER && type !== gl.ELEMENT_ARRAY_BUFFER) {\n          throw new Error(\"gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER\");\n        }\n\n        if (usage !== gl.DYNAMIC_DRAW && usage !== gl.STATIC_DRAW && usage !== gl.STREAM_DRAW) {\n          throw new Error(\"gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\");\n        }\n\n        var handle = gl.createBuffer();\n        var result = new GLBuffer(gl, type, handle, 0, usage);\n        result.update(data);\n        return result;\n      }\n\n      module.exports = createBuffer;\n    }, {\n      \"ndarray\": 259,\n      \"ndarray-ops\": 254,\n      \"typedarray-pool\": 308\n    }],\n    79: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var vec3 = _glvis_('gl-vec3');\n\n      module.exports = function (vectorfield, bounds) {\n        var positions = vectorfield.positions;\n        var vectors = vectorfield.vectors;\n        var geo = {\n          positions: [],\n          vertexIntensity: [],\n          vertexIntensityBounds: vectorfield.vertexIntensityBounds,\n          vectors: [],\n          cells: [],\n          coneOffset: vectorfield.coneOffset,\n          colormap: vectorfield.colormap\n        };\n\n        if (vectorfield.positions.length === 0) {\n          if (bounds) {\n            bounds[0] = [0, 0, 0];\n            bounds[1] = [0, 0, 0];\n          }\n\n          return geo;\n        } // Compute bounding box for the dataset.\n        // Compute maximum velocity for the dataset to use for scaling the cones.\n\n\n        var maxNorm = 0;\n        var minX = Infinity,\n            maxX = -Infinity;\n        var minY = Infinity,\n            maxY = -Infinity;\n        var minZ = Infinity,\n            maxZ = -Infinity;\n        var p2 = null;\n        var u2 = null;\n        var positionVectors = [];\n        var vectorScale = Infinity;\n        var skipIt = false;\n\n        for (var i = 0; i < positions.length; i++) {\n          var p = positions[i];\n          minX = Math.min(p[0], minX);\n          maxX = Math.max(p[0], maxX);\n          minY = Math.min(p[1], minY);\n          maxY = Math.max(p[1], maxY);\n          minZ = Math.min(p[2], minZ);\n          maxZ = Math.max(p[2], maxZ);\n          var u = vectors[i];\n\n          if (vec3.length(u) > maxNorm) {\n            maxNorm = vec3.length(u);\n          }\n\n          if (i) {\n            // Find vector scale [w/ units of time] using \"successive\" positions\n            // (not \"adjacent\" with would be O(n^2)),\n            //\n            // The vector scale corresponds to the minimum \"time\" to travel across two\n            // two adjacent positions at the average velocity of those two adjacent positions\n            var q = 2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u));\n\n            if (q) {\n              vectorScale = Math.min(vectorScale, q);\n              skipIt = false;\n            } else {\n              skipIt = true;\n            }\n          }\n\n          if (!skipIt) {\n            p2 = p;\n            u2 = u;\n          }\n\n          positionVectors.push(u);\n        }\n\n        var minV = [minX, minY, minZ];\n        var maxV = [maxX, maxY, maxZ];\n\n        if (bounds) {\n          bounds[0] = minV;\n          bounds[1] = maxV;\n        }\n\n        if (maxNorm === 0) {\n          maxNorm = 1;\n        } // Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\n\n        var invertedMaxNorm = 1 / maxNorm;\n\n        if (!isFinite(vectorScale)) {\n          vectorScale = 1.0;\n        }\n\n        geo.vectorScale = vectorScale;\n        var coneScale = vectorfield.coneSize || 0.5;\n\n        if (vectorfield.absoluteConeSize) {\n          coneScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n        }\n\n        geo.coneScale = coneScale; // Build the cone model.\n\n        for (var i = 0, j = 0; i < positions.length; i++) {\n          var p = positions[i];\n          var x = p[0],\n              y = p[1],\n              z = p[2];\n          var d = positionVectors[i];\n          var intensity = vec3.length(d) * invertedMaxNorm;\n\n          for (var k = 0, l = 8; k < l; k++) {\n            geo.positions.push([x, y, z, j++]);\n            geo.positions.push([x, y, z, j++]);\n            geo.positions.push([x, y, z, j++]);\n            geo.positions.push([x, y, z, j++]);\n            geo.positions.push([x, y, z, j++]);\n            geo.positions.push([x, y, z, j++]);\n            geo.vectors.push(d);\n            geo.vectors.push(d);\n            geo.vectors.push(d);\n            geo.vectors.push(d);\n            geo.vectors.push(d);\n            geo.vectors.push(d);\n            geo.vertexIntensity.push(intensity, intensity, intensity);\n            geo.vertexIntensity.push(intensity, intensity, intensity);\n            var m = geo.positions.length;\n            geo.cells.push([m - 6, m - 5, m - 4], [m - 3, m - 2, m - 1]);\n          }\n        }\n\n        return geo;\n      };\n\n      var shaders = _glvis_('./lib/shaders');\n\n      module.exports.createMesh = _glvis_('./create_mesh');\n\n      module.exports.createConeMesh = function (gl, params) {\n        return module.exports.createMesh(gl, params, {\n          shaders: shaders,\n          traceType: 'cone'\n        });\n      };\n    }, {\n      \"./create_mesh\": 80,\n      \"./lib/shaders\": 81,\n      \"gl-vec3\": 169\n    }],\n    80: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createShader = _glvis_('gl-shader');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createTexture = _glvis_('gl-texture2d');\n\n      var multiply = _glvis_('gl-mat4/multiply');\n\n      var invert = _glvis_('gl-mat4/invert');\n\n      var ndarray = _glvis_('ndarray');\n\n      var colormap = _glvis_('colormap');\n\n      var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n      function VectorMesh(gl, texture, triShader, pickShader, trianglePositions, triangleVectors, triangleIds, triangleColors, triangleUVs, triangleVAO, traceType) {\n        this.gl = gl;\n        this.pixelRatio = 1;\n        this.cells = [];\n        this.positions = [];\n        this.intensity = [];\n        this.texture = texture;\n        this.dirty = true;\n        this.triShader = triShader;\n        this.pickShader = pickShader;\n        this.trianglePositions = trianglePositions;\n        this.triangleVectors = triangleVectors;\n        this.triangleColors = triangleColors;\n        this.triangleUVs = triangleUVs;\n        this.triangleIds = triangleIds;\n        this.triangleVAO = triangleVAO;\n        this.triangleCount = 0;\n        this.pickId = 1;\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.lightPosition = [1e5, 1e5, 0];\n        this.ambientLight = 0.8;\n        this.diffuseLight = 0.8;\n        this.specularLight = 2.0;\n        this.roughness = 0.5;\n        this.fresnel = 1.5;\n        this.opacity = 1;\n        this.traceType = traceType;\n        this.tubeScale = 1; // used in streamtube\n\n        this.coneScale = 2; // used in cone\n\n        this.vectorScale = 1; // used in cone\n\n        this.coneOffset = 0.25; // used in cone\n\n        this._model = IDENTITY;\n        this._view = IDENTITY;\n        this._projection = IDENTITY;\n        this._resolution = [1, 1];\n      }\n\n      var proto = VectorMesh.prototype;\n\n      proto.isOpaque = function () {\n        return this.opacity >= 1;\n      };\n\n      proto.isTransparent = function () {\n        return this.opacity < 1;\n      };\n\n      proto.pickSlots = 1;\n\n      proto.setPickBase = function (id) {\n        this.pickId = id;\n      };\n\n      function genColormap(param) {\n        var colors = colormap({\n          colormap: param,\n          nshades: 256,\n          format: 'rgba'\n        });\n        var result = new Uint8Array(256 * 4);\n\n        for (var i = 0; i < 256; ++i) {\n          var c = colors[i];\n\n          for (var j = 0; j < 3; ++j) {\n            result[4 * i + j] = c[j];\n          }\n\n          result[4 * i + 3] = c[3] * 255;\n        }\n\n        return ndarray(result, [256, 256, 4], [4, 0, 1]);\n      }\n\n      function takeZComponent(array) {\n        var n = array.length;\n        var result = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          result[i] = array[i][2];\n        }\n\n        return result;\n      }\n\n      proto.update = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        this.dirty = true;\n\n        if ('lightPosition' in params) {\n          this.lightPosition = params.lightPosition;\n        }\n\n        if ('opacity' in params) {\n          this.opacity = params.opacity;\n        }\n\n        if ('ambient' in params) {\n          this.ambientLight = params.ambient;\n        }\n\n        if ('diffuse' in params) {\n          this.diffuseLight = params.diffuse;\n        }\n\n        if ('specular' in params) {\n          this.specularLight = params.specular;\n        }\n\n        if ('roughness' in params) {\n          this.roughness = params.roughness;\n        }\n\n        if ('fresnel' in params) {\n          this.fresnel = params.fresnel;\n        } // use in streamtube\n\n\n        if (params.tubeScale !== undefined) {\n          this.tubeScale = params.tubeScale;\n        } // used in cone\n\n\n        if (params.vectorScale !== undefined) {\n          this.vectorScale = params.vectorScale;\n        }\n\n        if (params.coneScale !== undefined) {\n          this.coneScale = params.coneScale;\n        }\n\n        if (params.coneOffset !== undefined) {\n          this.coneOffset = params.coneOffset;\n        }\n\n        if (params.colormap) {\n          this.texture.shape = [256, 256];\n          this.texture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n          this.texture.magFilter = gl.LINEAR;\n          this.texture.setPixels(genColormap(params.colormap));\n          this.texture.generateMipmap();\n        }\n\n        var cells = params.cells;\n        var positions = params.positions;\n        var vectors = params.vectors;\n\n        if (!positions || !cells || !vectors) {\n          return;\n        }\n\n        var tPos = [];\n        var tVec = [];\n        var tCol = [];\n        var tUVs = [];\n        var tIds = []; //Save geometry data for picking calculations\n\n        this.cells = cells;\n        this.positions = positions;\n        this.vectors = vectors; //Compute colors\n\n        var meshColor = params.meshColor || [1, 1, 1, 1]; //UVs\n\n        var vertexIntensity = params.vertexIntensity;\n        var intensityLo = Infinity;\n        var intensityHi = -Infinity;\n\n        if (vertexIntensity) {\n          if (params.vertexIntensityBounds) {\n            intensityLo = +params.vertexIntensityBounds[0];\n            intensityHi = +params.vertexIntensityBounds[1];\n          } else {\n            for (var i = 0; i < vertexIntensity.length; ++i) {\n              var f = vertexIntensity[i];\n              intensityLo = Math.min(intensityLo, f);\n              intensityHi = Math.max(intensityHi, f);\n            }\n          }\n        } else {\n          for (var i = 0; i < positions.length; ++i) {\n            var f = positions[i][2];\n            intensityLo = Math.min(intensityLo, f);\n            intensityHi = Math.max(intensityHi, f);\n          }\n        }\n\n        if (vertexIntensity) {\n          this.intensity = vertexIntensity;\n        } else {\n          this.intensity = takeZComponent(positions);\n        } //Update bounds\n\n\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n        for (var i = 0; i < positions.length; ++i) {\n          var p = positions[i];\n\n          for (var j = 0; j < 3; ++j) {\n            if (isNaN(p[j]) || !isFinite(p[j])) {\n              continue;\n            }\n\n            this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);\n            this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);\n          }\n        } //Pack cells into buffers\n\n\n        var triangleCount = 0;\n\n        fill_loop: for (var i = 0; i < cells.length; ++i) {\n          var cell = cells[i];\n\n          switch (cell.length) {\n            case 3:\n              //Check NaNs\n              for (var j = 0; j < 3; ++j) {\n                var v = cell[j];\n                var p = positions[v];\n\n                for (var k = 0; k < 3; ++k) {\n                  if (isNaN(p[k]) || !isFinite(p[k])) {\n                    continue fill_loop;\n                  }\n                }\n              }\n\n              for (var j = 0; j < 3; ++j) {\n                var v = cell[2 - j];\n                var p = positions[v];\n                tPos.push(p[0], p[1], p[2], p[3]);\n                var w = vectors[v];\n                tVec.push(w[0], w[1], w[2], w[3] || 0);\n                var c = meshColor;\n\n                if (c.length === 3) {\n                  tCol.push(c[0], c[1], c[2], 1);\n                } else {\n                  tCol.push(c[0], c[1], c[2], c[3]);\n                }\n\n                var uv;\n\n                if (vertexIntensity) {\n                  uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n                } else {\n                  uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n                }\n\n                tUVs.push(uv[0], uv[1]);\n                tIds.push(i);\n              }\n\n              triangleCount += 1;\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        this.triangleCount = triangleCount;\n        this.trianglePositions.update(tPos);\n        this.triangleVectors.update(tVec);\n        this.triangleColors.update(tCol);\n        this.triangleUVs.update(tUVs);\n        this.triangleIds.update(new Uint32Array(tIds));\n      };\n\n      proto.drawTransparent = proto.draw = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        var model = params.model || IDENTITY;\n        var view = params.view || IDENTITY;\n        var projection = params.projection || IDENTITY;\n        var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n        for (var i = 0; i < 3; ++i) {\n          clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n          clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n        }\n\n        var uniforms = {\n          model: model,\n          view: view,\n          projection: projection,\n          inverseModel: IDENTITY.slice(),\n          clipBounds: clipBounds,\n          kambient: this.ambientLight,\n          kdiffuse: this.diffuseLight,\n          kspecular: this.specularLight,\n          roughness: this.roughness,\n          fresnel: this.fresnel,\n          eyePosition: [0, 0, 0],\n          lightPosition: [0, 0, 0],\n          opacity: this.opacity,\n          tubeScale: this.tubeScale,\n          vectorScale: this.vectorScale,\n          coneScale: this.coneScale,\n          coneOffset: this.coneOffset,\n          texture: 0\n        };\n        uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n        gl.disable(gl.CULL_FACE);\n        this.texture.bind(0);\n        var invCameraMatrix = new Array(16);\n        multiply(invCameraMatrix, uniforms.view, uniforms.model);\n        multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n        invert(invCameraMatrix, invCameraMatrix);\n\n        for (var i = 0; i < 3; ++i) {\n          uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n        }\n\n        var w = invCameraMatrix[15];\n\n        for (var i = 0; i < 3; ++i) {\n          w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          var s = invCameraMatrix[12 + i];\n\n          for (var j = 0; j < 3; ++j) {\n            s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n          }\n\n          uniforms.lightPosition[i] = s / w;\n        }\n\n        if (this.triangleCount > 0) {\n          var shader = this.triShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.triangleVAO.bind();\n          gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n          this.triangleVAO.unbind();\n        }\n      };\n\n      proto.drawPick = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        var model = params.model || IDENTITY;\n        var view = params.view || IDENTITY;\n        var projection = params.projection || IDENTITY;\n        var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n        for (var i = 0; i < 3; ++i) {\n          clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n          clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n        } //Save camera parameters\n\n\n        this._model = [].slice.call(model);\n        this._view = [].slice.call(view);\n        this._projection = [].slice.call(projection);\n        this._resolution = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n        var uniforms = {\n          model: model,\n          view: view,\n          projection: projection,\n          clipBounds: clipBounds,\n          tubeScale: this.tubeScale,\n          vectorScale: this.vectorScale,\n          coneScale: this.coneScale,\n          coneOffset: this.coneOffset,\n          pickId: this.pickId / 255.0\n        };\n        var shader = this.pickShader;\n        shader.bind();\n        shader.uniforms = uniforms;\n\n        if (this.triangleCount > 0) {\n          this.triangleVAO.bind();\n          gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n          this.triangleVAO.unbind();\n        }\n      };\n\n      proto.pick = function (pickData) {\n        if (!pickData) {\n          return null;\n        }\n\n        if (pickData.id !== this.pickId) {\n          return null;\n        }\n\n        var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];\n        var cell = this.cells[cellId];\n        var pos = this.positions[cell[1]].slice(0, 3);\n        var result = {\n          position: pos,\n          dataCoordinate: pos,\n          index: Math.floor(cell[1] / 48)\n        };\n\n        if (this.traceType === 'cone') {\n          result.index = Math.floor(cell[1] / 48);\n        } else if (this.traceType === 'streamtube') {\n          result.intensity = this.intensity[cell[1]];\n          result.velocity = this.vectors[cell[1]].slice(0, 3);\n          result.divergence = this.vectors[cell[1]][3];\n          result.index = cellId;\n        }\n\n        return result;\n      };\n\n      proto.dispose = function () {\n        this.texture.dispose();\n        this.triShader.dispose();\n        this.pickShader.dispose();\n        this.triangleVAO.dispose();\n        this.trianglePositions.dispose();\n        this.triangleVectors.dispose();\n        this.triangleColors.dispose();\n        this.triangleUVs.dispose();\n        this.triangleIds.dispose();\n      };\n\n      function createMeshShader(gl, shaders) {\n        var shader = createShader(gl, shaders.meshShader.vertex, shaders.meshShader.fragment, null, shaders.meshShader.attributes);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 2;\n        shader.attributes.uv.location = 3;\n        shader.attributes.vector.location = 4;\n        return shader;\n      }\n\n      function createPickShader(gl, shaders) {\n        var shader = createShader(gl, shaders.pickShader.vertex, shaders.pickShader.fragment, null, shaders.pickShader.attributes);\n        shader.attributes.position.location = 0;\n        shader.attributes.id.location = 1;\n        shader.attributes.vector.location = 4;\n        return shader;\n      }\n\n      function createVectorMesh(gl, params, opts) {\n        var shaders = opts.shaders;\n\n        if (arguments.length === 1) {\n          params = gl;\n          gl = params.gl;\n        }\n\n        var triShader = createMeshShader(gl, shaders);\n        var pickShader = createPickShader(gl, shaders);\n        var meshTexture = createTexture(gl, ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4]));\n        meshTexture.generateMipmap();\n        meshTexture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n        meshTexture.magFilter = gl.LINEAR;\n        var trianglePositions = createBuffer(gl);\n        var triangleVectors = createBuffer(gl);\n        var triangleColors = createBuffer(gl);\n        var triangleUVs = createBuffer(gl);\n        var triangleIds = createBuffer(gl);\n        var triangleVAO = createVAO(gl, [{\n          buffer: trianglePositions,\n          type: gl.FLOAT,\n          size: 4\n        }, {\n          buffer: triangleIds,\n          type: gl.UNSIGNED_BYTE,\n          size: 4,\n          normalized: true\n        }, {\n          buffer: triangleColors,\n          type: gl.FLOAT,\n          size: 4\n        }, {\n          buffer: triangleUVs,\n          type: gl.FLOAT,\n          size: 2\n        }, {\n          buffer: triangleVectors,\n          type: gl.FLOAT,\n          size: 4\n        }]);\n        var mesh = new VectorMesh(gl, meshTexture, triShader, pickShader, trianglePositions, triangleVectors, triangleIds, triangleColors, triangleUVs, triangleVAO, opts.traceType || 'cone');\n        mesh.update(params);\n        return mesh;\n      }\n\n      module.exports = createVectorMesh;\n    }, {\n      \"colormap\": 53,\n      \"gl-buffer\": 78,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/multiply\": 100,\n      \"gl-shader\": 132,\n      \"gl-texture2d\": 146,\n      \"gl-vao\": 150,\n      \"ndarray\": 259\n    }],\n    81: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      var triVertSrc = glslify([\"precision highp float;\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvec3 getOrthogonalVector(vec3 v) {\\n  // Return up-vector for only-z vector.\\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\\n  // Assign z = 0, x = -b, y = a:\\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\\n    return normalize(vec3(-v.y, v.x, 0.0));\\n  } else {\\n    return normalize(vec3(0.0, v.z, -v.y));\\n  }\\n}\\n\\n// Calculate the cone vertex and normal at the given index.\\n//\\n// The returned vertex is for a cone with its top at origin and height of 1.0,\\n// pointing in the direction of the vector attribute.\\n//\\n// Each cone is made up of a top vertex, a center base vertex and base perimeter vertices.\\n// These vertices are used to make up the triangles of the cone by the following:\\n//   segment + 0 top vertex\\n//   segment + 1 perimeter vertex a+1\\n//   segment + 2 perimeter vertex a\\n//   segment + 3 center base vertex\\n//   segment + 4 perimeter vertex a\\n//   segment + 5 perimeter vertex a+1\\n// Where segment is the number of the radial segment * 6 and a is the angle at that radial segment.\\n// To go from index to segment, floor(index / 6)\\n// To go from segment to angle, 2*pi * (segment/segmentCount)\\n// To go from index to segment index, index - (segment*6)\\n//\\nvec3 getConePosition(vec3 d, float rawIndex, float coneOffset, out vec3 normal) {\\n\\n  const float segmentCount = 8.0;\\n\\n  float index = rawIndex - floor(rawIndex /\\n    (segmentCount * 6.0)) *\\n    (segmentCount * 6.0);\\n\\n  float segment = floor(0.001 + index/6.0);\\n  float segmentIndex = index - (segment*6.0);\\n\\n  normal = -normalize(d);\\n\\n  if (segmentIndex > 2.99 && segmentIndex < 3.01) {\\n    return mix(vec3(0.0), -d, coneOffset);\\n  }\\n\\n  float nextAngle = (\\n    (segmentIndex > 0.99 &&  segmentIndex < 1.01) ||\\n    (segmentIndex > 4.99 &&  segmentIndex < 5.01)\\n  ) ? 1.0 : 0.0;\\n  float angle = 2.0 * 3.14159 * ((segment + nextAngle) / segmentCount);\\n\\n  vec3 v1 = mix(d, vec3(0.0), coneOffset);\\n  vec3 v2 = v1 - d;\\n\\n  vec3 u = getOrthogonalVector(d);\\n  vec3 v = normalize(cross(u, d));\\n\\n  vec3 x = u * cos(angle) * length(d)*0.25;\\n  vec3 y = v * sin(angle) * length(d)*0.25;\\n  vec3 v3 = v2 + x + y;\\n  if (segmentIndex < 3.0) {\\n    vec3 tx = u * sin(angle);\\n    vec3 ty = v * -cos(angle);\\n    vec3 tangent = tx + ty;\\n    normal = normalize(cross(v3 - v1, tangent));\\n  }\\n\\n  if (segmentIndex == 0.0) {\\n    return mix(d, vec3(0.0), coneOffset);\\n  }\\n  return v3;\\n}\\n\\nattribute vec3 vector;\\nattribute vec4 color, position;\\nattribute vec2 uv;\\n\\nuniform float vectorScale, coneScale, coneOffset;\\nuniform mat4 model, view, projection, inverseModel;\\nuniform vec3 eyePosition, lightPosition;\\n\\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  // Scale the vector magnitude to stay constant with\\n  // model & view changes.\\n  vec3 normal;\\n  vec3 XYZ = getConePosition(mat3(model) * ((vectorScale * coneScale) * vector), position.w, coneOffset, normal);\\n  vec4 conePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\\n\\n  //Lighting geometry parameters\\n  vec4 cameraCoordinate = view * conePosition;\\n  cameraCoordinate.xyz /= cameraCoordinate.w;\\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\\n  f_normal = normalize((vec4(normal, 0.0) * inverseModel).xyz);\\n\\n  // vec4 m_position  = model * vec4(conePosition, 1.0);\\n  vec4 t_position  = view * conePosition;\\n  gl_Position      = projection * t_position;\\n\\n  f_color          = color;\\n  f_data           = conePosition.xyz;\\n  f_position       = position.xyz;\\n  f_uv             = uv;\\n}\\n\"]);\n      var triFragSrc = glslify([\"#extension GL_OES_standard_derivatives : enable\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nfloat beckmannDistribution(float x, float roughness) {\\n  float NdotH = max(x, 0.0001);\\n  float cos2Alpha = NdotH * NdotH;\\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\\n  float roughness2 = roughness * roughness;\\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\\n  return exp(tan2Alpha / roughness2) / denom;\\n}\\n\\nfloat cookTorranceSpecular(\\n  vec3 lightDirection,\\n  vec3 viewDirection,\\n  vec3 surfaceNormal,\\n  float roughness,\\n  float fresnel) {\\n\\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\\n\\n  //Half angle vector\\n  vec3 H = normalize(lightDirection + viewDirection);\\n\\n  //Geometric term\\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\\n  float VdotH = max(dot(viewDirection, H), 0.000001);\\n  float LdotH = max(dot(lightDirection, H), 0.000001);\\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\\n  float G = min(1.0, min(G1, G2));\\n  \\n  //Distribution term\\n  float D = beckmannDistribution(NdotH, roughness);\\n\\n  //Fresnel term\\n  float F = pow(1.0 - VdotN, fresnel);\\n\\n  //Multiply terms and done\\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\\n}\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 clipBounds[2];\\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\\nuniform sampler2D texture;\\n\\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\\n  vec3 N = normalize(f_normal);\\n  vec3 L = normalize(f_lightDirection);\\n  vec3 V = normalize(f_eyeDirection);\\n\\n  if(gl_FrontFacing) {\\n    N = -N;\\n  }\\n\\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\\n\\n  vec4 surfaceColor = f_color * texture2D(texture, f_uv);\\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\\n\\n  gl_FragColor = litColor * opacity;\\n}\\n\"]);\n      var pickVertSrc = glslify([\"precision highp float;\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvec3 getOrthogonalVector(vec3 v) {\\n  // Return up-vector for only-z vector.\\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\\n  // Assign z = 0, x = -b, y = a:\\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\\n    return normalize(vec3(-v.y, v.x, 0.0));\\n  } else {\\n    return normalize(vec3(0.0, v.z, -v.y));\\n  }\\n}\\n\\n// Calculate the cone vertex and normal at the given index.\\n//\\n// The returned vertex is for a cone with its top at origin and height of 1.0,\\n// pointing in the direction of the vector attribute.\\n//\\n// Each cone is made up of a top vertex, a center base vertex and base perimeter vertices.\\n// These vertices are used to make up the triangles of the cone by the following:\\n//   segment + 0 top vertex\\n//   segment + 1 perimeter vertex a+1\\n//   segment + 2 perimeter vertex a\\n//   segment + 3 center base vertex\\n//   segment + 4 perimeter vertex a\\n//   segment + 5 perimeter vertex a+1\\n// Where segment is the number of the radial segment * 6 and a is the angle at that radial segment.\\n// To go from index to segment, floor(index / 6)\\n// To go from segment to angle, 2*pi * (segment/segmentCount)\\n// To go from index to segment index, index - (segment*6)\\n//\\nvec3 getConePosition(vec3 d, float rawIndex, float coneOffset, out vec3 normal) {\\n\\n  const float segmentCount = 8.0;\\n\\n  float index = rawIndex - floor(rawIndex /\\n    (segmentCount * 6.0)) *\\n    (segmentCount * 6.0);\\n\\n  float segment = floor(0.001 + index/6.0);\\n  float segmentIndex = index - (segment*6.0);\\n\\n  normal = -normalize(d);\\n\\n  if (segmentIndex > 2.99 && segmentIndex < 3.01) {\\n    return mix(vec3(0.0), -d, coneOffset);\\n  }\\n\\n  float nextAngle = (\\n    (segmentIndex > 0.99 &&  segmentIndex < 1.01) ||\\n    (segmentIndex > 4.99 &&  segmentIndex < 5.01)\\n  ) ? 1.0 : 0.0;\\n  float angle = 2.0 * 3.14159 * ((segment + nextAngle) / segmentCount);\\n\\n  vec3 v1 = mix(d, vec3(0.0), coneOffset);\\n  vec3 v2 = v1 - d;\\n\\n  vec3 u = getOrthogonalVector(d);\\n  vec3 v = normalize(cross(u, d));\\n\\n  vec3 x = u * cos(angle) * length(d)*0.25;\\n  vec3 y = v * sin(angle) * length(d)*0.25;\\n  vec3 v3 = v2 + x + y;\\n  if (segmentIndex < 3.0) {\\n    vec3 tx = u * sin(angle);\\n    vec3 ty = v * -cos(angle);\\n    vec3 tangent = tx + ty;\\n    normal = normalize(cross(v3 - v1, tangent));\\n  }\\n\\n  if (segmentIndex == 0.0) {\\n    return mix(d, vec3(0.0), coneOffset);\\n  }\\n  return v3;\\n}\\n\\nattribute vec4 vector;\\nattribute vec4 position;\\nattribute vec4 id;\\n\\nuniform mat4 model, view, projection;\\nuniform float vectorScale, coneScale, coneOffset;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  vec3 normal;\\n  vec3 XYZ = getConePosition(mat3(model) * ((vectorScale * coneScale) * vector.xyz), position.w, coneOffset, normal);\\n  vec4 conePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\\n  gl_Position = projection * view * conePosition;\\n  f_id        = id;\\n  f_position  = position.xyz;\\n}\\n\"]);\n      var pickFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3  clipBounds[2];\\nuniform float pickId;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\\n\\n  gl_FragColor = vec4(pickId, f_id.xyz);\\n}\"]);\n      exports.meshShader = {\n        vertex: triVertSrc,\n        fragment: triFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec4'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'uv',\n          type: 'vec2'\n        }, {\n          name: 'vector',\n          type: 'vec3'\n        }]\n      };\n      exports.pickShader = {\n        vertex: pickVertSrc,\n        fragment: pickFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec4'\n        }, {\n          name: 'id',\n          type: 'vec4'\n        }, {\n          name: 'vector',\n          type: 'vec3'\n        }]\n      };\n    }, {\n      \"glslify\": 231\n    }],\n    82: [function (_glvis_, module, exports) {\n      module.exports = {\n        0: 'NONE',\n        1: 'ONE',\n        2: 'LINE_LOOP',\n        3: 'LINE_STRIP',\n        4: 'TRIANGLES',\n        5: 'TRIANGLE_STRIP',\n        6: 'TRIANGLE_FAN',\n        256: 'DEPTH_BUFFER_BIT',\n        512: 'NEVER',\n        513: 'LESS',\n        514: 'EQUAL',\n        515: 'LEQUAL',\n        516: 'GREATER',\n        517: 'NOTEQUAL',\n        518: 'GEQUAL',\n        519: 'ALWAYS',\n        768: 'SRC_COLOR',\n        769: 'ONE_MINUS_SRC_COLOR',\n        770: 'SRC_ALPHA',\n        771: 'ONE_MINUS_SRC_ALPHA',\n        772: 'DST_ALPHA',\n        773: 'ONE_MINUS_DST_ALPHA',\n        774: 'DST_COLOR',\n        775: 'ONE_MINUS_DST_COLOR',\n        776: 'SRC_ALPHA_SATURATE',\n        1024: 'STENCIL_BUFFER_BIT',\n        1028: 'FRONT',\n        1029: 'BACK',\n        1032: 'FRONT_AND_BACK',\n        1280: 'INVALID_ENUM',\n        1281: 'INVALID_VALUE',\n        1282: 'INVALID_OPERATION',\n        1285: 'OUT_OF_MEMORY',\n        1286: 'INVALID_FRAMEBUFFER_OPERATION',\n        2304: 'CW',\n        2305: 'CCW',\n        2849: 'LINE_WIDTH',\n        2884: 'CULL_FACE',\n        2885: 'CULL_FACE_MODE',\n        2886: 'FRONT_FACE',\n        2928: 'DEPTH_RANGE',\n        2929: 'DEPTH_TEST',\n        2930: 'DEPTH_WRITEMASK',\n        2931: 'DEPTH_CLEAR_VALUE',\n        2932: 'DEPTH_FUNC',\n        2960: 'STENCIL_TEST',\n        2961: 'STENCIL_CLEAR_VALUE',\n        2962: 'STENCIL_FUNC',\n        2963: 'STENCIL_VALUE_MASK',\n        2964: 'STENCIL_FAIL',\n        2965: 'STENCIL_PASS_DEPTH_FAIL',\n        2966: 'STENCIL_PASS_DEPTH_PASS',\n        2967: 'STENCIL_REF',\n        2968: 'STENCIL_WRITEMASK',\n        2978: 'VIEWPORT',\n        3024: 'DITHER',\n        3042: 'BLEND',\n        3088: 'SCISSOR_BOX',\n        3089: 'SCISSOR_TEST',\n        3106: 'COLOR_CLEAR_VALUE',\n        3107: 'COLOR_WRITEMASK',\n        3317: 'UNPACK_ALIGNMENT',\n        3333: 'PACK_ALIGNMENT',\n        3379: 'MAX_TEXTURE_SIZE',\n        3386: 'MAX_VIEWPORT_DIMS',\n        3408: 'SUBPIXEL_BITS',\n        3410: 'RED_BITS',\n        3411: 'GREEN_BITS',\n        3412: 'BLUE_BITS',\n        3413: 'ALPHA_BITS',\n        3414: 'DEPTH_BITS',\n        3415: 'STENCIL_BITS',\n        3553: 'TEXTURE_2D',\n        4352: 'DONT_CARE',\n        4353: 'FASTEST',\n        4354: 'NICEST',\n        5120: 'BYTE',\n        5121: 'UNSIGNED_BYTE',\n        5122: 'SHORT',\n        5123: 'UNSIGNED_SHORT',\n        5124: 'INT',\n        5125: 'UNSIGNED_INT',\n        5126: 'FLOAT',\n        5386: 'INVERT',\n        5890: 'TEXTURE',\n        6401: 'STENCIL_INDEX',\n        6402: 'DEPTH_COMPONENT',\n        6406: 'ALPHA',\n        6407: 'RGB',\n        6408: 'RGBA',\n        6409: 'LUMINANCE',\n        6410: 'LUMINANCE_ALPHA',\n        7680: 'KEEP',\n        7681: 'REPLACE',\n        7682: 'INCR',\n        7683: 'DECR',\n        7936: 'VENDOR',\n        7937: 'RENDERER',\n        7938: 'VERSION',\n        9728: 'NEAREST',\n        9729: 'LINEAR',\n        9984: 'NEAREST_MIPMAP_NEAREST',\n        9985: 'LINEAR_MIPMAP_NEAREST',\n        9986: 'NEAREST_MIPMAP_LINEAR',\n        9987: 'LINEAR_MIPMAP_LINEAR',\n        10240: 'TEXTURE_MAG_FILTER',\n        10241: 'TEXTURE_MIN_FILTER',\n        10242: 'TEXTURE_WRAP_S',\n        10243: 'TEXTURE_WRAP_T',\n        10497: 'REPEAT',\n        10752: 'POLYGON_OFFSET_UNITS',\n        16384: 'COLOR_BUFFER_BIT',\n        32769: 'CONSTANT_COLOR',\n        32770: 'ONE_MINUS_CONSTANT_COLOR',\n        32771: 'CONSTANT_ALPHA',\n        32772: 'ONE_MINUS_CONSTANT_ALPHA',\n        32773: 'BLEND_COLOR',\n        32774: 'FUNC_ADD',\n        32777: 'BLEND_EQUATION_RGB',\n        32778: 'FUNC_SUBTRACT',\n        32779: 'FUNC_REVERSE_SUBTRACT',\n        32819: 'UNSIGNED_SHORT_4_4_4_4',\n        32820: 'UNSIGNED_SHORT_5_5_5_1',\n        32823: 'POLYGON_OFFSET_FILL',\n        32824: 'POLYGON_OFFSET_FACTOR',\n        32854: 'RGBA4',\n        32855: 'RGB5_A1',\n        32873: 'TEXTURE_BINDING_2D',\n        32926: 'SAMPLE_ALPHA_TO_COVERAGE',\n        32928: 'SAMPLE_COVERAGE',\n        32936: 'SAMPLE_BUFFERS',\n        32937: 'SAMPLES',\n        32938: 'SAMPLE_COVERAGE_VALUE',\n        32939: 'SAMPLE_COVERAGE_INVERT',\n        32968: 'BLEND_DST_RGB',\n        32969: 'BLEND_SRC_RGB',\n        32970: 'BLEND_DST_ALPHA',\n        32971: 'BLEND_SRC_ALPHA',\n        33071: 'CLAMP_TO_EDGE',\n        33170: 'GENERATE_MIPMAP_HINT',\n        33189: 'DEPTH_COMPONENT16',\n        33306: 'DEPTH_STENCIL_ATTACHMENT',\n        33635: 'UNSIGNED_SHORT_5_6_5',\n        33648: 'MIRRORED_REPEAT',\n        33901: 'ALIASED_POINT_SIZE_RANGE',\n        33902: 'ALIASED_LINE_WIDTH_RANGE',\n        33984: 'TEXTURE0',\n        33985: 'TEXTURE1',\n        33986: 'TEXTURE2',\n        33987: 'TEXTURE3',\n        33988: 'TEXTURE4',\n        33989: 'TEXTURE5',\n        33990: 'TEXTURE6',\n        33991: 'TEXTURE7',\n        33992: 'TEXTURE8',\n        33993: 'TEXTURE9',\n        33994: 'TEXTURE10',\n        33995: 'TEXTURE11',\n        33996: 'TEXTURE12',\n        33997: 'TEXTURE13',\n        33998: 'TEXTURE14',\n        33999: 'TEXTURE15',\n        34000: 'TEXTURE16',\n        34001: 'TEXTURE17',\n        34002: 'TEXTURE18',\n        34003: 'TEXTURE19',\n        34004: 'TEXTURE20',\n        34005: 'TEXTURE21',\n        34006: 'TEXTURE22',\n        34007: 'TEXTURE23',\n        34008: 'TEXTURE24',\n        34009: 'TEXTURE25',\n        34010: 'TEXTURE26',\n        34011: 'TEXTURE27',\n        34012: 'TEXTURE28',\n        34013: 'TEXTURE29',\n        34014: 'TEXTURE30',\n        34015: 'TEXTURE31',\n        34016: 'ACTIVE_TEXTURE',\n        34024: 'MAX_RENDERBUFFER_SIZE',\n        34041: 'DEPTH_STENCIL',\n        34055: 'INCR_WRAP',\n        34056: 'DECR_WRAP',\n        34067: 'TEXTURE_CUBE_MAP',\n        34068: 'TEXTURE_BINDING_CUBE_MAP',\n        34069: 'TEXTURE_CUBE_MAP_POSITIVE_X',\n        34070: 'TEXTURE_CUBE_MAP_NEGATIVE_X',\n        34071: 'TEXTURE_CUBE_MAP_POSITIVE_Y',\n        34072: 'TEXTURE_CUBE_MAP_NEGATIVE_Y',\n        34073: 'TEXTURE_CUBE_MAP_POSITIVE_Z',\n        34074: 'TEXTURE_CUBE_MAP_NEGATIVE_Z',\n        34076: 'MAX_CUBE_MAP_TEXTURE_SIZE',\n        34338: 'VERTEX_ATTRIB_ARRAY_ENABLED',\n        34339: 'VERTEX_ATTRIB_ARRAY_SIZE',\n        34340: 'VERTEX_ATTRIB_ARRAY_STRIDE',\n        34341: 'VERTEX_ATTRIB_ARRAY_TYPE',\n        34342: 'CURRENT_VERTEX_ATTRIB',\n        34373: 'VERTEX_ATTRIB_ARRAY_POINTER',\n        34466: 'NUM_COMPRESSED_TEXTURE_FORMATS',\n        34467: 'COMPRESSED_TEXTURE_FORMATS',\n        34660: 'BUFFER_SIZE',\n        34661: 'BUFFER_USAGE',\n        34816: 'STENCIL_BACK_FUNC',\n        34817: 'STENCIL_BACK_FAIL',\n        34818: 'STENCIL_BACK_PASS_DEPTH_FAIL',\n        34819: 'STENCIL_BACK_PASS_DEPTH_PASS',\n        34877: 'BLEND_EQUATION_ALPHA',\n        34921: 'MAX_VERTEX_ATTRIBS',\n        34922: 'VERTEX_ATTRIB_ARRAY_NORMALIZED',\n        34930: 'MAX_TEXTURE_IMAGE_UNITS',\n        34962: 'ARRAY_BUFFER',\n        34963: 'ELEMENT_ARRAY_BUFFER',\n        34964: 'ARRAY_BUFFER_BINDING',\n        34965: 'ELEMENT_ARRAY_BUFFER_BINDING',\n        34975: 'VERTEX_ATTRIB_ARRAY_BUFFER_BINDING',\n        35040: 'STREAM_DRAW',\n        35044: 'STATIC_DRAW',\n        35048: 'DYNAMIC_DRAW',\n        35632: 'FRAGMENT_SHADER',\n        35633: 'VERTEX_SHADER',\n        35660: 'MAX_VERTEX_TEXTURE_IMAGE_UNITS',\n        35661: 'MAX_COMBINED_TEXTURE_IMAGE_UNITS',\n        35663: 'SHADER_TYPE',\n        35664: 'FLOAT_VEC2',\n        35665: 'FLOAT_VEC3',\n        35666: 'FLOAT_VEC4',\n        35667: 'INT_VEC2',\n        35668: 'INT_VEC3',\n        35669: 'INT_VEC4',\n        35670: 'BOOL',\n        35671: 'BOOL_VEC2',\n        35672: 'BOOL_VEC3',\n        35673: 'BOOL_VEC4',\n        35674: 'FLOAT_MAT2',\n        35675: 'FLOAT_MAT3',\n        35676: 'FLOAT_MAT4',\n        35678: 'SAMPLER_2D',\n        35680: 'SAMPLER_CUBE',\n        35712: 'DELETE_STATUS',\n        35713: 'COMPILE_STATUS',\n        35714: 'LINK_STATUS',\n        35715: 'VALIDATE_STATUS',\n        35716: 'INFO_LOG_LENGTH',\n        35717: 'ATTACHED_SHADERS',\n        35718: 'ACTIVE_UNIFORMS',\n        35719: 'ACTIVE_UNIFORM_MAX_LENGTH',\n        35720: 'SHADER_SOURCE_LENGTH',\n        35721: 'ACTIVE_ATTRIBUTES',\n        35722: 'ACTIVE_ATTRIBUTE_MAX_LENGTH',\n        35724: 'SHADING_LANGUAGE_VERSION',\n        35725: 'CURRENT_PROGRAM',\n        36003: 'STENCIL_BACK_REF',\n        36004: 'STENCIL_BACK_VALUE_MASK',\n        36005: 'STENCIL_BACK_WRITEMASK',\n        36006: 'FRAMEBUFFER_BINDING',\n        36007: 'RENDERBUFFER_BINDING',\n        36048: 'FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE',\n        36049: 'FRAMEBUFFER_ATTACHMENT_OBJECT_NAME',\n        36050: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL',\n        36051: 'FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE',\n        36053: 'FRAMEBUFFER_COMPLETE',\n        36054: 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n        36055: 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n        36057: 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n        36061: 'FRAMEBUFFER_UNSUPPORTED',\n        36064: 'COLOR_ATTACHMENT0',\n        36096: 'DEPTH_ATTACHMENT',\n        36128: 'STENCIL_ATTACHMENT',\n        36160: 'FRAMEBUFFER',\n        36161: 'RENDERBUFFER',\n        36162: 'RENDERBUFFER_WIDTH',\n        36163: 'RENDERBUFFER_HEIGHT',\n        36164: 'RENDERBUFFER_INTERNAL_FORMAT',\n        36168: 'STENCIL_INDEX8',\n        36176: 'RENDERBUFFER_RED_SIZE',\n        36177: 'RENDERBUFFER_GREEN_SIZE',\n        36178: 'RENDERBUFFER_BLUE_SIZE',\n        36179: 'RENDERBUFFER_ALPHA_SIZE',\n        36180: 'RENDERBUFFER_DEPTH_SIZE',\n        36181: 'RENDERBUFFER_STENCIL_SIZE',\n        36194: 'RGB565',\n        36336: 'LOW_FLOAT',\n        36337: 'MEDIUM_FLOAT',\n        36338: 'HIGH_FLOAT',\n        36339: 'LOW_INT',\n        36340: 'MEDIUM_INT',\n        36341: 'HIGH_INT',\n        36346: 'SHADER_COMPILER',\n        36347: 'MAX_VERTEX_UNIFORM_VECTORS',\n        36348: 'MAX_VARYING_VECTORS',\n        36349: 'MAX_FRAGMENT_UNIFORM_VECTORS',\n        37440: 'UNPACK_FLIP_Y_WEBGL',\n        37441: 'UNPACK_PREMULTIPLY_ALPHA_WEBGL',\n        37442: 'CONTEXT_LOST_WEBGL',\n        37443: 'UNPACK_COLORSPACE_CONVERSION_WEBGL',\n        37444: 'BROWSER_DEFAULT_WEBGL'\n      };\n    }, {}],\n    83: [function (_glvis_, module, exports) {\n      var gl10 = _glvis_('./1.0/numbers');\n\n      module.exports = function lookupConstant(number) {\n        return gl10[number];\n      };\n    }, {\n      \"./1.0/numbers\": 82\n    }],\n    84: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createErrorBars;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createShader = _glvis_('./shaders/index');\n\n      var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n      function ErrorBars(gl, buffer, vao, shader) {\n        this.gl = gl;\n        this.shader = shader;\n        this.buffer = buffer;\n        this.vao = vao;\n        this.pixelRatio = 1;\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.lineWidth = [1, 1, 1];\n        this.capSize = [10, 10, 10];\n        this.lineCount = [0, 0, 0];\n        this.lineOffset = [0, 0, 0];\n        this.opacity = 1;\n        this.hasAlpha = false;\n      }\n\n      var proto = ErrorBars.prototype;\n\n      proto.isOpaque = function () {\n        return !this.hasAlpha;\n      };\n\n      proto.isTransparent = function () {\n        return this.hasAlpha;\n      };\n\n      proto.drawTransparent = proto.draw = function (cameraParams) {\n        var gl = this.gl;\n        var uniforms = this.shader.uniforms;\n        this.shader.bind();\n        var view = uniforms.view = cameraParams.view || IDENTITY;\n        var projection = uniforms.projection = cameraParams.projection || IDENTITY;\n        uniforms.model = cameraParams.model || IDENTITY;\n        uniforms.clipBounds = this.clipBounds;\n        uniforms.opacity = this.opacity;\n        var cx = view[12];\n        var cy = view[13];\n        var cz = view[14];\n        var cw = view[15];\n        var isOrtho = cameraParams._ortho || false;\n        var orthoFix = isOrtho ? 2 : 1; // double up padding for orthographic ticks & labels\n\n        var pixelScaleF = orthoFix * this.pixelRatio * (projection[3] * cx + projection[7] * cy + projection[11] * cz + projection[15] * cw) / gl.drawingBufferHeight;\n        this.vao.bind();\n\n        for (var i = 0; i < 3; ++i) {\n          gl.lineWidth(this.lineWidth[i] * this.pixelRatio);\n          uniforms.capSize = this.capSize[i] * pixelScaleF;\n\n          if (this.lineCount[i]) {\n            gl.drawArrays(gl.LINES, this.lineOffset[i], this.lineCount[i]);\n          }\n        }\n\n        this.vao.unbind();\n      };\n\n      function updateBounds(bounds, point) {\n        for (var i = 0; i < 3; ++i) {\n          bounds[0][i] = Math.min(bounds[0][i], point[i]);\n          bounds[1][i] = Math.max(bounds[1][i], point[i]);\n        }\n      }\n\n      var FACE_TABLE = function () {\n        var table = new Array(3);\n\n        for (var d = 0; d < 3; ++d) {\n          var row = [];\n\n          for (var j = 1; j <= 2; ++j) {\n            for (var s = -1; s <= 1; s += 2) {\n              var u = (j + d) % 3;\n              var y = [0, 0, 0];\n              y[u] = s;\n              row.push(y);\n            }\n          }\n\n          table[d] = row;\n        }\n\n        return table;\n      }();\n\n      function emitFace(verts, x, c, d) {\n        var offsets = FACE_TABLE[d];\n\n        for (var i = 0; i < offsets.length; ++i) {\n          var o = offsets[i];\n          verts.push(x[0], x[1], x[2], c[0], c[1], c[2], c[3], o[0], o[1], o[2]);\n        }\n\n        return offsets.length;\n      }\n\n      proto.update = function (options) {\n        options = options || {};\n\n        if ('lineWidth' in options) {\n          this.lineWidth = options.lineWidth;\n\n          if (!Array.isArray(this.lineWidth)) {\n            this.lineWidth = [this.lineWidth, this.lineWidth, this.lineWidth];\n          }\n        }\n\n        if ('capSize' in options) {\n          this.capSize = options.capSize;\n\n          if (!Array.isArray(this.capSize)) {\n            this.capSize = [this.capSize, this.capSize, this.capSize];\n          }\n        }\n\n        this.hasAlpha = false; // default to no transparent draw\n\n        if ('opacity' in options) {\n          this.opacity = +options.opacity;\n\n          if (this.opacity < 1) {\n            this.hasAlpha = true;\n          }\n        }\n\n        var color = options.color || [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n        var position = options.position;\n        var error = options.error;\n\n        if (!Array.isArray(color[0])) {\n          color = [color, color, color];\n        }\n\n        if (position && error) {\n          var verts = [];\n          var n = position.length;\n          var vertexCount = 0;\n          this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n          this.lineCount = [0, 0, 0]; //Build geometry for lines\n\n          for (var j = 0; j < 3; ++j) {\n            this.lineOffset[j] = vertexCount;\n\n            i_loop: for (var i = 0; i < n; ++i) {\n              var p = position[i];\n\n              for (var k = 0; k < 3; ++k) {\n                if (isNaN(p[k]) || !isFinite(p[k])) {\n                  continue i_loop;\n                }\n              }\n\n              var e = error[i];\n              var c = color[j];\n\n              if (Array.isArray(c[0])) {\n                c = color[i];\n              }\n\n              if (c.length === 3) {\n                c = [c[0], c[1], c[2], 1];\n              } else if (c.length === 4) {\n                c = [c[0], c[1], c[2], c[3]];\n                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n              }\n\n              if (isNaN(e[0][j]) || isNaN(e[1][j])) {\n                continue;\n              }\n\n              if (e[0][j] < 0) {\n                var x = p.slice();\n                x[j] += e[0][j];\n                verts.push(p[0], p[1], p[2], c[0], c[1], c[2], c[3], 0, 0, 0, x[0], x[1], x[2], c[0], c[1], c[2], c[3], 0, 0, 0);\n                updateBounds(this.bounds, x);\n                vertexCount += 2 + emitFace(verts, x, c, j);\n              }\n\n              if (e[1][j] > 0) {\n                var x = p.slice();\n                x[j] += e[1][j];\n                verts.push(p[0], p[1], p[2], c[0], c[1], c[2], c[3], 0, 0, 0, x[0], x[1], x[2], c[0], c[1], c[2], c[3], 0, 0, 0);\n                updateBounds(this.bounds, x);\n                vertexCount += 2 + emitFace(verts, x, c, j);\n              }\n            }\n\n            this.lineCount[j] = vertexCount - this.lineOffset[j];\n          }\n\n          this.buffer.update(verts);\n        }\n      };\n\n      proto.dispose = function () {\n        this.shader.dispose();\n        this.buffer.dispose();\n        this.vao.dispose();\n      };\n\n      function createErrorBars(options) {\n        var gl = options.gl;\n        var buffer = createBuffer(gl);\n        var vao = createVAO(gl, [{\n          buffer: buffer,\n          type: gl.FLOAT,\n          size: 3,\n          offset: 0,\n          stride: 40\n        }, {\n          buffer: buffer,\n          type: gl.FLOAT,\n          size: 4,\n          offset: 12,\n          stride: 40\n        }, {\n          buffer: buffer,\n          type: gl.FLOAT,\n          size: 3,\n          offset: 28,\n          stride: 40\n        }]);\n        var shader = createShader(gl);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 1;\n        shader.attributes.offset.location = 2;\n        var result = new ErrorBars(gl, buffer, vao, shader);\n        result.update(options);\n        return result;\n      }\n    }, {\n      \"./shaders/index\": 85,\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150\n    }],\n    85: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      var createShader = _glvis_('gl-shader');\n\n      var vertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position, offset;\\nattribute vec4 color;\\nuniform mat4 model, view, projection;\\nuniform float capSize;\\nvarying vec4 fragColor;\\nvarying vec3 fragPosition;\\n\\nvoid main() {\\n  vec4 worldPosition  = model * vec4(position, 1.0);\\n  worldPosition       = (worldPosition / worldPosition.w) + vec4(capSize * offset, 0.0);\\n  gl_Position         = projection * view * worldPosition;\\n  fragColor           = color;\\n  fragPosition        = position;\\n}\"]);\n      var fragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 clipBounds[2];\\nuniform float opacity;\\nvarying vec3 fragPosition;\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n  if (\\n    outOfRange(clipBounds[0], clipBounds[1], fragPosition) ||\\n    fragColor.a * opacity == 0.\\n  ) discard;\\n\\n  gl_FragColor = opacity * fragColor;\\n}\"]);\n\n      module.exports = function (gl) {\n        return createShader(gl, vertSrc, fragSrc, null, [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'offset',\n          type: 'vec3'\n        }]);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    86: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createTexture = _glvis_('gl-texture2d');\n\n      module.exports = createFBO;\n      var colorAttachmentArrays = null;\n      var FRAMEBUFFER_UNSUPPORTED;\n      var FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\n      var FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\n      var FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\n\n      function saveFBOState(gl) {\n        var fbo = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n        var rbo = gl.getParameter(gl.RENDERBUFFER_BINDING);\n        var tex = gl.getParameter(gl.TEXTURE_BINDING_2D);\n        return [fbo, rbo, tex];\n      }\n\n      function restoreFBOState(gl, data) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, data[0]);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, data[1]);\n        gl.bindTexture(gl.TEXTURE_2D, data[2]);\n      }\n\n      function lazyInitColorAttachments(gl, ext) {\n        var maxColorAttachments = gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL);\n        colorAttachmentArrays = new Array(maxColorAttachments + 1);\n\n        for (var i = 0; i <= maxColorAttachments; ++i) {\n          var x = new Array(maxColorAttachments);\n\n          for (var j = 0; j < i; ++j) {\n            x[j] = gl.COLOR_ATTACHMENT0 + j;\n          }\n\n          for (var j = i; j < maxColorAttachments; ++j) {\n            x[j] = gl.NONE;\n          }\n\n          colorAttachmentArrays[i] = x;\n        }\n      } //Throw an appropriate error\n\n\n      function throwFBOError(status) {\n        switch (status) {\n          case FRAMEBUFFER_UNSUPPORTED:\n            throw new Error('gl-fbo: Framebuffer unsupported');\n\n          case FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            throw new Error('gl-fbo: Framebuffer incomplete attachment');\n\n          case FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            throw new Error('gl-fbo: Framebuffer incomplete dimensions');\n\n          case FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            throw new Error('gl-fbo: Framebuffer incomplete missing attachment');\n\n          default:\n            throw new Error('gl-fbo: Framebuffer failed for unspecified reason');\n        }\n      } //Initialize a texture object\n\n\n      function initTexture(gl, width, height, type, format, attachment) {\n        if (!type) {\n          return null;\n        }\n\n        var result = createTexture(gl, width, height, format, type);\n        result.magFilter = gl.NEAREST;\n        result.minFilter = gl.NEAREST;\n        result.mipSamples = 1;\n        result.bind();\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, result.handle, 0);\n        return result;\n      } //Initialize a render buffer object\n\n\n      function initRenderBuffer(gl, width, height, component, attachment) {\n        var result = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, result);\n        gl.renderbufferStorage(gl.RENDERBUFFER, component, width, height);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, result);\n        return result;\n      } //Rebuild the frame buffer\n\n\n      function rebuildFBO(fbo) {\n        //Save FBO state\n        var state = saveFBOState(fbo.gl);\n        var gl = fbo.gl;\n        var handle = fbo.handle = gl.createFramebuffer();\n        var width = fbo._shape[0];\n        var height = fbo._shape[1];\n        var numColors = fbo.color.length;\n        var ext = fbo._ext;\n        var useStencil = fbo._useStencil;\n        var useDepth = fbo._useDepth;\n        var colorType = fbo._colorType; //Bind the fbo\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, handle); //Allocate color buffers\n\n        for (var i = 0; i < numColors; ++i) {\n          fbo.color[i] = initTexture(gl, width, height, colorType, gl.RGBA, gl.COLOR_ATTACHMENT0 + i);\n        }\n\n        if (numColors === 0) {\n          fbo._color_rb = initRenderBuffer(gl, width, height, gl.RGBA4, gl.COLOR_ATTACHMENT0);\n\n          if (ext) {\n            ext.drawBuffersWEBGL(colorAttachmentArrays[0]);\n          }\n        } else if (numColors > 1) {\n          ext.drawBuffersWEBGL(colorAttachmentArrays[numColors]);\n        } //Allocate depth/stencil buffers\n\n\n        var WEBGL_depth_texture = gl.getExtension('WEBGL_depth_texture');\n\n        if (WEBGL_depth_texture) {\n          if (useStencil) {\n            fbo.depth = initTexture(gl, width, height, WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);\n          } else if (useDepth) {\n            fbo.depth = initTexture(gl, width, height, gl.UNSIGNED_SHORT, gl.DEPTH_COMPONENT, gl.DEPTH_ATTACHMENT);\n          }\n        } else {\n          if (useDepth && useStencil) {\n            fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_STENCIL, gl.DEPTH_STENCIL_ATTACHMENT);\n          } else if (useDepth) {\n            fbo._depth_rb = initRenderBuffer(gl, width, height, gl.DEPTH_COMPONENT16, gl.DEPTH_ATTACHMENT);\n          } else if (useStencil) {\n            fbo._depth_rb = initRenderBuffer(gl, width, height, gl.STENCIL_INDEX, gl.STENCIL_ATTACHMENT);\n          }\n        } //Check frame buffer state\n\n\n        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n        if (status !== gl.FRAMEBUFFER_COMPLETE) {\n          //Release all partially allocated resources\n          fbo._destroyed = true; //Release all resources\n\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n          gl.deleteFramebuffer(fbo.handle);\n          fbo.handle = null;\n\n          if (fbo.depth) {\n            fbo.depth.dispose();\n            fbo.depth = null;\n          }\n\n          if (fbo._depth_rb) {\n            gl.deleteRenderbuffer(fbo._depth_rb);\n            fbo._depth_rb = null;\n          }\n\n          for (var i = 0; i < fbo.color.length; ++i) {\n            fbo.color[i].dispose();\n            fbo.color[i] = null;\n          }\n\n          if (fbo._color_rb) {\n            gl.deleteRenderbuffer(fbo._color_rb);\n            fbo._color_rb = null;\n          }\n\n          restoreFBOState(gl, state); //Throw the frame buffer error\n\n          throwFBOError(status);\n        } //Everything ok, let's get on with life\n\n\n        restoreFBOState(gl, state);\n      }\n\n      function Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, ext) {\n        //Handle and set properties\n        this.gl = gl;\n        this._shape = [width | 0, height | 0];\n        this._destroyed = false;\n        this._ext = ext; //Allocate buffers\n\n        this.color = new Array(numColors);\n\n        for (var i = 0; i < numColors; ++i) {\n          this.color[i] = null;\n        }\n\n        this._color_rb = null;\n        this.depth = null;\n        this._depth_rb = null; //Save depth and stencil flags\n\n        this._colorType = colorType;\n        this._useDepth = useDepth;\n        this._useStencil = useStencil; //Shape vector for resizing\n\n        var parent = this;\n        var shapeVector = [width | 0, height | 0];\n        Object.defineProperties(shapeVector, {\n          0: {\n            get: function get() {\n              return parent._shape[0];\n            },\n            set: function set(w) {\n              return parent.width = w;\n            }\n          },\n          1: {\n            get: function get() {\n              return parent._shape[1];\n            },\n            set: function set(h) {\n              return parent.height = h;\n            }\n          }\n        });\n        this._shapeVector = shapeVector; //Initialize all attachments\n\n        rebuildFBO(this);\n      }\n\n      var proto = Framebuffer.prototype;\n\n      function reshapeFBO(fbo, w, h) {\n        //If fbo is invalid, just skip this\n        if (fbo._destroyed) {\n          throw new Error('gl-fbo: Can\\'t resize destroyed FBO');\n        } //Don't resize if no change in shape\n\n\n        if (fbo._shape[0] === w && fbo._shape[1] === h) {\n          return;\n        }\n\n        var gl = fbo.gl; //Check parameter ranges\n\n        var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\n        if (w < 0 || w > maxFBOSize || h < 0 || h > maxFBOSize) {\n          throw new Error('gl-fbo: Can\\'t resize FBO, invalid dimensions');\n        } //Update shape\n\n\n        fbo._shape[0] = w;\n        fbo._shape[1] = h; //Save framebuffer state\n\n        var state = saveFBOState(gl); //Resize framebuffer attachments\n\n        for (var i = 0; i < fbo.color.length; ++i) {\n          fbo.color[i].shape = fbo._shape;\n        }\n\n        if (fbo._color_rb) {\n          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._color_rb);\n          gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, fbo._shape[0], fbo._shape[1]);\n        }\n\n        if (fbo.depth) {\n          fbo.depth.shape = fbo._shape;\n        }\n\n        if (fbo._depth_rb) {\n          gl.bindRenderbuffer(gl.RENDERBUFFER, fbo._depth_rb);\n\n          if (fbo._useDepth && fbo._useStencil) {\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, fbo._shape[0], fbo._shape[1]);\n          } else if (fbo._useDepth) {\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, fbo._shape[0], fbo._shape[1]);\n          } else if (fbo._useStencil) {\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX, fbo._shape[0], fbo._shape[1]);\n          }\n        } //Check FBO status after resize, if something broke then die in a fire\n\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.handle);\n        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n        if (status !== gl.FRAMEBUFFER_COMPLETE) {\n          fbo.dispose();\n          restoreFBOState(gl, state);\n          throwFBOError(status);\n        } //Restore framebuffer state\n\n\n        restoreFBOState(gl, state);\n      }\n\n      Object.defineProperties(proto, {\n        'shape': {\n          get: function get() {\n            if (this._destroyed) {\n              return [0, 0];\n            }\n\n            return this._shapeVector;\n          },\n          set: function set(x) {\n            if (!Array.isArray(x)) {\n              x = [x | 0, x | 0];\n            }\n\n            if (x.length !== 2) {\n              throw new Error('gl-fbo: Shape vector must be length 2');\n            }\n\n            var w = x[0] | 0;\n            var h = x[1] | 0;\n            reshapeFBO(this, w, h);\n            return [w, h];\n          },\n          enumerable: false\n        },\n        'width': {\n          get: function get() {\n            if (this._destroyed) {\n              return 0;\n            }\n\n            return this._shape[0];\n          },\n          set: function set(w) {\n            w = w | 0;\n            reshapeFBO(this, w, this._shape[1]);\n            return w;\n          },\n          enumerable: false\n        },\n        'height': {\n          get: function get() {\n            if (this._destroyed) {\n              return 0;\n            }\n\n            return this._shape[1];\n          },\n          set: function set(h) {\n            h = h | 0;\n            reshapeFBO(this, this._shape[0], h);\n            return h;\n          },\n          enumerable: false\n        }\n      });\n\n      proto.bind = function () {\n        if (this._destroyed) {\n          return;\n        }\n\n        var gl = this.gl;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);\n        gl.viewport(0, 0, this._shape[0], this._shape[1]);\n      };\n\n      proto.dispose = function () {\n        if (this._destroyed) {\n          return;\n        }\n\n        this._destroyed = true;\n        var gl = this.gl;\n        gl.deleteFramebuffer(this.handle);\n        this.handle = null;\n\n        if (this.depth) {\n          this.depth.dispose();\n          this.depth = null;\n        }\n\n        if (this._depth_rb) {\n          gl.deleteRenderbuffer(this._depth_rb);\n          this._depth_rb = null;\n        }\n\n        for (var i = 0; i < this.color.length; ++i) {\n          this.color[i].dispose();\n          this.color[i] = null;\n        }\n\n        if (this._color_rb) {\n          gl.deleteRenderbuffer(this._color_rb);\n          this._color_rb = null;\n        }\n      };\n\n      function createFBO(gl, width, height, options) {\n        //Update frame buffer error code values\n        if (!FRAMEBUFFER_UNSUPPORTED) {\n          FRAMEBUFFER_UNSUPPORTED = gl.FRAMEBUFFER_UNSUPPORTED;\n          FRAMEBUFFER_INCOMPLETE_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\n          FRAMEBUFFER_INCOMPLETE_DIMENSIONS = gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\n          FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\n        } //Lazily initialize color attachment arrays\n\n\n        var WEBGL_draw_buffers = gl.getExtension('WEBGL_draw_buffers');\n\n        if (!colorAttachmentArrays && WEBGL_draw_buffers) {\n          lazyInitColorAttachments(gl, WEBGL_draw_buffers);\n        } //Special case: Can accept an array as argument\n\n\n        if (Array.isArray(width)) {\n          options = height;\n          height = width[1] | 0;\n          width = width[0] | 0;\n        }\n\n        if (typeof width !== 'number') {\n          throw new Error('gl-fbo: Missing shape parameter');\n        } //Validate width/height properties\n\n\n        var maxFBOSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\n        if (width < 0 || width > maxFBOSize || height < 0 || height > maxFBOSize) {\n          throw new Error('gl-fbo: Parameters are too large for FBO');\n        } //Handle each option type\n\n\n        options = options || {}; //Figure out number of color buffers to use\n\n        var numColors = 1;\n\n        if ('color' in options) {\n          numColors = Math.max(options.color | 0, 0);\n\n          if (numColors < 0) {\n            throw new Error('gl-fbo: Must specify a nonnegative number of colors');\n          }\n\n          if (numColors > 1) {\n            //Check if multiple render targets supported\n            if (!WEBGL_draw_buffers) {\n              throw new Error('gl-fbo: Multiple draw buffer extension not supported');\n            } else if (numColors > gl.getParameter(WEBGL_draw_buffers.MAX_COLOR_ATTACHMENTS_WEBGL)) {\n              throw new Error('gl-fbo: Context does not support ' + numColors + ' draw buffers');\n            }\n          }\n        } //Determine whether to use floating point textures\n\n\n        var colorType = gl.UNSIGNED_BYTE;\n        var OES_texture_float = gl.getExtension('OES_texture_float');\n\n        if (options.float && numColors > 0) {\n          if (!OES_texture_float) {\n            throw new Error('gl-fbo: Context does not support floating point textures');\n          }\n\n          colorType = gl.FLOAT;\n        } else if (options.preferFloat && numColors > 0) {\n          if (OES_texture_float) {\n            colorType = gl.FLOAT;\n          }\n        } //Check if we should use depth buffer\n\n\n        var useDepth = true;\n\n        if ('depth' in options) {\n          useDepth = !!options.depth;\n        } //Check if we should use a stencil buffer\n\n\n        var useStencil = false;\n\n        if ('stencil' in options) {\n          useStencil = !!options.stencil;\n        }\n\n        return new Framebuffer(gl, width, height, colorType, numColors, useDepth, useStencil, WEBGL_draw_buffers);\n      }\n    }, {\n      \"gl-texture2d\": 146\n    }],\n    87: [function (_glvis_, module, exports) {\n      var sprintf = _glvis_('sprintf-js').sprintf;\n\n      var glConstants = _glvis_('gl-constants/lookup');\n\n      var shaderName = _glvis_('glsl-shader-name');\n\n      var addLineNumbers = _glvis_('add-line-numbers');\n\n      module.exports = formatCompilerError;\n\n      function formatCompilerError(errLog, src, type) {\n        \"use strict\";\n\n        var name = shaderName(src) || 'of unknown name (see npm glsl-shader-name)';\n        var typeName = 'unknown type';\n\n        if (type !== undefined) {\n          typeName = type === glConstants.FRAGMENT_SHADER ? 'fragment' : 'vertex';\n        }\n\n        var longForm = sprintf('Error compiling %s shader %s:\\n', typeName, name);\n        var shortForm = sprintf(\"%s%s\", longForm, errLog);\n        var errorStrings = errLog.split('\\n');\n        var errors = {};\n\n        for (var i = 0; i < errorStrings.length; i++) {\n          var errorString = errorStrings[i];\n          if (errorString === '' || errorString === \"\\0\") continue;\n          var lineNo = parseInt(errorString.split(':')[2]);\n\n          if (isNaN(lineNo)) {\n            throw new Error(sprintf('Could not parse error: %s', errorString));\n          }\n\n          errors[lineNo] = errorString;\n        }\n\n        var lines = addLineNumbers(src).split('\\n');\n\n        for (var i = 0; i < lines.length; i++) {\n          if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) continue;\n          var line = lines[i];\n          longForm += line + '\\n';\n\n          if (errors[i + 1]) {\n            var e = errors[i + 1];\n            e = e.substr(e.split(':', 3).join(':').length + 1).trim();\n            longForm += sprintf('^^^ %s\\n\\n', e);\n          }\n        }\n\n        return {\n          long: longForm.trim(),\n          short: shortForm.trim()\n        };\n      }\n    }, {\n      \"add-line-numbers\": 9,\n      \"gl-constants/lookup\": 83,\n      \"glsl-shader-name\": 223,\n      \"sprintf-js\": 301\n    }],\n    88: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createHeatmap2D;\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var iota = _glvis_('iota-array');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var createShader = _glvis_('gl-shader');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var shaders = _glvis_('./lib/shaders');\n\n      function GLHeatmap2D(plot, shader, pickShader, positionBuffer, weightBuffer, colorBuffer, idBuffer) {\n        this.plot = plot;\n        this.shader = shader;\n        this.pickShader = pickShader;\n        this.positionBuffer = positionBuffer;\n        this.weightBuffer = weightBuffer;\n        this.colorBuffer = colorBuffer;\n        this.idBuffer = idBuffer;\n        this.xData = [];\n        this.yData = [];\n        this.shape = [0, 0];\n        this.bounds = [Infinity, Infinity, -Infinity, -Infinity];\n        this.pickOffset = 0;\n      }\n\n      var proto = GLHeatmap2D.prototype;\n      var WEIGHTS = [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1];\n\n      proto.draw = function () {\n        var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        return function () {\n          var plot = this.plot;\n          var shader = this.shader;\n          var bounds = this.bounds;\n          var numVertices = this.numVertices;\n\n          if (numVertices <= 0) {\n            return;\n          }\n\n          var gl = plot.gl;\n          var dataBox = plot.dataBox;\n          var boundX = bounds[2] - bounds[0];\n          var boundY = bounds[3] - bounds[1];\n          var dataX = dataBox[2] - dataBox[0];\n          var dataY = dataBox[3] - dataBox[1];\n          MATRIX[0] = 2.0 * boundX / dataX;\n          MATRIX[4] = 2.0 * boundY / dataY;\n          MATRIX[6] = 2.0 * (bounds[0] - dataBox[0]) / dataX - 1.0;\n          MATRIX[7] = 2.0 * (bounds[1] - dataBox[1]) / dataY - 1.0;\n          shader.bind();\n          var uniforms = shader.uniforms;\n          uniforms.viewTransform = MATRIX;\n          uniforms.shape = this.shape;\n          var attributes = shader.attributes;\n          this.positionBuffer.bind();\n          attributes.position.pointer();\n          this.weightBuffer.bind();\n          attributes.weight.pointer(gl.UNSIGNED_BYTE, false);\n          this.colorBuffer.bind();\n          attributes.color.pointer(gl.UNSIGNED_BYTE, true);\n          gl.drawArrays(gl.TRIANGLES, 0, numVertices);\n        };\n      }();\n\n      proto.drawPick = function () {\n        var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        var PICK_VECTOR = [0, 0, 0, 0];\n        return function (pickOffset) {\n          var plot = this.plot;\n          var shader = this.pickShader;\n          var bounds = this.bounds;\n          var numVertices = this.numVertices;\n\n          if (numVertices <= 0) {\n            return;\n          }\n\n          var gl = plot.gl;\n          var dataBox = plot.dataBox;\n          var boundX = bounds[2] - bounds[0];\n          var boundY = bounds[3] - bounds[1];\n          var dataX = dataBox[2] - dataBox[0];\n          var dataY = dataBox[3] - dataBox[1];\n          MATRIX[0] = 2.0 * boundX / dataX;\n          MATRIX[4] = 2.0 * boundY / dataY;\n          MATRIX[6] = 2.0 * (bounds[0] - dataBox[0]) / dataX - 1.0;\n          MATRIX[7] = 2.0 * (bounds[1] - dataBox[1]) / dataY - 1.0;\n\n          for (var i = 0; i < 4; ++i) {\n            PICK_VECTOR[i] = pickOffset >> i * 8 & 0xff;\n          }\n\n          this.pickOffset = pickOffset;\n          shader.bind();\n          var uniforms = shader.uniforms;\n          uniforms.viewTransform = MATRIX;\n          uniforms.pickOffset = PICK_VECTOR;\n          uniforms.shape = this.shape;\n          var attributes = shader.attributes;\n          this.positionBuffer.bind();\n          attributes.position.pointer();\n          this.weightBuffer.bind();\n          attributes.weight.pointer(gl.UNSIGNED_BYTE, false);\n          this.idBuffer.bind();\n          attributes.pickId.pointer(gl.UNSIGNED_BYTE, false);\n          gl.drawArrays(gl.TRIANGLES, 0, numVertices);\n          return pickOffset + this.shape[0] * this.shape[1];\n        };\n      }();\n\n      proto.pick = function (x, y, value) {\n        var pickOffset = this.pickOffset;\n        var pointCount = this.shape[0] * this.shape[1];\n\n        if (value < pickOffset || value >= pickOffset + pointCount) {\n          return null;\n        }\n\n        var pointId = value - pickOffset;\n        var xData = this.xData;\n        var yData = this.yData;\n        return {\n          object: this,\n          pointId: pointId,\n          dataCoord: [xData[pointId % this.shape[0]], yData[pointId / this.shape[0] | 0]]\n        };\n      };\n\n      proto.update = function (options) {\n        options = options || {};\n        var shape = options.shape || [0, 0];\n        var x = options.x || iota(shape[0]);\n        var y = options.y || iota(shape[1]);\n        var z = options.z || new Float32Array(shape[0] * shape[1]);\n        var isSmooth = options.zsmooth !== false;\n        this.xData = x;\n        this.yData = y;\n        var colorLevels = options.colorLevels || [0];\n        var colorValues = options.colorValues || [0, 0, 0, 1];\n        var colorCount = colorLevels.length;\n        var bounds = this.bounds;\n        var lox, loy, hix, hiy;\n\n        if (isSmooth) {\n          lox = bounds[0] = x[0];\n          loy = bounds[1] = y[0];\n          hix = bounds[2] = x[x.length - 1];\n          hiy = bounds[3] = y[y.length - 1];\n        } else {\n          // To get squares to centre on data values\n          lox = bounds[0] = x[0] + (x[1] - x[0]) / 2; // starting x value\n\n          loy = bounds[1] = y[0] + (y[1] - y[0]) / 2; // starting y value\n          // Bounds needs to add half a square on each end\n\n          hix = bounds[2] = x[x.length - 1] + (x[x.length - 1] - x[x.length - 2]) / 2;\n          hiy = bounds[3] = y[y.length - 1] + (y[y.length - 1] - y[y.length - 2]) / 2; // N.B. Resolution = 1 / range\n        }\n\n        var xs = 1.0 / (hix - lox);\n        var ys = 1.0 / (hiy - loy);\n        var numX = shape[0];\n        var numY = shape[1];\n        this.shape = [numX, numY];\n        var numVerts = (isSmooth ? (numX - 1) * (numY - 1) : numX * numY) * (WEIGHTS.length >>> 1);\n        this.numVertices = numVerts;\n        var colors = pool.mallocUint8(numVerts * 4);\n        var positions = pool.mallocFloat32(numVerts * 2);\n        var weights = pool.mallocUint8(numVerts * 2);\n        var ids = pool.mallocUint32(numVerts);\n        var ptr = 0;\n        var ni = isSmooth ? numX - 1 : numX;\n        var nj = isSmooth ? numY - 1 : numY;\n\n        for (var j = 0; j < nj; ++j) {\n          var yc0, yc1;\n\n          if (isSmooth) {\n            yc0 = ys * (y[j] - loy);\n            yc1 = ys * (y[j + 1] - loy);\n          } else {\n            yc0 = j < numY - 1 ? ys * (y[j] - (y[j + 1] - y[j]) / 2 - loy) : ys * (y[j] - (y[j] - y[j - 1]) / 2 - loy);\n            yc1 = j < numY - 1 ? ys * (y[j] + (y[j + 1] - y[j]) / 2 - loy) : ys * (y[j] + (y[j] - y[j - 1]) / 2 - loy);\n          }\n\n          for (var i = 0; i < ni; ++i) {\n            var xc0, xc1;\n\n            if (isSmooth) {\n              xc0 = xs * (x[i] - lox);\n              xc1 = xs * (x[i + 1] - lox);\n            } else {\n              xc0 = i < numX - 1 ? xs * (x[i] - (x[i + 1] - x[i]) / 2 - lox) : xs * (x[i] - (x[i] - x[i - 1]) / 2 - lox);\n              xc1 = i < numX - 1 ? xs * (x[i] + (x[i + 1] - x[i]) / 2 - lox) : xs * (x[i] + (x[i] - x[i - 1]) / 2 - lox);\n            }\n\n            for (var dd = 0; dd < WEIGHTS.length; dd += 2) {\n              var dx = WEIGHTS[dd];\n              var dy = WEIGHTS[dd + 1];\n              var offset = isSmooth ? (j + dy) * numX + (i + dx) : j * numX + i;\n              var zc = z[offset];\n              var colorIdx = bsearch.le(colorLevels, zc);\n              var r, g, b, a;\n\n              if (colorIdx < 0) {\n                r = colorValues[0];\n                g = colorValues[1];\n                b = colorValues[2];\n                a = colorValues[3];\n              } else if (colorIdx === colorCount - 1) {\n                r = colorValues[4 * colorCount - 4];\n                g = colorValues[4 * colorCount - 3];\n                b = colorValues[4 * colorCount - 2];\n                a = colorValues[4 * colorCount - 1];\n              } else {\n                var t = (zc - colorLevels[colorIdx]) / (colorLevels[colorIdx + 1] - colorLevels[colorIdx]);\n                var ti = 1.0 - t;\n                var i0 = 4 * colorIdx;\n                var i1 = 4 * (colorIdx + 1);\n                r = ti * colorValues[i0] + t * colorValues[i1];\n                g = ti * colorValues[i0 + 1] + t * colorValues[i1 + 1];\n                b = ti * colorValues[i0 + 2] + t * colorValues[i1 + 2];\n                a = ti * colorValues[i0 + 3] + t * colorValues[i1 + 3];\n              }\n\n              colors[4 * ptr] = 255 * r;\n              colors[4 * ptr + 1] = 255 * g;\n              colors[4 * ptr + 2] = 255 * b;\n              colors[4 * ptr + 3] = 255 * a;\n              positions[2 * ptr] = xc0 * .5 + xc1 * .5;\n              positions[2 * ptr + 1] = yc0 * .5 + yc1 * .5;\n              weights[2 * ptr] = dx;\n              weights[2 * ptr + 1] = dy;\n              ids[ptr] = j * numX + i;\n              ptr += 1;\n            }\n          }\n        }\n\n        this.positionBuffer.update(positions);\n        this.weightBuffer.update(weights);\n        this.colorBuffer.update(colors);\n        this.idBuffer.update(ids);\n        pool.free(positions);\n        pool.free(colors);\n        pool.free(weights);\n        pool.free(ids);\n      };\n\n      proto.dispose = function () {\n        this.shader.dispose();\n        this.pickShader.dispose();\n        this.positionBuffer.dispose();\n        this.weightBuffer.dispose();\n        this.colorBuffer.dispose();\n        this.idBuffer.dispose();\n        this.plot.removeObject(this);\n      };\n\n      function createHeatmap2D(plot, options) {\n        var gl = plot.gl;\n        var shader = createShader(gl, shaders.vertex, shaders.fragment);\n        var pickShader = createShader(gl, shaders.pickVertex, shaders.pickFragment);\n        var positionBuffer = createBuffer(gl);\n        var weightBuffer = createBuffer(gl);\n        var colorBuffer = createBuffer(gl);\n        var idBuffer = createBuffer(gl);\n        var heatmap = new GLHeatmap2D(plot, shader, pickShader, positionBuffer, weightBuffer, colorBuffer, idBuffer);\n        heatmap.update(options);\n        plot.addObject(heatmap);\n        return heatmap;\n      }\n    }, {\n      \"./lib/shaders\": 89,\n      \"binary-search-bounds\": 31,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132,\n      \"iota-array\": 235,\n      \"typedarray-pool\": 308\n    }],\n    89: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      module.exports = {\n        fragment: glslify([\"precision lowp float;\\n#define GLSLIFY 1\\nvarying vec4 fragColor;\\nvoid main() {\\n  gl_FragColor = vec4(fragColor.rgb * fragColor.a, fragColor.a);\\n}\\n\"]),\n        vertex: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nattribute vec4 color;\\nattribute vec2 weight;\\n\\nuniform vec2 shape;\\nuniform mat3 viewTransform;\\n\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n  vec3 vPosition = viewTransform * vec3( position + (weight-.5)/(shape-1.) , 1.0);\\n  fragColor = color;\\n  gl_Position = vec4(vPosition.xy, 0, vPosition.z);\\n}\\n\"]),\n        pickFragment: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragId;\\nvarying vec2 vWeight;\\n\\nuniform vec2 shape;\\nuniform vec4 pickOffset;\\n\\nvoid main() {\\n  vec2 d = step(.5, vWeight);\\n  vec4 id = fragId + pickOffset;\\n  id.x += d.x + d.y*shape.x;\\n\\n  id.y += floor(id.x / 256.0);\\n  id.x -= floor(id.x / 256.0) * 256.0;\\n\\n  id.z += floor(id.y / 256.0);\\n  id.y -= floor(id.y / 256.0) * 256.0;\\n\\n  id.w += floor(id.z / 256.0);\\n  id.z -= floor(id.z / 256.0) * 256.0;\\n\\n  gl_FragColor = id/255.;\\n}\\n\"]),\n        pickVertex: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nattribute vec4 pickId;\\nattribute vec2 weight;\\n\\nuniform vec2 shape;\\nuniform mat3 viewTransform;\\n\\nvarying vec4 fragId;\\nvarying vec2 vWeight;\\n\\nvoid main() {\\n  vWeight = weight;\\n\\n  fragId = pickId;\\n\\n  vec3 vPosition = viewTransform * vec3( position + (weight-.5)/(shape-1.) , 1.0);\\n  gl_Position = vec4(vPosition.xy, 0, vPosition.z);\\n}\\n\"])\n      };\n    }, {\n      \"glslify\": 231\n    }],\n    90: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      var createShader = _glvis_('gl-shader');\n\n      var vertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position, nextPosition;\\nattribute float arcLength, lineWidth;\\nattribute vec4 color;\\n\\nuniform vec2 screenShape;\\nuniform float pixelRatio;\\nuniform mat4 model, view, projection;\\n\\nvarying vec4 fragColor;\\nvarying vec3 worldPosition;\\nvarying float pixelArcLength;\\n\\nvec4 project(vec3 p) {\\n  return projection * view * model * vec4(p, 1.0);\\n}\\n\\nvoid main() {\\n  vec4 startPoint = project(position);\\n  vec4 endPoint   = project(nextPosition);\\n\\n  vec2 A = startPoint.xy / startPoint.w;\\n  vec2 B =   endPoint.xy /   endPoint.w;\\n\\n  float clipAngle = atan(\\n    (B.y - A.y) * screenShape.y,\\n    (B.x - A.x) * screenShape.x\\n  );\\n\\n  vec2 offset = 0.5 * pixelRatio * lineWidth * vec2(\\n    sin(clipAngle),\\n    -cos(clipAngle)\\n  ) / screenShape;\\n\\n  gl_Position = vec4(startPoint.xy + startPoint.w * offset, startPoint.zw);\\n\\n  worldPosition = position;\\n  pixelArcLength = arcLength;\\n  fragColor = color;\\n}\\n\"]);\n      var forwardFrag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3      clipBounds[2];\\nuniform sampler2D dashTexture;\\nuniform float     dashScale;\\nuniform float     opacity;\\n\\nvarying vec3    worldPosition;\\nvarying float   pixelArcLength;\\nvarying vec4    fragColor;\\n\\nvoid main() {\\n  if (\\n    outOfRange(clipBounds[0], clipBounds[1], worldPosition) ||\\n    fragColor.a * opacity == 0.\\n  ) discard;\\n\\n  float dashWeight = texture2D(dashTexture, vec2(dashScale * pixelArcLength, 0)).r;\\n  if(dashWeight < 0.5) {\\n    discard;\\n  }\\n  gl_FragColor = fragColor * opacity;\\n}\\n\"]);\n      var pickFrag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\n#define FLOAT_MAX  1.70141184e38\\n#define FLOAT_MIN  1.17549435e-38\\n\\n// https://github.com/mikolalysenko/glsl-read-float/blob/master/index.glsl\\nvec4 packFloat(float v) {\\n  float av = abs(v);\\n\\n  //Handle special cases\\n  if(av < FLOAT_MIN) {\\n    return vec4(0.0, 0.0, 0.0, 0.0);\\n  } else if(v > FLOAT_MAX) {\\n    return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;\\n  } else if(v < -FLOAT_MAX) {\\n    return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;\\n  }\\n\\n  vec4 c = vec4(0,0,0,0);\\n\\n  //Compute exponent and mantissa\\n  float e = floor(log2(av));\\n  float m = av * pow(2.0, -e) - 1.0;\\n\\n  //Unpack mantissa\\n  c[1] = floor(128.0 * m);\\n  m -= c[1] / 128.0;\\n  c[2] = floor(32768.0 * m);\\n  m -= c[2] / 32768.0;\\n  c[3] = floor(8388608.0 * m);\\n\\n  //Unpack exponent\\n  float ebias = e + 127.0;\\n  c[0] = floor(ebias / 2.0);\\n  ebias -= c[0] * 2.0;\\n  c[1] += floor(ebias) * 128.0;\\n\\n  //Unpack sign bit\\n  c[0] += 128.0 * step(0.0, -v);\\n\\n  //Scale back to range\\n  return c / 255.0;\\n}\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform float pickId;\\nuniform vec3 clipBounds[2];\\n\\nvarying vec3 worldPosition;\\nvarying float pixelArcLength;\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], worldPosition)) discard;\\n\\n  gl_FragColor = vec4(pickId/255.0, packFloat(pixelArcLength).xyz);\\n}\"]);\n      var ATTRIBUTES = [{\n        name: 'position',\n        type: 'vec3'\n      }, {\n        name: 'nextPosition',\n        type: 'vec3'\n      }, {\n        name: 'arcLength',\n        type: 'float'\n      }, {\n        name: 'lineWidth',\n        type: 'float'\n      }, {\n        name: 'color',\n        type: 'vec4'\n      }];\n\n      exports.createShader = function (gl) {\n        return createShader(gl, vertSrc, forwardFrag, null, ATTRIBUTES);\n      };\n\n      exports.createPickShader = function (gl) {\n        return createShader(gl, vertSrc, pickFrag, null, ATTRIBUTES);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    91: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createLinePlot;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createTexture = _glvis_('gl-texture2d');\n\n      var UINT8_VIEW = new Uint8Array(4);\n      var FLOAT_VIEW = new Float32Array(UINT8_VIEW.buffer); // https://github.com/mikolalysenko/glsl-read-float/blob/master/index.js\n\n      function unpackFloat(x, y, z, w) {\n        UINT8_VIEW[0] = w;\n        UINT8_VIEW[1] = z;\n        UINT8_VIEW[2] = y;\n        UINT8_VIEW[3] = x;\n        return FLOAT_VIEW[0];\n      }\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var ndarray = _glvis_('ndarray');\n\n      var shaders = _glvis_('./lib/shaders');\n\n      var createShader = shaders.createShader;\n      var createPickShader = shaders.createPickShader;\n      var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n      function distance(a, b) {\n        var s = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          var d = a[i] - b[i];\n          s += d * d;\n        }\n\n        return Math.sqrt(s);\n      }\n\n      function filterClipBounds(bounds) {\n        var result = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n        for (var i = 0; i < 3; ++i) {\n          result[0][i] = Math.max(bounds[0][i], result[0][i]);\n          result[1][i] = Math.min(bounds[1][i], result[1][i]);\n        }\n\n        return result;\n      }\n\n      function PickResult(tau, position, index, dataCoordinate) {\n        this.arcLength = tau;\n        this.position = position;\n        this.index = index;\n        this.dataCoordinate = dataCoordinate;\n      }\n\n      function LinePlot(gl, shader, pickShader, buffer, vao, texture) {\n        this.gl = gl;\n        this.shader = shader;\n        this.pickShader = pickShader;\n        this.buffer = buffer;\n        this.vao = vao;\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.points = [];\n        this.arcLength = [];\n        this.vertexCount = 0;\n        this.bounds = [[0, 0, 0], [0, 0, 0]];\n        this.pickId = 0;\n        this.lineWidth = 1;\n        this.texture = texture;\n        this.dashScale = 1;\n        this.opacity = 1;\n        this.hasAlpha = false;\n        this.dirty = true;\n        this.pixelRatio = 1;\n      }\n\n      var proto = LinePlot.prototype;\n\n      proto.isTransparent = function () {\n        return this.hasAlpha;\n      };\n\n      proto.isOpaque = function () {\n        return !this.hasAlpha;\n      };\n\n      proto.pickSlots = 1;\n\n      proto.setPickBase = function (id) {\n        this.pickId = id;\n      };\n\n      proto.drawTransparent = proto.draw = function (camera) {\n        if (!this.vertexCount) return;\n        var gl = this.gl;\n        var shader = this.shader;\n        var vao = this.vao;\n        shader.bind();\n        shader.uniforms = {\n          model: camera.model || identity,\n          view: camera.view || identity,\n          projection: camera.projection || identity,\n          clipBounds: filterClipBounds(this.clipBounds),\n          dashTexture: this.texture.bind(),\n          dashScale: this.dashScale / this.arcLength[this.arcLength.length - 1],\n          opacity: this.opacity,\n          screenShape: [gl.drawingBufferWidth, gl.drawingBufferHeight],\n          pixelRatio: this.pixelRatio\n        };\n        vao.bind();\n        vao.draw(gl.TRIANGLE_STRIP, this.vertexCount);\n        vao.unbind();\n      };\n\n      proto.drawPick = function (camera) {\n        if (!this.vertexCount) return;\n        var gl = this.gl;\n        var shader = this.pickShader;\n        var vao = this.vao;\n        shader.bind();\n        shader.uniforms = {\n          model: camera.model || identity,\n          view: camera.view || identity,\n          projection: camera.projection || identity,\n          pickId: this.pickId,\n          clipBounds: filterClipBounds(this.clipBounds),\n          screenShape: [gl.drawingBufferWidth, gl.drawingBufferHeight],\n          pixelRatio: this.pixelRatio\n        };\n        vao.bind();\n        vao.draw(gl.TRIANGLE_STRIP, this.vertexCount);\n        vao.unbind();\n      };\n\n      proto.update = function (options) {\n        var i, j;\n        this.dirty = true;\n        var connectGaps = !!options.connectGaps;\n\n        if ('dashScale' in options) {\n          this.dashScale = options.dashScale;\n        }\n\n        this.hasAlpha = false; // default to no transparent draw\n\n        if ('opacity' in options) {\n          this.opacity = +options.opacity;\n\n          if (this.opacity < 1) {\n            this.hasAlpha = true;\n          }\n        } // Recalculate buffer data\n\n\n        var buffer = [];\n        var arcLengthArray = [];\n        var pointArray = [];\n        var arcLength = 0.0;\n        var vertexCount = 0;\n        var bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        var positions = options.position || options.positions;\n\n        if (positions) {\n          // Default color\n          var colors = options.color || options.colors || [0, 0, 0, 1];\n          var lineWidth = options.lineWidth || 1;\n          var hadGap = false;\n\n          fill_loop: for (i = 1; i < positions.length; ++i) {\n            var a = positions[i - 1];\n            var b = positions[i];\n            arcLengthArray.push(arcLength);\n            pointArray.push(a.slice());\n\n            for (j = 0; j < 3; ++j) {\n              if (isNaN(a[j]) || isNaN(b[j]) || !isFinite(a[j]) || !isFinite(b[j])) {\n                if (!connectGaps && buffer.length > 0) {\n                  for (var k = 0; k < 24; ++k) {\n                    buffer.push(buffer[buffer.length - 12]);\n                  }\n\n                  vertexCount += 2;\n                  hadGap = true;\n                }\n\n                continue fill_loop;\n              }\n\n              bounds[0][j] = Math.min(bounds[0][j], a[j], b[j]);\n              bounds[1][j] = Math.max(bounds[1][j], a[j], b[j]);\n            }\n\n            var acolor, bcolor;\n\n            if (Array.isArray(colors[0])) {\n              acolor = colors.length > i - 1 ? colors[i - 1] : // using index value\n              colors.length > 0 ? colors[colors.length - 1] : // using last item\n              [0, 0, 0, 1]; // using black\n\n              bcolor = colors.length > i ? colors[i] : // using index value\n              colors.length > 0 ? colors[colors.length - 1] : // using last item\n              [0, 0, 0, 1]; // using black\n            } else {\n              acolor = bcolor = colors;\n            }\n\n            if (acolor.length === 3) {\n              acolor = [acolor[0], acolor[1], acolor[2], 1];\n            }\n\n            if (bcolor.length === 3) {\n              bcolor = [bcolor[0], bcolor[1], bcolor[2], 1];\n            }\n\n            if (!this.hasAlpha && acolor[3] < 1) this.hasAlpha = true;\n            var w0;\n\n            if (Array.isArray(lineWidth)) {\n              w0 = lineWidth.length > i - 1 ? lineWidth[i - 1] : // using index value\n              lineWidth.length > 0 ? lineWidth[lineWidth.length - 1] : // using last item\n              [0, 0, 0, 1]; // using black\n            } else {\n              w0 = lineWidth;\n            }\n\n            var t0 = arcLength;\n            arcLength += distance(a, b);\n\n            if (hadGap) {\n              for (j = 0; j < 2; ++j) {\n                buffer.push(a[0], a[1], a[2], b[0], b[1], b[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3]);\n              }\n\n              vertexCount += 2;\n              hadGap = false;\n            }\n\n            buffer.push(a[0], a[1], a[2], b[0], b[1], b[2], t0, w0, acolor[0], acolor[1], acolor[2], acolor[3], a[0], a[1], a[2], b[0], b[1], b[2], t0, -w0, acolor[0], acolor[1], acolor[2], acolor[3], b[0], b[1], b[2], a[0], a[1], a[2], arcLength, -w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3], b[0], b[1], b[2], a[0], a[1], a[2], arcLength, w0, bcolor[0], bcolor[1], bcolor[2], bcolor[3]);\n            vertexCount += 4;\n          }\n        }\n\n        this.buffer.update(buffer);\n        arcLengthArray.push(arcLength);\n        pointArray.push(positions[positions.length - 1].slice());\n        this.bounds = bounds;\n        this.vertexCount = vertexCount;\n        this.points = pointArray;\n        this.arcLength = arcLengthArray;\n\n        if ('dashes' in options) {\n          var dashArray = options.dashes; // Calculate prefix sum\n\n          var prefixSum = dashArray.slice();\n          prefixSum.unshift(0);\n\n          for (i = 1; i < prefixSum.length; ++i) {\n            prefixSum[i] = prefixSum[i - 1] + prefixSum[i];\n          }\n\n          var dashTexture = ndarray(new Array(256 * 4), [256, 1, 4]);\n\n          for (i = 0; i < 256; ++i) {\n            for (j = 0; j < 4; ++j) {\n              dashTexture.set(i, 0, j, 0);\n            }\n\n            if (bsearch.le(prefixSum, prefixSum[prefixSum.length - 1] * i / 255.0) & 1) {\n              dashTexture.set(i, 0, 0, 0);\n            } else {\n              dashTexture.set(i, 0, 0, 255);\n            }\n          }\n\n          this.texture.setPixels(dashTexture);\n        }\n      };\n\n      proto.dispose = function () {\n        this.shader.dispose();\n        this.vao.dispose();\n        this.buffer.dispose();\n      };\n\n      proto.pick = function (selection) {\n        if (!selection) {\n          return null;\n        }\n\n        if (selection.id !== this.pickId) {\n          return null;\n        }\n\n        var tau = unpackFloat(selection.value[0], selection.value[1], selection.value[2], 0);\n        var index = bsearch.le(this.arcLength, tau);\n\n        if (index < 0) {\n          return null;\n        }\n\n        if (index === this.arcLength.length - 1) {\n          return new PickResult(this.arcLength[this.arcLength.length - 1], this.points[this.points.length - 1].slice(), index);\n        }\n\n        var a = this.points[index];\n        var b = this.points[Math.min(index + 1, this.points.length - 1)];\n        var t = (tau - this.arcLength[index]) / (this.arcLength[index + 1] - this.arcLength[index]);\n        var ti = 1.0 - t;\n        var x = [0, 0, 0];\n\n        for (var i = 0; i < 3; ++i) {\n          x[i] = ti * a[i] + t * b[i];\n        }\n\n        var dataIndex = Math.min(t < 0.5 ? index : index + 1, this.points.length - 1);\n        return new PickResult(tau, x, dataIndex, this.points[dataIndex]);\n      };\n\n      function createLinePlot(options) {\n        var gl = options.gl || options.scene && options.scene.gl;\n        var shader = createShader(gl);\n        shader.attributes.position.location = 0;\n        shader.attributes.nextPosition.location = 1;\n        shader.attributes.arcLength.location = 2;\n        shader.attributes.lineWidth.location = 3;\n        shader.attributes.color.location = 4;\n        var pickShader = createPickShader(gl);\n        pickShader.attributes.position.location = 0;\n        pickShader.attributes.nextPosition.location = 1;\n        pickShader.attributes.arcLength.location = 2;\n        pickShader.attributes.lineWidth.location = 3;\n        pickShader.attributes.color.location = 4;\n        var buffer = createBuffer(gl);\n        var vao = createVAO(gl, [{\n          'buffer': buffer,\n          'size': 3,\n          'offset': 0,\n          'stride': 48\n        }, {\n          'buffer': buffer,\n          'size': 3,\n          'offset': 12,\n          'stride': 48\n        }, {\n          'buffer': buffer,\n          'size': 1,\n          'offset': 24,\n          'stride': 48\n        }, {\n          'buffer': buffer,\n          'size': 1,\n          'offset': 28,\n          'stride': 48\n        }, {\n          'buffer': buffer,\n          'size': 4,\n          'offset': 32,\n          'stride': 48\n        }]); // Create texture for dash pattern\n\n        var defaultTexture = ndarray(new Array(256 * 4), [256, 1, 4]);\n\n        for (var i = 0; i < 256 * 4; ++i) {\n          defaultTexture.data[i] = 255;\n        }\n\n        var texture = createTexture(gl, defaultTexture);\n        texture.wrap = gl.REPEAT;\n        var linePlot = new LinePlot(gl, shader, pickShader, buffer, vao, texture);\n        linePlot.update(options);\n        return linePlot;\n      }\n    }, {\n      \"./lib/shaders\": 90,\n      \"binary-search-bounds\": 31,\n      \"gl-buffer\": 78,\n      \"gl-texture2d\": 146,\n      \"gl-vao\": 150,\n      \"ndarray\": 259\n    }],\n    92: [function (_glvis_, module, exports) {\n      module.exports = clone;\n      /**\n       * Creates a new mat4 initialized with values from an existing matrix\n       *\n       * @param {mat4} a matrix to clone\n       * @returns {mat4} a new 4x4 matrix\n       */\n\n      function clone(a) {\n        var out = new Float32Array(16);\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n        return out;\n      }\n\n      ;\n    }, {}],\n    93: [function (_glvis_, module, exports) {\n      module.exports = create;\n      /**\n       * Creates a new identity mat4\n       *\n       * @returns {mat4} a new 4x4 matrix\n       */\n\n      function create() {\n        var out = new Float32Array(16);\n        out[0] = 1;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = 1;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 1;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {}],\n    94: [function (_glvis_, module, exports) {\n      module.exports = determinant;\n      /**\n       * Calculates the determinant of a mat4\n       *\n       * @param {mat4} a the source matrix\n       * @returns {Number} determinant of a\n       */\n\n      function determinant(a) {\n        var a00 = a[0],\n            a01 = a[1],\n            a02 = a[2],\n            a03 = a[3],\n            a10 = a[4],\n            a11 = a[5],\n            a12 = a[6],\n            a13 = a[7],\n            a20 = a[8],\n            a21 = a[9],\n            a22 = a[10],\n            a23 = a[11],\n            a30 = a[12],\n            a31 = a[13],\n            a32 = a[14],\n            a33 = a[15],\n            b00 = a00 * a11 - a01 * a10,\n            b01 = a00 * a12 - a02 * a10,\n            b02 = a00 * a13 - a03 * a10,\n            b03 = a01 * a12 - a02 * a11,\n            b04 = a01 * a13 - a03 * a11,\n            b05 = a02 * a13 - a03 * a12,\n            b06 = a20 * a31 - a21 * a30,\n            b07 = a20 * a32 - a22 * a30,\n            b08 = a20 * a33 - a23 * a30,\n            b09 = a21 * a32 - a22 * a31,\n            b10 = a21 * a33 - a23 * a31,\n            b11 = a22 * a33 - a23 * a32; // Calculate the determinant\n\n        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n      }\n\n      ;\n    }, {}],\n    95: [function (_glvis_, module, exports) {\n      module.exports = fromQuat;\n      /**\n       * Creates a matrix from a quaternion rotation.\n       *\n       * @param {mat4} out mat4 receiving operation result\n       * @param {quat4} q Rotation quaternion\n       * @returns {mat4} out\n       */\n\n      function fromQuat(out, q) {\n        var x = q[0],\n            y = q[1],\n            z = q[2],\n            w = q[3],\n            x2 = x + x,\n            y2 = y + y,\n            z2 = z + z,\n            xx = x * x2,\n            yx = y * x2,\n            yy = y * y2,\n            zx = z * x2,\n            zy = z * y2,\n            zz = z * z2,\n            wx = w * x2,\n            wy = w * y2,\n            wz = w * z2;\n        out[0] = 1 - yy - zz;\n        out[1] = yx + wz;\n        out[2] = zx - wy;\n        out[3] = 0;\n        out[4] = yx - wz;\n        out[5] = 1 - xx - zz;\n        out[6] = zy + wx;\n        out[7] = 0;\n        out[8] = zx + wy;\n        out[9] = zy - wx;\n        out[10] = 1 - xx - yy;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {}],\n    96: [function (_glvis_, module, exports) {\n      module.exports = fromRotationTranslation;\n      /**\n       * Creates a matrix from a quaternion rotation and vector translation\n       * This is equivalent to (but much faster than):\n       *\n       *     mat4.identity(dest);\n       *     mat4.translate(dest, vec);\n       *     var quatMat = mat4.create();\n       *     quat4.toMat4(quat, quatMat);\n       *     mat4.multiply(dest, quatMat);\n       *\n       * @param {mat4} out mat4 receiving operation result\n       * @param {quat4} q Rotation quaternion\n       * @param {vec3} v Translation vector\n       * @returns {mat4} out\n       */\n\n      function fromRotationTranslation(out, q, v) {\n        // Quaternion math\n        var x = q[0],\n            y = q[1],\n            z = q[2],\n            w = q[3],\n            x2 = x + x,\n            y2 = y + y,\n            z2 = z + z,\n            xx = x * x2,\n            xy = x * y2,\n            xz = x * z2,\n            yy = y * y2,\n            yz = y * z2,\n            zz = z * z2,\n            wx = w * x2,\n            wy = w * y2,\n            wz = w * z2;\n        out[0] = 1 - (yy + zz);\n        out[1] = xy + wz;\n        out[2] = xz - wy;\n        out[3] = 0;\n        out[4] = xy - wz;\n        out[5] = 1 - (xx + zz);\n        out[6] = yz + wx;\n        out[7] = 0;\n        out[8] = xz + wy;\n        out[9] = yz - wx;\n        out[10] = 1 - (xx + yy);\n        out[11] = 0;\n        out[12] = v[0];\n        out[13] = v[1];\n        out[14] = v[2];\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {}],\n    97: [function (_glvis_, module, exports) {\n      module.exports = identity;\n      /**\n       * Set a mat4 to the identity matrix\n       *\n       * @param {mat4} out the receiving matrix\n       * @returns {mat4} out\n       */\n\n      function identity(out) {\n        out[0] = 1;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = 1;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 1;\n        out[11] = 0;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 0;\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {}],\n    98: [function (_glvis_, module, exports) {\n      module.exports = invert;\n      /**\n       * Inverts a mat4\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the source matrix\n       * @returns {mat4} out\n       */\n\n      function invert(out, a) {\n        var a00 = a[0],\n            a01 = a[1],\n            a02 = a[2],\n            a03 = a[3],\n            a10 = a[4],\n            a11 = a[5],\n            a12 = a[6],\n            a13 = a[7],\n            a20 = a[8],\n            a21 = a[9],\n            a22 = a[10],\n            a23 = a[11],\n            a30 = a[12],\n            a31 = a[13],\n            a32 = a[14],\n            a33 = a[15],\n            b00 = a00 * a11 - a01 * a10,\n            b01 = a00 * a12 - a02 * a10,\n            b02 = a00 * a13 - a03 * a10,\n            b03 = a01 * a12 - a02 * a11,\n            b04 = a01 * a13 - a03 * a11,\n            b05 = a02 * a13 - a03 * a12,\n            b06 = a20 * a31 - a21 * a30,\n            b07 = a20 * a32 - a22 * a30,\n            b08 = a20 * a33 - a23 * a30,\n            b09 = a21 * a32 - a22 * a31,\n            b10 = a21 * a33 - a23 * a31,\n            b11 = a22 * a33 - a23 * a32,\n            // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n        if (!det) {\n          return null;\n        }\n\n        det = 1.0 / det;\n        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n        return out;\n      }\n\n      ;\n    }, {}],\n    99: [function (_glvis_, module, exports) {\n      var identity = _glvis_('./identity');\n\n      module.exports = lookAt;\n      /**\n       * Generates a look-at matrix with the given eye position, focal point, and up axis\n       *\n       * @param {mat4} out mat4 frustum matrix will be written into\n       * @param {vec3} eye Position of the viewer\n       * @param {vec3} center Point the viewer is looking at\n       * @param {vec3} up vec3 pointing up\n       * @returns {mat4} out\n       */\n\n      function lookAt(out, eye, center, up) {\n        var x0,\n            x1,\n            x2,\n            y0,\n            y1,\n            y2,\n            z0,\n            z1,\n            z2,\n            len,\n            eyex = eye[0],\n            eyey = eye[1],\n            eyez = eye[2],\n            upx = up[0],\n            upy = up[1],\n            upz = up[2],\n            centerx = center[0],\n            centery = center[1],\n            centerz = center[2];\n\n        if (Math.abs(eyex - centerx) < 0.000001 && Math.abs(eyey - centery) < 0.000001 && Math.abs(eyez - centerz) < 0.000001) {\n          return identity(out);\n        }\n\n        z0 = eyex - centerx;\n        z1 = eyey - centery;\n        z2 = eyez - centerz;\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n\n        if (!len) {\n          x0 = 0;\n          x1 = 0;\n          x2 = 0;\n        } else {\n          len = 1 / len;\n          x0 *= len;\n          x1 *= len;\n          x2 *= len;\n        }\n\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n\n        if (!len) {\n          y0 = 0;\n          y1 = 0;\n          y2 = 0;\n        } else {\n          len = 1 / len;\n          y0 *= len;\n          y1 *= len;\n          y2 *= len;\n        }\n\n        out[0] = x0;\n        out[1] = y0;\n        out[2] = z0;\n        out[3] = 0;\n        out[4] = x1;\n        out[5] = y1;\n        out[6] = z1;\n        out[7] = 0;\n        out[8] = x2;\n        out[9] = y2;\n        out[10] = z2;\n        out[11] = 0;\n        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {\n      \"./identity\": 97\n    }],\n    100: [function (_glvis_, module, exports) {\n      module.exports = multiply;\n      /**\n       * Multiplies two mat4's\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the first operand\n       * @param {mat4} b the second operand\n       * @returns {mat4} out\n       */\n\n      function multiply(out, a, b) {\n        var a00 = a[0],\n            a01 = a[1],\n            a02 = a[2],\n            a03 = a[3],\n            a10 = a[4],\n            a11 = a[5],\n            a12 = a[6],\n            a13 = a[7],\n            a20 = a[8],\n            a21 = a[9],\n            a22 = a[10],\n            a23 = a[11],\n            a30 = a[12],\n            a31 = a[13],\n            a32 = a[14],\n            a33 = a[15]; // Cache only the current line of the second matrix\n\n        var b0 = b[0],\n            b1 = b[1],\n            b2 = b[2],\n            b3 = b[3];\n        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[4];\n        b1 = b[5];\n        b2 = b[6];\n        b3 = b[7];\n        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[8];\n        b1 = b[9];\n        b2 = b[10];\n        b3 = b[11];\n        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        b0 = b[12];\n        b1 = b[13];\n        b2 = b[14];\n        b3 = b[15];\n        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n        return out;\n      }\n\n      ;\n    }, {}],\n    101: [function (_glvis_, module, exports) {\n      module.exports = ortho;\n      /**\n       * Generates a orthogonal projection matrix with the given bounds\n       *\n       * @param {mat4} out mat4 frustum matrix will be written into\n       * @param {number} left Left bound of the frustum\n       * @param {number} right Right bound of the frustum\n       * @param {number} bottom Bottom bound of the frustum\n       * @param {number} top Top bound of the frustum\n       * @param {number} near Near bound of the frustum\n       * @param {number} far Far bound of the frustum\n       * @returns {mat4} out\n       */\n\n      function ortho(out, left, right, bottom, top, near, far) {\n        var lr = 1 / (left - right),\n            bt = 1 / (bottom - top),\n            nf = 1 / (near - far);\n        out[0] = -2 * lr;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = -2 * bt;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = 2 * nf;\n        out[11] = 0;\n        out[12] = (left + right) * lr;\n        out[13] = (top + bottom) * bt;\n        out[14] = (far + near) * nf;\n        out[15] = 1;\n        return out;\n      }\n\n      ;\n    }, {}],\n    102: [function (_glvis_, module, exports) {\n      module.exports = perspective;\n      /**\n       * Generates a perspective projection matrix with the given bounds\n       *\n       * @param {mat4} out mat4 frustum matrix will be written into\n       * @param {number} fovy Vertical field of view in radians\n       * @param {number} aspect Aspect ratio. typically viewport width/height\n       * @param {number} near Near bound of the frustum\n       * @param {number} far Far bound of the frustum\n       * @returns {mat4} out\n       */\n\n      function perspective(out, fovy, aspect, near, far) {\n        var f = 1.0 / Math.tan(fovy / 2),\n            nf = 1 / (near - far);\n        out[0] = f / aspect;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[4] = 0;\n        out[5] = f;\n        out[6] = 0;\n        out[7] = 0;\n        out[8] = 0;\n        out[9] = 0;\n        out[10] = (far + near) * nf;\n        out[11] = -1;\n        out[12] = 0;\n        out[13] = 0;\n        out[14] = 2 * far * near * nf;\n        out[15] = 0;\n        return out;\n      }\n\n      ;\n    }, {}],\n    103: [function (_glvis_, module, exports) {\n      module.exports = rotate;\n      /**\n       * Rotates a mat4 by the given angle\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to rotate\n       * @param {Number} rad the angle to rotate the matrix by\n       * @param {vec3} axis the axis to rotate around\n       * @returns {mat4} out\n       */\n\n      function rotate(out, a, rad, axis) {\n        var x = axis[0],\n            y = axis[1],\n            z = axis[2],\n            len = Math.sqrt(x * x + y * y + z * z),\n            s,\n            c,\n            t,\n            a00,\n            a01,\n            a02,\n            a03,\n            a10,\n            a11,\n            a12,\n            a13,\n            a20,\n            a21,\n            a22,\n            a23,\n            b00,\n            b01,\n            b02,\n            b10,\n            b11,\n            b12,\n            b20,\n            b21,\n            b22;\n\n        if (Math.abs(len) < 0.000001) {\n          return null;\n        }\n\n        len = 1 / len;\n        x *= len;\n        y *= len;\n        z *= len;\n        s = Math.sin(rad);\n        c = Math.cos(rad);\n        t = 1 - c;\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11]; // Construct the elements of the rotation matrix\n\n        b00 = x * x * t + c;\n        b01 = y * x * t + z * s;\n        b02 = z * x * t - y * s;\n        b10 = x * y * t - z * s;\n        b11 = y * y * t + c;\n        b12 = z * y * t + x * s;\n        b20 = x * z * t + y * s;\n        b21 = y * z * t - x * s;\n        b22 = z * z * t + c; // Perform rotation-specific matrix multiplication\n\n        out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n        out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n        out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n        out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n        out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n        out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n        out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n        out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n        out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n        out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n        out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n        out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n        if (a !== out) {\n          // If the source and destination differ, copy the unchanged last row\n          out[12] = a[12];\n          out[13] = a[13];\n          out[14] = a[14];\n          out[15] = a[15];\n        }\n\n        return out;\n      }\n\n      ;\n    }, {}],\n    104: [function (_glvis_, module, exports) {\n      module.exports = rotateX;\n      /**\n       * Rotates a matrix by the given angle around the X axis\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to rotate\n       * @param {Number} rad the angle to rotate the matrix by\n       * @returns {mat4} out\n       */\n\n      function rotateX(out, a, rad) {\n        var s = Math.sin(rad),\n            c = Math.cos(rad),\n            a10 = a[4],\n            a11 = a[5],\n            a12 = a[6],\n            a13 = a[7],\n            a20 = a[8],\n            a21 = a[9],\n            a22 = a[10],\n            a23 = a[11];\n\n        if (a !== out) {\n          // If the source and destination differ, copy the unchanged rows\n          out[0] = a[0];\n          out[1] = a[1];\n          out[2] = a[2];\n          out[3] = a[3];\n          out[12] = a[12];\n          out[13] = a[13];\n          out[14] = a[14];\n          out[15] = a[15];\n        } // Perform axis-specific matrix multiplication\n\n\n        out[4] = a10 * c + a20 * s;\n        out[5] = a11 * c + a21 * s;\n        out[6] = a12 * c + a22 * s;\n        out[7] = a13 * c + a23 * s;\n        out[8] = a20 * c - a10 * s;\n        out[9] = a21 * c - a11 * s;\n        out[10] = a22 * c - a12 * s;\n        out[11] = a23 * c - a13 * s;\n        return out;\n      }\n\n      ;\n    }, {}],\n    105: [function (_glvis_, module, exports) {\n      module.exports = rotateY;\n      /**\n       * Rotates a matrix by the given angle around the Y axis\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to rotate\n       * @param {Number} rad the angle to rotate the matrix by\n       * @returns {mat4} out\n       */\n\n      function rotateY(out, a, rad) {\n        var s = Math.sin(rad),\n            c = Math.cos(rad),\n            a00 = a[0],\n            a01 = a[1],\n            a02 = a[2],\n            a03 = a[3],\n            a20 = a[8],\n            a21 = a[9],\n            a22 = a[10],\n            a23 = a[11];\n\n        if (a !== out) {\n          // If the source and destination differ, copy the unchanged rows\n          out[4] = a[4];\n          out[5] = a[5];\n          out[6] = a[6];\n          out[7] = a[7];\n          out[12] = a[12];\n          out[13] = a[13];\n          out[14] = a[14];\n          out[15] = a[15];\n        } // Perform axis-specific matrix multiplication\n\n\n        out[0] = a00 * c - a20 * s;\n        out[1] = a01 * c - a21 * s;\n        out[2] = a02 * c - a22 * s;\n        out[3] = a03 * c - a23 * s;\n        out[8] = a00 * s + a20 * c;\n        out[9] = a01 * s + a21 * c;\n        out[10] = a02 * s + a22 * c;\n        out[11] = a03 * s + a23 * c;\n        return out;\n      }\n\n      ;\n    }, {}],\n    106: [function (_glvis_, module, exports) {\n      module.exports = rotateZ;\n      /**\n       * Rotates a matrix by the given angle around the Z axis\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to rotate\n       * @param {Number} rad the angle to rotate the matrix by\n       * @returns {mat4} out\n       */\n\n      function rotateZ(out, a, rad) {\n        var s = Math.sin(rad),\n            c = Math.cos(rad),\n            a00 = a[0],\n            a01 = a[1],\n            a02 = a[2],\n            a03 = a[3],\n            a10 = a[4],\n            a11 = a[5],\n            a12 = a[6],\n            a13 = a[7];\n\n        if (a !== out) {\n          // If the source and destination differ, copy the unchanged last row\n          out[8] = a[8];\n          out[9] = a[9];\n          out[10] = a[10];\n          out[11] = a[11];\n          out[12] = a[12];\n          out[13] = a[13];\n          out[14] = a[14];\n          out[15] = a[15];\n        } // Perform axis-specific matrix multiplication\n\n\n        out[0] = a00 * c + a10 * s;\n        out[1] = a01 * c + a11 * s;\n        out[2] = a02 * c + a12 * s;\n        out[3] = a03 * c + a13 * s;\n        out[4] = a10 * c - a00 * s;\n        out[5] = a11 * c - a01 * s;\n        out[6] = a12 * c - a02 * s;\n        out[7] = a13 * c - a03 * s;\n        return out;\n      }\n\n      ;\n    }, {}],\n    107: [function (_glvis_, module, exports) {\n      module.exports = scale;\n      /**\n       * Scales the mat4 by the dimensions in the given vec3\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to scale\n       * @param {vec3} v the vec3 to scale the matrix by\n       * @returns {mat4} out\n       **/\n\n      function scale(out, a, v) {\n        var x = v[0],\n            y = v[1],\n            z = v[2];\n        out[0] = a[0] * x;\n        out[1] = a[1] * x;\n        out[2] = a[2] * x;\n        out[3] = a[3] * x;\n        out[4] = a[4] * y;\n        out[5] = a[5] * y;\n        out[6] = a[6] * y;\n        out[7] = a[7] * y;\n        out[8] = a[8] * z;\n        out[9] = a[9] * z;\n        out[10] = a[10] * z;\n        out[11] = a[11] * z;\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n        return out;\n      }\n\n      ;\n    }, {}],\n    108: [function (_glvis_, module, exports) {\n      module.exports = translate;\n      /**\n       * Translate a mat4 by the given vector\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the matrix to translate\n       * @param {vec3} v vector to translate by\n       * @returns {mat4} out\n       */\n\n      function translate(out, a, v) {\n        var x = v[0],\n            y = v[1],\n            z = v[2],\n            a00,\n            a01,\n            a02,\n            a03,\n            a10,\n            a11,\n            a12,\n            a13,\n            a20,\n            a21,\n            a22,\n            a23;\n\n        if (a === out) {\n          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n        } else {\n          a00 = a[0];\n          a01 = a[1];\n          a02 = a[2];\n          a03 = a[3];\n          a10 = a[4];\n          a11 = a[5];\n          a12 = a[6];\n          a13 = a[7];\n          a20 = a[8];\n          a21 = a[9];\n          a22 = a[10];\n          a23 = a[11];\n          out[0] = a00;\n          out[1] = a01;\n          out[2] = a02;\n          out[3] = a03;\n          out[4] = a10;\n          out[5] = a11;\n          out[6] = a12;\n          out[7] = a13;\n          out[8] = a20;\n          out[9] = a21;\n          out[10] = a22;\n          out[11] = a23;\n          out[12] = a00 * x + a10 * y + a20 * z + a[12];\n          out[13] = a01 * x + a11 * y + a21 * z + a[13];\n          out[14] = a02 * x + a12 * y + a22 * z + a[14];\n          out[15] = a03 * x + a13 * y + a23 * z + a[15];\n        }\n\n        return out;\n      }\n\n      ;\n    }, {}],\n    109: [function (_glvis_, module, exports) {\n      module.exports = transpose;\n      /**\n       * Transpose the values of a mat4\n       *\n       * @param {mat4} out the receiving matrix\n       * @param {mat4} a the source matrix\n       * @returns {mat4} out\n       */\n\n      function transpose(out, a) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        if (out === a) {\n          var a01 = a[1],\n              a02 = a[2],\n              a03 = a[3],\n              a12 = a[6],\n              a13 = a[7],\n              a23 = a[11];\n          out[1] = a[4];\n          out[2] = a[8];\n          out[3] = a[12];\n          out[4] = a01;\n          out[6] = a[9];\n          out[7] = a[13];\n          out[8] = a02;\n          out[9] = a12;\n          out[11] = a[14];\n          out[12] = a03;\n          out[13] = a13;\n          out[14] = a23;\n        } else {\n          out[0] = a[0];\n          out[1] = a[4];\n          out[2] = a[8];\n          out[3] = a[12];\n          out[4] = a[1];\n          out[5] = a[5];\n          out[6] = a[9];\n          out[7] = a[13];\n          out[8] = a[2];\n          out[9] = a[6];\n          out[10] = a[10];\n          out[11] = a[14];\n          out[12] = a[3];\n          out[13] = a[7];\n          out[14] = a[11];\n          out[15] = a[15];\n        }\n\n        return out;\n      }\n\n      ;\n    }, {}],\n    110: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var barycentric = _glvis_('barycentric');\n\n      var closestPointToTriangle = _glvis_('polytope-closest-point/lib/closest_point_2d.js');\n\n      module.exports = closestPointToPickLocation;\n\n      function xformMatrix(m, v) {\n        var out = [0, 0, 0, 0];\n\n        for (var i = 0; i < 4; ++i) {\n          for (var j = 0; j < 4; ++j) {\n            out[j] += m[4 * i + j] * v[i];\n          }\n        }\n\n        return out;\n      }\n\n      function projectVertex(v, model, view, projection, resolution) {\n        var p = xformMatrix(projection, xformMatrix(view, xformMatrix(model, [v[0], v[1], v[2], 1])));\n\n        for (var i = 0; i < 3; ++i) {\n          p[i] /= p[3];\n        }\n\n        return [0.5 * resolution[0] * (1.0 + p[0]), 0.5 * resolution[1] * (1.0 - p[1])];\n      }\n\n      function barycentricCoord(simplex, point) {\n        if (simplex.length === 2) {\n          var d0 = 0.0;\n          var d1 = 0.0;\n\n          for (var i = 0; i < 2; ++i) {\n            d0 += Math.pow(point[i] - simplex[0][i], 2);\n            d1 += Math.pow(point[i] - simplex[1][i], 2);\n          }\n\n          d0 = Math.sqrt(d0);\n          d1 = Math.sqrt(d1);\n\n          if (d0 + d1 < 1e-6) {\n            return [1, 0];\n          }\n\n          return [d1 / (d0 + d1), d0 / (d1 + d0)];\n        } else if (simplex.length === 3) {\n          var closestPoint = [0, 0];\n          closestPointToTriangle(simplex[0], simplex[1], simplex[2], point, closestPoint);\n          return barycentric(simplex, closestPoint);\n        }\n\n        return [];\n      }\n\n      function interpolate(simplex, weights) {\n        var result = [0, 0, 0];\n\n        for (var i = 0; i < simplex.length; ++i) {\n          var p = simplex[i];\n          var w = weights[i];\n\n          for (var j = 0; j < 3; ++j) {\n            result[j] += w * p[j];\n          }\n        }\n\n        return result;\n      }\n\n      function closestPointToPickLocation(simplex, pixelCoord, model, view, projection, resolution) {\n        if (simplex.length === 1) {\n          return [0, simplex[0].slice()];\n        }\n\n        var simplex2D = new Array(simplex.length);\n\n        for (var i = 0; i < simplex.length; ++i) {\n          simplex2D[i] = projectVertex(simplex[i], model, view, projection, resolution);\n        }\n\n        var closestIndex = 0;\n        var closestDist = Infinity;\n\n        for (var i = 0; i < simplex2D.length; ++i) {\n          var d2 = 0.0;\n\n          for (var j = 0; j < 2; ++j) {\n            d2 += Math.pow(simplex2D[i][j] - pixelCoord[j], 2);\n          }\n\n          if (d2 < closestDist) {\n            closestDist = d2;\n            closestIndex = i;\n          }\n        }\n\n        var weights = barycentricCoord(simplex2D, pixelCoord);\n        var s = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          if (weights[i] < -0.001 || weights[i] > 1.0001) {\n            return null;\n          }\n\n          s += weights[i];\n        }\n\n        if (Math.abs(s - 1.0) > 0.001) {\n          return null;\n        }\n\n        return [closestIndex, interpolate(simplex, weights), weights];\n      }\n    }, {\n      \"barycentric\": 14,\n      \"polytope-closest-point/lib/closest_point_2d.js\": 270\n    }],\n    111: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      var triVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position, normal;\\nattribute vec4 color;\\nattribute vec2 uv;\\n\\nuniform mat4 model\\n           , view\\n           , projection\\n           , inverseModel;\\nuniform vec3 eyePosition\\n           , lightPosition;\\n\\nvarying vec3 f_normal\\n           , f_lightDirection\\n           , f_eyeDirection\\n           , f_data;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvec4 project(vec3 p) {\\n  return projection * view * model * vec4(p, 1.0);\\n}\\n\\nvoid main() {\\n  gl_Position      = project(position);\\n\\n  //Lighting geometry parameters\\n  vec4 cameraCoordinate = view * vec4(position , 1.0);\\n  cameraCoordinate.xyz /= cameraCoordinate.w;\\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\\n  f_normal  = normalize((vec4(normal, 0.0) * inverseModel).xyz);\\n\\n  f_color          = color;\\n  f_data           = position;\\n  f_uv             = uv;\\n}\\n\"]);\n      var triFragSrc = glslify([\"#extension GL_OES_standard_derivatives : enable\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nfloat beckmannDistribution(float x, float roughness) {\\n  float NdotH = max(x, 0.0001);\\n  float cos2Alpha = NdotH * NdotH;\\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\\n  float roughness2 = roughness * roughness;\\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\\n  return exp(tan2Alpha / roughness2) / denom;\\n}\\n\\nfloat cookTorranceSpecular(\\n  vec3 lightDirection,\\n  vec3 viewDirection,\\n  vec3 surfaceNormal,\\n  float roughness,\\n  float fresnel) {\\n\\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\\n\\n  //Half angle vector\\n  vec3 H = normalize(lightDirection + viewDirection);\\n\\n  //Geometric term\\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\\n  float VdotH = max(dot(viewDirection, H), 0.000001);\\n  float LdotH = max(dot(lightDirection, H), 0.000001);\\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\\n  float G = min(1.0, min(G1, G2));\\n  \\n  //Distribution term\\n  float D = beckmannDistribution(NdotH, roughness);\\n\\n  //Fresnel term\\n  float F = pow(1.0 - VdotN, fresnel);\\n\\n  //Multiply terms and done\\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\\n}\\n\\n//#pragma glslify: beckmann = require(glsl-specular-beckmann) // used in gl-surface3d\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 clipBounds[2];\\nuniform float roughness\\n            , fresnel\\n            , kambient\\n            , kdiffuse\\n            , kspecular;\\nuniform sampler2D texture;\\n\\nvarying vec3 f_normal\\n           , f_lightDirection\\n           , f_eyeDirection\\n           , f_data;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  if (f_color.a == 0.0 ||\\n    outOfRange(clipBounds[0], clipBounds[1], f_data)\\n  ) discard;\\n\\n  vec3 N = normalize(f_normal);\\n  vec3 L = normalize(f_lightDirection);\\n  vec3 V = normalize(f_eyeDirection);\\n\\n  if(gl_FrontFacing) {\\n    N = -N;\\n  }\\n\\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\\n  //float specular = max(0.0, beckmann(L, V, N, roughness)); // used in gl-surface3d\\n\\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\\n\\n  vec4 surfaceColor = vec4(f_color.rgb, 1.0) * texture2D(texture, f_uv);\\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\\n\\n  gl_FragColor = litColor * f_color.a;\\n}\\n\"]);\n      var edgeVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec2 uv;\\n\\nuniform mat4 model, view, projection;\\n\\nvarying vec4 f_color;\\nvarying vec3 f_data;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  gl_Position = projection * view * model * vec4(position, 1.0);\\n  f_color = color;\\n  f_data  = position;\\n  f_uv    = uv;\\n}\"]);\n      var edgeFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 clipBounds[2];\\nuniform sampler2D texture;\\nuniform float opacity;\\n\\nvarying vec4 f_color;\\nvarying vec3 f_data;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_data)) discard;\\n\\n  gl_FragColor = f_color * texture2D(texture, f_uv) * opacity;\\n}\"]);\n      var pointVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec2 uv;\\nattribute float pointSize;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 clipBounds[2];\\n\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\\n\\n    gl_Position = vec4(0.0, 0.0 ,0.0 ,0.0);\\n  } else {\\n    gl_Position = projection * view * model * vec4(position, 1.0);\\n  }\\n  gl_PointSize = pointSize;\\n  f_color = color;\\n  f_uv = uv;\\n}\"]);\n      var pointFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D texture;\\nuniform float opacity;\\n\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  vec2 pointR = gl_PointCoord.xy - vec2(0.5, 0.5);\\n  if(dot(pointR, pointR) > 0.25) {\\n    discard;\\n  }\\n  gl_FragColor = f_color * texture2D(texture, f_uv) * opacity;\\n}\"]);\n      var pickVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\nattribute vec4 id;\\n\\nuniform mat4 model, view, projection;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  gl_Position = projection * view * model * vec4(position, 1.0);\\n  f_id        = id;\\n  f_position  = position;\\n}\"]);\n      var pickFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3  clipBounds[2];\\nuniform float pickId;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\\n\\n  gl_FragColor = vec4(pickId, f_id.xyz);\\n}\"]);\n      var pickPointVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nattribute vec3  position;\\nattribute float pointSize;\\nattribute vec4  id;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 clipBounds[2];\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\\n\\n    gl_Position = vec4(0.0, 0.0, 0.0, 0.0);\\n  } else {\\n    gl_Position  = projection * view * model * vec4(position, 1.0);\\n    gl_PointSize = pointSize;\\n  }\\n  f_id         = id;\\n  f_position   = position;\\n}\"]);\n      var contourVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position;\\n\\nuniform mat4 model, view, projection;\\n\\nvoid main() {\\n  gl_Position = projection * view * model * vec4(position, 1.0);\\n}\"]);\n      var contourFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform vec3 contourColor;\\n\\nvoid main() {\\n  gl_FragColor = vec4(contourColor, 1.0);\\n}\\n\"]);\n      exports.meshShader = {\n        vertex: triVertSrc,\n        fragment: triFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'normal',\n          type: 'vec3'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'uv',\n          type: 'vec2'\n        }]\n      };\n      exports.wireShader = {\n        vertex: edgeVertSrc,\n        fragment: edgeFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'uv',\n          type: 'vec2'\n        }]\n      };\n      exports.pointShader = {\n        vertex: pointVertSrc,\n        fragment: pointFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'uv',\n          type: 'vec2'\n        }, {\n          name: 'pointSize',\n          type: 'float'\n        }]\n      };\n      exports.pickShader = {\n        vertex: pickVertSrc,\n        fragment: pickFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'id',\n          type: 'vec4'\n        }]\n      };\n      exports.pointPickShader = {\n        vertex: pickPointVertSrc,\n        fragment: pickFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'pointSize',\n          type: 'float'\n        }, {\n          name: 'id',\n          type: 'vec4'\n        }]\n      };\n      exports.contourShader = {\n        vertex: contourVertSrc,\n        fragment: contourFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec3'\n        }]\n      };\n    }, {\n      \"glslify\": 231\n    }],\n    112: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var DEFAULT_VERTEX_NORMALS_EPSILON = 1e-6; // may be too large if triangles are very small\n\n      var DEFAULT_FACE_NORMALS_EPSILON = 1e-6;\n\n      var createShader = _glvis_('gl-shader');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createTexture = _glvis_('gl-texture2d');\n\n      var normals = _glvis_('normals');\n\n      var multiply = _glvis_('gl-mat4/multiply');\n\n      var invert = _glvis_('gl-mat4/invert');\n\n      var ndarray = _glvis_('ndarray');\n\n      var colormap = _glvis_('colormap');\n\n      var getContour = _glvis_('simplicial-complex-contour');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var shaders = _glvis_('./lib/shaders');\n\n      var closestPoint = _glvis_('./lib/closest-point');\n\n      var meshShader = shaders.meshShader;\n      var wireShader = shaders.wireShader;\n      var pointShader = shaders.pointShader;\n      var pickShader = shaders.pickShader;\n      var pointPickShader = shaders.pointPickShader;\n      var contourShader = shaders.contourShader;\n      var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n      function SimplicialMesh(gl, texture, triShader, lineShader, pointShader, pickShader, pointPickShader, contourShader, trianglePositions, triangleIds, triangleColors, triangleUVs, triangleNormals, triangleVAO, edgePositions, edgeIds, edgeColors, edgeUVs, edgeVAO, pointPositions, pointIds, pointColors, pointUVs, pointSizes, pointVAO, contourPositions, contourVAO) {\n        this.gl = gl;\n        this.pixelRatio = 1;\n        this.cells = [];\n        this.positions = [];\n        this.intensity = [];\n        this.texture = texture;\n        this.dirty = true;\n        this.triShader = triShader;\n        this.lineShader = lineShader;\n        this.pointShader = pointShader;\n        this.pickShader = pickShader;\n        this.pointPickShader = pointPickShader;\n        this.contourShader = contourShader;\n        this.trianglePositions = trianglePositions;\n        this.triangleColors = triangleColors;\n        this.triangleNormals = triangleNormals;\n        this.triangleUVs = triangleUVs;\n        this.triangleIds = triangleIds;\n        this.triangleVAO = triangleVAO;\n        this.triangleCount = 0;\n        this.lineWidth = 1;\n        this.edgePositions = edgePositions;\n        this.edgeColors = edgeColors;\n        this.edgeUVs = edgeUVs;\n        this.edgeIds = edgeIds;\n        this.edgeVAO = edgeVAO;\n        this.edgeCount = 0;\n        this.pointPositions = pointPositions;\n        this.pointColors = pointColors;\n        this.pointUVs = pointUVs;\n        this.pointSizes = pointSizes;\n        this.pointIds = pointIds;\n        this.pointVAO = pointVAO;\n        this.pointCount = 0;\n        this.contourLineWidth = 1;\n        this.contourPositions = contourPositions;\n        this.contourVAO = contourVAO;\n        this.contourCount = 0;\n        this.contourColor = [0, 0, 0];\n        this.contourEnable = true;\n        this.pickVertex = true;\n        this.pickId = 1;\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.lightPosition = [1e5, 1e5, 0];\n        this.ambientLight = 0.8;\n        this.diffuseLight = 0.8;\n        this.specularLight = 2.0;\n        this.roughness = 0.5;\n        this.fresnel = 1.5;\n        this.opacity = 1.0;\n        this.hasAlpha = false;\n        this.opacityscale = false;\n        this._model = IDENTITY;\n        this._view = IDENTITY;\n        this._projection = IDENTITY;\n        this._resolution = [1, 1];\n      }\n\n      var proto = SimplicialMesh.prototype;\n\n      proto.isOpaque = function () {\n        return !this.hasAlpha;\n      };\n\n      proto.isTransparent = function () {\n        return this.hasAlpha;\n      };\n\n      proto.pickSlots = 1;\n\n      proto.setPickBase = function (id) {\n        this.pickId = id;\n      };\n\n      function getOpacityFromScale(ratio, opacityscale) {\n        if (!opacityscale) return 1;\n        if (!opacityscale.length) return 1;\n\n        for (var i = 0; i < opacityscale.length; ++i) {\n          if (opacityscale.length < 2) return 1;\n          if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n\n          if (opacityscale[i][0] > ratio && i > 0) {\n            var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n            return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n          }\n        }\n\n        return 1;\n      }\n\n      function genColormap(param, opacityscale) {\n        var colors = colormap({\n          colormap: param,\n          nshades: 256,\n          format: 'rgba'\n        });\n        var result = new Uint8Array(256 * 4);\n\n        for (var i = 0; i < 256; ++i) {\n          var c = colors[i];\n\n          for (var j = 0; j < 3; ++j) {\n            result[4 * i + j] = c[j];\n          }\n\n          if (!opacityscale) {\n            result[4 * i + 3] = 255 * c[3];\n          } else {\n            result[4 * i + 3] = 255 * getOpacityFromScale(i / 255.0, opacityscale);\n          }\n        }\n\n        return ndarray(result, [256, 256, 4], [4, 0, 1]);\n      }\n\n      function takeZComponent(array) {\n        var n = array.length;\n        var result = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          result[i] = array[i][2];\n        }\n\n        return result;\n      }\n\n      proto.highlight = function (selection) {\n        if (!selection || !this.contourEnable) {\n          this.contourCount = 0;\n          return;\n        }\n\n        var level = getContour(this.cells, this.intensity, selection.intensity);\n        var cells = level.cells;\n        var vertexIds = level.vertexIds;\n        var vertexWeights = level.vertexWeights;\n        var numCells = cells.length;\n        var result = pool.mallocFloat32(2 * 3 * numCells);\n        var ptr = 0;\n\n        for (var i = 0; i < numCells; ++i) {\n          var c = cells[i];\n\n          for (var j = 0; j < 2; ++j) {\n            var v = c[0];\n\n            if (c.length === 2) {\n              v = c[j];\n            }\n\n            var a = vertexIds[v][0];\n            var b = vertexIds[v][1];\n            var w = vertexWeights[v];\n            var wi = 1.0 - w;\n            var pa = this.positions[a];\n            var pb = this.positions[b];\n\n            for (var k = 0; k < 3; ++k) {\n              result[ptr++] = w * pa[k] + wi * pb[k];\n            }\n          }\n        }\n\n        this.contourCount = ptr / 3 | 0;\n        this.contourPositions.update(result.subarray(0, ptr));\n        pool.free(result);\n      };\n\n      proto.update = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        this.dirty = true;\n\n        if ('contourEnable' in params) {\n          this.contourEnable = params.contourEnable;\n        }\n\n        if ('contourColor' in params) {\n          this.contourColor = params.contourColor;\n        }\n\n        if ('lineWidth' in params) {\n          this.lineWidth = params.lineWidth;\n        }\n\n        if ('lightPosition' in params) {\n          this.lightPosition = params.lightPosition;\n        }\n\n        this.hasAlpha = false; // default to no transparent draw\n\n        if ('opacity' in params) {\n          this.opacity = params.opacity;\n\n          if (this.opacity < 1) {\n            this.hasAlpha = true;\n          }\n        }\n\n        if ('opacityscale' in params) {\n          this.opacityscale = params.opacityscale;\n          this.hasAlpha = true;\n        }\n\n        if ('ambient' in params) {\n          this.ambientLight = params.ambient;\n        }\n\n        if ('diffuse' in params) {\n          this.diffuseLight = params.diffuse;\n        }\n\n        if ('specular' in params) {\n          this.specularLight = params.specular;\n        }\n\n        if ('roughness' in params) {\n          this.roughness = params.roughness;\n        }\n\n        if ('fresnel' in params) {\n          this.fresnel = params.fresnel;\n        }\n\n        if (params.texture) {\n          this.texture.dispose();\n          this.texture = createTexture(gl, params.texture);\n        } else if (params.colormap) {\n          this.texture.shape = [256, 256];\n          this.texture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n          this.texture.magFilter = gl.LINEAR;\n          this.texture.setPixels(genColormap(params.colormap, this.opacityscale));\n          this.texture.generateMipmap();\n        }\n\n        var cells = params.cells;\n        var positions = params.positions;\n\n        if (!positions || !cells) {\n          return;\n        }\n\n        var tPos = [];\n        var tCol = [];\n        var tNor = [];\n        var tUVs = [];\n        var tIds = [];\n        var ePos = [];\n        var eCol = [];\n        var eUVs = [];\n        var eIds = [];\n        var pPos = [];\n        var pCol = [];\n        var pUVs = [];\n        var pSiz = [];\n        var pIds = []; //Save geometry data for picking calculations\n\n        this.cells = cells;\n        this.positions = positions; //Compute normals\n\n        var vertexNormals = params.vertexNormals;\n        var cellNormals = params.cellNormals;\n        var vertexNormalsEpsilon = params.vertexNormalsEpsilon === void 0 ? DEFAULT_VERTEX_NORMALS_EPSILON : params.vertexNormalsEpsilon;\n        var faceNormalsEpsilon = params.faceNormalsEpsilon === void 0 ? DEFAULT_FACE_NORMALS_EPSILON : params.faceNormalsEpsilon;\n\n        if (params.useFacetNormals && !cellNormals) {\n          cellNormals = normals.faceNormals(cells, positions, faceNormalsEpsilon);\n        }\n\n        if (!cellNormals && !vertexNormals) {\n          vertexNormals = normals.vertexNormals(cells, positions, vertexNormalsEpsilon);\n        } //Compute colors\n\n\n        var vertexColors = params.vertexColors;\n        var cellColors = params.cellColors;\n        var meshColor = params.meshColor || [1, 1, 1, 1]; //UVs\n\n        var vertexUVs = params.vertexUVs;\n        var vertexIntensity = params.vertexIntensity;\n        var cellUVs = params.cellUVs;\n        var cellIntensity = params.cellIntensity;\n        var intensityLo = Infinity;\n        var intensityHi = -Infinity;\n\n        if (!vertexUVs && !cellUVs) {\n          if (vertexIntensity) {\n            if (params.vertexIntensityBounds) {\n              intensityLo = +params.vertexIntensityBounds[0];\n              intensityHi = +params.vertexIntensityBounds[1];\n            } else {\n              for (var i = 0; i < vertexIntensity.length; ++i) {\n                var f = vertexIntensity[i];\n                intensityLo = Math.min(intensityLo, f);\n                intensityHi = Math.max(intensityHi, f);\n              }\n            }\n          } else if (cellIntensity) {\n            if (params.cellIntensityBounds) {\n              intensityLo = +params.cellIntensityBounds[0];\n              intensityHi = +params.cellIntensityBounds[1];\n            } else {\n              for (var i = 0; i < cellIntensity.length; ++i) {\n                var f = cellIntensity[i];\n                intensityLo = Math.min(intensityLo, f);\n                intensityHi = Math.max(intensityHi, f);\n              }\n            }\n          } else {\n            for (var i = 0; i < positions.length; ++i) {\n              var f = positions[i][2];\n              intensityLo = Math.min(intensityLo, f);\n              intensityHi = Math.max(intensityHi, f);\n            }\n          }\n        }\n\n        if (vertexIntensity) {\n          this.intensity = vertexIntensity;\n        } else if (cellIntensity) {\n          this.intensity = cellIntensity;\n        } else {\n          this.intensity = takeZComponent(positions);\n        }\n\n        this.pickVertex = !(cellIntensity || cellColors); //Point size\n\n        var pointSizes = params.pointSizes;\n        var meshPointSize = params.pointSize || 1.0; //Update bounds\n\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n        for (var i = 0; i < positions.length; ++i) {\n          var p = positions[i];\n\n          for (var j = 0; j < 3; ++j) {\n            if (isNaN(p[j]) || !isFinite(p[j])) {\n              continue;\n            }\n\n            this.bounds[0][j] = Math.min(this.bounds[0][j], p[j]);\n            this.bounds[1][j] = Math.max(this.bounds[1][j], p[j]);\n          }\n        } //Pack cells into buffers\n\n\n        var triangleCount = 0;\n        var edgeCount = 0;\n        var pointCount = 0;\n\n        fill_loop: for (var i = 0; i < cells.length; ++i) {\n          var cell = cells[i];\n\n          switch (cell.length) {\n            case 1:\n              var v = cell[0];\n              var p = positions[v]; //Check NaNs\n\n              for (var j = 0; j < 3; ++j) {\n                if (isNaN(p[j]) || !isFinite(p[j])) {\n                  continue fill_loop;\n                }\n              }\n\n              pPos.push(p[0], p[1], p[2]);\n              var c;\n\n              if (vertexColors) {\n                c = vertexColors[v];\n              } else if (cellColors) {\n                c = cellColors[i];\n              } else {\n                c = meshColor;\n              }\n\n              if (this.opacityscale && vertexIntensity) {\n                tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n              } else if (c.length === 3) {\n                pCol.push(c[0], c[1], c[2], this.opacity);\n              } else {\n                pCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n                if (c[3] < 1) this.hasAlpha = true;\n              }\n\n              var uv;\n\n              if (vertexUVs) {\n                uv = vertexUVs[v];\n              } else if (vertexIntensity) {\n                uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n              } else if (cellUVs) {\n                uv = cellUVs[i];\n              } else if (cellIntensity) {\n                uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n              } else {\n                uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n              }\n\n              pUVs.push(uv[0], uv[1]);\n\n              if (pointSizes) {\n                pSiz.push(pointSizes[v]);\n              } else {\n                pSiz.push(meshPointSize);\n              }\n\n              pIds.push(i);\n              pointCount += 1;\n              break;\n\n            case 2:\n              //Check NaNs\n              for (var j = 0; j < 2; ++j) {\n                var v = cell[j];\n                var p = positions[v];\n\n                for (var k = 0; k < 3; ++k) {\n                  if (isNaN(p[k]) || !isFinite(p[k])) {\n                    continue fill_loop;\n                  }\n                }\n              }\n\n              for (var j = 0; j < 2; ++j) {\n                var v = cell[j];\n                var p = positions[v];\n                ePos.push(p[0], p[1], p[2]);\n                var c;\n\n                if (vertexColors) {\n                  c = vertexColors[v];\n                } else if (cellColors) {\n                  c = cellColors[i];\n                } else {\n                  c = meshColor;\n                }\n\n                if (this.opacityscale && vertexIntensity) {\n                  tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n                } else if (c.length === 3) {\n                  eCol.push(c[0], c[1], c[2], this.opacity);\n                } else {\n                  eCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n                  if (c[3] < 1) this.hasAlpha = true;\n                }\n\n                var uv;\n\n                if (vertexUVs) {\n                  uv = vertexUVs[v];\n                } else if (vertexIntensity) {\n                  uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n                } else if (cellUVs) {\n                  uv = cellUVs[i];\n                } else if (cellIntensity) {\n                  uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n                } else {\n                  uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n                }\n\n                eUVs.push(uv[0], uv[1]);\n                eIds.push(i);\n              }\n\n              edgeCount += 1;\n              break;\n\n            case 3:\n              //Check NaNs\n              for (var j = 0; j < 3; ++j) {\n                var v = cell[j];\n                var p = positions[v];\n\n                for (var k = 0; k < 3; ++k) {\n                  if (isNaN(p[k]) || !isFinite(p[k])) {\n                    continue fill_loop;\n                  }\n                }\n              }\n\n              for (var j = 0; j < 3; ++j) {\n                var v = cell[2 - j];\n                var p = positions[v];\n                tPos.push(p[0], p[1], p[2]);\n                var c;\n\n                if (vertexColors) {\n                  c = vertexColors[v];\n                } else if (cellColors) {\n                  c = cellColors[i];\n                } else {\n                  c = meshColor;\n                }\n\n                if (!c) {\n                  tCol.push(0.5, 0.5, 0.5, 1);\n                } else if (this.opacityscale && vertexIntensity) {\n                  tCol.push(c[0], c[1], c[2], this.opacity * getOpacityFromScale((vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), this.opacityscale));\n                } else if (c.length === 3) {\n                  tCol.push(c[0], c[1], c[2], this.opacity);\n                } else {\n                  tCol.push(c[0], c[1], c[2], c[3] * this.opacity);\n                  if (c[3] < 1) this.hasAlpha = true;\n                }\n\n                var uv;\n\n                if (vertexUVs) {\n                  uv = vertexUVs[v];\n                } else if (vertexIntensity) {\n                  uv = [(vertexIntensity[v] - intensityLo) / (intensityHi - intensityLo), 0];\n                } else if (cellUVs) {\n                  uv = cellUVs[i];\n                } else if (cellIntensity) {\n                  uv = [(cellIntensity[i] - intensityLo) / (intensityHi - intensityLo), 0];\n                } else {\n                  uv = [(p[2] - intensityLo) / (intensityHi - intensityLo), 0];\n                }\n\n                tUVs.push(uv[0], uv[1]);\n                var q;\n\n                if (vertexNormals) {\n                  q = vertexNormals[v];\n                } else {\n                  q = cellNormals[i];\n                }\n\n                tNor.push(q[0], q[1], q[2]);\n                tIds.push(i);\n              }\n\n              triangleCount += 1;\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        this.pointCount = pointCount;\n        this.edgeCount = edgeCount;\n        this.triangleCount = triangleCount;\n        this.pointPositions.update(pPos);\n        this.pointColors.update(pCol);\n        this.pointUVs.update(pUVs);\n        this.pointSizes.update(pSiz);\n        this.pointIds.update(new Uint32Array(pIds));\n        this.edgePositions.update(ePos);\n        this.edgeColors.update(eCol);\n        this.edgeUVs.update(eUVs);\n        this.edgeIds.update(new Uint32Array(eIds));\n        this.trianglePositions.update(tPos);\n        this.triangleColors.update(tCol);\n        this.triangleUVs.update(tUVs);\n        this.triangleNormals.update(tNor);\n        this.triangleIds.update(new Uint32Array(tIds));\n      };\n\n      proto.drawTransparent = proto.draw = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        var model = params.model || IDENTITY;\n        var view = params.view || IDENTITY;\n        var projection = params.projection || IDENTITY;\n        var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n        for (var i = 0; i < 3; ++i) {\n          clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n          clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n        }\n\n        var uniforms = {\n          model: model,\n          view: view,\n          projection: projection,\n          inverseModel: IDENTITY.slice(),\n          clipBounds: clipBounds,\n          kambient: this.ambientLight,\n          kdiffuse: this.diffuseLight,\n          kspecular: this.specularLight,\n          roughness: this.roughness,\n          fresnel: this.fresnel,\n          eyePosition: [0, 0, 0],\n          lightPosition: [0, 0, 0],\n          contourColor: this.contourColor,\n          texture: 0\n        };\n        uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n        gl.disable(gl.CULL_FACE);\n        this.texture.bind(0);\n        var invCameraMatrix = new Array(16);\n        multiply(invCameraMatrix, uniforms.view, uniforms.model);\n        multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n        invert(invCameraMatrix, invCameraMatrix);\n\n        for (var i = 0; i < 3; ++i) {\n          uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n        }\n\n        var w = invCameraMatrix[15];\n\n        for (var i = 0; i < 3; ++i) {\n          w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          var s = invCameraMatrix[12 + i];\n\n          for (var j = 0; j < 3; ++j) {\n            s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n          }\n\n          uniforms.lightPosition[i] = s / w;\n        }\n\n        if (this.triangleCount > 0) {\n          var shader = this.triShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.triangleVAO.bind();\n          gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n          this.triangleVAO.unbind();\n        }\n\n        if (this.edgeCount > 0 && this.lineWidth > 0) {\n          var shader = this.lineShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.edgeVAO.bind();\n          gl.lineWidth(this.lineWidth * this.pixelRatio);\n          gl.drawArrays(gl.LINES, 0, this.edgeCount * 2);\n          this.edgeVAO.unbind();\n        }\n\n        if (this.pointCount > 0) {\n          var shader = this.pointShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.pointVAO.bind();\n          gl.drawArrays(gl.POINTS, 0, this.pointCount);\n          this.pointVAO.unbind();\n        }\n\n        if (this.contourEnable && this.contourCount > 0 && this.contourLineWidth > 0) {\n          var shader = this.contourShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.contourVAO.bind();\n          gl.drawArrays(gl.LINES, 0, this.contourCount);\n          this.contourVAO.unbind();\n        }\n      };\n\n      proto.drawPick = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        var model = params.model || IDENTITY;\n        var view = params.view || IDENTITY;\n        var projection = params.projection || IDENTITY;\n        var clipBounds = [[-1e6, -1e6, -1e6], [1e6, 1e6, 1e6]];\n\n        for (var i = 0; i < 3; ++i) {\n          clipBounds[0][i] = Math.max(clipBounds[0][i], this.clipBounds[0][i]);\n          clipBounds[1][i] = Math.min(clipBounds[1][i], this.clipBounds[1][i]);\n        } //Save camera parameters\n\n\n        this._model = [].slice.call(model);\n        this._view = [].slice.call(view);\n        this._projection = [].slice.call(projection);\n        this._resolution = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n        var uniforms = {\n          model: model,\n          view: view,\n          projection: projection,\n          clipBounds: clipBounds,\n          pickId: this.pickId / 255.0\n        };\n        var shader = this.pickShader;\n        shader.bind();\n        shader.uniforms = uniforms;\n\n        if (this.triangleCount > 0) {\n          this.triangleVAO.bind();\n          gl.drawArrays(gl.TRIANGLES, 0, this.triangleCount * 3);\n          this.triangleVAO.unbind();\n        }\n\n        if (this.edgeCount > 0) {\n          this.edgeVAO.bind();\n          gl.lineWidth(this.lineWidth * this.pixelRatio);\n          gl.drawArrays(gl.LINES, 0, this.edgeCount * 2);\n          this.edgeVAO.unbind();\n        }\n\n        if (this.pointCount > 0) {\n          var shader = this.pointPickShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          this.pointVAO.bind();\n          gl.drawArrays(gl.POINTS, 0, this.pointCount);\n          this.pointVAO.unbind();\n        }\n      };\n\n      proto.pick = function (pickData) {\n        if (!pickData) {\n          return null;\n        }\n\n        if (pickData.id !== this.pickId) {\n          return null;\n        }\n\n        var cellId = pickData.value[0] + 256 * pickData.value[1] + 65536 * pickData.value[2];\n        var cell = this.cells[cellId];\n        var positions = this.positions;\n        var simplex = new Array(cell.length);\n\n        for (var i = 0; i < cell.length; ++i) {\n          simplex[i] = positions[cell[i]];\n        }\n\n        var x = pickData.coord[0];\n        var y = pickData.coord[1];\n\n        if (!this.pickVertex) {\n          var A = this.positions[cell[0]];\n          var B = this.positions[cell[1]];\n          var C = this.positions[cell[2]];\n          var dataCoordinate = [(A[0] + B[0] + C[0]) / 3, (A[1] + B[1] + C[1]) / 3, (A[2] + B[2] + C[2]) / 3];\n          return {\n            _cellCenter: true,\n            position: [x, y],\n            index: cellId,\n            cell: cell,\n            cellId: cellId,\n            intensity: this.intensity[cellId],\n            dataCoordinate: dataCoordinate\n          };\n        }\n\n        var data = closestPoint(simplex, [x * this.pixelRatio, this._resolution[1] - y * this.pixelRatio], this._model, this._view, this._projection, this._resolution);\n\n        if (!data) {\n          return null;\n        }\n\n        var weights = data[2];\n        var interpIntensity = 0.0;\n\n        for (var i = 0; i < cell.length; ++i) {\n          interpIntensity += weights[i] * this.intensity[cell[i]];\n        }\n\n        return {\n          position: data[1],\n          index: cell[data[0]],\n          cell: cell,\n          cellId: cellId,\n          intensity: interpIntensity,\n          dataCoordinate: this.positions[cell[data[0]]]\n        };\n      };\n\n      proto.dispose = function () {\n        this.texture.dispose();\n        this.triShader.dispose();\n        this.lineShader.dispose();\n        this.pointShader.dispose();\n        this.pickShader.dispose();\n        this.pointPickShader.dispose();\n        this.triangleVAO.dispose();\n        this.trianglePositions.dispose();\n        this.triangleColors.dispose();\n        this.triangleUVs.dispose();\n        this.triangleNormals.dispose();\n        this.triangleIds.dispose();\n        this.edgeVAO.dispose();\n        this.edgePositions.dispose();\n        this.edgeColors.dispose();\n        this.edgeUVs.dispose();\n        this.edgeIds.dispose();\n        this.pointVAO.dispose();\n        this.pointPositions.dispose();\n        this.pointColors.dispose();\n        this.pointUVs.dispose();\n        this.pointSizes.dispose();\n        this.pointIds.dispose();\n        this.contourVAO.dispose();\n        this.contourPositions.dispose();\n        this.contourShader.dispose();\n      };\n\n      function createMeshShader(gl) {\n        var shader = createShader(gl, meshShader.vertex, meshShader.fragment);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 2;\n        shader.attributes.uv.location = 3;\n        shader.attributes.normal.location = 4;\n        return shader;\n      }\n\n      function createWireShader(gl) {\n        var shader = createShader(gl, wireShader.vertex, wireShader.fragment);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 2;\n        shader.attributes.uv.location = 3;\n        return shader;\n      }\n\n      function createPointShader(gl) {\n        var shader = createShader(gl, pointShader.vertex, pointShader.fragment);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 2;\n        shader.attributes.uv.location = 3;\n        shader.attributes.pointSize.location = 4;\n        return shader;\n      }\n\n      function createPickShader(gl) {\n        var shader = createShader(gl, pickShader.vertex, pickShader.fragment);\n        shader.attributes.position.location = 0;\n        shader.attributes.id.location = 1;\n        return shader;\n      }\n\n      function createPointPickShader(gl) {\n        var shader = createShader(gl, pointPickShader.vertex, pointPickShader.fragment);\n        shader.attributes.position.location = 0;\n        shader.attributes.id.location = 1;\n        shader.attributes.pointSize.location = 4;\n        return shader;\n      }\n\n      function createContourShader(gl) {\n        var shader = createShader(gl, contourShader.vertex, contourShader.fragment);\n        shader.attributes.position.location = 0;\n        return shader;\n      }\n\n      function createSimplicialMesh(gl, params) {\n        if (arguments.length === 1) {\n          params = gl;\n          gl = params.gl;\n        } //enable derivatives for face normals\n\n\n        var ext = gl.getExtension('OES_standard_derivatives') || gl.getExtension('MOZ_OES_standard_derivatives') || gl.getExtension('WEBKIT_OES_standard_derivatives');\n        if (!ext) throw new Error('derivatives not supported');\n        var triShader = createMeshShader(gl);\n        var lineShader = createWireShader(gl);\n        var pointShader = createPointShader(gl);\n        var pickShader = createPickShader(gl);\n        var pointPickShader = createPointPickShader(gl);\n        var contourShader = createContourShader(gl);\n        var meshTexture = createTexture(gl, ndarray(new Uint8Array([255, 255, 255, 255]), [1, 1, 4]));\n        meshTexture.generateMipmap();\n        meshTexture.minFilter = gl.LINEAR_MIPMAP_LINEAR;\n        meshTexture.magFilter = gl.LINEAR;\n        var trianglePositions = createBuffer(gl);\n        var triangleColors = createBuffer(gl);\n        var triangleUVs = createBuffer(gl);\n        var triangleNormals = createBuffer(gl);\n        var triangleIds = createBuffer(gl);\n        var triangleVAO = createVAO(gl, [{\n          buffer: trianglePositions,\n          type: gl.FLOAT,\n          size: 3\n        }, {\n          buffer: triangleIds,\n          type: gl.UNSIGNED_BYTE,\n          size: 4,\n          normalized: true\n        }, {\n          buffer: triangleColors,\n          type: gl.FLOAT,\n          size: 4\n        }, {\n          buffer: triangleUVs,\n          type: gl.FLOAT,\n          size: 2\n        }, {\n          buffer: triangleNormals,\n          type: gl.FLOAT,\n          size: 3\n        }]);\n        var edgePositions = createBuffer(gl);\n        var edgeColors = createBuffer(gl);\n        var edgeUVs = createBuffer(gl);\n        var edgeIds = createBuffer(gl);\n        var edgeVAO = createVAO(gl, [{\n          buffer: edgePositions,\n          type: gl.FLOAT,\n          size: 3\n        }, {\n          buffer: edgeIds,\n          type: gl.UNSIGNED_BYTE,\n          size: 4,\n          normalized: true\n        }, {\n          buffer: edgeColors,\n          type: gl.FLOAT,\n          size: 4\n        }, {\n          buffer: edgeUVs,\n          type: gl.FLOAT,\n          size: 2\n        }]);\n        var pointPositions = createBuffer(gl);\n        var pointColors = createBuffer(gl);\n        var pointUVs = createBuffer(gl);\n        var pointSizes = createBuffer(gl);\n        var pointIds = createBuffer(gl);\n        var pointVAO = createVAO(gl, [{\n          buffer: pointPositions,\n          type: gl.FLOAT,\n          size: 3\n        }, {\n          buffer: pointIds,\n          type: gl.UNSIGNED_BYTE,\n          size: 4,\n          normalized: true\n        }, {\n          buffer: pointColors,\n          type: gl.FLOAT,\n          size: 4\n        }, {\n          buffer: pointUVs,\n          type: gl.FLOAT,\n          size: 2\n        }, {\n          buffer: pointSizes,\n          type: gl.FLOAT,\n          size: 1\n        }]);\n        var contourPositions = createBuffer(gl);\n        var contourVAO = createVAO(gl, [{\n          buffer: contourPositions,\n          type: gl.FLOAT,\n          size: 3\n        }]);\n        var mesh = new SimplicialMesh(gl, meshTexture, triShader, lineShader, pointShader, pickShader, pointPickShader, contourShader, trianglePositions, triangleIds, triangleColors, triangleUVs, triangleNormals, triangleVAO, edgePositions, edgeIds, edgeColors, edgeUVs, edgeVAO, pointPositions, pointIds, pointColors, pointUVs, pointSizes, pointVAO, contourPositions, contourVAO);\n        mesh.update(params);\n        return mesh;\n      }\n\n      module.exports = createSimplicialMesh;\n    }, {\n      \"./lib/closest-point\": 110,\n      \"./lib/shaders\": 111,\n      \"colormap\": 53,\n      \"gl-buffer\": 78,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/multiply\": 100,\n      \"gl-shader\": 132,\n      \"gl-texture2d\": 146,\n      \"gl-vao\": 150,\n      \"ndarray\": 259,\n      \"normals\": 261,\n      \"simplicial-complex-contour\": 291,\n      \"typedarray-pool\": 308\n    }],\n    113: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createBoxes;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createShader = _glvis_('gl-shader');\n\n      var shaders = _glvis_('./shaders');\n\n      function Boxes(plot, vbo, shader) {\n        this.plot = plot;\n        this.vbo = vbo;\n        this.shader = shader;\n      }\n\n      var proto = Boxes.prototype;\n\n      proto.bind = function () {\n        var shader = this.shader;\n        this.vbo.bind();\n        this.shader.bind();\n        shader.attributes.coord.pointer();\n        shader.uniforms.screenBox = this.plot.screenBox;\n      };\n\n      proto.drawBox = function () {\n        var lo = [0, 0];\n        var hi = [0, 0];\n        return function (loX, loY, hiX, hiY, color) {\n          var plot = this.plot;\n          var shader = this.shader;\n          var gl = plot.gl;\n          lo[0] = loX;\n          lo[1] = loY;\n          hi[0] = hiX;\n          hi[1] = hiY;\n          shader.uniforms.lo = lo;\n          shader.uniforms.hi = hi;\n          shader.uniforms.color = color;\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        };\n      }();\n\n      proto.dispose = function () {\n        this.vbo.dispose();\n        this.shader.dispose();\n      };\n\n      function createBoxes(plot) {\n        var gl = plot.gl;\n        var vbo = createBuffer(gl, [0, 0, 0, 1, 1, 0, 1, 1]);\n        var shader = createShader(gl, shaders.boxVert, shaders.lineFrag);\n        return new Boxes(plot, vbo, shader);\n      }\n    }, {\n      \"./shaders\": 116,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132\n    }],\n    114: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createGrid;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createShader = _glvis_('gl-shader');\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var shaders = _glvis_('./shaders');\n\n      function Grid(plot, vbo, shader, tickShader) {\n        this.plot = plot;\n        this.vbo = vbo;\n        this.shader = shader;\n        this.tickShader = tickShader;\n        this.ticks = [[], []];\n      }\n\n      function compareTickNum(a, b) {\n        return a - b;\n      }\n\n      var proto = Grid.prototype;\n\n      proto.draw = function () {\n        var DATA_SHIFT = [0, 0];\n        var DATA_SCALE = [0, 0];\n        var DATA_AXIS = [0, 0];\n        return function () {\n          var plot = this.plot;\n          var vbo = this.vbo;\n          var shader = this.shader;\n          var ticks = this.ticks;\n          var gl = plot.gl;\n          var bounds = plot._tickBounds;\n          var dataBox = plot.dataBox;\n          var viewPixels = plot.viewBox;\n          var lineWidth = plot.gridLineWidth;\n          var gridColor = plot.gridLineColor;\n          var gridEnable = plot.gridLineEnable;\n          var pixelRatio = plot.pixelRatio;\n\n          for (var i = 0; i < 2; ++i) {\n            var lo = bounds[i];\n            var hi = bounds[i + 2];\n            var boundScale = hi - lo;\n            var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n            var dataWidth = dataBox[i + 2] - dataBox[i];\n            DATA_SCALE[i] = 2.0 * boundScale / dataWidth;\n            DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;\n          }\n\n          shader.bind();\n          vbo.bind();\n          shader.attributes.dataCoord.pointer();\n          shader.uniforms.dataShift = DATA_SHIFT;\n          shader.uniforms.dataScale = DATA_SCALE;\n          var offset = 0;\n\n          for (var i = 0; i < 2; ++i) {\n            DATA_AXIS[0] = DATA_AXIS[1] = 0;\n            DATA_AXIS[i] = 1;\n            shader.uniforms.dataAxis = DATA_AXIS;\n            shader.uniforms.lineWidth = lineWidth[i] / (viewPixels[i + 2] - viewPixels[i]) * pixelRatio;\n            shader.uniforms.color = gridColor[i];\n            var size = ticks[i].length * 6;\n\n            if (gridEnable[i] && size) {\n              gl.drawArrays(gl.TRIANGLES, offset, size);\n            }\n\n            offset += size;\n          }\n        };\n      }();\n\n      proto.drawTickMarks = function () {\n        var DATA_SHIFT = [0, 0];\n        var DATA_SCALE = [0, 0];\n        var X_AXIS = [1, 0];\n        var Y_AXIS = [0, 1];\n        var SCR_OFFSET = [0, 0];\n        var TICK_SCALE = [0, 0];\n        return function () {\n          var plot = this.plot;\n          var vbo = this.vbo;\n          var shader = this.tickShader;\n          var ticks = this.ticks;\n          var gl = plot.gl;\n          var bounds = plot._tickBounds;\n          var dataBox = plot.dataBox;\n          var viewBox = plot.viewBox;\n          var pixelRatio = plot.pixelRatio;\n          var screenBox = plot.screenBox;\n          var screenWidth = screenBox[2] - screenBox[0];\n          var screenHeight = screenBox[3] - screenBox[1];\n          var viewWidth = viewBox[2] - viewBox[0];\n          var viewHeight = viewBox[3] - viewBox[1];\n\n          for (var i = 0; i < 2; ++i) {\n            var lo = bounds[i];\n            var hi = bounds[i + 2];\n            var boundScale = hi - lo;\n            var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n            var dataWidth = dataBox[i + 2] - dataBox[i];\n            DATA_SCALE[i] = 2.0 * boundScale / dataWidth;\n            DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth;\n          }\n\n          DATA_SCALE[0] *= viewWidth / screenWidth;\n          DATA_SHIFT[0] *= viewWidth / screenWidth;\n          DATA_SCALE[1] *= viewHeight / screenHeight;\n          DATA_SHIFT[1] *= viewHeight / screenHeight;\n          shader.bind();\n          vbo.bind();\n          shader.attributes.dataCoord.pointer();\n          var uniforms = shader.uniforms;\n          uniforms.dataShift = DATA_SHIFT;\n          uniforms.dataScale = DATA_SCALE;\n          var tickMarkLength = plot.tickMarkLength;\n          var tickMarkWidth = plot.tickMarkWidth;\n          var tickMarkColor = plot.tickMarkColor;\n          var xTicksOffset = 0;\n          var yTicksOffset = ticks[0].length * 6;\n          var xStart = Math.min(bsearch.ge(ticks[0], (dataBox[0] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);\n          var xEnd = Math.min(bsearch.gt(ticks[0], (dataBox[2] - bounds[0]) / (bounds[2] - bounds[0]), compareTickNum), ticks[0].length);\n          var xOffset = xTicksOffset + 6 * xStart;\n          var xCount = 6 * Math.max(0, xEnd - xStart);\n          var yStart = Math.min(bsearch.ge(ticks[1], (dataBox[1] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);\n          var yEnd = Math.min(bsearch.gt(ticks[1], (dataBox[3] - bounds[1]) / (bounds[3] - bounds[1]), compareTickNum), ticks[1].length);\n          var yOffset = yTicksOffset + 6 * yStart;\n          var yCount = 6 * Math.max(0, yEnd - yStart);\n          SCR_OFFSET[0] = 2.0 * (viewBox[0] - tickMarkLength[1]) / screenWidth - 1.0;\n          SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;\n          TICK_SCALE[0] = tickMarkLength[1] * pixelRatio / screenWidth;\n          TICK_SCALE[1] = tickMarkWidth[1] * pixelRatio / screenHeight;\n\n          if (yCount) {\n            uniforms.color = tickMarkColor[1];\n            uniforms.tickScale = TICK_SCALE;\n            uniforms.dataAxis = Y_AXIS;\n            uniforms.screenOffset = SCR_OFFSET;\n            gl.drawArrays(gl.TRIANGLES, yOffset, yCount);\n          }\n\n          SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;\n          SCR_OFFSET[1] = 2.0 * (viewBox[1] - tickMarkLength[0]) / screenHeight - 1.0;\n          TICK_SCALE[0] = tickMarkWidth[0] * pixelRatio / screenWidth;\n          TICK_SCALE[1] = tickMarkLength[0] * pixelRatio / screenHeight;\n\n          if (xCount) {\n            uniforms.color = tickMarkColor[0];\n            uniforms.tickScale = TICK_SCALE;\n            uniforms.dataAxis = X_AXIS;\n            uniforms.screenOffset = SCR_OFFSET;\n            gl.drawArrays(gl.TRIANGLES, xOffset, xCount);\n          }\n\n          SCR_OFFSET[0] = 2.0 * (viewBox[2] + tickMarkLength[3]) / screenWidth - 1.0;\n          SCR_OFFSET[1] = (viewBox[3] + viewBox[1]) / screenHeight - 1.0;\n          TICK_SCALE[0] = tickMarkLength[3] * pixelRatio / screenWidth;\n          TICK_SCALE[1] = tickMarkWidth[3] * pixelRatio / screenHeight;\n\n          if (yCount) {\n            uniforms.color = tickMarkColor[3];\n            uniforms.tickScale = TICK_SCALE;\n            uniforms.dataAxis = Y_AXIS;\n            uniforms.screenOffset = SCR_OFFSET;\n            gl.drawArrays(gl.TRIANGLES, yOffset, yCount);\n          }\n\n          SCR_OFFSET[0] = (viewBox[2] + viewBox[0]) / screenWidth - 1.0;\n          SCR_OFFSET[1] = 2.0 * (viewBox[3] + tickMarkLength[2]) / screenHeight - 1.0;\n          TICK_SCALE[0] = tickMarkWidth[2] * pixelRatio / screenWidth;\n          TICK_SCALE[1] = tickMarkLength[2] * pixelRatio / screenHeight;\n\n          if (xCount) {\n            uniforms.color = tickMarkColor[2];\n            uniforms.tickScale = TICK_SCALE;\n            uniforms.dataAxis = X_AXIS;\n            uniforms.screenOffset = SCR_OFFSET;\n            gl.drawArrays(gl.TRIANGLES, xOffset, xCount);\n          }\n        };\n      }();\n\n      proto.update = function () {\n        var OFFSET_X = [1, 1, -1, -1, 1, -1];\n        var OFFSET_Y = [1, -1, 1, 1, -1, -1];\n        return function (options) {\n          var ticks = options.ticks;\n          var bounds = options.bounds;\n          var data = new Float32Array(6 * 3 * (ticks[0].length + ticks[1].length));\n          var zeroLineEnable = this.plot.zeroLineEnable;\n          var ptr = 0;\n          var gridTicks = [[], []];\n\n          for (var dim = 0; dim < 2; ++dim) {\n            var localTicks = gridTicks[dim];\n            var axisTicks = ticks[dim];\n            var lo = bounds[dim];\n            var hi = bounds[dim + 2];\n\n            for (var i = 0; i < axisTicks.length; ++i) {\n              var x = (axisTicks[i].x - lo) / (hi - lo);\n              localTicks.push(x);\n\n              for (var j = 0; j < 6; ++j) {\n                data[ptr++] = x;\n                data[ptr++] = OFFSET_X[j];\n                data[ptr++] = OFFSET_Y[j];\n              }\n            }\n          }\n\n          this.ticks = gridTicks;\n          this.vbo.update(data);\n        };\n      }();\n\n      proto.dispose = function () {\n        this.vbo.dispose();\n        this.shader.dispose();\n        this.tickShader.dispose();\n      };\n\n      function createGrid(plot) {\n        var gl = plot.gl;\n        var vbo = createBuffer(gl);\n        var shader = createShader(gl, shaders.gridVert, shaders.gridFrag);\n        var tickShader = createShader(gl, shaders.tickVert, shaders.gridFrag);\n        var grid = new Grid(plot, vbo, shader, tickShader);\n        return grid;\n      }\n    }, {\n      \"./shaders\": 116,\n      \"binary-search-bounds\": 31,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132\n    }],\n    115: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createLines;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createShader = _glvis_('gl-shader');\n\n      var shaders = _glvis_('./shaders');\n\n      function Lines(plot, vbo, shader) {\n        this.plot = plot;\n        this.vbo = vbo;\n        this.shader = shader;\n      }\n\n      var proto = Lines.prototype;\n\n      proto.bind = function () {\n        var shader = this.shader;\n        this.vbo.bind();\n        this.shader.bind();\n        shader.attributes.coord.pointer();\n        shader.uniforms.screenBox = this.plot.screenBox;\n      };\n\n      proto.drawLine = function () {\n        var start = [0, 0];\n        var end = [0, 0];\n        return function (startX, startY, endX, endY, width, color) {\n          var plot = this.plot;\n          var shader = this.shader;\n          var gl = plot.gl;\n          start[0] = startX;\n          start[1] = startY;\n          end[0] = endX;\n          end[1] = endY;\n          shader.uniforms.start = start;\n          shader.uniforms.end = end;\n          shader.uniforms.width = width * plot.pixelRatio;\n          shader.uniforms.color = color;\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n        };\n      }();\n\n      proto.dispose = function () {\n        this.vbo.dispose();\n        this.shader.dispose();\n      };\n\n      function createLines(plot) {\n        var gl = plot.gl;\n        var vbo = createBuffer(gl, [-1, -1, -1, 1, 1, -1, 1, 1]);\n        var shader = createShader(gl, shaders.lineVert, shaders.lineFrag);\n        var lines = new Lines(plot, vbo, shader);\n        return lines;\n      }\n    }, {\n      \"./shaders\": 116,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132\n    }],\n    116: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      var FRAGMENT = glslify([\"precision lowp float;\\n#define GLSLIFY 1\\nuniform vec4 color;\\nvoid main() {\\n  gl_FragColor = vec4(color.xyz * color.w, color.w);\\n}\\n\"]);\n      module.exports = {\n        lineVert: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 coord;\\n\\nuniform vec4 screenBox;\\nuniform vec2 start, end;\\nuniform float width;\\n\\nvec2 perp(vec2 v) {\\n  return vec2(v.y, -v.x);\\n}\\n\\nvec2 screen(vec2 v) {\\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\\n}\\n\\nvoid main() {\\n  vec2 delta = normalize(perp(start - end));\\n  vec2 offset = mix(start, end, 0.5 * (coord.y+1.0));\\n  gl_Position = vec4(screen(offset + 0.5 * width * delta * coord.x), 0, 1);\\n}\\n\"]),\n        lineFrag: FRAGMENT,\n        textVert: glslify([\"#define GLSLIFY 1\\nattribute vec3 textCoordinate;\\n\\nuniform vec2 dataScale, dataShift, dataAxis, screenOffset, textScale;\\nuniform float angle;\\n\\nvoid main() {\\n  float dataOffset  = textCoordinate.z;\\n  vec2 glyphOffset  = textCoordinate.xy;\\n  mat2 glyphMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\\n  vec2 screenCoordinate = dataAxis * (dataScale * dataOffset + dataShift) +\\n    glyphMatrix * glyphOffset * textScale + screenOffset;\\n  gl_Position = vec4(screenCoordinate, 0, 1);\\n}\\n\"]),\n        textFrag: FRAGMENT,\n        gridVert: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec3 dataCoord;\\n\\nuniform vec2 dataAxis, dataShift, dataScale;\\nuniform float lineWidth;\\n\\nvoid main() {\\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\\n  pos += 10.0 * dataCoord.y * vec2(dataAxis.y, -dataAxis.x) + dataCoord.z * lineWidth;\\n  gl_Position = vec4(pos, 0, 1);\\n}\\n\"]),\n        gridFrag: FRAGMENT,\n        boxVert: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 coord;\\n\\nuniform vec4 screenBox;\\nuniform vec2 lo, hi;\\n\\nvec2 screen(vec2 v) {\\n  return 2.0 * (v - screenBox.xy) / (screenBox.zw - screenBox.xy) - 1.0;\\n}\\n\\nvoid main() {\\n  gl_Position = vec4(screen(mix(lo, hi, coord)), 0, 1);\\n}\\n\"]),\n        tickVert: glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec3 dataCoord;\\n\\nuniform vec2 dataAxis, dataShift, dataScale, screenOffset, tickScale;\\n\\nvoid main() {\\n  vec2 pos = dataAxis * (dataScale * dataCoord.x + dataShift);\\n  gl_Position = vec4(pos + tickScale*dataCoord.yz + screenOffset, 0, 1);\\n}\\n\"])\n      };\n    }, {\n      \"glslify\": 231\n    }],\n    117: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createTextElements;\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createShader = _glvis_('gl-shader');\n\n      var getText = _glvis_('text-cache');\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var shaders = _glvis_('./shaders');\n\n      function TextElements(plot, vbo, shader) {\n        this.plot = plot;\n        this.vbo = vbo;\n        this.shader = shader;\n        this.tickOffset = [[], []];\n        this.tickX = [[], []];\n        this.labelOffset = [0, 0];\n        this.labelCount = [0, 0];\n      }\n\n      var proto = TextElements.prototype;\n\n      proto.drawTicks = function () {\n        var DATA_AXIS = [0, 0];\n        var SCREEN_OFFSET = [0, 0];\n        var ZERO_2 = [0, 0];\n        return function (axis) {\n          var plot = this.plot;\n          var shader = this.shader;\n          var tickX = this.tickX[axis];\n          var tickOffset = this.tickOffset[axis];\n          var gl = plot.gl;\n          var viewBox = plot.viewBox;\n          var dataBox = plot.dataBox;\n          var screenBox = plot.screenBox;\n          var pixelRatio = plot.pixelRatio;\n          var tickEnable = plot.tickEnable;\n          var tickPad = plot.tickPad;\n          var textColor = plot.tickColor;\n          var textAngle = plot.tickAngle; // todo check if this should be used (now unused)\n          // var tickLength  = plot.tickMarkLength\n\n          var labelEnable = plot.labelEnable;\n          var labelPad = plot.labelPad;\n          var labelColor = plot.labelColor;\n          var labelAngle = plot.labelAngle;\n          var labelOffset = this.labelOffset[axis];\n          var labelCount = this.labelCount[axis];\n          var start = bsearch.lt(tickX, dataBox[axis]);\n          var end = bsearch.le(tickX, dataBox[axis + 2]);\n          DATA_AXIS[0] = DATA_AXIS[1] = 0;\n          DATA_AXIS[axis] = 1;\n          SCREEN_OFFSET[axis] = (viewBox[2 + axis] + viewBox[axis]) / (screenBox[2 + axis] - screenBox[axis]) - 1.0;\n          var screenScale = 2.0 / screenBox[2 + (axis ^ 1)] - screenBox[axis ^ 1];\n          SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[axis ^ 1] - 1.0;\n\n          if (tickEnable[axis]) {\n            SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * tickPad[axis];\n\n            if (start < end && tickOffset[end] > tickOffset[start]) {\n              shader.uniforms.dataAxis = DATA_AXIS;\n              shader.uniforms.screenOffset = SCREEN_OFFSET;\n              shader.uniforms.color = textColor[axis];\n              shader.uniforms.angle = textAngle[axis];\n              gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);\n            }\n          }\n\n          if (labelEnable[axis] && labelCount) {\n            SCREEN_OFFSET[axis ^ 1] -= screenScale * pixelRatio * labelPad[axis];\n            shader.uniforms.dataAxis = ZERO_2;\n            shader.uniforms.screenOffset = SCREEN_OFFSET;\n            shader.uniforms.color = labelColor[axis];\n            shader.uniforms.angle = labelAngle[axis];\n            gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);\n          }\n\n          SCREEN_OFFSET[axis ^ 1] = screenScale * viewBox[2 + (axis ^ 1)] - 1.0;\n\n          if (tickEnable[axis + 2]) {\n            SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * tickPad[axis + 2];\n\n            if (start < end && tickOffset[end] > tickOffset[start]) {\n              shader.uniforms.dataAxis = DATA_AXIS;\n              shader.uniforms.screenOffset = SCREEN_OFFSET;\n              shader.uniforms.color = textColor[axis + 2];\n              shader.uniforms.angle = textAngle[axis + 2];\n              gl.drawArrays(gl.TRIANGLES, tickOffset[start], tickOffset[end] - tickOffset[start]);\n            }\n          }\n\n          if (labelEnable[axis + 2] && labelCount) {\n            SCREEN_OFFSET[axis ^ 1] += screenScale * pixelRatio * labelPad[axis + 2];\n            shader.uniforms.dataAxis = ZERO_2;\n            shader.uniforms.screenOffset = SCREEN_OFFSET;\n            shader.uniforms.color = labelColor[axis + 2];\n            shader.uniforms.angle = labelAngle[axis + 2];\n            gl.drawArrays(gl.TRIANGLES, labelOffset, labelCount);\n          }\n        };\n      }();\n\n      proto.drawTitle = function () {\n        var DATA_AXIS = [0, 0];\n        var SCREEN_OFFSET = [0, 0];\n        return function () {\n          var plot = this.plot;\n          var shader = this.shader;\n          var gl = plot.gl;\n          var screenBox = plot.screenBox;\n          var titleCenter = plot.titleCenter;\n          var titleAngle = plot.titleAngle;\n          var titleColor = plot.titleColor;\n          var pixelRatio = plot.pixelRatio;\n\n          if (!this.titleCount) {\n            return;\n          }\n\n          for (var i = 0; i < 2; ++i) {\n            SCREEN_OFFSET[i] = 2.0 * (titleCenter[i] * pixelRatio - screenBox[i]) / (screenBox[2 + i] - screenBox[i]) - 1;\n          }\n\n          shader.bind();\n          shader.uniforms.dataAxis = DATA_AXIS;\n          shader.uniforms.screenOffset = SCREEN_OFFSET;\n          shader.uniforms.angle = titleAngle;\n          shader.uniforms.color = titleColor;\n          gl.drawArrays(gl.TRIANGLES, this.titleOffset, this.titleCount);\n        };\n      }();\n\n      proto.bind = function () {\n        var DATA_SHIFT = [0, 0];\n        var DATA_SCALE = [0, 0];\n        var TEXT_SCALE = [0, 0];\n        return function () {\n          var plot = this.plot;\n          var shader = this.shader;\n          var bounds = plot._tickBounds;\n          var dataBox = plot.dataBox;\n          var screenBox = plot.screenBox;\n          var viewBox = plot.viewBox;\n          shader.bind(); //Set up coordinate scaling uniforms\n\n          for (var i = 0; i < 2; ++i) {\n            var lo = bounds[i];\n            var hi = bounds[i + 2];\n            var boundScale = hi - lo;\n            var dataCenter = 0.5 * (dataBox[i + 2] + dataBox[i]);\n            var dataWidth = dataBox[i + 2] - dataBox[i];\n            var viewLo = viewBox[i];\n            var viewHi = viewBox[i + 2];\n            var viewScale = viewHi - viewLo;\n            var screenLo = screenBox[i];\n            var screenHi = screenBox[i + 2];\n            var screenScale = screenHi - screenLo;\n            DATA_SCALE[i] = 2.0 * boundScale / dataWidth * viewScale / screenScale;\n            DATA_SHIFT[i] = 2.0 * (lo - dataCenter) / dataWidth * viewScale / screenScale;\n          }\n\n          TEXT_SCALE[1] = 2.0 * plot.pixelRatio / (screenBox[3] - screenBox[1]);\n          TEXT_SCALE[0] = TEXT_SCALE[1] * (screenBox[3] - screenBox[1]) / (screenBox[2] - screenBox[0]);\n          shader.uniforms.dataScale = DATA_SCALE;\n          shader.uniforms.dataShift = DATA_SHIFT;\n          shader.uniforms.textScale = TEXT_SCALE; //Set attributes\n\n          this.vbo.bind();\n          shader.attributes.textCoordinate.pointer();\n        };\n      }();\n\n      proto.update = function (options) {\n        var vertices = [];\n        var axesTicks = options.ticks;\n        var bounds = options.bounds;\n        var i, j, k, data, scale, dimension;\n\n        for (dimension = 0; dimension < 2; ++dimension) {\n          var offsets = [Math.floor(vertices.length / 3)],\n              tickX = [-Infinity]; //Copy vertices over to buffer\n\n          var ticks = axesTicks[dimension];\n\n          for (i = 0; i < ticks.length; ++i) {\n            var tick = ticks[i];\n            var x = tick.x;\n            var text = tick.text;\n            var font = tick.font || 'sans-serif';\n            scale = tick.fontSize || 12;\n            var coordScale = 1.0 / (bounds[dimension + 2] - bounds[dimension]);\n            var coordShift = bounds[dimension];\n            var rows = text.split('\\n');\n\n            for (var r = 0; r < rows.length; r++) {\n              data = getText(font, rows[r]).data;\n\n              for (j = 0; j < data.length; j += 2) {\n                vertices.push(data[j] * scale, -data[j + 1] * scale - r * scale * 1.2, (x - coordShift) * coordScale);\n              }\n            }\n\n            offsets.push(Math.floor(vertices.length / 3));\n            tickX.push(x);\n          }\n\n          this.tickOffset[dimension] = offsets;\n          this.tickX[dimension] = tickX;\n        } //Add labels\n\n\n        for (dimension = 0; dimension < 2; ++dimension) {\n          this.labelOffset[dimension] = Math.floor(vertices.length / 3);\n          data = getText(options.labelFont[dimension], options.labels[dimension], {\n            textAlign: 'center'\n          }).data;\n          scale = options.labelSize[dimension];\n\n          for (i = 0; i < data.length; i += 2) {\n            vertices.push(data[i] * scale, -data[i + 1] * scale, 0);\n          }\n\n          this.labelCount[dimension] = Math.floor(vertices.length / 3) - this.labelOffset[dimension];\n        } //Add title\n\n\n        this.titleOffset = Math.floor(vertices.length / 3);\n        data = getText(options.titleFont, options.title).data;\n        scale = options.titleSize;\n\n        for (i = 0; i < data.length; i += 2) {\n          vertices.push(data[i] * scale, -data[i + 1] * scale, 0);\n        }\n\n        this.titleCount = Math.floor(vertices.length / 3) - this.titleOffset; //Upload new vertices\n\n        this.vbo.update(vertices);\n      };\n\n      proto.dispose = function () {\n        this.vbo.dispose();\n        this.shader.dispose();\n      };\n\n      function createTextElements(plot) {\n        var gl = plot.gl;\n        var vbo = createBuffer(gl);\n        var shader = createShader(gl, shaders.textVert, shaders.textFrag);\n        var text = new TextElements(plot, vbo, shader);\n        return text;\n      }\n    }, {\n      \"./shaders\": 116,\n      \"binary-search-bounds\": 31,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132,\n      \"text-cache\": 303\n    }],\n    118: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createGLPlot2D;\n\n      var createPick = _glvis_('gl-select-static');\n\n      var createGrid = _glvis_('./lib/grid');\n\n      var createText = _glvis_('./lib/text');\n\n      var createLine = _glvis_('./lib/line');\n\n      var createBox = _glvis_('./lib/box');\n\n      function GLPlot2D(gl, pickBuffer) {\n        this.gl = gl;\n        this.pickBuffer = pickBuffer;\n        this.screenBox = [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight];\n        this.viewBox = [0, 0, 0, 0];\n        this.dataBox = [-10, -10, 10, 10];\n        this.gridLineEnable = [true, true];\n        this.gridLineWidth = [1, 1];\n        this.gridLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];\n        this.pixelRatio = 1;\n        this.tickMarkLength = [0, 0, 0, 0];\n        this.tickMarkWidth = [0, 0, 0, 0];\n        this.tickMarkColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.tickPad = [15, 15, 15, 15];\n        this.tickAngle = [0, 0, 0, 0];\n        this.tickEnable = [true, true, true, true];\n        this.tickColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.labelPad = [15, 15, 15, 15];\n        this.labelAngle = [0, Math.PI / 2, 0, 3.0 * Math.PI / 2];\n        this.labelEnable = [true, true, true, true];\n        this.labelColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.titleCenter = [0, 0];\n        this.titleEnable = true;\n        this.titleAngle = 0;\n        this.titleColor = [0, 0, 0, 1];\n        this.borderColor = [0, 0, 0, 0];\n        this.backgroundColor = [0, 0, 0, 0];\n        this.zeroLineEnable = [true, true];\n        this.zeroLineWidth = [4, 4];\n        this.zeroLineColor = [[0, 0, 0, 1], [0, 0, 0, 1]];\n        this.borderLineEnable = [true, true, true, true];\n        this.borderLineWidth = [2, 2, 2, 2];\n        this.borderLineColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]; //Drawing parameters\n\n        this.grid = null;\n        this.text = null;\n        this.line = null;\n        this.box = null;\n        this.objects = [];\n        this.overlays = [];\n        this._tickBounds = [Infinity, Infinity, -Infinity, -Infinity];\n        this.static = false;\n        this.dirty = false;\n        this.pickDirty = false;\n        this.pickDelay = 120;\n        this.pickRadius = 10;\n        this._pickTimeout = null;\n        this._drawPick = this.drawPick.bind(this);\n        this._depthCounter = 0;\n      }\n\n      var proto = GLPlot2D.prototype;\n\n      proto.setDirty = function () {\n        this.dirty = this.pickDirty = true;\n      };\n\n      proto.setOverlayDirty = function () {\n        this.dirty = true;\n      };\n\n      proto.nextDepthValue = function () {\n        return this._depthCounter++ / 65536.0;\n      };\n\n      function lerp(a, b, t) {\n        var s = 0.5 * (t + 1.0);\n        return Math.floor((1.0 - s) * a + s * b) | 0;\n      }\n\n      proto.draw = function () {\n        var TICK_MARK_BOX = [0, 0, 0, 0];\n        return function () {\n          var gl = this.gl;\n          var screenBox = this.screenBox;\n          var viewPixels = this.viewBox;\n          var dataBox = this.dataBox;\n          var pixelRatio = this.pixelRatio;\n          var grid = this.grid;\n          var line = this.line;\n          var text = this.text;\n          var objects = this.objects;\n          this._depthCounter = 0;\n\n          if (this.pickDirty) {\n            if (this._pickTimeout) {\n              clearTimeout(this._pickTimeout);\n            }\n\n            this.pickDirty = false;\n            this._pickTimeout = setTimeout(this._drawPick, this.pickDelay);\n          }\n\n          if (!this.dirty) {\n            return;\n          }\n\n          this.dirty = false;\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null); //Turn on scissor\n\n          gl.enable(gl.SCISSOR_TEST); //Turn off depth buffer\n\n          gl.disable(gl.DEPTH_TEST);\n          gl.depthFunc(gl.LESS);\n          gl.depthMask(false); //Configure premultiplied alpha blending\n\n          gl.enable(gl.BLEND);\n          gl.blendEquation(gl.FUNC_ADD, gl.FUNC_ADD);\n          gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); //Draw border\n\n          if (this.borderColor) {\n            gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);\n            var borderColor = this.borderColor;\n            gl.clearColor(borderColor[0] * borderColor[3], borderColor[1] * borderColor[3], borderColor[2] * borderColor[3], borderColor[3]);\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n          } //Draw center pane\n\n\n          gl.scissor(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);\n          gl.viewport(viewPixels[0], viewPixels[1], viewPixels[2] - viewPixels[0], viewPixels[3] - viewPixels[1]);\n          var backgroundColor = this.backgroundColor;\n          gl.clearColor(backgroundColor[0] * backgroundColor[3], backgroundColor[1] * backgroundColor[3], backgroundColor[2] * backgroundColor[3], backgroundColor[3]);\n          gl.clear(gl.COLOR_BUFFER_BIT); //Draw grid\n\n          grid.draw(); //Draw zero lines separately\n\n          var zeroLineEnable = this.zeroLineEnable;\n          var zeroLineColor = this.zeroLineColor;\n          var zeroLineWidth = this.zeroLineWidth;\n\n          if (zeroLineEnable[0] || zeroLineEnable[1]) {\n            line.bind();\n\n            for (var i = 0; i < 2; ++i) {\n              if (!zeroLineEnable[i] || !(dataBox[i] <= 0 && dataBox[i + 2] >= 0)) {\n                continue;\n              }\n\n              var zeroIntercept = screenBox[i] - dataBox[i] * (screenBox[i + 2] - screenBox[i]) / (dataBox[i + 2] - dataBox[i]);\n\n              if (i === 0) {\n                line.drawLine(zeroIntercept, screenBox[1], zeroIntercept, screenBox[3], zeroLineWidth[i], zeroLineColor[i]);\n              } else {\n                line.drawLine(screenBox[0], zeroIntercept, screenBox[2], zeroIntercept, zeroLineWidth[i], zeroLineColor[i]);\n              }\n            }\n          } //Draw traces\n\n\n          for (var i = 0; i < objects.length; ++i) {\n            objects[i].draw();\n          } //Return viewport to default\n\n\n          gl.viewport(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]);\n          gl.scissor(screenBox[0], screenBox[1], screenBox[2] - screenBox[0], screenBox[3] - screenBox[1]); //Draw tick marks\n\n          this.grid.drawTickMarks(); //Draw line elements\n\n          line.bind(); //Draw border lines\n\n          var borderLineEnable = this.borderLineEnable;\n          var borderLineWidth = this.borderLineWidth;\n          var borderLineColor = this.borderLineColor;\n\n          if (borderLineEnable[1]) {\n            line.drawLine(viewPixels[0], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[0], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[1], borderLineColor[1]);\n          }\n\n          if (borderLineEnable[0]) {\n            line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[1], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[1], borderLineWidth[0], borderLineColor[0]);\n          }\n\n          if (borderLineEnable[3]) {\n            line.drawLine(viewPixels[2], viewPixels[1] - 0.5 * borderLineWidth[1] * pixelRatio, viewPixels[2], viewPixels[3] + 0.5 * borderLineWidth[3] * pixelRatio, borderLineWidth[3], borderLineColor[3]);\n          }\n\n          if (borderLineEnable[2]) {\n            line.drawLine(viewPixels[0] - 0.5 * borderLineWidth[0] * pixelRatio, viewPixels[3], viewPixels[2] + 0.5 * borderLineWidth[2] * pixelRatio, viewPixels[3], borderLineWidth[2], borderLineColor[2]);\n          } //Draw text elements\n\n\n          text.bind();\n\n          for (var i = 0; i < 2; ++i) {\n            text.drawTicks(i);\n          }\n\n          if (this.titleEnable) {\n            text.drawTitle();\n          } //Draw other overlay elements (select boxes, etc.)\n\n\n          var overlays = this.overlays;\n\n          for (var i = 0; i < overlays.length; ++i) {\n            overlays[i].draw();\n          } //Turn off scissor test\n\n\n          gl.disable(gl.SCISSOR_TEST);\n          gl.disable(gl.BLEND);\n          gl.depthMask(true);\n        };\n      }();\n\n      proto.drawPick = function () {\n        return function () {\n          if (this.static) return;\n          var pickBuffer = this.pickBuffer;\n          var gl = this.gl;\n          this._pickTimeout = null;\n          pickBuffer.begin();\n          var pickOffset = 1;\n          var objects = this.objects;\n\n          for (var i = 0; i < objects.length; ++i) {\n            pickOffset = objects[i].drawPick(pickOffset);\n          }\n\n          pickBuffer.end();\n        };\n      }();\n\n      proto.pick = function () {\n        return function (x, y) {\n          if (this.static) return;\n          var pixelRatio = this.pixelRatio;\n          var pickPixelRatio = this.pickPixelRatio;\n          var viewBox = this.viewBox;\n          var scrX = Math.round((x - viewBox[0] / pixelRatio) * pickPixelRatio) | 0;\n          var scrY = Math.round((y - viewBox[1] / pixelRatio) * pickPixelRatio) | 0;\n          var pickResult = this.pickBuffer.query(scrX, scrY, this.pickRadius);\n\n          if (!pickResult) {\n            return null;\n          }\n\n          var pickValue = pickResult.id + (pickResult.value[0] << 8) + (pickResult.value[1] << 16) + (pickResult.value[2] << 24);\n          var objects = this.objects;\n\n          for (var i = 0; i < objects.length; ++i) {\n            var result = objects[i].pick(scrX, scrY, pickValue);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          return null;\n        };\n      }();\n\n      function deepClone(array) {\n        var result = array.slice();\n\n        for (var i = 0; i < result.length; ++i) {\n          result[i] = result[i].slice();\n        }\n\n        return result;\n      }\n\n      function compareTicks(a, b) {\n        return a.x - b.x;\n      }\n\n      proto.setScreenBox = function (nbox) {\n        var screenBox = this.screenBox;\n        var pixelRatio = this.pixelRatio;\n        screenBox[0] = Math.round(nbox[0] * pixelRatio) | 0;\n        screenBox[1] = Math.round(nbox[1] * pixelRatio) | 0;\n        screenBox[2] = Math.round(nbox[2] * pixelRatio) | 0;\n        screenBox[3] = Math.round(nbox[3] * pixelRatio) | 0;\n        this.setDirty();\n      };\n\n      proto.setDataBox = function (nbox) {\n        var dataBox = this.dataBox;\n        var different = dataBox[0] !== nbox[0] || dataBox[1] !== nbox[1] || dataBox[2] !== nbox[2] || dataBox[3] !== nbox[3];\n\n        if (different) {\n          dataBox[0] = nbox[0];\n          dataBox[1] = nbox[1];\n          dataBox[2] = nbox[2];\n          dataBox[3] = nbox[3];\n          this.setDirty();\n        }\n      };\n\n      proto.setViewBox = function (nbox) {\n        var pixelRatio = this.pixelRatio;\n        var viewBox = this.viewBox;\n        viewBox[0] = Math.round(nbox[0] * pixelRatio) | 0;\n        viewBox[1] = Math.round(nbox[1] * pixelRatio) | 0;\n        viewBox[2] = Math.round(nbox[2] * pixelRatio) | 0;\n        viewBox[3] = Math.round(nbox[3] * pixelRatio) | 0;\n        var pickPixelRatio = this.pickPixelRatio;\n        this.pickBuffer.shape = [Math.round((nbox[2] - nbox[0]) * pickPixelRatio) | 0, Math.round((nbox[3] - nbox[1]) * pickPixelRatio) | 0];\n        this.setDirty();\n      };\n\n      proto.update = function (options) {\n        options = options || {};\n        var gl = this.gl;\n        this.pixelRatio = options.pixelRatio || 1;\n        var pixelRatio = this.pixelRatio;\n        this.pickPixelRatio = Math.max(pixelRatio, 1);\n        this.setScreenBox(options.screenBox || [0, 0, gl.drawingBufferWidth / pixelRatio, gl.drawingBufferHeight / pixelRatio]);\n        var screenBox = this.screenBox;\n        this.setViewBox(options.viewBox || [0.125 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.125 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio, 0.875 * (this.screenBox[2] - this.screenBox[0]) / pixelRatio, 0.875 * (this.screenBox[3] - this.screenBox[1]) / pixelRatio]);\n        var viewBox = this.viewBox;\n        var aspectRatio = (viewBox[2] - viewBox[0]) / (viewBox[3] - viewBox[1]);\n        this.setDataBox(options.dataBox || [-10, -10 / aspectRatio, 10, 10 / aspectRatio]);\n        this.borderColor = options.borderColor !== false ? (options.borderColor || [0, 0, 0, 0]).slice() : false;\n        this.backgroundColor = (options.backgroundColor || [0, 0, 0, 0]).slice();\n        this.gridLineEnable = (options.gridLineEnable || [true, true]).slice();\n        this.gridLineWidth = (options.gridLineWidth || [1, 1]).slice();\n        this.gridLineColor = deepClone(options.gridLineColor || [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]);\n        this.zeroLineEnable = (options.zeroLineEnable || [true, true]).slice();\n        this.zeroLineWidth = (options.zeroLineWidth || [4, 4]).slice();\n        this.zeroLineColor = deepClone(options.zeroLineColor || [[0, 0, 0, 1], [0, 0, 0, 1]]);\n        this.tickMarkLength = (options.tickMarkLength || [0, 0, 0, 0]).slice();\n        this.tickMarkWidth = (options.tickMarkWidth || [0, 0, 0, 0]).slice();\n        this.tickMarkColor = deepClone(options.tickMarkColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n        this.titleCenter = (options.titleCenter || [0.5 * (viewBox[0] + viewBox[2]) / pixelRatio, (viewBox[3] + 120) / pixelRatio]).slice();\n        this.titleEnable = !('titleEnable' in options) || !!options.titleEnable;\n        this.titleAngle = options.titleAngle || 0;\n        this.titleColor = (options.titleColor || [0, 0, 0, 1]).slice();\n        this.labelPad = (options.labelPad || [15, 15, 15, 15]).slice();\n        this.labelAngle = (options.labelAngle || [0, Math.PI / 2, 0, 3.0 * Math.PI / 2]).slice();\n        this.labelEnable = (options.labelEnable || [true, true, true, true]).slice();\n        this.labelColor = deepClone(options.labelColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n        this.tickPad = (options.tickPad || [15, 15, 15, 15]).slice();\n        this.tickAngle = (options.tickAngle || [0, 0, 0, 0]).slice();\n        this.tickEnable = (options.tickEnable || [true, true, true, true]).slice();\n        this.tickColor = deepClone(options.tickColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n        this.borderLineEnable = (options.borderLineEnable || [true, true, true, true]).slice();\n        this.borderLineWidth = (options.borderLineWidth || [2, 2, 2, 2]).slice();\n        this.borderLineColor = deepClone(options.borderLineColor || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]);\n        var ticks = options.ticks || [[], []]; //Compute bounds on ticks\n\n        var bounds = this._tickBounds;\n        bounds[0] = bounds[1] = Infinity;\n        bounds[2] = bounds[3] = -Infinity;\n\n        for (var i = 0; i < 2; ++i) {\n          var axisTicks = ticks[i].slice(0);\n\n          if (axisTicks.length === 0) {\n            continue;\n          }\n\n          axisTicks.sort(compareTicks);\n          bounds[i] = Math.min(bounds[i], axisTicks[0].x);\n          bounds[i + 2] = Math.max(bounds[i + 2], axisTicks[axisTicks.length - 1].x);\n        } //Update grid\n\n\n        this.grid.update({\n          bounds: bounds,\n          ticks: ticks\n        }); //Update text\n\n        this.text.update({\n          bounds: bounds,\n          ticks: ticks,\n          labels: options.labels || ['x', 'y'],\n          labelSize: options.labelSize || [12, 12],\n          labelFont: options.labelFont || ['sans-serif', 'sans-serif'],\n          title: options.title || '',\n          titleSize: options.titleSize || 18,\n          titleFont: options.titleFont || 'sans-serif'\n        });\n        this.static = !!options.static;\n        this.setDirty();\n      };\n\n      proto.dispose = function () {\n        this.box.dispose();\n        this.grid.dispose();\n        this.text.dispose();\n        this.line.dispose();\n\n        for (var i = this.objects.length - 1; i >= 0; --i) {\n          this.objects[i].dispose();\n        }\n\n        this.objects.length = 0;\n\n        for (var i = this.overlays.length - 1; i >= 0; --i) {\n          this.overlays[i].dispose();\n        }\n\n        this.overlays.length = 0;\n        this.gl = null;\n      };\n\n      proto.addObject = function (object) {\n        if (this.objects.indexOf(object) < 0) {\n          this.objects.push(object);\n          this.setDirty();\n        }\n      };\n\n      proto.removeObject = function (object) {\n        var objects = this.objects;\n\n        for (var i = 0; i < objects.length; ++i) {\n          if (objects[i] === object) {\n            objects.splice(i, 1);\n            this.setDirty();\n            break;\n          }\n        }\n      };\n\n      proto.addOverlay = function (object) {\n        if (this.overlays.indexOf(object) < 0) {\n          this.overlays.push(object);\n          this.setOverlayDirty();\n        }\n      };\n\n      proto.removeOverlay = function (object) {\n        var objects = this.overlays;\n\n        for (var i = 0; i < objects.length; ++i) {\n          if (objects[i] === object) {\n            objects.splice(i, 1);\n            this.setOverlayDirty();\n            break;\n          }\n        }\n      };\n\n      function createGLPlot2D(options) {\n        var gl = options.gl;\n        var pickBuffer = createPick(gl, [gl.drawingBufferWidth, gl.drawingBufferHeight]);\n        var plot = new GLPlot2D(gl, pickBuffer);\n        plot.grid = createGrid(plot);\n        plot.text = createText(plot);\n        plot.line = createLine(plot);\n        plot.box = createBox(plot);\n        plot.update(options);\n        return plot;\n      }\n    }, {\n      \"./lib/box\": 113,\n      \"./lib/grid\": 114,\n      \"./lib/line\": 115,\n      \"./lib/text\": 117,\n      \"gl-select-static\": 131\n    }],\n    119: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createCamera;\n\n      var now = _glvis_('right-now');\n\n      var createView = _glvis_('3d-view');\n\n      var mouseChange = _glvis_('mouse-change');\n\n      var mouseWheel = _glvis_('mouse-wheel');\n\n      var mouseOffset = _glvis_('mouse-event-offset');\n\n      var hasPassive = _glvis_('has-passive-events');\n\n      function createCamera(element, options) {\n        element = element || document.body;\n        options = options || {};\n        var limits = [0.01, Infinity];\n\n        if ('distanceLimits' in options) {\n          limits[0] = options.distanceLimits[0];\n          limits[1] = options.distanceLimits[1];\n        }\n\n        if ('zoomMin' in options) {\n          limits[0] = options.zoomMin;\n        }\n\n        if ('zoomMax' in options) {\n          limits[1] = options.zoomMax;\n        }\n\n        var view = createView({\n          center: options.center || [0, 0, 0],\n          up: options.up || [0, 1, 0],\n          eye: options.eye || [0, 0, 10],\n          mode: options.mode || 'orbit',\n          distanceLimits: limits\n        });\n        var pmatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        var distance = 0.0;\n        var width = element.clientWidth;\n        var height = element.clientHeight;\n        var camera = {\n          keyBindingMode: 'rotate',\n          enableWheel: true,\n          view: view,\n          element: element,\n          delay: options.delay || 16,\n          rotateSpeed: options.rotateSpeed || 1,\n          zoomSpeed: options.zoomSpeed || 1,\n          translateSpeed: options.translateSpeed || 1,\n          flipX: !!options.flipX,\n          flipY: !!options.flipY,\n          modes: view.modes,\n          _ortho: options._ortho || options.projection && options.projection.type === 'orthographic' || false,\n          tick: function tick() {\n            var t = now();\n            var delay = this.delay;\n            var ctime = t - 2 * delay;\n            view.idle(t - delay);\n            view.recalcMatrix(ctime);\n            view.flush(t - (100 + delay * 2));\n            var allEqual = true;\n            var matrix = view.computedMatrix;\n\n            for (var i = 0; i < 16; ++i) {\n              allEqual = allEqual && pmatrix[i] === matrix[i];\n              pmatrix[i] = matrix[i];\n            }\n\n            var sizeChanged = element.clientWidth === width && element.clientHeight === height;\n            width = element.clientWidth;\n            height = element.clientHeight;\n\n            if (allEqual) {\n              return !sizeChanged;\n            }\n\n            distance = Math.exp(view.computedRadius[0]);\n            return true;\n          },\n          lookAt: function lookAt(eye, center, up) {\n            view.lookAt(view.lastT(), eye, center, up);\n          },\n          rotate: function rotate(pitch, yaw, roll) {\n            view.rotate(view.lastT(), pitch, yaw, roll);\n          },\n          pan: function pan(dx, dy, dz) {\n            view.pan(view.lastT(), dx, dy, dz);\n          },\n          translate: function translate(dx, dy, dz) {\n            view.translate(view.lastT(), dx, dy, dz);\n          }\n        };\n        Object.defineProperties(camera, {\n          matrix: {\n            get: function get() {\n              return view.computedMatrix;\n            },\n            set: function set(mat) {\n              view.setMatrix(view.lastT(), mat);\n              return view.computedMatrix;\n            },\n            enumerable: true\n          },\n          mode: {\n            get: function get() {\n              return view.getMode();\n            },\n            set: function set(mode) {\n              var curUp = view.computedUp.slice();\n              var curEye = view.computedEye.slice();\n              var curCenter = view.computedCenter.slice();\n              view.setMode(mode);\n\n              if (mode === 'turntable') {\n                // Hacky time warping stuff to generate smooth animation\n                var t0 = now();\n\n                view._active.lookAt(t0, curEye, curCenter, curUp);\n\n                view._active.lookAt(t0 + 500, curEye, curCenter, [0, 0, 1]);\n\n                view._active.flush(t0);\n              }\n\n              return view.getMode();\n            },\n            enumerable: true\n          },\n          center: {\n            get: function get() {\n              return view.computedCenter;\n            },\n            set: function set(ncenter) {\n              view.lookAt(view.lastT(), null, ncenter);\n              return view.computedCenter;\n            },\n            enumerable: true\n          },\n          eye: {\n            get: function get() {\n              return view.computedEye;\n            },\n            set: function set(neye) {\n              view.lookAt(view.lastT(), neye);\n              return view.computedEye;\n            },\n            enumerable: true\n          },\n          up: {\n            get: function get() {\n              return view.computedUp;\n            },\n            set: function set(nup) {\n              view.lookAt(view.lastT(), null, null, nup);\n              return view.computedUp;\n            },\n            enumerable: true\n          },\n          distance: {\n            get: function get() {\n              return distance;\n            },\n            set: function set(d) {\n              view.setDistance(view.lastT(), d);\n              return d;\n            },\n            enumerable: true\n          },\n          distanceLimits: {\n            get: function get() {\n              return view.getDistanceLimits(limits);\n            },\n            set: function set(v) {\n              view.setDistanceLimits(v);\n              return v;\n            },\n            enumerable: true\n          }\n        });\n        element.addEventListener('contextmenu', function (ev) {\n          ev.preventDefault();\n          return false;\n        });\n        camera._lastX = -1;\n        camera._lastY = -1;\n        camera._lastMods = {\n          shift: false,\n          control: false,\n          alt: false,\n          meta: false\n        };\n\n        camera.enableMouseListeners = function () {\n          camera.mouseListener = mouseChange(element, handleInteraction); //enable simple touch interactions\n\n          element.addEventListener('touchstart', function (ev) {\n            var xy = mouseOffset(ev.changedTouches[0], element);\n            handleInteraction(0, xy[0], xy[1], camera._lastMods);\n            handleInteraction(1, xy[0], xy[1], camera._lastMods);\n          }, hasPassive ? {\n            passive: true\n          } : false);\n          element.addEventListener('touchmove', function (ev) {\n            var xy = mouseOffset(ev.changedTouches[0], element);\n            handleInteraction(1, xy[0], xy[1], camera._lastMods);\n            ev.preventDefault();\n          }, hasPassive ? {\n            passive: false\n          } : false);\n          element.addEventListener('touchend', function (ev) {\n            handleInteraction(0, camera._lastX, camera._lastY, camera._lastMods);\n          }, hasPassive ? {\n            passive: true\n          } : false);\n\n          function handleInteraction(buttons, x, y, mods) {\n            var keyBindingMode = camera.keyBindingMode;\n            if (keyBindingMode === false) return;\n            var rotate = keyBindingMode === 'rotate';\n            var pan = keyBindingMode === 'pan';\n            var zoom = keyBindingMode === 'zoom';\n            var ctrl = !!mods.control;\n            var alt = !!mods.alt;\n            var shift = !!mods.shift;\n            var left = !!(buttons & 1);\n            var right = !!(buttons & 2);\n            var middle = !!(buttons & 4);\n            var scale = 1.0 / element.clientHeight;\n            var dx = scale * (x - camera._lastX);\n            var dy = scale * (y - camera._lastY);\n            var flipX = camera.flipX ? 1 : -1;\n            var flipY = camera.flipY ? 1 : -1;\n            var drot = Math.PI * camera.rotateSpeed;\n            var t = now();\n\n            if (camera._lastX !== -1 && camera._lastY !== -1) {\n              if (rotate && left && !ctrl && !alt && !shift || left && !ctrl && !alt && shift) {\n                // Rotate\n                view.rotate(t, flipX * drot * dx, -flipY * drot * dy, 0);\n              }\n\n              if (pan && left && !ctrl && !alt && !shift || right || left && ctrl && !alt && !shift) {\n                // Pan\n                view.pan(t, -camera.translateSpeed * dx * distance, camera.translateSpeed * dy * distance, 0);\n              }\n\n              if (zoom && left && !ctrl && !alt && !shift || middle || left && !ctrl && alt && !shift) {\n                // Zoom\n                var kzoom = -camera.zoomSpeed * dy / window.innerHeight * (t - view.lastT()) * 100;\n                view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n              }\n            }\n\n            camera._lastX = x;\n            camera._lastY = y;\n            camera._lastMods = mods;\n            return true;\n          }\n\n          camera.wheelListener = mouseWheel(element, function (dx, dy) {\n            // TODO remove now that we can disable scroll via scrollZoom?\n            if (camera.keyBindingMode === false) return;\n            if (!camera.enableWheel) return;\n            var flipX = camera.flipX ? 1 : -1;\n            var flipY = camera.flipY ? 1 : -1;\n            var t = now();\n\n            if (Math.abs(dx) > Math.abs(dy)) {\n              view.rotate(t, 0, 0, -dx * flipX * Math.PI * camera.rotateSpeed / window.innerWidth);\n            } else {\n              if (!camera._ortho) {\n                var kzoom = -camera.zoomSpeed * flipY * dy / window.innerHeight * (t - view.lastT()) / 20.0;\n                view.pan(t, 0, 0, distance * (Math.exp(kzoom) - 1));\n              }\n            }\n          }, true);\n        };\n\n        camera.enableMouseListeners();\n        return camera;\n      }\n    }, {\n      \"3d-view\": 7,\n      \"has-passive-events\": 232,\n      \"mouse-change\": 247,\n      \"mouse-event-offset\": 248,\n      \"mouse-wheel\": 250,\n      \"right-now\": 278\n    }],\n    120: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      var createShader = _glvis_('gl-shader');\n\n      var vertSrc = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 uv;\\nvoid main() {\\n  uv = position;\\n  gl_Position = vec4(position, 0, 1);\\n}\"]);\n      var fragSrc = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D accumBuffer;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec4 accum = texture2D(accumBuffer, 0.5 * (uv + 1.0));\\n  gl_FragColor = min(vec4(1,1,1,1), accum);\\n}\"]);\n\n      module.exports = function (gl) {\n        return createShader(gl, vertSrc, fragSrc, null, [{\n          name: 'position',\n          type: 'vec2'\n        }]);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    121: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createCamera = _glvis_('./camera.js');\n\n      var createAxes = _glvis_('gl-axes3d');\n\n      var axesRanges = _glvis_('gl-axes3d/properties');\n\n      var createSpikes = _glvis_('gl-spikes3d');\n\n      var createSelect = _glvis_('gl-select-static');\n\n      var createFBO = _glvis_('gl-fbo');\n\n      var drawTriangle = _glvis_('a-big-triangle');\n\n      var mouseChange = _glvis_('mouse-change');\n\n      var perspective = _glvis_('gl-mat4/perspective');\n\n      var ortho = _glvis_('gl-mat4/ortho');\n\n      var createShader = _glvis_('./lib/shader');\n\n      var isMobile = _glvis_('is-mobile')({\n        tablet: true,\n        featureDetect: true\n      });\n\n      module.exports = {\n        createScene: createScene,\n        createCamera: createCamera\n      };\n\n      function MouseSelect() {\n        this.mouse = [-1, -1];\n        this.screen = null;\n        this.distance = Infinity;\n        this.index = null;\n        this.dataCoordinate = null;\n        this.dataPosition = null;\n        this.object = null;\n        this.data = null;\n      }\n\n      function getContext(canvas, options) {\n        var gl = null;\n\n        try {\n          gl = canvas.getContext('webgl', options);\n\n          if (!gl) {\n            gl = canvas.getContext('experimental-webgl', options);\n          }\n        } catch (e) {\n          return null;\n        }\n\n        return gl;\n      }\n\n      function roundUpPow10(x) {\n        var y = Math.round(Math.log(Math.abs(x)) / Math.log(10));\n\n        if (y < 0) {\n          var base = Math.round(Math.pow(10, -y));\n          return Math.ceil(x * base) / base;\n        } else if (y > 0) {\n          var base = Math.round(Math.pow(10, y));\n          return Math.ceil(x / base) * base;\n        }\n\n        return Math.ceil(x);\n      }\n\n      function defaultBool(x) {\n        if (typeof x === 'boolean') {\n          return x;\n        }\n\n        return true;\n      }\n\n      function createScene(options) {\n        options = options || {};\n        options.camera = options.camera || {};\n        var canvas = options.canvas;\n\n        if (!canvas) {\n          canvas = document.createElement('canvas');\n\n          if (options.container) {\n            var container = options.container;\n            container.appendChild(canvas);\n          } else {\n            document.body.appendChild(canvas);\n          }\n        }\n\n        var gl = options.gl;\n\n        if (!gl) {\n          if (options.glOptions) {\n            isMobile = !!options.glOptions.preserveDrawingBuffer;\n          }\n\n          gl = getContext(canvas, options.glOptions || {\n            premultipliedAlpha: true,\n            antialias: true,\n            preserveDrawingBuffer: isMobile\n          });\n        }\n\n        if (!gl) {\n          throw new Error('webgl not supported');\n        } //Initial bounds\n\n\n        var bounds = options.bounds || [[-10, -10, -10], [10, 10, 10]]; //Create selection\n\n        var selection = new MouseSelect(); //Accumulation buffer\n\n        var accumBuffer = createFBO(gl, gl.drawingBufferWidth, gl.drawingBufferHeight, {\n          preferFloat: !isMobile\n        });\n        var accumShader = createShader(gl);\n        var isOrtho = options.cameraObject && options.cameraObject._ortho === true || options.camera.projection && options.camera.projection.type === 'orthographic' || false; //Create a camera\n\n        var cameraOptions = {\n          eye: options.camera.eye || [2, 0, 0],\n          center: options.camera.center || [0, 0, 0],\n          up: options.camera.up || [0, 1, 0],\n          zoomMin: options.camera.zoomMax || 0.1,\n          zoomMax: options.camera.zoomMin || 100,\n          mode: options.camera.mode || 'turntable',\n          _ortho: isOrtho //Create axes\n\n        };\n        var axesOptions = options.axes || {};\n        var axes = createAxes(gl, axesOptions);\n        axes.enable = !axesOptions.disable; //Create spikes\n\n        var spikeOptions = options.spikes || {};\n        var spikes = createSpikes(gl, spikeOptions); //Object list is empty initially\n\n        var objects = [];\n        var pickBufferIds = [];\n        var pickBufferCount = [];\n        var pickBuffers = []; //Dirty flag, skip redraw if scene static\n\n        var dirty = true;\n        var pickDirty = true;\n        var projection = new Array(16);\n        var model = new Array(16);\n        var cameraParams = {\n          view: null,\n          projection: projection,\n          model: model,\n          _ortho: false\n        };\n        var pickDirty = true;\n        var viewShape = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n        var camera = options.cameraObject || createCamera(canvas, cameraOptions); //Create scene object\n\n        var scene = {\n          gl: gl,\n          contextLost: false,\n          pixelRatio: options.pixelRatio || 1,\n          canvas: canvas,\n          selection: selection,\n          camera: camera,\n          axes: axes,\n          axesPixels: null,\n          spikes: spikes,\n          bounds: bounds,\n          objects: objects,\n          shape: viewShape,\n          aspect: options.aspectRatio || [1, 1, 1],\n          pickRadius: options.pickRadius || 10,\n          zNear: options.zNear || 0.01,\n          zFar: options.zFar || 1000,\n          fovy: options.fovy || Math.PI / 4,\n          clearColor: options.clearColor || [0, 0, 0, 0],\n          autoResize: defaultBool(options.autoResize),\n          autoBounds: defaultBool(options.autoBounds),\n          autoScale: !!options.autoScale,\n          autoCenter: defaultBool(options.autoCenter),\n          clipToBounds: defaultBool(options.clipToBounds),\n          snapToData: !!options.snapToData,\n          onselect: options.onselect || null,\n          onrender: options.onrender || null,\n          onclick: options.onclick || null,\n          cameraParams: cameraParams,\n          oncontextloss: null,\n          mouseListener: null,\n          _stopped: false,\n          getAspectratio: function getAspectratio() {\n            return {\n              x: this.aspect[0],\n              y: this.aspect[1],\n              z: this.aspect[2]\n            };\n          },\n          setAspectratio: function setAspectratio(aspectratio) {\n            this.aspect[0] = aspectratio.x;\n            this.aspect[1] = aspectratio.y;\n            this.aspect[2] = aspectratio.z;\n            pickDirty = true;\n          },\n          setBounds: function setBounds(axisIndex, range) {\n            this.bounds[0][axisIndex] = range.min;\n            this.bounds[1][axisIndex] = range.max;\n          },\n          setClearColor: function setClearColor(clearColor) {\n            this.clearColor = clearColor;\n          },\n          clearRGBA: function clearRGBA() {\n            this.gl.clearColor(this.clearColor[0], this.clearColor[1], this.clearColor[2], this.clearColor[3]);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n          }\n        };\n        var pickShape = [gl.drawingBufferWidth / scene.pixelRatio | 0, gl.drawingBufferHeight / scene.pixelRatio | 0];\n\n        function resizeListener() {\n          if (scene._stopped) {\n            return;\n          }\n\n          if (!scene.autoResize) {\n            return;\n          }\n\n          var parent = canvas.parentNode;\n          var width = 1;\n          var height = 1;\n\n          if (parent && parent !== document.body) {\n            width = parent.clientWidth;\n            height = parent.clientHeight;\n          } else {\n            width = window.innerWidth;\n            height = window.innerHeight;\n          }\n\n          var nextWidth = Math.ceil(width * scene.pixelRatio) | 0;\n          var nextHeight = Math.ceil(height * scene.pixelRatio) | 0;\n\n          if (nextWidth !== canvas.width || nextHeight !== canvas.height) {\n            canvas.width = nextWidth;\n            canvas.height = nextHeight;\n            var style = canvas.style;\n            style.position = style.position || 'absolute';\n            style.left = '0px';\n            style.top = '0px';\n            style.width = width + 'px';\n            style.height = height + 'px';\n            dirty = true;\n          }\n        }\n\n        if (scene.autoResize) {\n          resizeListener();\n        }\n\n        window.addEventListener('resize', resizeListener);\n\n        function reallocPickIds() {\n          var numObjs = objects.length;\n          var numPick = pickBuffers.length;\n\n          for (var i = 0; i < numPick; ++i) {\n            pickBufferCount[i] = 0;\n          }\n\n          obj_loop: for (var i = 0; i < numObjs; ++i) {\n            var obj = objects[i];\n            var pickCount = obj.pickSlots;\n\n            if (!pickCount) {\n              pickBufferIds[i] = -1;\n              continue;\n            }\n\n            for (var j = 0; j < numPick; ++j) {\n              if (pickBufferCount[j] + pickCount < 255) {\n                pickBufferIds[i] = j;\n                obj.setPickBase(pickBufferCount[j] + 1);\n                pickBufferCount[j] += pickCount;\n                continue obj_loop;\n              }\n            } //Create new pick buffer\n\n\n            var nbuffer = createSelect(gl, viewShape);\n            pickBufferIds[i] = numPick;\n            pickBuffers.push(nbuffer);\n            pickBufferCount.push(pickCount);\n            obj.setPickBase(1);\n            numPick += 1;\n          }\n\n          while (numPick > 0 && pickBufferCount[numPick - 1] === 0) {\n            pickBufferCount.pop();\n            pickBuffers.pop().dispose();\n          }\n        }\n\n        scene.update = function (options) {\n          if (scene._stopped) {\n            return;\n          }\n\n          options = options || {};\n          dirty = true;\n          pickDirty = true;\n        };\n\n        scene.add = function (obj) {\n          if (scene._stopped) {\n            return;\n          }\n\n          obj.axes = axes;\n          objects.push(obj);\n          pickBufferIds.push(-1);\n          dirty = true;\n          pickDirty = true;\n          reallocPickIds();\n        };\n\n        scene.remove = function (obj) {\n          if (scene._stopped) {\n            return;\n          }\n\n          var idx = objects.indexOf(obj);\n\n          if (idx < 0) {\n            return;\n          }\n\n          objects.splice(idx, 1);\n          pickBufferIds.pop();\n          dirty = true;\n          pickDirty = true;\n          reallocPickIds();\n        };\n\n        scene.dispose = function () {\n          if (scene._stopped) {\n            return;\n          }\n\n          scene._stopped = true;\n          window.removeEventListener('resize', resizeListener);\n          canvas.removeEventListener('webglcontextlost', checkContextLoss);\n          scene.mouseListener.enabled = false;\n\n          if (scene.contextLost) {\n            return;\n          } //Destroy objects\n\n\n          axes.dispose();\n          spikes.dispose();\n\n          for (var i = 0; i < objects.length; ++i) {\n            objects[i].dispose();\n          } //Clean up buffers\n\n\n          accumBuffer.dispose();\n\n          for (var i = 0; i < pickBuffers.length; ++i) {\n            pickBuffers[i].dispose();\n          } //Clean up shaders\n\n\n          accumShader.dispose(); //Release all references\n\n          gl = null;\n          axes = null;\n          spikes = null;\n          objects = [];\n        }; //Update mouse position\n\n\n        scene._mouseRotating = false;\n        scene._prevButtons = 0;\n\n        scene.enableMouseListeners = function () {\n          scene.mouseListener = mouseChange(canvas, function (buttons, x, y) {\n            if (scene._stopped) {\n              return;\n            }\n\n            var numPick = pickBuffers.length;\n            var numObjs = objects.length;\n            var prevObj = selection.object;\n            selection.distance = Infinity;\n            selection.mouse[0] = x;\n            selection.mouse[1] = y;\n            selection.object = null;\n            selection.screen = null;\n            selection.dataCoordinate = selection.dataPosition = null;\n            var change = false;\n\n            if (buttons && scene._prevButtons) {\n              scene._mouseRotating = true;\n            } else {\n              if (scene._mouseRotating) {\n                pickDirty = true;\n              }\n\n              scene._mouseRotating = false;\n\n              for (var i = 0; i < numPick; ++i) {\n                var result = pickBuffers[i].query(x, pickShape[1] - y - 1, scene.pickRadius);\n\n                if (result) {\n                  if (result.distance > selection.distance) {\n                    continue;\n                  }\n\n                  for (var j = 0; j < numObjs; ++j) {\n                    var obj = objects[j];\n\n                    if (pickBufferIds[j] !== i) {\n                      continue;\n                    }\n\n                    var objPick = obj.pick(result);\n\n                    if (objPick) {\n                      selection.buttons = buttons;\n                      selection.screen = result.coord;\n                      selection.distance = result.distance;\n                      selection.object = obj;\n                      selection.index = objPick.distance;\n                      selection.dataPosition = objPick.position;\n                      selection.dataCoordinate = objPick.dataCoordinate;\n                      selection.data = objPick;\n                      change = true;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (prevObj && prevObj !== selection.object) {\n              if (prevObj.highlight) {\n                prevObj.highlight(null);\n              }\n\n              dirty = true;\n            }\n\n            if (selection.object) {\n              if (selection.object.highlight) {\n                selection.object.highlight(selection.data);\n              }\n\n              dirty = true;\n            }\n\n            change = change || selection.object !== prevObj;\n\n            if (change && scene.onselect) {\n              scene.onselect(selection);\n            }\n\n            if (buttons & 1 && !(scene._prevButtons & 1) && scene.onclick) {\n              scene.onclick(selection);\n            }\n\n            scene._prevButtons = buttons;\n          });\n        };\n\n        function checkContextLoss() {\n          if (scene.contextLost) {\n            return true;\n          }\n\n          if (gl.isContextLost()) {\n            scene.contextLost = true;\n            scene.mouseListener.enabled = false;\n            scene.selection.object = null;\n\n            if (scene.oncontextloss) {\n              scene.oncontextloss();\n            }\n          }\n        }\n\n        canvas.addEventListener('webglcontextlost', checkContextLoss); //Render the scene for mouse picking\n\n        function renderPick() {\n          if (checkContextLoss()) {\n            return;\n          }\n\n          gl.colorMask(true, true, true, true);\n          gl.depthMask(true);\n          gl.disable(gl.BLEND);\n          gl.enable(gl.DEPTH_TEST);\n          gl.depthFunc(gl.LEQUAL);\n          var numObjs = objects.length;\n          var numPick = pickBuffers.length;\n\n          for (var j = 0; j < numPick; ++j) {\n            var buf = pickBuffers[j];\n            buf.shape = pickShape;\n            buf.begin();\n\n            for (var i = 0; i < numObjs; ++i) {\n              if (pickBufferIds[i] !== j) {\n                continue;\n              }\n\n              var obj = objects[i];\n\n              if (obj.drawPick) {\n                obj.pixelRatio = 1;\n                obj.drawPick(cameraParams);\n              }\n            }\n\n            buf.end();\n          }\n        }\n\n        var nBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        var prevBounds = [nBounds[0].slice(), nBounds[1].slice()];\n\n        function redraw() {\n          if (checkContextLoss()) {\n            return;\n          }\n\n          resizeListener(); //Tick camera\n\n          var cameraMoved = scene.camera.tick();\n          cameraParams.view = scene.camera.matrix;\n          dirty = dirty || cameraMoved;\n          pickDirty = pickDirty || cameraMoved; //Set pixel ratio\n\n          axes.pixelRatio = scene.pixelRatio;\n          spikes.pixelRatio = scene.pixelRatio; //Check if any objects changed, recalculate bounds\n\n          var numObjs = objects.length;\n          var lo = nBounds[0];\n          var hi = nBounds[1];\n          lo[0] = lo[1] = lo[2] = Infinity;\n          hi[0] = hi[1] = hi[2] = -Infinity;\n\n          for (var i = 0; i < numObjs; ++i) {\n            var obj = objects[i]; //Set the axes properties for each object\n\n            obj.pixelRatio = scene.pixelRatio;\n            obj.axes = scene.axes;\n            dirty = dirty || !!obj.dirty;\n            pickDirty = pickDirty || !!obj.dirty;\n            var obb = obj.bounds;\n\n            if (obb) {\n              var olo = obb[0];\n              var ohi = obb[1];\n\n              for (var j = 0; j < 3; ++j) {\n                lo[j] = Math.min(lo[j], olo[j]);\n                hi[j] = Math.max(hi[j], ohi[j]);\n              }\n            }\n          } //Recalculate bounds\n\n\n          var bounds = scene.bounds;\n\n          if (scene.autoBounds) {\n            for (var j = 0; j < 3; ++j) {\n              if (hi[j] < lo[j]) {\n                lo[j] = -1;\n                hi[j] = 1;\n              } else {\n                if (lo[j] === hi[j]) {\n                  lo[j] -= 1;\n                  hi[j] += 1;\n                }\n\n                var padding = 0.05 * (hi[j] - lo[j]);\n                lo[j] = lo[j] - padding;\n                hi[j] = hi[j] + padding;\n              }\n\n              bounds[0][j] = lo[j];\n              bounds[1][j] = hi[j];\n            }\n          }\n\n          var boundsChanged = false;\n\n          for (var j = 0; j < 3; ++j) {\n            boundsChanged = boundsChanged || prevBounds[0][j] !== bounds[0][j] || prevBounds[1][j] !== bounds[1][j];\n            prevBounds[0][j] = bounds[0][j];\n            prevBounds[1][j] = bounds[1][j];\n          } //Recalculate bounds\n\n\n          pickDirty = pickDirty || boundsChanged;\n          dirty = dirty || boundsChanged;\n\n          if (!dirty) {\n            return;\n          }\n\n          if (boundsChanged) {\n            var tickSpacing = [0, 0, 0];\n\n            for (var i = 0; i < 3; ++i) {\n              tickSpacing[i] = roundUpPow10((bounds[1][i] - bounds[0][i]) / 10.0);\n            }\n\n            if (axes.autoTicks) {\n              axes.update({\n                bounds: bounds,\n                tickSpacing: tickSpacing\n              });\n            } else {\n              axes.update({\n                bounds: bounds\n              });\n            }\n          } //Get scene\n\n\n          var width = gl.drawingBufferWidth;\n          var height = gl.drawingBufferHeight;\n          viewShape[0] = width;\n          viewShape[1] = height;\n          pickShape[0] = Math.max(width / scene.pixelRatio, 1) | 0;\n          pickShape[1] = Math.max(height / scene.pixelRatio, 1) | 0; //Compute camera parameters\n\n          calcCameraParams(scene, isOrtho); //Apply axes/clip bounds\n\n          for (var i = 0; i < numObjs; ++i) {\n            var obj = objects[i]; //Set axes bounds\n\n            obj.axesBounds = bounds; //Set clip bounds\n\n            if (scene.clipToBounds) {\n              obj.clipBounds = bounds;\n            }\n          } //Set spike parameters\n\n\n          if (selection.object) {\n            if (scene.snapToData) {\n              spikes.position = selection.dataCoordinate;\n            } else {\n              spikes.position = selection.dataPosition;\n            }\n\n            spikes.bounds = bounds;\n          } //If state changed, then redraw pick buffers\n\n\n          if (pickDirty) {\n            pickDirty = false;\n            renderPick();\n          } //Recalculate pixel data\n\n\n          scene.axesPixels = axesRanges(scene.axes, cameraParams, width, height); //Call render callback\n\n          if (scene.onrender) {\n            scene.onrender();\n          } //Read value\n\n\n          gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n          gl.viewport(0, 0, width, height); //General strategy: 3 steps\n          //  1. render non-transparent objects\n          //  2. accumulate transparent objects into separate fbo\n          //  3. composite final scene\n          //Clear FBO\n\n          scene.clearRGBA();\n          gl.depthMask(true);\n          gl.colorMask(true, true, true, true);\n          gl.enable(gl.DEPTH_TEST);\n          gl.depthFunc(gl.LEQUAL);\n          gl.disable(gl.BLEND);\n          gl.disable(gl.CULL_FACE); //most visualization surfaces are 2 sided\n          //Render opaque pass\n\n          var hasTransparent = false;\n\n          if (axes.enable) {\n            hasTransparent = hasTransparent || axes.isTransparent();\n            axes.draw(cameraParams);\n          }\n\n          spikes.axes = axes;\n\n          if (selection.object) {\n            spikes.draw(cameraParams);\n          }\n\n          gl.disable(gl.CULL_FACE); //most visualization surfaces are 2 sided\n\n          for (var i = 0; i < numObjs; ++i) {\n            var obj = objects[i];\n            obj.axes = axes;\n            obj.pixelRatio = scene.pixelRatio;\n\n            if (obj.isOpaque && obj.isOpaque()) {\n              obj.draw(cameraParams);\n            }\n\n            if (obj.isTransparent && obj.isTransparent()) {\n              hasTransparent = true;\n            }\n          }\n\n          if (hasTransparent) {\n            //Render transparent pass\n            accumBuffer.shape = viewShape;\n            accumBuffer.bind();\n            gl.clear(gl.DEPTH_BUFFER_BIT);\n            gl.colorMask(false, false, false, false);\n            gl.depthMask(true);\n            gl.depthFunc(gl.LESS); //Render forward facing objects\n\n            if (axes.enable && axes.isTransparent()) {\n              axes.drawTransparent(cameraParams);\n            }\n\n            for (var i = 0; i < numObjs; ++i) {\n              var obj = objects[i];\n\n              if (obj.isOpaque && obj.isOpaque()) {\n                obj.draw(cameraParams);\n              }\n            } //Render transparent pass\n\n\n            gl.enable(gl.BLEND);\n            gl.blendEquation(gl.FUNC_ADD);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.colorMask(true, true, true, true);\n            gl.depthMask(false);\n            gl.clearColor(0, 0, 0, 0);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n\n            if (axes.isTransparent()) {\n              axes.drawTransparent(cameraParams);\n            }\n\n            for (var i = 0; i < numObjs; ++i) {\n              var obj = objects[i];\n\n              if (obj.isTransparent && obj.isTransparent()) {\n                obj.drawTransparent(cameraParams);\n              }\n            } //Unbind framebuffer\n\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null); //Draw composite pass\n\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n            gl.disable(gl.DEPTH_TEST);\n            accumShader.bind();\n            accumBuffer.color[0].bind(0);\n            accumShader.uniforms.accumBuffer = 0;\n            drawTriangle(gl); //Turn off blending\n\n            gl.disable(gl.BLEND);\n          } //Clear dirty flags\n\n\n          dirty = false;\n\n          for (var i = 0; i < numObjs; ++i) {\n            objects[i].dirty = false;\n          }\n        } //Draw the whole scene\n\n\n        function render() {\n          if (scene._stopped || scene.contextLost) {\n            return;\n          } // this order is important: ios safari sometimes has sync raf\n\n\n          redraw();\n          requestAnimationFrame(render);\n        }\n\n        scene.enableMouseListeners();\n        render(); //Force redraw of whole scene\n\n        scene.redraw = function () {\n          if (scene._stopped) {\n            return;\n          }\n\n          dirty = true;\n          redraw();\n        };\n\n        return scene;\n      }\n\n      function calcCameraParams(scene, isOrtho) {\n        var bounds = scene.bounds;\n        var cameraParams = scene.cameraParams;\n        var projection = cameraParams.projection;\n        var model = cameraParams.model;\n        var width = scene.gl.drawingBufferWidth;\n        var height = scene.gl.drawingBufferHeight;\n        var zNear = scene.zNear;\n        var zFar = scene.zFar;\n        var fovy = scene.fovy;\n        var r = width / height;\n\n        if (isOrtho) {\n          ortho(projection, -r, r, -1, 1, zNear, zFar);\n          cameraParams._ortho = true;\n        } else {\n          perspective(projection, fovy, r, zNear, zFar);\n          cameraParams._ortho = false;\n        } //Compute model matrix\n\n\n        for (var i = 0; i < 16; ++i) {\n          model[i] = 0;\n        }\n\n        model[15] = 1;\n        var maxS = 0;\n\n        for (var i = 0; i < 3; ++i) {\n          maxS = Math.max(maxS, bounds[1][i] - bounds[0][i]);\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          if (scene.autoScale) {\n            model[5 * i] = scene.aspect[i] / (bounds[1][i] - bounds[0][i]);\n          } else {\n            model[5 * i] = 1 / maxS;\n          }\n\n          if (scene.autoCenter) {\n            model[12 + i] = -model[5 * i] * 0.5 * (bounds[0][i] + bounds[1][i]);\n          }\n        }\n      }\n    }, {\n      \"./camera.js\": 119,\n      \"./lib/shader\": 120,\n      \"a-big-triangle\": 8,\n      \"gl-axes3d\": 70,\n      \"gl-axes3d/properties\": 77,\n      \"gl-fbo\": 86,\n      \"gl-mat4/ortho\": 101,\n      \"gl-mat4/perspective\": 102,\n      \"gl-select-static\": 131,\n      \"gl-spikes3d\": 141,\n      \"is-mobile\": 238,\n      \"mouse-change\": 247\n    }],\n    122: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      exports.pointVertex = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nuniform mat3 matrix;\\nuniform float pointSize;\\nuniform float pointCloud;\\n\\nhighp float rand(vec2 co) {\\n  highp float a = 12.9898;\\n  highp float b = 78.233;\\n  highp float c = 43758.5453;\\n  highp float d = dot(co.xy, vec2(a, b));\\n  highp float e = mod(d, 3.14);\\n  return fract(sin(e) * c);\\n}\\n\\nvoid main() {\\n  vec3 hgPosition = matrix * vec3(position, 1);\\n  gl_Position  = vec4(hgPosition.xy, 0, hgPosition.z);\\n    // if we don't jitter the point size a bit, overall point cloud\\n    // saturation 'jumps' on zooming, which is disturbing and confusing\\n  gl_PointSize = pointSize * ((19.5 + rand(position)) / 20.0);\\n  if(pointCloud != 0.0) { // pointCloud is truthy\\n    // get the same square surface as circle would be\\n    gl_PointSize *= 0.886;\\n  }\\n}\"]);\n      exports.pointFragment = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color, borderColor;\\nuniform float centerFraction;\\nuniform float pointCloud;\\n\\nvoid main() {\\n  float radius;\\n  vec4 baseColor;\\n  if(pointCloud != 0.0) { // pointCloud is truthy\\n    if(centerFraction == 1.0) {\\n      gl_FragColor = color;\\n    } else {\\n      gl_FragColor = mix(borderColor, color, centerFraction);\\n    }\\n  } else {\\n    radius = length(2.0 * gl_PointCoord.xy - 1.0);\\n    if(radius > 1.0) {\\n      discard;\\n    }\\n    baseColor = mix(borderColor, color, step(radius, centerFraction));\\n    gl_FragColor = vec4(baseColor.rgb * baseColor.a, baseColor.a);\\n  }\\n}\\n\"]);\n      exports.pickVertex = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\nattribute vec4 pickId;\\n\\nuniform mat3 matrix;\\nuniform float pointSize;\\nuniform vec4 pickOffset;\\n\\nvarying vec4 fragId;\\n\\nvoid main() {\\n  vec3 hgPosition = matrix * vec3(position, 1);\\n  gl_Position  = vec4(hgPosition.xy, 0, hgPosition.z);\\n  gl_PointSize = pointSize;\\n\\n  vec4 id = pickId + pickOffset;\\n  id.y += floor(id.x / 256.0);\\n  id.x -= floor(id.x / 256.0) * 256.0;\\n\\n  id.z += floor(id.y / 256.0);\\n  id.y -= floor(id.y / 256.0) * 256.0;\\n\\n  id.w += floor(id.z / 256.0);\\n  id.z -= floor(id.z / 256.0) * 256.0;\\n\\n  fragId = id;\\n}\\n\"]);\n      exports.pickFragment = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragId;\\n\\nvoid main() {\\n  float radius = length(2.0 * gl_PointCoord.xy - 1.0);\\n  if(radius > 1.0) {\\n    discard;\\n  }\\n  gl_FragColor = fragId / 255.0;\\n}\\n\"]);\n    }, {\n      \"glslify\": 231\n    }],\n    123: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createShader = _glvis_('gl-shader');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var SHADERS = _glvis_('./lib/shader');\n\n      module.exports = createPointcloud2D;\n\n      function Pointcloud2D(plot, offsetBuffer, pickBuffer, shader, pickShader) {\n        this.plot = plot;\n        this.offsetBuffer = offsetBuffer;\n        this.pickBuffer = pickBuffer;\n        this.shader = shader;\n        this.pickShader = pickShader;\n        this.sizeMin = 0.5;\n        this.sizeMinCap = 2;\n        this.sizeMax = 20;\n        this.areaRatio = 1.0;\n        this.pointCount = 0;\n        this.color = [1, 0, 0, 1];\n        this.borderColor = [0, 0, 0, 1];\n        this.blend = false;\n        this.pickOffset = 0;\n        this.points = null;\n      }\n\n      var proto = Pointcloud2D.prototype;\n\n      proto.dispose = function () {\n        this.shader.dispose();\n        this.pickShader.dispose();\n        this.offsetBuffer.dispose();\n        this.pickBuffer.dispose();\n        this.plot.removeObject(this);\n      };\n\n      proto.update = function (options) {\n        var i;\n        options = options || {};\n\n        function dflt(opt, value) {\n          if (opt in options) {\n            return options[opt];\n          }\n\n          return value;\n        }\n\n        this.sizeMin = dflt('sizeMin', 0.5); // this.sizeMinCap      = dflt('sizeMinCap', 2)\n\n        this.sizeMax = dflt('sizeMax', 20);\n        this.color = dflt('color', [1, 0, 0, 1]).slice();\n        this.areaRatio = dflt('areaRatio', 1);\n        this.borderColor = dflt('borderColor', [0, 0, 0, 1]).slice();\n        this.blend = dflt('blend', false); //Update point data\n        // Attempt straight-through processing (STP) to avoid allocation and copy\n        // TODO eventually abstract out STP logic, maybe into `pool` or a layer above\n\n        var pointCount = options.positions.length >>> 1;\n        var dataStraightThrough = options.positions instanceof Float32Array;\n        var idStraightThrough = options.idToIndex instanceof Int32Array && options.idToIndex.length >= pointCount; // permit larger to help reuse\n\n        var data = options.positions;\n        var packed = dataStraightThrough ? data : pool.mallocFloat32(data.length);\n        var packedId = idStraightThrough ? options.idToIndex : pool.mallocInt32(pointCount);\n\n        if (!dataStraightThrough) {\n          packed.set(data);\n        }\n\n        if (!idStraightThrough) {\n          packed.set(data);\n\n          for (i = 0; i < pointCount; i++) {\n            packedId[i] = i;\n          }\n        }\n\n        this.points = data;\n        this.offsetBuffer.update(packed);\n        this.pickBuffer.update(packedId);\n\n        if (!dataStraightThrough) {\n          pool.free(packed);\n        }\n\n        if (!idStraightThrough) {\n          pool.free(packedId);\n        }\n\n        this.pointCount = pointCount;\n        this.pickOffset = 0;\n      };\n\n      function count(points, dataBox) {\n        var visiblePointCountEstimate = 0;\n        var length = points.length >>> 1;\n        var i;\n\n        for (i = 0; i < length; i++) {\n          var x = points[i * 2];\n          var y = points[i * 2 + 1];\n          if (x >= dataBox[0] && x <= dataBox[2] && y >= dataBox[1] && y <= dataBox[3]) visiblePointCountEstimate++;\n        }\n\n        return visiblePointCountEstimate;\n      }\n\n      proto.unifiedDraw = function () {\n        var MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n        var PICK_VEC4 = [0, 0, 0, 0];\n        return function (pickOffset) {\n          var pick = pickOffset !== void 0;\n          var shader = pick ? this.pickShader : this.shader;\n          var gl = this.plot.gl;\n          var dataBox = this.plot.dataBox;\n\n          if (this.pointCount === 0) {\n            return pickOffset;\n          }\n\n          var dataX = dataBox[2] - dataBox[0];\n          var dataY = dataBox[3] - dataBox[1];\n          var visiblePointCountEstimate = count(this.points, dataBox);\n          var basicPointSize = this.plot.pickPixelRatio * Math.max(Math.min(this.sizeMinCap, this.sizeMin), Math.min(this.sizeMax, this.sizeMax / Math.pow(visiblePointCountEstimate, 0.33333)));\n          MATRIX[0] = 2.0 / dataX;\n          MATRIX[4] = 2.0 / dataY;\n          MATRIX[6] = -2.0 * dataBox[0] / dataX - 1.0;\n          MATRIX[7] = -2.0 * dataBox[1] / dataY - 1.0;\n          this.offsetBuffer.bind();\n          shader.bind();\n          shader.attributes.position.pointer();\n          shader.uniforms.matrix = MATRIX;\n          shader.uniforms.color = this.color;\n          shader.uniforms.borderColor = this.borderColor;\n          shader.uniforms.pointCloud = basicPointSize < 5;\n          shader.uniforms.pointSize = basicPointSize;\n          shader.uniforms.centerFraction = Math.min(1, Math.max(0, Math.sqrt(1 - this.areaRatio)));\n\n          if (pick) {\n            PICK_VEC4[0] = pickOffset & 0xff;\n            PICK_VEC4[1] = pickOffset >> 8 & 0xff;\n            PICK_VEC4[2] = pickOffset >> 16 & 0xff;\n            PICK_VEC4[3] = pickOffset >> 24 & 0xff;\n            this.pickBuffer.bind();\n            shader.attributes.pickId.pointer(gl.UNSIGNED_BYTE);\n            shader.uniforms.pickOffset = PICK_VEC4;\n            this.pickOffset = pickOffset;\n          } // Worth switching these off, but we can't make assumptions about other\n          // renderers, so let's restore it after each draw\n\n\n          var blend = gl.getParameter(gl.BLEND);\n          var dither = gl.getParameter(gl.DITHER);\n          if (blend && !this.blend) gl.disable(gl.BLEND);\n          if (dither) gl.disable(gl.DITHER);\n          gl.drawArrays(gl.POINTS, 0, this.pointCount);\n          if (blend && !this.blend) gl.enable(gl.BLEND);\n          if (dither) gl.enable(gl.DITHER);\n          return pickOffset + this.pointCount;\n        };\n      }();\n\n      proto.draw = proto.unifiedDraw;\n      proto.drawPick = proto.unifiedDraw;\n\n      proto.pick = function (x, y, value) {\n        var pickOffset = this.pickOffset;\n        var pointCount = this.pointCount;\n\n        if (value < pickOffset || value >= pickOffset + pointCount) {\n          return null;\n        }\n\n        var pointId = value - pickOffset;\n        var points = this.points;\n        return {\n          object: this,\n          pointId: pointId,\n          dataCoord: [points[2 * pointId], points[2 * pointId + 1]]\n        };\n      };\n\n      function createPointcloud2D(plot, options) {\n        var gl = plot.gl;\n        var buffer = createBuffer(gl);\n        var pickBuffer = createBuffer(gl);\n        var shader = createShader(gl, SHADERS.pointVertex, SHADERS.pointFragment);\n        var pickShader = createShader(gl, SHADERS.pickVertex, SHADERS.pickFragment);\n        var result = new Pointcloud2D(plot, buffer, pickBuffer, shader, pickShader);\n        result.update(options); //Register with plot\n\n        plot.addObject(result);\n        return result;\n      }\n    }, {\n      \"./lib/shader\": 122,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132,\n      \"typedarray-pool\": 308\n    }],\n    124: [function (_glvis_, module, exports) {\n      module.exports = slerp;\n      /**\n       * Performs a spherical linear interpolation between two quat\n       *\n       * @param {quat} out the receiving quaternion\n       * @param {quat} a the first operand\n       * @param {quat} b the second operand\n       * @param {Number} t interpolation amount between the two inputs\n       * @returns {quat} out\n       */\n\n      function slerp(out, a, b, t) {\n        // benchmarks:\n        //    http://jsperf.com/quaternion-slerp-implementations\n        var ax = a[0],\n            ay = a[1],\n            az = a[2],\n            aw = a[3],\n            bx = b[0],\n            by = b[1],\n            bz = b[2],\n            bw = b[3];\n        var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n        cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n        if (cosom < 0.0) {\n          cosom = -cosom;\n          bx = -bx;\n          by = -by;\n          bz = -bz;\n          bw = -bw;\n        } // calculate coefficients\n\n\n        if (1.0 - cosom > 0.000001) {\n          // standard case (slerp)\n          omega = Math.acos(cosom);\n          sinom = Math.sin(omega);\n          scale0 = Math.sin((1.0 - t) * omega) / sinom;\n          scale1 = Math.sin(t * omega) / sinom;\n        } else {\n          // \"from\" and \"to\" quaternions are very close\n          //  ... so we can do a linear interpolation\n          scale0 = 1.0 - t;\n          scale1 = t;\n        } // calculate final values\n\n\n        out[0] = scale0 * ax + scale1 * bx;\n        out[1] = scale0 * ay + scale1 * by;\n        out[2] = scale0 * az + scale1 * bz;\n        out[3] = scale0 * aw + scale1 * bw;\n        return out;\n      }\n    }, {}],\n    125: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = function (a) {\n        return !a && a !== 0 ? '' : a.toString();\n      };\n    }, {}],\n    126: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var vectorizeText = _glvis_(\"vectorize-text\");\n\n      module.exports = getGlyph;\n      var GLYPH_CACHE = {};\n\n      function getGlyph(symbol, font, pixelRatio) {\n        var fontCache = GLYPH_CACHE[font];\n\n        if (!fontCache) {\n          fontCache = GLYPH_CACHE[font] = {};\n        }\n\n        if (symbol in fontCache) {\n          return fontCache[symbol];\n        }\n\n        var config = {\n          textAlign: \"center\",\n          textBaseline: \"middle\",\n          lineHeight: 1.0,\n          font: font,\n          lineSpacing: 1.25,\n          styletags: {\n            breaklines: true,\n            bolds: true,\n            italics: true,\n            subscripts: true,\n            superscripts: true\n          } //Get line and triangle meshes for glyph\n\n        };\n        config.triangles = true;\n        var triSymbol = vectorizeText(symbol, config);\n        config.triangles = false;\n        var lineSymbol = vectorizeText(symbol, config);\n        var i, j;\n\n        if (pixelRatio && pixelRatio !== 1) {\n          for (i = 0; i < triSymbol.positions.length; ++i) {\n            for (j = 0; j < triSymbol.positions[i].length; ++j) {\n              triSymbol.positions[i][j] /= pixelRatio;\n            }\n          }\n\n          for (i = 0; i < lineSymbol.positions.length; ++i) {\n            for (j = 0; j < lineSymbol.positions[i].length; ++j) {\n              lineSymbol.positions[i][j] /= pixelRatio;\n            }\n          }\n        } //Calculate bounding box\n\n\n        var bounds = [[Infinity, Infinity], [-Infinity, -Infinity]];\n        var n = lineSymbol.positions.length;\n\n        for (i = 0; i < n; ++i) {\n          var p = lineSymbol.positions[i];\n\n          for (j = 0; j < 2; ++j) {\n            bounds[0][j] = Math.min(bounds[0][j], p[j]);\n            bounds[1][j] = Math.max(bounds[1][j], p[j]);\n          }\n        } //Save cached symbol\n\n\n        return fontCache[symbol] = [triSymbol, lineSymbol, bounds];\n      }\n    }, {\n      \"vectorize-text\": 311\n    }],\n    127: [function (_glvis_, module, exports) {\n      var createShaderWrapper = _glvis_('gl-shader');\n\n      var glslify = _glvis_('glslify');\n\n      var perspectiveVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec2 glyph;\\nattribute vec4 id;\\n\\nuniform vec4 highlightId;\\nuniform float highlightScale;\\nuniform mat4 model, view, projection;\\nuniform vec3 clipBounds[2];\\n\\nvarying vec4 interpColor;\\nvarying vec4 pickId;\\nvarying vec3 dataCoordinate;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\\n\\n    gl_Position = vec4(0,0,0,0);\\n  } else {\\n    float scale = 1.0;\\n    if(distance(highlightId, id) < 0.0001) {\\n      scale = highlightScale;\\n    }\\n\\n    vec4 worldPosition = model * vec4(position, 1);\\n    vec4 viewPosition = view * worldPosition;\\n    viewPosition = viewPosition / viewPosition.w;\\n    vec4 clipPosition = projection * (viewPosition + scale * vec4(glyph.x, -glyph.y, 0, 0));\\n\\n    gl_Position = clipPosition;\\n    interpColor = color;\\n    pickId = id;\\n    dataCoordinate = position;\\n  }\\n}\"]);\n      var orthographicVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec2 glyph;\\nattribute vec4 id;\\n\\nuniform mat4 model, view, projection;\\nuniform vec2 screenSize;\\nuniform vec3 clipBounds[2];\\nuniform float highlightScale, pixelRatio;\\nuniform vec4 highlightId;\\n\\nvarying vec4 interpColor;\\nvarying vec4 pickId;\\nvarying vec3 dataCoordinate;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\\n\\n    gl_Position = vec4(0,0,0,0);\\n  } else {\\n    float scale = pixelRatio;\\n    if(distance(highlightId.bgr, id.bgr) < 0.001) {\\n      scale *= highlightScale;\\n    }\\n\\n    vec4 worldPosition = model * vec4(position, 1.0);\\n    vec4 viewPosition = view * worldPosition;\\n    vec4 clipPosition = projection * viewPosition;\\n    clipPosition /= clipPosition.w;\\n\\n    gl_Position = clipPosition + vec4(screenSize * scale * vec2(glyph.x, -glyph.y), 0.0, 0.0);\\n    interpColor = color;\\n    pickId = id;\\n    dataCoordinate = position;\\n  }\\n}\"]);\n      var projectionVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec2 glyph;\\nattribute vec4 id;\\n\\nuniform float highlightScale;\\nuniform vec4 highlightId;\\nuniform vec3 axes[2];\\nuniform mat4 model, view, projection;\\nuniform vec2 screenSize;\\nuniform vec3 clipBounds[2];\\nuniform float scale, pixelRatio;\\n\\nvarying vec4 interpColor;\\nvarying vec4 pickId;\\nvarying vec3 dataCoordinate;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], position)) {\\n\\n    gl_Position = vec4(0,0,0,0);\\n  } else {\\n    float lscale = pixelRatio * scale;\\n    if(distance(highlightId, id) < 0.0001) {\\n      lscale *= highlightScale;\\n    }\\n\\n    vec4 clipCenter   = projection * view * model * vec4(position, 1);\\n    vec3 dataPosition = position + 0.5*lscale*(axes[0] * glyph.x + axes[1] * glyph.y) * clipCenter.w * screenSize.y;\\n    vec4 clipPosition = projection * view * model * vec4(dataPosition, 1);\\n\\n    gl_Position = clipPosition;\\n    interpColor = color;\\n    pickId = id;\\n    dataCoordinate = dataPosition;\\n  }\\n}\\n\"]);\n      var drawFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 fragClipBounds[2];\\nuniform float opacity;\\n\\nvarying vec4 interpColor;\\nvarying vec3 dataCoordinate;\\n\\nvoid main() {\\n  if (\\n    outOfRange(fragClipBounds[0], fragClipBounds[1], dataCoordinate) ||\\n    interpColor.a * opacity == 0.\\n  ) discard;\\n  gl_FragColor = interpColor * opacity;\\n}\\n\"]);\n      var pickFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 fragClipBounds[2];\\nuniform float pickGroup;\\n\\nvarying vec4 pickId;\\nvarying vec3 dataCoordinate;\\n\\nvoid main() {\\n  if (outOfRange(fragClipBounds[0], fragClipBounds[1], dataCoordinate)) discard;\\n\\n  gl_FragColor = vec4(pickGroup, pickId.bgr);\\n}\"]);\n      var ATTRIBUTES = [{\n        name: 'position',\n        type: 'vec3'\n      }, {\n        name: 'color',\n        type: 'vec4'\n      }, {\n        name: 'glyph',\n        type: 'vec2'\n      }, {\n        name: 'id',\n        type: 'vec4'\n      }];\n      var perspective = {\n        vertex: perspectiveVertSrc,\n        fragment: drawFragSrc,\n        attributes: ATTRIBUTES\n      },\n          ortho = {\n        vertex: orthographicVertSrc,\n        fragment: drawFragSrc,\n        attributes: ATTRIBUTES\n      },\n          project = {\n        vertex: projectionVertSrc,\n        fragment: drawFragSrc,\n        attributes: ATTRIBUTES\n      },\n          pickPerspective = {\n        vertex: perspectiveVertSrc,\n        fragment: pickFragSrc,\n        attributes: ATTRIBUTES\n      },\n          pickOrtho = {\n        vertex: orthographicVertSrc,\n        fragment: pickFragSrc,\n        attributes: ATTRIBUTES\n      },\n          pickProject = {\n        vertex: projectionVertSrc,\n        fragment: pickFragSrc,\n        attributes: ATTRIBUTES\n      };\n\n      function createShader(gl, src) {\n        var shader = createShaderWrapper(gl, src);\n        var attr = shader.attributes;\n        attr.position.location = 0;\n        attr.color.location = 1;\n        attr.glyph.location = 2;\n        attr.id.location = 3;\n        return shader;\n      }\n\n      exports.createPerspective = function (gl) {\n        return createShader(gl, perspective);\n      };\n\n      exports.createOrtho = function (gl) {\n        return createShader(gl, ortho);\n      };\n\n      exports.createProject = function (gl) {\n        return createShader(gl, project);\n      };\n\n      exports.createPickPerspective = function (gl) {\n        return createShader(gl, pickPerspective);\n      };\n\n      exports.createPickOrtho = function (gl) {\n        return createShader(gl, pickOrtho);\n      };\n\n      exports.createPickProject = function (gl) {\n        return createShader(gl, pickProject);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    128: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var isAllBlank = _glvis_('is-string-blank');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var mat4mult = _glvis_('gl-mat4/multiply');\n\n      var shaders = _glvis_('./lib/shaders');\n\n      var getGlyph = _glvis_('./lib/glyphs');\n\n      var getSimpleString = _glvis_('./lib/get-simple-string');\n\n      var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n      module.exports = createPointCloud;\n\n      function transformMat4(x, m) {\n        var x0 = x[0];\n        var x1 = x[1];\n        var x2 = x[2];\n        var x3 = x[3];\n        x[0] = m[0] * x0 + m[4] * x1 + m[8] * x2 + m[12] * x3;\n        x[1] = m[1] * x0 + m[5] * x1 + m[9] * x2 + m[13] * x3;\n        x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3;\n        x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3;\n        return x;\n      }\n\n      function project(p, v, m, x) {\n        transformMat4(x, x, m);\n        transformMat4(x, x, v);\n        return transformMat4(x, x, p);\n      }\n\n      function ScatterPlotPickResult(index, position) {\n        this.index = index;\n        this.dataCoordinate = this.position = position;\n      }\n\n      function fixOpacity(a) {\n        if (a === true) return 1;\n        if (a > 1) return 1;\n        return a;\n      }\n\n      function PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader) {\n        this.gl = gl;\n        this.pixelRatio = 1;\n        this.shader = shader;\n        this.orthoShader = orthoShader;\n        this.projectShader = projectShader;\n        this.pointBuffer = pointBuffer;\n        this.colorBuffer = colorBuffer;\n        this.glyphBuffer = glyphBuffer;\n        this.idBuffer = idBuffer;\n        this.vao = vao;\n        this.vertexCount = 0;\n        this.lineVertexCount = 0;\n        this.opacity = 1;\n        this.hasAlpha = false;\n        this.lineWidth = 0;\n        this.projectScale = [2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0];\n        this.projectOpacity = [1, 1, 1];\n        this.projectHasAlpha = false;\n        this.pickId = 0;\n        this.pickPerspectiveShader = pickPerspectiveShader;\n        this.pickOrthoShader = pickOrthoShader;\n        this.pickProjectShader = pickProjectShader;\n        this.points = [];\n        this._selectResult = new ScatterPlotPickResult(0, [0, 0, 0]);\n        this.useOrtho = true;\n        this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]; //Axes projections\n\n        this.axesProject = [true, true, true];\n        this.axesBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.highlightId = [1, 1, 1, 1];\n        this.highlightScale = 2;\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.dirty = true;\n      }\n\n      var proto = PointCloud.prototype;\n      proto.pickSlots = 1;\n\n      proto.setPickBase = function (pickBase) {\n        this.pickId = pickBase;\n      };\n\n      proto.isTransparent = function () {\n        if (this.hasAlpha) {\n          return true;\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          if (this.axesProject[i] && this.projectHasAlpha) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      proto.isOpaque = function () {\n        if (!this.hasAlpha) {\n          return true;\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          if (this.axesProject[i] && !this.projectHasAlpha) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      var VIEW_SHAPE = [0, 0];\n      var U_VEC = [0, 0, 0];\n      var V_VEC = [0, 0, 0];\n      var MU_VEC = [0, 0, 0, 1];\n      var MV_VEC = [0, 0, 0, 1];\n      var SCRATCH_MATRIX = IDENTITY.slice();\n      var SCRATCH_VEC = [0, 0, 0];\n      var CLIP_BOUNDS = [[0, 0, 0], [0, 0, 0]];\n\n      function zeroVec(a) {\n        a[0] = a[1] = a[2] = 0;\n        return a;\n      }\n\n      function augment(hg, af) {\n        hg[0] = af[0];\n        hg[1] = af[1];\n        hg[2] = af[2];\n        hg[3] = 1;\n        return hg;\n      }\n\n      function setComponent(out, v, i, x) {\n        out[0] = v[0];\n        out[1] = v[1];\n        out[2] = v[2];\n        out[i] = x;\n        return out;\n      }\n\n      function getClipBounds(bounds) {\n        var result = CLIP_BOUNDS;\n\n        for (var i = 0; i < 2; ++i) {\n          for (var j = 0; j < 3; ++j) {\n            result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8);\n          }\n        }\n\n        return result;\n      }\n\n      function drawProject(shader, points, camera, pixelRatio) {\n        var axesProject = points.axesProject;\n        var gl = points.gl;\n        var uniforms = shader.uniforms;\n        var model = camera.model || IDENTITY;\n        var view = camera.view || IDENTITY;\n        var projection = camera.projection || IDENTITY;\n        var bounds = points.axesBounds;\n        var clipBounds = getClipBounds(points.clipBounds);\n        var cubeAxis;\n\n        if (points.axes && points.axes.lastCubeProps) {\n          cubeAxis = points.axes.lastCubeProps.axis;\n        } else {\n          cubeAxis = [1, 1, 1];\n        }\n\n        VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n        VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n        shader.bind();\n        uniforms.view = view;\n        uniforms.projection = projection;\n        uniforms.screenSize = VIEW_SHAPE;\n        uniforms.highlightId = points.highlightId;\n        uniforms.highlightScale = points.highlightScale;\n        uniforms.clipBounds = clipBounds;\n        uniforms.pickGroup = points.pickId / 255.0;\n        uniforms.pixelRatio = pixelRatio;\n\n        for (var i = 0; i < 3; ++i) {\n          if (!axesProject[i]) {\n            continue;\n          }\n\n          uniforms.scale = points.projectScale[i];\n          uniforms.opacity = points.projectOpacity[i]; //Project model matrix\n\n          var pmodel = SCRATCH_MATRIX;\n\n          for (var j = 0; j < 16; ++j) {\n            pmodel[j] = 0;\n          }\n\n          for (var j = 0; j < 4; ++j) {\n            pmodel[5 * j] = 1;\n          }\n\n          pmodel[5 * i] = 0;\n\n          if (cubeAxis[i] < 0) {\n            pmodel[12 + i] = bounds[0][i];\n          } else {\n            pmodel[12 + i] = bounds[1][i];\n          }\n\n          mat4mult(pmodel, model, pmodel);\n          uniforms.model = pmodel; //Compute initial axes\n\n          var u = (i + 1) % 3;\n          var v = (i + 2) % 3;\n          var du = zeroVec(U_VEC);\n          var dv = zeroVec(V_VEC);\n          du[u] = 1;\n          dv[v] = 1; //Align orientation relative to viewer\n\n          var mdu = project(projection, view, model, augment(MU_VEC, du));\n          var mdv = project(projection, view, model, augment(MV_VEC, dv));\n\n          if (Math.abs(mdu[1]) > Math.abs(mdv[1])) {\n            var tmp = mdu;\n            mdu = mdv;\n            mdv = tmp;\n            tmp = du;\n            du = dv;\n            dv = tmp;\n            var t = u;\n            u = v;\n            v = t;\n          }\n\n          if (mdu[0] < 0) {\n            du[u] = -1;\n          }\n\n          if (mdv[1] > 0) {\n            dv[v] = -1;\n          }\n\n          var su = 0.0;\n          var sv = 0.0;\n\n          for (var j = 0; j < 4; ++j) {\n            su += Math.pow(model[4 * u + j], 2);\n            sv += Math.pow(model[4 * v + j], 2);\n          }\n\n          du[u] /= Math.sqrt(su);\n          dv[v] /= Math.sqrt(sv);\n          uniforms.axes[0] = du;\n          uniforms.axes[1] = dv; //Update fragment clip bounds\n\n          uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8);\n          uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8);\n          points.vao.bind(); //Draw interior\n\n          points.vao.draw(gl.TRIANGLES, points.vertexCount); //Draw edges\n\n          if (points.lineWidth > 0) {\n            gl.lineWidth(points.lineWidth * pixelRatio);\n            points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n          }\n\n          points.vao.unbind();\n        }\n      }\n\n      var NEG_INFINITY3 = [-1e8, -1e8, -1e8];\n      var POS_INFINITY3 = [1e8, 1e8, 1e8];\n      var CLIP_GROUP = [NEG_INFINITY3, POS_INFINITY3];\n\n      function drawFull(shader, pshader, points, camera, pixelRatio, transparent, forceDraw) {\n        var gl = points.gl;\n\n        if (transparent === points.projectHasAlpha || forceDraw) {\n          drawProject(pshader, points, camera, pixelRatio);\n        }\n\n        if (transparent === points.hasAlpha || forceDraw) {\n          shader.bind();\n          var uniforms = shader.uniforms;\n          uniforms.model = camera.model || IDENTITY;\n          uniforms.view = camera.view || IDENTITY;\n          uniforms.projection = camera.projection || IDENTITY;\n          VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n          VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n          uniforms.screenSize = VIEW_SHAPE;\n          uniforms.highlightId = points.highlightId;\n          uniforms.highlightScale = points.highlightScale;\n          uniforms.fragClipBounds = CLIP_GROUP;\n          uniforms.clipBounds = points.axes.bounds;\n          uniforms.opacity = points.opacity;\n          uniforms.pickGroup = points.pickId / 255.0;\n          uniforms.pixelRatio = pixelRatio;\n          points.vao.bind(); //Draw interior\n\n          points.vao.draw(gl.TRIANGLES, points.vertexCount); //Draw edges\n\n          if (points.lineWidth > 0) {\n            gl.lineWidth(points.lineWidth * pixelRatio);\n            points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n          }\n\n          points.vao.unbind();\n        }\n      }\n\n      proto.draw = function (camera) {\n        var shader = this.useOrtho ? this.orthoShader : this.shader;\n        drawFull(shader, this.projectShader, this, camera, this.pixelRatio, false, false);\n      };\n\n      proto.drawTransparent = function (camera) {\n        var shader = this.useOrtho ? this.orthoShader : this.shader;\n        drawFull(shader, this.projectShader, this, camera, this.pixelRatio, true, false);\n      };\n\n      proto.drawPick = function (camera) {\n        var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader;\n        drawFull(shader, this.pickProjectShader, this, camera, 1, true, true);\n      };\n\n      proto.pick = function (selected) {\n        if (!selected) {\n          return null;\n        }\n\n        if (selected.id !== this.pickId) {\n          return null;\n        }\n\n        var x = selected.value[2] + (selected.value[1] << 8) + (selected.value[0] << 16);\n\n        if (x >= this.pointCount || x < 0) {\n          return null;\n        } //Unpack result\n\n\n        var coord = this.points[x];\n        var result = this._selectResult;\n        result.index = x;\n\n        for (var i = 0; i < 3; ++i) {\n          result.position[i] = result.dataCoordinate[i] = coord[i];\n        }\n\n        return result;\n      };\n\n      proto.highlight = function (selection) {\n        if (!selection) {\n          this.highlightId = [1, 1, 1, 1];\n        } else {\n          var pointId = selection.index;\n          var a0 = pointId & 0xff;\n          var a1 = pointId >> 8 & 0xff;\n          var a2 = pointId >> 16 & 0xff;\n          this.highlightId = [a0 / 255.0, a1 / 255.0, a2 / 255.0, 0];\n        }\n      };\n\n      function get_glyphData(glyphs, index, font, pixelRatio) {\n        var str; // use the data if presented in an array\n\n        if (Array.isArray(glyphs)) {\n          if (index < glyphs.length) {\n            str = glyphs[index];\n          } else {\n            str = undefined;\n          }\n        } else {\n          str = glyphs;\n        }\n\n        str = getSimpleString(str); // this would handle undefined cases\n\n        var visible = true;\n\n        if (isAllBlank(str)) {\n          str = ''; // Note: this special character may have minimum number of surfaces\n\n          visible = false;\n        }\n\n        var glyph = getGlyph(str, font, pixelRatio);\n        return {\n          mesh: glyph[0],\n          lines: glyph[1],\n          bounds: glyph[2],\n          visible: visible\n        };\n      }\n\n      proto.update = function (options) {\n        options = options || {};\n\n        if ('perspective' in options) {\n          this.useOrtho = !options.perspective;\n        }\n\n        if ('orthographic' in options) {\n          this.useOrtho = !!options.orthographic;\n        }\n\n        if ('lineWidth' in options) {\n          this.lineWidth = options.lineWidth;\n        }\n\n        if ('project' in options) {\n          if (Array.isArray(options.project)) {\n            this.axesProject = options.project;\n          } else {\n            var v = !!options.project;\n            this.axesProject = [v, v, v];\n          }\n        }\n\n        if ('projectScale' in options) {\n          if (Array.isArray(options.projectScale)) {\n            this.projectScale = options.projectScale.slice();\n          } else {\n            var s = +options.projectScale;\n            this.projectScale = [s, s, s];\n          }\n        }\n\n        this.projectHasAlpha = false; // default to no transparent draw\n\n        if ('projectOpacity' in options) {\n          if (Array.isArray(options.projectOpacity)) {\n            this.projectOpacity = options.projectOpacity.slice();\n          } else {\n            var s = +options.projectOpacity;\n            this.projectOpacity = [s, s, s];\n          }\n\n          for (var i = 0; i < 3; ++i) {\n            this.projectOpacity[i] = fixOpacity(this.projectOpacity[i]);\n\n            if (this.projectOpacity[i] < 1) {\n              this.projectHasAlpha = true;\n            }\n          }\n        }\n\n        this.hasAlpha = false; // default to no transparent draw\n\n        if ('opacity' in options) {\n          this.opacity = fixOpacity(options.opacity);\n\n          if (this.opacity < 1) {\n            this.hasAlpha = true;\n          }\n        } //Set dirty flag\n\n\n        this.dirty = true; //Create new buffers\n\n        var points = options.position; //Text font\n\n        var font = options.font || 'normal';\n        var alignment = options.alignment || [0, 0];\n        var alignmentX;\n        var alignmentY;\n\n        if (alignment.length === 2) {\n          alignmentX = alignment[0];\n          alignmentY = alignment[1];\n        } else {\n          alignmentX = [];\n          alignmentY = [];\n\n          for (var i = 0; i < alignment.length; ++i) {\n            alignmentX[i] = alignment[i][0];\n            alignmentY[i] = alignment[i][1];\n          }\n        } //Bounds\n\n\n        var lowerBound = [Infinity, Infinity, Infinity];\n        var upperBound = [-Infinity, -Infinity, -Infinity]; //Unpack options\n\n        var glyphs = options.glyph;\n        var colors = options.color;\n        var sizes = options.size;\n        var angles = options.angle;\n        var lineColors = options.lineColor; //Picking geometry\n\n        var pickCounter = -1; //First do pass to compute buffer sizes\n\n        var triVertexCount = 0;\n        var lineVertexCount = 0;\n        var numPoints = 0;\n\n        if (points.length) {\n          //Count number of points and buffer size\n          numPoints = points.length;\n\n          count_loop: for (var i = 0; i < numPoints; ++i) {\n            var x = points[i];\n\n            for (var j = 0; j < 3; ++j) {\n              if (isNaN(x[j]) || !isFinite(x[j])) {\n                continue count_loop;\n              }\n            }\n\n            var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n            var glyphMesh = glyphData.mesh;\n            var glyphLines = glyphData.lines;\n            var glyphBounds = glyphData.bounds;\n            triVertexCount += glyphMesh.cells.length * 3;\n            lineVertexCount += glyphLines.edges.length * 2;\n          }\n        }\n\n        var vertexCount = triVertexCount + lineVertexCount; //Preallocate data\n\n        var positionArray = pool.mallocFloat(3 * vertexCount);\n        var colorArray = pool.mallocFloat(4 * vertexCount);\n        var glyphArray = pool.mallocFloat(2 * vertexCount);\n        var idArray = pool.mallocUint32(vertexCount);\n\n        if (vertexCount > 0) {\n          var triOffset = 0;\n          var lineOffset = triVertexCount;\n          var color = [0, 0, 0, 1];\n          var lineColor = [0, 0, 0, 1];\n          var isColorArray = Array.isArray(colors) && Array.isArray(colors[0]);\n          var isLineColorArray = Array.isArray(lineColors) && Array.isArray(lineColors[0]);\n\n          fill_loop: for (var i = 0; i < numPoints; ++i) {\n            //Increment pickCounter\n            pickCounter += 1;\n            var x = points[i];\n\n            for (var j = 0; j < 3; ++j) {\n              if (isNaN(x[j]) || !isFinite(x[j])) {\n                continue fill_loop;\n              }\n\n              upperBound[j] = Math.max(upperBound[j], x[j]);\n              lowerBound[j] = Math.min(lowerBound[j], x[j]);\n            }\n\n            var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n            var glyphMesh = glyphData.mesh;\n            var glyphLines = glyphData.lines;\n            var glyphBounds = glyphData.bounds;\n            var glyphVisible = glyphData.visible; //Get color\n\n            if (!glyphVisible) color = [1, 1, 1, 0];else if (Array.isArray(colors)) {\n              var c;\n\n              if (isColorArray) {\n                if (i < colors.length) {\n                  c = colors[i];\n                } else {\n                  c = [0, 0, 0, 0];\n                }\n              } else {\n                c = colors;\n              }\n\n              if (c.length === 3) {\n                for (var j = 0; j < 3; ++j) {\n                  color[j] = c[j];\n                }\n\n                color[3] = 1;\n              } else if (c.length === 4) {\n                for (var j = 0; j < 4; ++j) {\n                  color[j] = c[j];\n                }\n\n                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n              }\n            } else {\n              color[0] = color[1] = color[2] = 0;\n              color[3] = 1;\n            } //Get lineColor\n\n            if (!glyphVisible) lineColor = [1, 1, 1, 0];else if (Array.isArray(lineColors)) {\n              var c;\n\n              if (isLineColorArray) {\n                if (i < lineColors.length) {\n                  c = lineColors[i];\n                } else {\n                  c = [0, 0, 0, 0];\n                }\n              } else {\n                c = lineColors;\n              }\n\n              if (c.length === 3) {\n                for (var j = 0; j < 3; ++j) {\n                  lineColor[j] = c[j];\n                }\n\n                lineColor[j] = 1;\n              } else if (c.length === 4) {\n                for (var j = 0; j < 4; ++j) {\n                  lineColor[j] = c[j];\n                }\n\n                if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n              }\n            } else {\n              lineColor[0] = lineColor[1] = lineColor[2] = 0;\n              lineColor[3] = 1;\n            }\n            var size = 0.5;\n            if (!glyphVisible) size = 0.0;else if (Array.isArray(sizes)) {\n              if (i < sizes.length) {\n                size = +sizes[i];\n              } else {\n                size = 12;\n              }\n            } else if (sizes) {\n              size = +sizes;\n            } else if (this.useOrtho) {\n              size = 12;\n            }\n            var angle = 0;\n\n            if (Array.isArray(angles)) {\n              if (i < angles.length) {\n                angle = +angles[i];\n              } else {\n                angle = 0;\n              }\n            } else if (angles) {\n              angle = +angles;\n            } //Loop through markers and append to buffers\n\n\n            var cos = Math.cos(angle);\n            var sin = Math.sin(angle);\n            var x = points[i];\n\n            for (var j = 0; j < 3; ++j) {\n              upperBound[j] = Math.max(upperBound[j], x[j]);\n              lowerBound[j] = Math.min(lowerBound[j], x[j]);\n            } //Calculate text offset\n\n\n            var textOffsetX = alignmentX;\n            var textOffsetY = alignmentY;\n            var textOffsetX = 0;\n\n            if (Array.isArray(alignmentX)) {\n              if (i < alignmentX.length) {\n                textOffsetX = alignmentX[i];\n              } else {\n                textOffsetX = 0;\n              }\n            } else if (alignmentX) {\n              textOffsetX = alignmentX;\n            }\n\n            var textOffsetY = 0;\n\n            if (Array.isArray(alignmentY)) {\n              if (i < alignmentY.length) {\n                textOffsetY = alignmentY[i];\n              } else {\n                textOffsetY = 0;\n              }\n            } else if (alignmentY) {\n              textOffsetY = alignmentY;\n            }\n\n            textOffsetX *= textOffsetX > 0 ? 1 - glyphBounds[0][0] : textOffsetX < 0 ? 1 + glyphBounds[1][0] : 1;\n            textOffsetY *= textOffsetY > 0 ? 1 - glyphBounds[0][1] : textOffsetY < 0 ? 1 + glyphBounds[1][1] : 1;\n            var textOffset = [textOffsetX, textOffsetY]; //Write out inner marker\n\n            var cells = glyphMesh.cells || [];\n            var verts = glyphMesh.positions || [];\n\n            for (var j = 0; j < cells.length; ++j) {\n              var cell = cells[j];\n\n              for (var k = 0; k < 3; ++k) {\n                for (var l = 0; l < 3; ++l) {\n                  positionArray[3 * triOffset + l] = x[l];\n                }\n\n                for (var l = 0; l < 4; ++l) {\n                  colorArray[4 * triOffset + l] = color[l];\n                }\n\n                idArray[triOffset] = pickCounter;\n                var p = verts[cell[k]];\n                glyphArray[2 * triOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n                glyphArray[2 * triOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n                triOffset += 1;\n              }\n            }\n\n            var cells = glyphLines.edges;\n            var verts = glyphLines.positions;\n\n            for (var j = 0; j < cells.length; ++j) {\n              var cell = cells[j];\n\n              for (var k = 0; k < 2; ++k) {\n                for (var l = 0; l < 3; ++l) {\n                  positionArray[3 * lineOffset + l] = x[l];\n                }\n\n                for (var l = 0; l < 4; ++l) {\n                  colorArray[4 * lineOffset + l] = lineColor[l];\n                }\n\n                idArray[lineOffset] = pickCounter;\n                var p = verts[cell[k]];\n                glyphArray[2 * lineOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n                glyphArray[2 * lineOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n                lineOffset += 1;\n              }\n            }\n          }\n        } //Update bounds\n\n\n        this.bounds = [lowerBound, upperBound]; //Save points\n\n        this.points = points; //Save number of points\n\n        this.pointCount = points.length; //Update vertex counts\n\n        this.vertexCount = triVertexCount;\n        this.lineVertexCount = lineVertexCount;\n        this.pointBuffer.update(positionArray);\n        this.colorBuffer.update(colorArray);\n        this.glyphBuffer.update(glyphArray); //this.idBuffer.update(new Uint32Array(idArray))\n\n        this.idBuffer.update(idArray);\n        pool.free(positionArray);\n        pool.free(colorArray);\n        pool.free(glyphArray);\n        pool.free(idArray);\n      };\n\n      proto.dispose = function () {\n        //Shaders\n        this.shader.dispose();\n        this.orthoShader.dispose();\n        this.pickPerspectiveShader.dispose();\n        this.pickOrthoShader.dispose(); //Vertex array\n\n        this.vao.dispose(); //Buffers\n\n        this.pointBuffer.dispose();\n        this.colorBuffer.dispose();\n        this.glyphBuffer.dispose();\n        this.idBuffer.dispose();\n      };\n\n      function createPointCloud(options) {\n        var gl = options.gl;\n        var shader = shaders.createPerspective(gl);\n        var orthoShader = shaders.createOrtho(gl);\n        var projectShader = shaders.createProject(gl);\n        var pickPerspectiveShader = shaders.createPickPerspective(gl);\n        var pickOrthoShader = shaders.createPickOrtho(gl);\n        var pickProjectShader = shaders.createPickProject(gl);\n        var pointBuffer = createBuffer(gl);\n        var colorBuffer = createBuffer(gl);\n        var glyphBuffer = createBuffer(gl);\n        var idBuffer = createBuffer(gl);\n        var vao = createVAO(gl, [{\n          buffer: pointBuffer,\n          size: 3,\n          type: gl.FLOAT\n        }, {\n          buffer: colorBuffer,\n          size: 4,\n          type: gl.FLOAT\n        }, {\n          buffer: glyphBuffer,\n          size: 2,\n          type: gl.FLOAT\n        }, {\n          buffer: idBuffer,\n          size: 4,\n          type: gl.UNSIGNED_BYTE,\n          normalized: true\n        }]);\n        var pointCloud = new PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader);\n        pointCloud.update(options);\n        return pointCloud;\n      }\n    }, {\n      \"./lib/get-simple-string\": 125,\n      \"./lib/glyphs\": 126,\n      \"./lib/shaders\": 127,\n      \"gl-buffer\": 78,\n      \"gl-mat4/multiply\": 100,\n      \"gl-vao\": 150,\n      \"is-string-blank\": 239,\n      \"typedarray-pool\": 308\n    }],\n    129: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      exports.boxVertex = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec2 vertex;\\n\\nuniform vec2 cornerA, cornerB;\\n\\nvoid main() {\\n  gl_Position = vec4(mix(cornerA, cornerB, vertex), 0, 1);\\n}\\n\"]);\n      exports.boxFragment = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec4 color;\\n\\nvoid main() {\\n  gl_FragColor = color;\\n}\\n\"]);\n    }, {\n      \"glslify\": 231\n    }],\n    130: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createShader = _glvis_('gl-shader');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var SHADERS = _glvis_('./lib/shaders');\n\n      module.exports = createSelectBox;\n\n      function SelectBox(plot, boxBuffer, boxShader) {\n        this.plot = plot;\n        this.boxBuffer = boxBuffer;\n        this.boxShader = boxShader;\n        this.enabled = true;\n        this.selectBox = [Infinity, Infinity, -Infinity, -Infinity];\n        this.borderColor = [0, 0, 0, 1];\n        this.innerFill = false;\n        this.innerColor = [0, 0, 0, 0.25];\n        this.outerFill = true;\n        this.outerColor = [0, 0, 0, 0.5];\n        this.borderWidth = 10;\n      }\n\n      var proto = SelectBox.prototype;\n\n      proto.draw = function () {\n        if (!this.enabled) {\n          return;\n        }\n\n        var plot = this.plot;\n        var selectBox = this.selectBox;\n        var lineWidth = this.borderWidth;\n        var innerFill = this.innerFill;\n        var innerColor = this.innerColor;\n        var outerFill = this.outerFill;\n        var outerColor = this.outerColor;\n        var borderColor = this.borderColor;\n        var boxes = plot.box;\n        var screenBox = plot.screenBox;\n        var dataBox = plot.dataBox;\n        var viewBox = plot.viewBox;\n        var pixelRatio = plot.pixelRatio; //Map select box into pixel coordinates\n\n        var loX = (selectBox[0] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];\n        var loY = (selectBox[1] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];\n        var hiX = (selectBox[2] - dataBox[0]) * (viewBox[2] - viewBox[0]) / (dataBox[2] - dataBox[0]) + viewBox[0];\n        var hiY = (selectBox[3] - dataBox[1]) * (viewBox[3] - viewBox[1]) / (dataBox[3] - dataBox[1]) + viewBox[1];\n        loX = Math.max(loX, viewBox[0]);\n        loY = Math.max(loY, viewBox[1]);\n        hiX = Math.min(hiX, viewBox[2]);\n        hiY = Math.min(hiY, viewBox[3]);\n\n        if (hiX < loX || hiY < loY) {\n          return;\n        }\n\n        boxes.bind(); //Draw box\n\n        var screenWidth = screenBox[2] - screenBox[0];\n        var screenHeight = screenBox[3] - screenBox[1];\n\n        if (this.outerFill) {\n          boxes.drawBox(0, 0, screenWidth, loY, outerColor);\n          boxes.drawBox(0, loY, loX, hiY, outerColor);\n          boxes.drawBox(0, hiY, screenWidth, screenHeight, outerColor);\n          boxes.drawBox(hiX, loY, screenWidth, hiY, outerColor);\n        }\n\n        if (this.innerFill) {\n          boxes.drawBox(loX, loY, hiX, hiY, innerColor);\n        } //Draw border\n\n\n        if (lineWidth > 0) {\n          //Draw border\n          var w = lineWidth * pixelRatio;\n          boxes.drawBox(loX - w, loY - w, hiX + w, loY + w, borderColor);\n          boxes.drawBox(loX - w, hiY - w, hiX + w, hiY + w, borderColor);\n          boxes.drawBox(loX - w, loY - w, loX + w, hiY + w, borderColor);\n          boxes.drawBox(hiX - w, loY - w, hiX + w, hiY + w, borderColor);\n        }\n      };\n\n      proto.update = function (options) {\n        options = options || {};\n        this.innerFill = !!options.innerFill;\n        this.outerFill = !!options.outerFill;\n        this.innerColor = (options.innerColor || [0, 0, 0, 0.5]).slice();\n        this.outerColor = (options.outerColor || [0, 0, 0, 0.5]).slice();\n        this.borderColor = (options.borderColor || [0, 0, 0, 1]).slice();\n        this.borderWidth = options.borderWidth || 0;\n        this.selectBox = (options.selectBox || this.selectBox).slice();\n      };\n\n      proto.dispose = function () {\n        this.boxBuffer.dispose();\n        this.boxShader.dispose();\n        this.plot.removeOverlay(this);\n      };\n\n      function createSelectBox(plot, options) {\n        var gl = plot.gl;\n        var buffer = createBuffer(gl, [0, 0, 0, 1, 1, 0, 1, 1]);\n        var shader = createShader(gl, SHADERS.boxVertex, SHADERS.boxFragment);\n        var selectBox = new SelectBox(plot, buffer, shader);\n        selectBox.update(options);\n        plot.addOverlay(selectBox);\n        return selectBox;\n      }\n    }, {\n      \"./lib/shaders\": 129,\n      \"gl-buffer\": 78,\n      \"gl-shader\": 132\n    }],\n    131: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createSelectBuffer;\n\n      var createFBO = _glvis_('gl-fbo');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var ndarray = _glvis_('ndarray');\n\n      var nextPow2 = _glvis_('bit-twiddle').nextPow2;\n\n      var selectRange = function selectRange(arr, x, y) {\n        var closestD2 = 1e8;\n        var closestX = -1;\n        var closestY = -1;\n        var ni = arr.shape[0];\n        var nj = arr.shape[1];\n\n        for (var i = 0; i < ni; i++) {\n          for (var j = 0; j < nj; j++) {\n            var r = arr.get(i, j, 0);\n            var g = arr.get(i, j, 1);\n            var b = arr.get(i, j, 2);\n            var a = arr.get(i, j, 3);\n\n            if (r < 255 || g < 255 || b < 255 || a < 255) {\n              var dx = x - i;\n              var dy = y - j;\n              var d2 = dx * dx + dy * dy;\n\n              if (d2 < closestD2) {\n                closestD2 = d2;\n                closestX = i;\n                closestY = j;\n              }\n            }\n          }\n        }\n\n        return [closestX, closestY, closestD2];\n      };\n\n      function SelectResult(x, y, id, value, distance) {\n        this.coord = [x, y];\n        this.id = id;\n        this.value = value;\n        this.distance = distance;\n      }\n\n      function SelectBuffer(gl, fbo, buffer) {\n        this.gl = gl;\n        this.fbo = fbo;\n        this.buffer = buffer;\n        this._readTimeout = null;\n        var self = this;\n\n        this._readCallback = function () {\n          if (!self.gl) {\n            return;\n          }\n\n          fbo.bind();\n          gl.readPixels(0, 0, fbo.shape[0], fbo.shape[1], gl.RGBA, gl.UNSIGNED_BYTE, self.buffer);\n          self._readTimeout = null;\n        };\n      }\n\n      var proto = SelectBuffer.prototype;\n      Object.defineProperty(proto, 'shape', {\n        get: function get() {\n          if (!this.gl) {\n            return [0, 0];\n          }\n\n          return this.fbo.shape.slice();\n        },\n        set: function set(v) {\n          if (!this.gl) {\n            return;\n          }\n\n          this.fbo.shape = v;\n          var c = this.fbo.shape[0];\n          var r = this.fbo.shape[1];\n\n          if (r * c * 4 > this.buffer.length) {\n            pool.free(this.buffer);\n            var buffer = this.buffer = pool.mallocUint8(nextPow2(r * c * 4));\n\n            for (var i = 0; i < r * c * 4; ++i) {\n              buffer[i] = 0xff;\n            }\n          }\n\n          return v;\n        }\n      });\n\n      proto.begin = function () {\n        var gl = this.gl;\n        var shape = this.shape;\n\n        if (!gl) {\n          return;\n        }\n\n        this.fbo.bind();\n        gl.clearColor(1, 1, 1, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      };\n\n      proto.end = function () {\n        var gl = this.gl;\n\n        if (!gl) {\n          return;\n        }\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        if (!this._readTimeout) {\n          clearTimeout(this._readTimeout);\n        }\n\n        this._readTimeout = setTimeout(this._readCallback, 1);\n      };\n\n      proto.query = function (x, y, radius) {\n        if (!this.gl) {\n          return null;\n        }\n\n        var shape = this.fbo.shape.slice();\n        x = x | 0;\n        y = y | 0;\n\n        if (typeof radius !== 'number') {\n          radius = 1.0;\n        }\n\n        var x0 = Math.min(Math.max(x - radius, 0), shape[0]) | 0;\n        var x1 = Math.min(Math.max(x + radius, 0), shape[0]) | 0;\n        var y0 = Math.min(Math.max(y - radius, 0), shape[1]) | 0;\n        var y1 = Math.min(Math.max(y + radius, 0), shape[1]) | 0;\n\n        if (x1 <= x0 || y1 <= y0) {\n          return null;\n        }\n\n        var dims = [x1 - x0, y1 - y0];\n        var region = ndarray(this.buffer, [dims[0], dims[1], 4], [4, shape[0] * 4, 1], 4 * (x0 + shape[0] * y0));\n        var closest = selectRange(region.hi(dims[0], dims[1], 1), radius, radius);\n        var dx = closest[0];\n        var dy = closest[1];\n\n        if (dx < 0 || Math.pow(this.radius, 2) < closest[2]) {\n          return null;\n        }\n\n        var c0 = region.get(dx, dy, 0);\n        var c1 = region.get(dx, dy, 1);\n        var c2 = region.get(dx, dy, 2);\n        var c3 = region.get(dx, dy, 3);\n        return new SelectResult(dx + x0 | 0, dy + y0 | 0, c0, [c1, c2, c3], Math.sqrt(closest[2]));\n      };\n\n      proto.dispose = function () {\n        if (!this.gl) {\n          return;\n        }\n\n        this.fbo.dispose();\n        pool.free(this.buffer);\n        this.gl = null;\n\n        if (this._readTimeout) {\n          clearTimeout(this._readTimeout);\n        }\n      };\n\n      function createSelectBuffer(gl, shape) {\n        var width = shape[0];\n        var height = shape[1];\n        var options = {};\n        var fbo = createFBO(gl, width, height, options);\n        var buffer = pool.mallocUint8(width * height * 4);\n        return new SelectBuffer(gl, fbo, buffer);\n      }\n    }, {\n      \"bit-twiddle\": 32,\n      \"gl-fbo\": 86,\n      \"ndarray\": 259,\n      \"typedarray-pool\": 308\n    }],\n    132: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createUniformWrapper = _glvis_('./lib/create-uniforms');\n\n      var createAttributeWrapper = _glvis_('./lib/create-attributes');\n\n      var makeReflect = _glvis_('./lib/reflect');\n\n      var shaderCache = _glvis_('./lib/shader-cache');\n\n      var runtime = _glvis_('./lib/runtime-reflect');\n\n      var GLError = _glvis_(\"./lib/GLError\"); //Shader object\n\n\n      function Shader(gl) {\n        this.gl = gl;\n        this.gl.lastAttribCount = 0; // fixme where else should we store info, safe but not nice on the gl object\n        //Default initialize these to null\n\n        this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;\n      }\n\n      var proto = Shader.prototype;\n\n      proto.bind = function () {\n        if (!this.program) {\n          this._relink();\n        } // ensuring that we have the right number of enabled vertex attributes\n\n\n        var i;\n        var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES); // more robust approach\n        //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown\n\n        var oldAttribCount = this.gl.lastAttribCount;\n\n        if (newAttribCount > oldAttribCount) {\n          for (i = oldAttribCount; i < newAttribCount; i++) {\n            this.gl.enableVertexAttribArray(i);\n          }\n        } else if (oldAttribCount > newAttribCount) {\n          for (i = newAttribCount; i < oldAttribCount; i++) {\n            this.gl.disableVertexAttribArray(i);\n          }\n        }\n\n        this.gl.lastAttribCount = newAttribCount;\n        this.gl.useProgram(this.program);\n      };\n\n      proto.dispose = function () {\n        // disabling vertex attributes so new shader starts with zero\n        // and it's also useful if all shaders are disposed but the\n        // gl context is reused for subsequent replotting\n        var oldAttribCount = this.gl.lastAttribCount;\n\n        for (var i = 0; i < oldAttribCount; i++) {\n          this.gl.disableVertexAttribArray(i);\n        }\n\n        this.gl.lastAttribCount = 0;\n\n        if (this._fref) {\n          this._fref.dispose();\n        }\n\n        if (this._vref) {\n          this._vref.dispose();\n        }\n\n        this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;\n      };\n\n      function compareAttributes(a, b) {\n        if (a.name < b.name) {\n          return -1;\n        }\n\n        return 1;\n      } //Update export hook for glslify-live\n\n\n      proto.update = function (vertSource, fragSource, uniforms, attributes) {\n        //If only one object passed, assume glslify style output\n        if (!fragSource || arguments.length === 1) {\n          var obj = vertSource;\n          vertSource = obj.vertex;\n          fragSource = obj.fragment;\n          uniforms = obj.uniforms;\n          attributes = obj.attributes;\n        }\n\n        var wrapper = this;\n        var gl = wrapper.gl; //Compile vertex and fragment shaders\n\n        var pvref = wrapper._vref;\n        wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource);\n\n        if (pvref) {\n          pvref.dispose();\n        }\n\n        wrapper.vertShader = wrapper._vref.shader;\n        var pfref = this._fref;\n        wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource);\n\n        if (pfref) {\n          pfref.dispose();\n        }\n\n        wrapper.fragShader = wrapper._fref.shader; //If uniforms/attributes is not specified, use RT reflection\n\n        if (!uniforms || !attributes) {\n          //Create initial test program\n          var testProgram = gl.createProgram();\n          gl.attachShader(testProgram, wrapper.fragShader);\n          gl.attachShader(testProgram, wrapper.vertShader);\n          gl.linkProgram(testProgram);\n\n          if (!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {\n            var errLog = gl.getProgramInfoLog(testProgram);\n            throw new GLError(errLog, 'Error linking program:' + errLog);\n          } //Load data from runtime\n\n\n          uniforms = uniforms || runtime.uniforms(gl, testProgram);\n          attributes = attributes || runtime.attributes(gl, testProgram); //Release test program\n\n          gl.deleteProgram(testProgram);\n        } //Sort attributes lexicographically\n        // overrides undefined WebGL behavior for attribute locations\n\n\n        attributes = attributes.slice();\n        attributes.sort(compareAttributes); //Convert attribute types, read out locations\n\n        var attributeUnpacked = [];\n        var attributeNames = [];\n        var attributeLocations = [];\n        var i;\n\n        for (i = 0; i < attributes.length; ++i) {\n          var attr = attributes[i];\n\n          if (attr.type.indexOf('mat') >= 0) {\n            var size = attr.type.charAt(attr.type.length - 1) | 0;\n            var locVector = new Array(size);\n\n            for (var j = 0; j < size; ++j) {\n              locVector[j] = attributeLocations.length;\n              attributeNames.push(attr.name + '[' + j + ']');\n\n              if (typeof attr.location === 'number') {\n                attributeLocations.push(attr.location + j);\n              } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === 'number') {\n                attributeLocations.push(attr.location[j] | 0);\n              } else {\n                attributeLocations.push(-1);\n              }\n            }\n\n            attributeUnpacked.push({\n              name: attr.name,\n              type: attr.type,\n              locations: locVector\n            });\n          } else {\n            attributeUnpacked.push({\n              name: attr.name,\n              type: attr.type,\n              locations: [attributeLocations.length]\n            });\n            attributeNames.push(attr.name);\n\n            if (typeof attr.location === 'number') {\n              attributeLocations.push(attr.location | 0);\n            } else {\n              attributeLocations.push(-1);\n            }\n          }\n        } //For all unspecified attributes, assign them lexicographically min attribute\n\n\n        var curLocation = 0;\n\n        for (i = 0; i < attributeLocations.length; ++i) {\n          if (attributeLocations[i] < 0) {\n            while (attributeLocations.indexOf(curLocation) >= 0) {\n              curLocation += 1;\n            }\n\n            attributeLocations[i] = curLocation;\n          }\n        } //Rebuild program and recompute all uniform locations\n\n\n        var uniformLocations = new Array(uniforms.length);\n\n        function relink() {\n          wrapper.program = shaderCache.program(gl, wrapper._vref, wrapper._fref, attributeNames, attributeLocations);\n\n          for (var i = 0; i < uniforms.length; ++i) {\n            uniformLocations[i] = gl.getUniformLocation(wrapper.program, uniforms[i].name);\n          }\n        } //Perform initial linking, reuse program used for reflection\n\n\n        relink(); //Save relinking procedure, defer until runtime\n\n        wrapper._relink = relink; //Generate type info\n\n        wrapper.types = {\n          uniforms: makeReflect(uniforms),\n          attributes: makeReflect(attributes) //Generate attribute wrappers\n\n        };\n        wrapper.attributes = createAttributeWrapper(gl, wrapper, attributeUnpacked, attributeLocations); //Generate uniform wrappers\n\n        Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(gl, wrapper, uniforms, uniformLocations));\n      }; //Compiles and links a shader program with the given attribute and vertex list\n\n\n      function createShader(gl, vertSource, fragSource, uniforms, attributes) {\n        var shader = new Shader(gl);\n        shader.update(vertSource, fragSource, uniforms, attributes);\n        return shader;\n      }\n\n      module.exports = createShader;\n    }, {\n      \"./lib/GLError\": 133,\n      \"./lib/create-attributes\": 134,\n      \"./lib/create-uniforms\": 135,\n      \"./lib/reflect\": 136,\n      \"./lib/runtime-reflect\": 137,\n      \"./lib/shader-cache\": 138\n    }],\n    133: [function (_glvis_, module, exports) {\n      function GLError(rawError, shortMessage, longMessage) {\n        this.shortMessage = shortMessage || '';\n        this.longMessage = longMessage || '';\n        this.rawError = rawError || '';\n        this.message = 'gl-shader: ' + (shortMessage || rawError || '') + (longMessage ? '\\n' + longMessage : '');\n        this.stack = new Error().stack;\n      }\n\n      GLError.prototype = new Error();\n      GLError.prototype.name = 'GLError';\n      GLError.prototype.constructor = GLError;\n      module.exports = GLError;\n    }, {}],\n    134: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createAttributeWrapper;\n\n      var GLError = _glvis_(\"./GLError\");\n\n      function ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc) {\n        this._gl = gl;\n        this._wrapper = wrapper;\n        this._index = index;\n        this._locations = locations;\n        this._dimension = dimension;\n        this._constFunc = constFunc;\n      }\n\n      var proto = ShaderAttribute.prototype;\n\n      proto.pointer = function setAttribPointer(type, normalized, stride, offset) {\n        var self = this;\n        var gl = self._gl;\n        var location = self._locations[self._index];\n        gl.vertexAttribPointer(location, self._dimension, type || gl.FLOAT, !!normalized, stride || 0, offset || 0);\n        gl.enableVertexAttribArray(location);\n      };\n\n      proto.set = function (x0, x1, x2, x3) {\n        return this._constFunc(this._locations[this._index], x0, x1, x2, x3);\n      };\n\n      Object.defineProperty(proto, 'location', {\n        get: function get() {\n          return this._locations[this._index];\n        },\n        set: function set(v) {\n          if (v !== this._locations[this._index]) {\n            this._locations[this._index] = v | 0;\n            this._wrapper.program = null;\n          }\n\n          return v | 0;\n        }\n      });\n      var allFns = [function (gl, v, x0) {\n        if (x0.length === undefined) {\n          return gl.vertexAttrib1f(v, x0);\n        } else {\n          return gl.vertexAttrib1fv(v, x0);\n        }\n      }, function (gl, v, x0, x1) {\n        if (x0.length === undefined) {\n          return gl.vertexAttrib2f(v, x0, x1);\n        } else {\n          return gl.vertexAttrib2fv(v, x0);\n        }\n      }, function (gl, v, x0, x1, x2) {\n        if (x0.length === undefined) {\n          return gl.vertexAttrib3f(v, x0, x1, x2);\n        } else {\n          return gl.vertexAttrib3fv(v, x0);\n        }\n      }, function (gl, v, x0, x1, x2, x3) {\n        if (x0.length === undefined) {\n          return gl.vertexAttrib4f(v, x0, x1, x2, x3);\n        } else {\n          return gl.vertexAttrib4fv(v, x0);\n        }\n      }]; //Adds a vector attribute to obj\n\n      function addVectorAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n        var constFunc = allFns[dimension]; //Create attribute wrapper\n\n        var attr = new ShaderAttribute(gl, wrapper, index, locations, dimension, constFunc); //Create accessor\n\n        Object.defineProperty(obj, name, {\n          set: function set(x) {\n            gl.disableVertexAttribArray(locations[index]);\n            constFunc(gl, locations[index], x);\n            return x;\n          },\n          get: function get() {\n            return attr;\n          },\n          enumerable: true\n        });\n      }\n\n      function addMatrixAttribute(gl, wrapper, index, locations, dimension, obj, name) {\n        var parts = new Array(dimension);\n        var attrs = new Array(dimension);\n\n        for (var i = 0; i < dimension; ++i) {\n          addVectorAttribute(gl, wrapper, index[i], locations, dimension, parts, i);\n          attrs[i] = parts[i];\n        }\n\n        Object.defineProperty(parts, 'location', {\n          set: function set(v) {\n            if (Array.isArray(v)) {\n              for (var i = 0; i < dimension; ++i) {\n                attrs[i].location = v[i];\n              }\n            } else {\n              for (var i = 0; i < dimension; ++i) {\n                attrs[i].location = v + i;\n              }\n            }\n\n            return v;\n          },\n          get: function get() {\n            var result = new Array(dimension);\n\n            for (var i = 0; i < dimension; ++i) {\n              result[i] = locations[index[i]];\n            }\n\n            return result;\n          },\n          enumerable: true\n        });\n\n        parts.pointer = function (type, normalized, stride, offset) {\n          type = type || gl.FLOAT;\n          normalized = !!normalized;\n          stride = stride || dimension * dimension;\n          offset = offset || 0;\n\n          for (var i = 0; i < dimension; ++i) {\n            var location = locations[index[i]];\n            gl.vertexAttribPointer(location, dimension, type, normalized, stride, offset + i * dimension);\n            gl.enableVertexAttribArray(location);\n          }\n        };\n\n        var scratch = new Array(dimension);\n        var vertexAttrib = gl['vertexAttrib' + dimension + 'fv'];\n        Object.defineProperty(obj, name, {\n          set: function set(x) {\n            for (var i = 0; i < dimension; ++i) {\n              var loc = locations[index[i]];\n              gl.disableVertexAttribArray(loc);\n\n              if (Array.isArray(x[0])) {\n                vertexAttrib.call(gl, loc, x[i]);\n              } else {\n                for (var j = 0; j < dimension; ++j) {\n                  scratch[j] = x[dimension * i + j];\n                }\n\n                vertexAttrib.call(gl, loc, scratch);\n              }\n            }\n\n            return x;\n          },\n          get: function get() {\n            return parts;\n          },\n          enumerable: true\n        });\n      } //Create shims for attributes\n\n\n      function createAttributeWrapper(gl, wrapper, attributes, locations) {\n        var obj = {};\n\n        for (var i = 0, n = attributes.length; i < n; ++i) {\n          var a = attributes[i];\n          var name = a.name;\n          var type = a.type;\n          var locs = a.locations;\n\n          switch (type) {\n            case 'bool':\n            case 'int':\n            case 'float':\n              addVectorAttribute(gl, wrapper, locs[0], locations, 1, obj, name);\n              break;\n\n            default:\n              if (type.indexOf('vec') >= 0) {\n                var d = type.charCodeAt(type.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n                }\n\n                addVectorAttribute(gl, wrapper, locs[0], locations, d, obj, name);\n              } else if (type.indexOf('mat') >= 0) {\n                var d = type.charCodeAt(type.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid data type for attribute ' + name + ': ' + type);\n                }\n\n                addMatrixAttribute(gl, wrapper, locs, locations, d, obj, name);\n              } else {\n                throw new GLError('', 'Unknown data type for attribute ' + name + ': ' + type);\n              }\n\n              break;\n          }\n        }\n\n        return obj;\n      }\n    }, {\n      \"./GLError\": 133\n    }],\n    135: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var coallesceUniforms = _glvis_('./reflect');\n\n      var GLError = _glvis_(\"./GLError\");\n\n      module.exports = createUniformWrapper; //Binds a function and returns a value\n\n      function identity(x) {\n        return function () {\n          return x;\n        };\n      }\n\n      function makeVector(length, fill) {\n        var result = new Array(length);\n\n        for (var i = 0; i < length; ++i) {\n          result[i] = fill;\n        }\n\n        return result;\n      } //Create shims for uniforms\n\n\n      function createUniformWrapper(gl, wrapper, uniforms, locations) {\n        function makeGetter(idx) {\n          return function (gl, wrapper, locations) {\n            return gl.getUniform(wrapper.program, locations[idx]);\n          };\n        }\n\n        function makeSetter(type) {\n          return function updateProperty(obj) {\n            var indices = enumerateIndices('', type);\n\n            for (var i = 0; i < indices.length; ++i) {\n              var item = indices[i];\n              var path = item[0];\n              var idx = item[1];\n\n              if (locations[idx]) {\n                var objPath = obj;\n\n                if (typeof path === 'string' && (path.indexOf('.') === 0 || path.indexOf('[') === 0)) {\n                  var key = path;\n\n                  if (path.indexOf('.') === 0) {\n                    key = path.slice(1);\n                  }\n\n                  if (key.indexOf(']') === key.length - 1) {\n                    var j = key.indexOf('[');\n                    var k1 = key.slice(0, j);\n                    var k2 = key.slice(j + 1, key.length - 1);\n                    objPath = k1 ? obj[k1][k2] : obj[k2];\n                  } else {\n                    objPath = obj[key];\n                  }\n                }\n\n                var t = uniforms[idx].type;\n                var d;\n\n                switch (t) {\n                  case 'bool':\n                  case 'int':\n                  case 'sampler2D':\n                  case 'samplerCube':\n                    gl.uniform1i(locations[idx], objPath);\n                    break;\n\n                  case 'float':\n                    gl.uniform1f(locations[idx], objPath);\n                    break;\n\n                  default:\n                    var vidx = t.indexOf('vec');\n\n                    if (0 <= vidx && vidx <= 1 && t.length === 4 + vidx) {\n                      d = t.charCodeAt(t.length - 1) - 48;\n\n                      if (d < 2 || d > 4) {\n                        throw new GLError('', 'Invalid data type');\n                      }\n\n                      switch (t.charAt(0)) {\n                        case 'b':\n                        case 'i':\n                          gl['uniform' + d + 'iv'](locations[idx], objPath);\n                          break;\n\n                        case 'v':\n                          gl['uniform' + d + 'fv'](locations[idx], objPath);\n                          break;\n\n                        default:\n                          throw new GLError('', 'Unrecognized data type for vector ' + name + ': ' + t);\n                      }\n                    } else if (t.indexOf('mat') === 0 && t.length === 4) {\n                      d = t.charCodeAt(t.length - 1) - 48;\n\n                      if (d < 2 || d > 4) {\n                        throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + t);\n                      }\n\n                      gl['uniformMatrix' + d + 'fv'](locations[idx], false, objPath);\n                      break;\n                    } else {\n                      throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + t);\n                    }\n\n                }\n              }\n            }\n          };\n        }\n\n        function enumerateIndices(prefix, type) {\n          if (typeof type !== 'object') {\n            return [[prefix, type]];\n          }\n\n          var indices = [];\n\n          for (var id in type) {\n            var prop = type[id];\n            var tprefix = prefix;\n\n            if (parseInt(id) + '' === id) {\n              tprefix += '[' + id + ']';\n            } else {\n              tprefix += '.' + id;\n            }\n\n            if (typeof prop === 'object') {\n              indices.push.apply(indices, enumerateIndices(tprefix, prop));\n            } else {\n              indices.push([tprefix, prop]);\n            }\n          }\n\n          return indices;\n        }\n\n        function defaultValue(type) {\n          switch (type) {\n            case 'bool':\n              return false;\n\n            case 'int':\n            case 'sampler2D':\n            case 'samplerCube':\n              return 0;\n\n            case 'float':\n              return 0.0;\n\n            default:\n              var vidx = type.indexOf('vec');\n\n              if (0 <= vidx && vidx <= 1 && type.length === 4 + vidx) {\n                var d = type.charCodeAt(type.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid data type');\n                }\n\n                if (type.charAt(0) === 'b') {\n                  return makeVector(d, false);\n                }\n\n                return makeVector(d, 0);\n              } else if (type.indexOf('mat') === 0 && type.length === 4) {\n                var d = type.charCodeAt(type.length - 1) - 48;\n\n                if (d < 2 || d > 4) {\n                  throw new GLError('', 'Invalid uniform dimension type for matrix ' + name + ': ' + type);\n                }\n\n                return makeVector(d * d, 0);\n              } else {\n                throw new GLError('', 'Unknown uniform data type for ' + name + ': ' + type);\n              }\n\n          }\n        }\n\n        function storeProperty(obj, prop, type) {\n          if (typeof type === 'object') {\n            var child = processObject(type);\n            Object.defineProperty(obj, prop, {\n              get: identity(child),\n              set: makeSetter(type),\n              enumerable: true,\n              configurable: false\n            });\n          } else {\n            if (locations[type]) {\n              Object.defineProperty(obj, prop, {\n                get: makeGetter(type),\n                set: makeSetter(type),\n                enumerable: true,\n                configurable: false\n              });\n            } else {\n              obj[prop] = defaultValue(uniforms[type].type);\n            }\n          }\n        }\n\n        function processObject(obj) {\n          var result;\n\n          if (Array.isArray(obj)) {\n            result = new Array(obj.length);\n\n            for (var i = 0; i < obj.length; ++i) {\n              storeProperty(result, i, obj[i]);\n            }\n          } else {\n            result = {};\n\n            for (var id in obj) {\n              storeProperty(result, id, obj[id]);\n            }\n          }\n\n          return result;\n        } //Return data\n\n\n        var coallesced = coallesceUniforms(uniforms, true);\n        return {\n          get: identity(processObject(coallesced)),\n          set: makeSetter(coallesced),\n          enumerable: true,\n          configurable: true\n        };\n      }\n    }, {\n      \"./GLError\": 133,\n      \"./reflect\": 136\n    }],\n    136: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = makeReflectTypes; //Construct type info for reflection.\n      //\n      // This iterates over the flattened list of uniform type values and smashes them into a JSON object.\n      //\n      // The leaves of the resulting object are either indices or type strings representing primitive glslify types\n\n      function makeReflectTypes(uniforms, useIndex) {\n        var obj = {};\n\n        for (var i = 0; i < uniforms.length; ++i) {\n          var n = uniforms[i].name;\n          var parts = n.split(\".\");\n          var o = obj;\n\n          for (var j = 0; j < parts.length; ++j) {\n            var x = parts[j].split(\"[\");\n\n            if (x.length > 1) {\n              if (!(x[0] in o)) {\n                o[x[0]] = [];\n              }\n\n              o = o[x[0]];\n\n              for (var k = 1; k < x.length; ++k) {\n                var y = parseInt(x[k]);\n\n                if (k < x.length - 1 || j < parts.length - 1) {\n                  if (!(y in o)) {\n                    if (k < x.length - 1) {\n                      o[y] = [];\n                    } else {\n                      o[y] = {};\n                    }\n                  }\n\n                  o = o[y];\n                } else {\n                  if (useIndex) {\n                    o[y] = i;\n                  } else {\n                    o[y] = uniforms[i].type;\n                  }\n                }\n              }\n            } else if (j < parts.length - 1) {\n              if (!(x[0] in o)) {\n                o[x[0]] = {};\n              }\n\n              o = o[x[0]];\n            } else {\n              if (useIndex) {\n                o[x[0]] = i;\n              } else {\n                o[x[0]] = uniforms[i].type;\n              }\n            }\n          }\n        }\n\n        return obj;\n      }\n    }, {}],\n    137: [function (_glvis_, module, exports) {\n      'use strict';\n\n      exports.uniforms = runtimeUniforms;\n      exports.attributes = runtimeAttributes;\n      var GL_TO_GLSL_TYPES = {\n        'FLOAT': 'float',\n        'FLOAT_VEC2': 'vec2',\n        'FLOAT_VEC3': 'vec3',\n        'FLOAT_VEC4': 'vec4',\n        'INT': 'int',\n        'INT_VEC2': 'ivec2',\n        'INT_VEC3': 'ivec3',\n        'INT_VEC4': 'ivec4',\n        'BOOL': 'bool',\n        'BOOL_VEC2': 'bvec2',\n        'BOOL_VEC3': 'bvec3',\n        'BOOL_VEC4': 'bvec4',\n        'FLOAT_MAT2': 'mat2',\n        'FLOAT_MAT3': 'mat3',\n        'FLOAT_MAT4': 'mat4',\n        'SAMPLER_2D': 'sampler2D',\n        'SAMPLER_CUBE': 'samplerCube'\n      };\n      var GL_TABLE = null;\n\n      function getType(gl, type) {\n        if (!GL_TABLE) {\n          var typeNames = Object.keys(GL_TO_GLSL_TYPES);\n          GL_TABLE = {};\n\n          for (var i = 0; i < typeNames.length; ++i) {\n            var tn = typeNames[i];\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n          }\n        }\n\n        return GL_TABLE[type];\n      }\n\n      function runtimeUniforms(gl, program) {\n        var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n        var result = [];\n\n        for (var i = 0; i < numUniforms; ++i) {\n          var info = gl.getActiveUniform(program, i);\n\n          if (info) {\n            var type = getType(gl, info.type);\n\n            if (info.size > 1) {\n              for (var j = 0; j < info.size; ++j) {\n                result.push({\n                  name: info.name.replace('[0]', '[' + j + ']'),\n                  type: type\n                });\n              }\n            } else {\n              result.push({\n                name: info.name,\n                type: type\n              });\n            }\n          }\n        }\n\n        return result;\n      }\n\n      function runtimeAttributes(gl, program) {\n        var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n        var result = [];\n\n        for (var i = 0; i < numAttributes; ++i) {\n          var info = gl.getActiveAttrib(program, i);\n\n          if (info) {\n            result.push({\n              name: info.name,\n              type: getType(gl, info.type)\n            });\n          }\n        }\n\n        return result;\n      }\n    }, {}],\n    138: [function (_glvis_, module, exports) {\n      'use strict';\n\n      exports.shader = getShaderReference;\n      exports.program = createProgram;\n\n      var GLError = _glvis_(\"./GLError\");\n\n      var formatCompilerError = _glvis_('gl-format-compiler-error');\n\n      var weakMap = typeof WeakMap === 'undefined' ? _glvis_('weakmap-shim') : WeakMap;\n      var CACHE = new weakMap();\n      var SHADER_COUNTER = 0;\n\n      function ShaderReference(id, src, type, shader, programs, count, cache) {\n        this.id = id;\n        this.src = src;\n        this.type = type;\n        this.shader = shader;\n        this.count = count;\n        this.programs = [];\n        this.cache = cache;\n      }\n\n      ShaderReference.prototype.dispose = function () {\n        if (--this.count === 0) {\n          var cache = this.cache;\n          var gl = cache.gl; //Remove program references\n\n          var programs = this.programs;\n\n          for (var i = 0, n = programs.length; i < n; ++i) {\n            var p = cache.programs[programs[i]];\n\n            if (p) {\n              delete cache.programs[i];\n              gl.deleteProgram(p);\n            }\n          } //Remove shader reference\n\n\n          gl.deleteShader(this.shader);\n          delete cache.shaders[this.type === gl.FRAGMENT_SHADER | 0][this.src];\n        }\n      };\n\n      function ContextCache(gl) {\n        this.gl = gl;\n        this.shaders = [{}, {}];\n        this.programs = {};\n      }\n\n      var proto = ContextCache.prototype;\n\n      function compileShader(gl, type, src) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n          var errLog = gl.getShaderInfoLog(shader);\n\n          try {\n            var fmt = formatCompilerError(errLog, src, type);\n          } catch (e) {\n            console.warn('Failed to format compiler error: ' + e);\n            throw new GLError(errLog, 'Error compiling shader:\\n' + errLog);\n          }\n\n          throw new GLError(errLog, fmt.short, fmt.long);\n        }\n\n        return shader;\n      }\n\n      proto.getShaderReference = function (type, src) {\n        var gl = this.gl;\n        var shaders = this.shaders[type === gl.FRAGMENT_SHADER | 0];\n        var shader = shaders[src];\n\n        if (!shader || !gl.isShader(shader.shader)) {\n          var shaderObj = compileShader(gl, type, src);\n          shader = shaders[src] = new ShaderReference(SHADER_COUNTER++, src, type, shaderObj, [], 1, this);\n        } else {\n          shader.count += 1;\n        }\n\n        return shader;\n      };\n\n      function linkProgram(gl, vshader, fshader, attribs, locations) {\n        var program = gl.createProgram();\n        gl.attachShader(program, vshader);\n        gl.attachShader(program, fshader);\n\n        for (var i = 0; i < attribs.length; ++i) {\n          gl.bindAttribLocation(program, locations[i], attribs[i]);\n        }\n\n        gl.linkProgram(program);\n\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n          var errLog = gl.getProgramInfoLog(program);\n          throw new GLError(errLog, 'Error linking program: ' + errLog);\n        }\n\n        return program;\n      }\n\n      proto.getProgram = function (vref, fref, attribs, locations) {\n        var token = [vref.id, fref.id, attribs.join(':'), locations.join(':')].join('@');\n        var prog = this.programs[token];\n\n        if (!prog || !this.gl.isProgram(prog)) {\n          this.programs[token] = prog = linkProgram(this.gl, vref.shader, fref.shader, attribs, locations);\n          vref.programs.push(token);\n          fref.programs.push(token);\n        }\n\n        return prog;\n      };\n\n      function getCache(gl) {\n        var ctxCache = CACHE.get(gl);\n\n        if (!ctxCache) {\n          ctxCache = new ContextCache(gl);\n          CACHE.set(gl, ctxCache);\n        }\n\n        return ctxCache;\n      }\n\n      function getShaderReference(gl, type, src) {\n        return getCache(gl).getShaderReference(type, src);\n      }\n\n      function createProgram(gl, vref, fref, attribs, locations) {\n        return getCache(gl).getProgram(vref, fref, attribs, locations);\n      }\n    }, {\n      \"./GLError\": 133,\n      \"gl-format-compiler-error\": 87,\n      \"weakmap-shim\": 316\n    }],\n    139: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createSpikes2D;\n\n      function GLSpikes2D(plot) {\n        this.plot = plot;\n        this.enable = [true, true, false, false];\n        this.width = [1, 1, 1, 1];\n        this.color = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.center = [Infinity, Infinity];\n      }\n\n      var proto = GLSpikes2D.prototype;\n\n      proto.update = function (options) {\n        options = options || {};\n        this.enable = (options.enable || [true, true, false, false]).slice();\n        this.width = (options.width || [1, 1, 1, 1]).slice();\n        this.color = (options.color || [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]).map(function (x) {\n          return x.slice();\n        });\n        this.center = (options.center || [Infinity, Infinity]).slice();\n        this.plot.setOverlayDirty();\n      };\n\n      proto.draw = function () {\n        var spikeEnable = this.enable;\n        var spikeWidth = this.width;\n        var spikeColor = this.color;\n        var spikeCenter = this.center;\n        var plot = this.plot;\n        var line = plot.line;\n        var dataBox = plot.dataBox;\n        var viewPixels = plot.viewBox;\n        line.bind();\n\n        if (dataBox[0] <= spikeCenter[0] && spikeCenter[0] <= dataBox[2] && dataBox[1] <= spikeCenter[1] && spikeCenter[1] <= dataBox[3]) {\n          var centerX = viewPixels[0] + (spikeCenter[0] - dataBox[0]) / (dataBox[2] - dataBox[0]) * (viewPixels[2] - viewPixels[0]);\n          var centerY = viewPixels[1] + (spikeCenter[1] - dataBox[1]) / (dataBox[3] - dataBox[1]) * (viewPixels[3] - viewPixels[1]);\n\n          if (spikeEnable[0]) {\n            line.drawLine(centerX, centerY, viewPixels[0], centerY, spikeWidth[0], spikeColor[0]);\n          }\n\n          if (spikeEnable[1]) {\n            line.drawLine(centerX, centerY, centerX, viewPixels[1], spikeWidth[1], spikeColor[1]);\n          }\n\n          if (spikeEnable[2]) {\n            line.drawLine(centerX, centerY, viewPixels[2], centerY, spikeWidth[2], spikeColor[2]);\n          }\n\n          if (spikeEnable[3]) {\n            line.drawLine(centerX, centerY, centerX, viewPixels[3], spikeWidth[3], spikeColor[3]);\n          }\n        }\n      };\n\n      proto.dispose = function () {\n        this.plot.removeOverlay(this);\n      };\n\n      function createSpikes2D(plot, options) {\n        var spikes = new GLSpikes2D(plot);\n        spikes.update(options);\n        plot.addOverlay(spikes);\n        return spikes;\n      }\n    }, {}],\n    140: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var glslify = _glvis_('glslify');\n\n      var createShader = _glvis_('gl-shader');\n\n      var vertSrc = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nattribute vec3 position, color;\\nattribute float weight;\\n\\nuniform mat4 model, view, projection;\\nuniform vec3 coordinates[3];\\nuniform vec4 colors[3];\\nuniform vec2 screenShape;\\nuniform float lineWidth;\\n\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n  vec3 vertexPosition = mix(coordinates[0],\\n    mix(coordinates[2], coordinates[1], 0.5 * (position + 1.0)), abs(position));\\n\\n  vec4 clipPos = projection * view * model * vec4(vertexPosition, 1.0);\\n  vec2 clipOffset = (projection * view * model * vec4(color, 0.0)).xy;\\n  vec2 delta = weight * clipOffset * screenShape;\\n  vec2 lineOffset = normalize(vec2(delta.y, -delta.x)) / screenShape;\\n\\n  gl_Position   = vec4(clipPos.xy + clipPos.w * 0.5 * lineWidth * lineOffset, clipPos.z, clipPos.w);\\n  fragColor     = color.x * colors[0] + color.y * colors[1] + color.z * colors[2];\\n}\\n\"]);\n      var fragSrc = glslify([\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor;\\n\\nvoid main() {\\n  gl_FragColor = fragColor;\\n}\"]);\n\n      module.exports = function (gl) {\n        return createShader(gl, vertSrc, fragSrc, null, [{\n          name: 'position',\n          type: 'vec3'\n        }, {\n          name: 'color',\n          type: 'vec3'\n        }, {\n          name: 'weight',\n          type: 'float'\n        }]);\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    141: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createShader = _glvis_('./shaders/index');\n\n      module.exports = createSpikes;\n      var identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n      function AxisSpikes(gl, buffer, vao, shader) {\n        this.gl = gl;\n        this.buffer = buffer;\n        this.vao = vao;\n        this.shader = shader;\n        this.pixelRatio = 1;\n        this.bounds = [[-1000, -1000, -1000], [1000, 1000, 1000]];\n        this.position = [0, 0, 0];\n        this.lineWidth = [2, 2, 2];\n        this.colors = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.enabled = [true, true, true];\n        this.drawSides = [true, true, true];\n        this.axes = null;\n      }\n\n      var proto = AxisSpikes.prototype;\n      var OUTER_FACE = [0, 0, 0];\n      var INNER_FACE = [0, 0, 0];\n      var SHAPE = [0, 0];\n\n      proto.isTransparent = function () {\n        return false;\n      };\n\n      proto.drawTransparent = function (camera) {};\n\n      proto.draw = function (camera) {\n        var gl = this.gl;\n        var vao = this.vao;\n        var shader = this.shader;\n        vao.bind();\n        shader.bind();\n        var model = camera.model || identity;\n        var view = camera.view || identity;\n        var projection = camera.projection || identity;\n        var axis;\n\n        if (this.axes) {\n          axis = this.axes.lastCubeProps.axis;\n        }\n\n        var outerFace = OUTER_FACE;\n        var innerFace = INNER_FACE;\n\n        for (var i = 0; i < 3; ++i) {\n          if (axis && axis[i] < 0) {\n            outerFace[i] = this.bounds[0][i];\n            innerFace[i] = this.bounds[1][i];\n          } else {\n            outerFace[i] = this.bounds[1][i];\n            innerFace[i] = this.bounds[0][i];\n          }\n        }\n\n        SHAPE[0] = gl.drawingBufferWidth;\n        SHAPE[1] = gl.drawingBufferHeight;\n        shader.uniforms.model = model;\n        shader.uniforms.view = view;\n        shader.uniforms.projection = projection;\n        shader.uniforms.coordinates = [this.position, outerFace, innerFace];\n        shader.uniforms.colors = this.colors;\n        shader.uniforms.screenShape = SHAPE;\n\n        for (var i = 0; i < 3; ++i) {\n          shader.uniforms.lineWidth = this.lineWidth[i] * this.pixelRatio;\n\n          if (this.enabled[i]) {\n            vao.draw(gl.TRIANGLES, 6, 6 * i);\n\n            if (this.drawSides[i]) {\n              vao.draw(gl.TRIANGLES, 12, 18 + 12 * i);\n            }\n          }\n        }\n\n        vao.unbind();\n      };\n\n      proto.update = function (options) {\n        if (!options) {\n          return;\n        }\n\n        if (\"bounds\" in options) {\n          this.bounds = options.bounds;\n        }\n\n        if (\"position\" in options) {\n          this.position = options.position;\n        }\n\n        if (\"lineWidth\" in options) {\n          this.lineWidth = options.lineWidth;\n        }\n\n        if (\"colors\" in options) {\n          this.colors = options.colors;\n        }\n\n        if (\"enabled\" in options) {\n          this.enabled = options.enabled;\n        }\n\n        if (\"drawSides\" in options) {\n          this.drawSides = options.drawSides;\n        }\n      };\n\n      proto.dispose = function () {\n        this.vao.dispose();\n        this.buffer.dispose();\n        this.shader.dispose();\n      };\n\n      function createSpikes(gl, options) {\n        //Create buffers\n        var data = [];\n\n        function line(x, y, z, i, l, h) {\n          var row = [x, y, z, 0, 0, 0, 1];\n          row[i + 3] = 1;\n          row[i] = l;\n          data.push.apply(data, row);\n          row[6] = -1;\n          data.push.apply(data, row);\n          row[i] = h;\n          data.push.apply(data, row);\n          data.push.apply(data, row);\n          row[6] = 1;\n          data.push.apply(data, row);\n          row[i] = l;\n          data.push.apply(data, row);\n        }\n\n        line(0, 0, 0, 0, 0, 1);\n        line(0, 0, 0, 1, 0, 1);\n        line(0, 0, 0, 2, 0, 1);\n        line(1, 0, 0, 1, -1, 1);\n        line(1, 0, 0, 2, -1, 1);\n        line(0, 1, 0, 0, -1, 1);\n        line(0, 1, 0, 2, -1, 1);\n        line(0, 0, 1, 0, -1, 1);\n        line(0, 0, 1, 1, -1, 1);\n        var buffer = createBuffer(gl, data);\n        var vao = createVAO(gl, [{\n          type: gl.FLOAT,\n          buffer: buffer,\n          size: 3,\n          offset: 0,\n          stride: 28\n        }, {\n          type: gl.FLOAT,\n          buffer: buffer,\n          size: 3,\n          offset: 12,\n          stride: 28\n        }, {\n          type: gl.FLOAT,\n          buffer: buffer,\n          size: 1,\n          offset: 24,\n          stride: 28\n        }]); //Create shader\n\n        var shader = createShader(gl);\n        shader.attributes.position.location = 0;\n        shader.attributes.color.location = 1;\n        shader.attributes.weight.location = 2; //Create spike object\n\n        var spikes = new AxisSpikes(gl, buffer, vao, shader); //Set parameters\n\n        spikes.update(options); //Return resulting object\n\n        return spikes;\n      }\n    }, {\n      \"./shaders/index\": 140,\n      \"gl-buffer\": 78,\n      \"gl-vao\": 150\n    }],\n    142: [function (_glvis_, module, exports) {\n      var glslify = _glvis_('glslify');\n\n      var triVertSrc = glslify([\"precision highp float;\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvec3 getOrthogonalVector(vec3 v) {\\n  // Return up-vector for only-z vector.\\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\\n  // Assign z = 0, x = -b, y = a:\\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\\n    return normalize(vec3(-v.y, v.x, 0.0));\\n  } else {\\n    return normalize(vec3(0.0, v.z, -v.y));\\n  }\\n}\\n\\n// Calculate the tube vertex and normal at the given index.\\n//\\n// The returned vertex is for a tube ring with its center at origin, radius of length(d), pointing in the direction of d.\\n//\\n// Each tube segment is made up of a ring of vertices.\\n// These vertices are used to make up the triangles of the tube by connecting them together in the vertex array.\\n// The indexes of tube segments run from 0 to 8.\\n//\\nvec3 getTubePosition(vec3 d, float index, out vec3 normal) {\\n  float segmentCount = 8.0;\\n\\n  float angle = 2.0 * 3.14159 * (index / segmentCount);\\n\\n  vec3 u = getOrthogonalVector(d);\\n  vec3 v = normalize(cross(u, d));\\n\\n  vec3 x = u * cos(angle) * length(d);\\n  vec3 y = v * sin(angle) * length(d);\\n  vec3 v3 = x + y;\\n\\n  normal = normalize(v3);\\n\\n  return v3;\\n}\\n\\nattribute vec4 vector;\\nattribute vec4 color, position;\\nattribute vec2 uv;\\n\\nuniform float vectorScale, tubeScale;\\nuniform mat4 model, view, projection, inverseModel;\\nuniform vec3 eyePosition, lightPosition;\\n\\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  // Scale the vector magnitude to stay constant with\\n  // model & view changes.\\n  vec3 normal;\\n  vec3 XYZ = getTubePosition(mat3(model) * (tubeScale * vector.w * normalize(vector.xyz)), position.w, normal);\\n  vec4 tubePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\\n\\n  //Lighting geometry parameters\\n  vec4 cameraCoordinate = view * tubePosition;\\n  cameraCoordinate.xyz /= cameraCoordinate.w;\\n  f_lightDirection = lightPosition - cameraCoordinate.xyz;\\n  f_eyeDirection   = eyePosition - cameraCoordinate.xyz;\\n  f_normal = normalize((vec4(normal, 0.0) * inverseModel).xyz);\\n\\n  // vec4 m_position  = model * vec4(tubePosition, 1.0);\\n  vec4 t_position  = view * tubePosition;\\n  gl_Position      = projection * t_position;\\n\\n  f_color          = color;\\n  f_data           = tubePosition.xyz;\\n  f_position       = position.xyz;\\n  f_uv             = uv;\\n}\\n\"]);\n      var triFragSrc = glslify([\"#extension GL_OES_standard_derivatives : enable\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nfloat beckmannDistribution(float x, float roughness) {\\n  float NdotH = max(x, 0.0001);\\n  float cos2Alpha = NdotH * NdotH;\\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\\n  float roughness2 = roughness * roughness;\\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\\n  return exp(tan2Alpha / roughness2) / denom;\\n}\\n\\nfloat cookTorranceSpecular(\\n  vec3 lightDirection,\\n  vec3 viewDirection,\\n  vec3 surfaceNormal,\\n  float roughness,\\n  float fresnel) {\\n\\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\\n\\n  //Half angle vector\\n  vec3 H = normalize(lightDirection + viewDirection);\\n\\n  //Geometric term\\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\\n  float VdotH = max(dot(viewDirection, H), 0.000001);\\n  float LdotH = max(dot(lightDirection, H), 0.000001);\\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\\n  float G = min(1.0, min(G1, G2));\\n  \\n  //Distribution term\\n  float D = beckmannDistribution(NdotH, roughness);\\n\\n  //Fresnel term\\n  float F = pow(1.0 - VdotN, fresnel);\\n\\n  //Multiply terms and done\\n  return  G * F * D / max(3.14159265 * VdotN, 0.000001);\\n}\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 clipBounds[2];\\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\\nuniform sampler2D texture;\\n\\nvarying vec3 f_normal, f_lightDirection, f_eyeDirection, f_data, f_position;\\nvarying vec4 f_color;\\nvarying vec2 f_uv;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\\n  vec3 N = normalize(f_normal);\\n  vec3 L = normalize(f_lightDirection);\\n  vec3 V = normalize(f_eyeDirection);\\n\\n  if(gl_FrontFacing) {\\n    N = -N;\\n  }\\n\\n  float specular = min(1.0, max(0.0, cookTorranceSpecular(L, V, N, roughness, fresnel)));\\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\\n\\n  vec4 surfaceColor = f_color * texture2D(texture, f_uv);\\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\\n\\n  gl_FragColor = litColor * opacity;\\n}\\n\"]);\n      var pickVertSrc = glslify([\"precision highp float;\\n\\nprecision highp float;\\n#define GLSLIFY 1\\n\\nvec3 getOrthogonalVector(vec3 v) {\\n  // Return up-vector for only-z vector.\\n  // Return ax + by + cz = 0, a point that lies on the plane that has v as a normal and that isn't (0,0,0).\\n  // From the above if-statement we have ||a|| > 0  U  ||b|| > 0.\\n  // Assign z = 0, x = -b, y = a:\\n  // a*-b + b*a + c*0 = -ba + ba + 0 = 0\\n  if (v.x*v.x > v.z*v.z || v.y*v.y > v.z*v.z) {\\n    return normalize(vec3(-v.y, v.x, 0.0));\\n  } else {\\n    return normalize(vec3(0.0, v.z, -v.y));\\n  }\\n}\\n\\n// Calculate the tube vertex and normal at the given index.\\n//\\n// The returned vertex is for a tube ring with its center at origin, radius of length(d), pointing in the direction of d.\\n//\\n// Each tube segment is made up of a ring of vertices.\\n// These vertices are used to make up the triangles of the tube by connecting them together in the vertex array.\\n// The indexes of tube segments run from 0 to 8.\\n//\\nvec3 getTubePosition(vec3 d, float index, out vec3 normal) {\\n  float segmentCount = 8.0;\\n\\n  float angle = 2.0 * 3.14159 * (index / segmentCount);\\n\\n  vec3 u = getOrthogonalVector(d);\\n  vec3 v = normalize(cross(u, d));\\n\\n  vec3 x = u * cos(angle) * length(d);\\n  vec3 y = v * sin(angle) * length(d);\\n  vec3 v3 = x + y;\\n\\n  normal = normalize(v3);\\n\\n  return v3;\\n}\\n\\nattribute vec4 vector;\\nattribute vec4 position;\\nattribute vec4 id;\\n\\nuniform mat4 model, view, projection;\\nuniform float tubeScale;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  vec3 normal;\\n  vec3 XYZ = getTubePosition(mat3(model) * (tubeScale * vector.w * normalize(vector.xyz)), position.w, normal);\\n  vec4 tubePosition = model * vec4(position.xyz, 1.0) + vec4(XYZ, 0.0);\\n\\n  gl_Position = projection * view * tubePosition;\\n  f_id        = id;\\n  f_position  = position.xyz;\\n}\\n\"]);\n      var pickFragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3  clipBounds[2];\\nuniform float pickId;\\n\\nvarying vec3 f_position;\\nvarying vec4 f_id;\\n\\nvoid main() {\\n  if (outOfRange(clipBounds[0], clipBounds[1], f_position)) discard;\\n\\n  gl_FragColor = vec4(pickId, f_id.xyz);\\n}\"]);\n      exports.meshShader = {\n        vertex: triVertSrc,\n        fragment: triFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec4'\n        }, {\n          name: 'color',\n          type: 'vec4'\n        }, {\n          name: 'uv',\n          type: 'vec2'\n        }, {\n          name: 'vector',\n          type: 'vec4'\n        }]\n      };\n      exports.pickShader = {\n        vertex: pickVertSrc,\n        fragment: pickFragSrc,\n        attributes: [{\n          name: 'position',\n          type: 'vec4'\n        }, {\n          name: 'id',\n          type: 'vec4'\n        }, {\n          name: 'vector',\n          type: 'vec4'\n        }]\n      };\n    }, {\n      \"glslify\": 231\n    }],\n    143: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var vec3 = _glvis_('gl-vec3');\n\n      var vec4 = _glvis_('gl-vec4');\n\n      var GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\n      var streamToTube = function streamToTube(stream, maxDivergence, minDistance, maxNorm) {\n        var points = stream.points;\n        var velocities = stream.velocities;\n        var divergences = stream.divergences;\n        var verts = [];\n        var faces = [];\n        var vectors = [];\n        var previousVerts = [];\n        var currentVerts = [];\n        var intensities = [];\n        var previousIntensity = 0;\n        var currentIntensity = 0;\n        var currentVector = vec4.create();\n        var previousVector = vec4.create();\n        var facets = 8;\n\n        for (var i = 0; i < points.length; i++) {\n          var p = points[i];\n          var fwd = velocities[i];\n          var r = divergences[i];\n\n          if (maxDivergence === 0) {\n            r = minDistance * 0.05;\n          }\n\n          currentIntensity = vec3.length(fwd) / maxNorm;\n          currentVector = vec4.create();\n          vec3.copy(currentVector, fwd);\n          currentVector[3] = r;\n\n          for (var a = 0; a < facets; a++) {\n            currentVerts[a] = [p[0], p[1], p[2], a];\n          }\n\n          if (previousVerts.length > 0) {\n            for (var a = 0; a < facets; a++) {\n              var a1 = (a + 1) % facets;\n              verts.push(previousVerts[a], currentVerts[a], currentVerts[a1], currentVerts[a1], previousVerts[a1], previousVerts[a]);\n              vectors.push(previousVector, currentVector, currentVector, currentVector, previousVector, previousVector);\n              intensities.push(previousIntensity, currentIntensity, currentIntensity, currentIntensity, previousIntensity, previousIntensity);\n              var len = verts.length;\n              faces.push([len - 6, len - 5, len - 4], [len - 3, len - 2, len - 1]);\n            }\n          }\n\n          var tmp1 = previousVerts;\n          previousVerts = currentVerts;\n          currentVerts = tmp1;\n          var tmp2 = previousVector;\n          previousVector = currentVector;\n          currentVector = tmp2;\n          var tmp3 = previousIntensity;\n          previousIntensity = currentIntensity;\n          currentIntensity = tmp3;\n        }\n\n        return {\n          positions: verts,\n          cells: faces,\n          vectors: vectors,\n          vertexIntensity: intensities\n        };\n      };\n\n      var createTubes = function createTubes(streams, colormap, maxDivergence, minDistance) {\n        var maxNorm = 0;\n\n        for (var i = 0; i < streams.length; i++) {\n          var velocities = streams[i].velocities;\n\n          for (var j = 0; j < velocities.length; j++) {\n            maxNorm = Math.max(maxNorm, vec3.length(velocities[j]));\n          }\n        }\n\n        var tubes = streams.map(function (s) {\n          return streamToTube(s, maxDivergence, minDistance, maxNorm);\n        });\n        var positions = [];\n        var cells = [];\n        var vectors = [];\n        var vertexIntensity = [];\n\n        for (var i = 0; i < tubes.length; i++) {\n          var tube = tubes[i];\n          var offset = positions.length;\n          positions = positions.concat(tube.positions);\n          vectors = vectors.concat(tube.vectors);\n          vertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n\n          for (var j = 0; j < tube.cells.length; j++) {\n            var cell = tube.cells[j];\n            var newCell = [];\n            cells.push(newCell);\n\n            for (var k = 0; k < cell.length; k++) {\n              newCell.push(cell[k] + offset);\n            }\n          }\n        }\n\n        return {\n          positions: positions,\n          cells: cells,\n          vectors: vectors,\n          vertexIntensity: vertexIntensity,\n          colormap: colormap\n        };\n      };\n\n      var findLastSmallerIndex = function findLastSmallerIndex(points, v) {\n        var len = points.length;\n        var i;\n\n        for (i = 0; i < len; i++) {\n          var p = points[i];\n          if (p === v) return i;else if (p > v) return i - 1;\n        }\n\n        return i;\n      };\n\n      var clamp = function clamp(v, min, max) {\n        return v < min ? min : v > max ? max : v;\n      };\n\n      var sampleMeshgrid = function sampleMeshgrid(point, vectorField, gridInfo) {\n        var vectors = vectorField.vectors;\n        var meshgrid = vectorField.meshgrid;\n        var x = point[0];\n        var y = point[1];\n        var z = point[2];\n        var w = meshgrid[0].length;\n        var h = meshgrid[1].length;\n        var d = meshgrid[2].length; // Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n        // The nearest smaller value index for x is the index x0 such that\n        // meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\n        var x0 = findLastSmallerIndex(meshgrid[0], x);\n        var y0 = findLastSmallerIndex(meshgrid[1], y);\n        var z0 = findLastSmallerIndex(meshgrid[2], z); // Get the nearest larger meshgrid value indices.\n        // From the above \"nearest smaller value\", we know that\n        //   meshgrid[0][x0] < x\n        //   meshgrid[0][x0+1] >= x\n\n        var x1 = x0 + 1;\n        var y1 = y0 + 1;\n        var z1 = z0 + 1;\n        x0 = clamp(x0, 0, w - 1);\n        x1 = clamp(x1, 0, w - 1);\n        y0 = clamp(y0, 0, h - 1);\n        y1 = clamp(y1, 0, h - 1);\n        z0 = clamp(z0, 0, d - 1);\n        z1 = clamp(z1, 0, d - 1); // Reject points outside the meshgrid, return a zero vector.\n\n        if (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w - 1 || y1 > h - 1 || z1 > d - 1) {\n          return vec3.create();\n        } // Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\n\n        var mX0 = meshgrid[0][x0];\n        var mX1 = meshgrid[0][x1];\n        var mY0 = meshgrid[1][y0];\n        var mY1 = meshgrid[1][y1];\n        var mZ0 = meshgrid[2][z0];\n        var mZ1 = meshgrid[2][z1];\n        var xf = (x - mX0) / (mX1 - mX0);\n        var yf = (y - mY0) / (mY1 - mY0);\n        var zf = (z - mZ0) / (mZ1 - mZ0);\n        if (!isFinite(xf)) xf = 0.5;\n        if (!isFinite(yf)) yf = 0.5;\n        if (!isFinite(zf)) zf = 0.5;\n        var x0off;\n        var x1off;\n        var y0off;\n        var y1off;\n        var z0off;\n        var z1off;\n\n        if (gridInfo.reversedX) {\n          x0 = w - 1 - x0;\n          x1 = w - 1 - x1;\n        }\n\n        if (gridInfo.reversedY) {\n          y0 = h - 1 - y0;\n          y1 = h - 1 - y1;\n        }\n\n        if (gridInfo.reversedZ) {\n          z0 = d - 1 - z0;\n          z1 = d - 1 - z1;\n        }\n\n        switch (gridInfo.filled) {\n          case 5:\n            // 'zyx'\n            z0off = z0;\n            z1off = z1;\n            y0off = y0 * d;\n            y1off = y1 * d;\n            x0off = x0 * d * h;\n            x1off = x1 * d * h;\n            break;\n\n          case 4:\n            // 'zxy'\n            z0off = z0;\n            z1off = z1;\n            x0off = x0 * d;\n            x1off = x1 * d;\n            y0off = y0 * d * w;\n            y1off = y1 * d * w;\n            break;\n\n          case 3:\n            // 'yzx'\n            y0off = y0;\n            y1off = y1;\n            z0off = z0 * h;\n            z1off = z1 * h;\n            x0off = x0 * h * d;\n            x1off = x1 * h * d;\n            break;\n\n          case 2:\n            // 'yxz'\n            y0off = y0;\n            y1off = y1;\n            x0off = x0 * h;\n            x1off = x1 * h;\n            z0off = z0 * h * w;\n            z1off = z1 * h * w;\n            break;\n\n          case 1:\n            // 'xzy'\n            x0off = x0;\n            x1off = x1;\n            z0off = z0 * w;\n            z1off = z1 * w;\n            y0off = y0 * w * d;\n            y1off = y1 * w * d;\n            break;\n\n          default:\n            // case 0: // 'xyz'\n            x0off = x0;\n            x1off = x1;\n            y0off = y0 * w;\n            y1off = y1 * w;\n            z0off = z0 * w * h;\n            z1off = z1 * w * h;\n            break;\n        } // Sample data vectors around the (x,y,z) point.\n\n\n        var v000 = vectors[x0off + y0off + z0off];\n        var v001 = vectors[x0off + y0off + z1off];\n        var v010 = vectors[x0off + y1off + z0off];\n        var v011 = vectors[x0off + y1off + z1off];\n        var v100 = vectors[x1off + y0off + z0off];\n        var v101 = vectors[x1off + y0off + z1off];\n        var v110 = vectors[x1off + y1off + z0off];\n        var v111 = vectors[x1off + y1off + z1off];\n        var c00 = vec3.create();\n        var c01 = vec3.create();\n        var c10 = vec3.create();\n        var c11 = vec3.create();\n        vec3.lerp(c00, v000, v100, xf);\n        vec3.lerp(c01, v001, v101, xf);\n        vec3.lerp(c10, v010, v110, xf);\n        vec3.lerp(c11, v011, v111, xf);\n        var c0 = vec3.create();\n        var c1 = vec3.create();\n        vec3.lerp(c0, c00, c10, yf);\n        vec3.lerp(c1, c01, c11, yf);\n        var c = vec3.create();\n        vec3.lerp(c, c0, c1, zf);\n        return c;\n      };\n\n      var vabs = function vabs(dst, v) {\n        var x = v[0];\n        var y = v[1];\n        var z = v[2];\n        dst[0] = x < 0 ? -x : x;\n        dst[1] = y < 0 ? -y : y;\n        dst[2] = z < 0 ? -z : z;\n        return dst;\n      };\n\n      var findMinSeparation = function findMinSeparation(xs) {\n        var minSeparation = Infinity;\n        xs.sort(function (a, b) {\n          return a - b;\n        });\n        var len = xs.length;\n\n        for (var i = 1; i < len; i++) {\n          var d = Math.abs(xs[i] - xs[i - 1]);\n\n          if (d < minSeparation) {\n            minSeparation = d;\n          }\n        }\n\n        return minSeparation;\n      }; // Finds the minimum per-component distance in positions.\n      //\n\n\n      var calculateMinPositionDistance = function calculateMinPositionDistance(positions) {\n        var xs = [],\n            ys = [],\n            zs = [];\n        var xi = {},\n            yi = {},\n            zi = {};\n        var len = positions.length;\n\n        for (var i = 0; i < len; i++) {\n          var p = positions[i];\n          var x = p[0],\n              y = p[1],\n              z = p[2]; // Split the positions array into arrays of unique component values.\n          //\n          // Why go through the trouble of using a uniqueness hash table vs\n          // sort and uniq:\n          //\n          // Suppose you've got a million positions in a 100x100x100 grid.\n          //\n          // Using a uniqueness hash table, you're doing 1M array reads,\n          // 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n          // sorting three 100-element arrays and iterating over them.\n          // Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n          //          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n          //          =~ 15M\n          //\n          // Sort and uniq solution would do 1M array reads, 3M array inserts,\n          // sort three 1M-element arrays and iterate over them.\n          // Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n          //          1M + 3M + 41.4M + 3M\n          //          =~ 48.4M\n          //\n          // Guessing that a hard-coded sort & uniq would be faster due to not having\n          // to run a hashing function on everything. More memory usage though\n          // (bunch of small hash tables vs. duplicating the input array.)\n          //\n          // In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n          // maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n          // Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n          //\n          // ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n          //\n\n          if (!xi[x]) {\n            xs.push(x);\n            xi[x] = true;\n          }\n\n          if (!yi[y]) {\n            ys.push(y);\n            yi[y] = true;\n          }\n\n          if (!zi[z]) {\n            zs.push(z);\n            zi[z] = true;\n          }\n        }\n\n        var xSep = findMinSeparation(xs);\n        var ySep = findMinSeparation(ys);\n        var zSep = findMinSeparation(zs);\n        var minSeparation = Math.min(xSep, ySep, zSep);\n        return isFinite(minSeparation) ? minSeparation : 1;\n      };\n\n      module.exports = function (vectorField, bounds) {\n        var positions = vectorField.startingPositions;\n        var maxLength = vectorField.maxLength || 1000;\n        var tubeSize = vectorField.tubeSize || 1;\n        var absoluteTubeSize = vectorField.absoluteTubeSize;\n        var gridFill = vectorField.gridFill || '+x+y+z';\n        var gridInfo = {};\n\n        if (gridFill.indexOf('-x') !== -1) {\n          gridInfo.reversedX = true;\n        }\n\n        if (gridFill.indexOf('-y') !== -1) {\n          gridInfo.reversedY = true;\n        }\n\n        if (gridFill.indexOf('-z') !== -1) {\n          gridInfo.reversedZ = true;\n        }\n\n        gridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n        var getVelocity = vectorField.getVelocity || function (p) {\n          return sampleMeshgrid(p, vectorField, gridInfo);\n        };\n\n        var getDivergence = vectorField.getDivergence || function (p, v0) {\n          var dp = vec3.create();\n          var e = 0.0001;\n          vec3.add(dp, p, [e, 0, 0]);\n          var vx = getVelocity(dp);\n          vec3.subtract(vx, vx, v0);\n          vec3.scale(vx, vx, 1 / e);\n          vec3.add(dp, p, [0, e, 0]);\n          var vy = getVelocity(dp);\n          vec3.subtract(vy, vy, v0);\n          vec3.scale(vy, vy, 1 / e);\n          vec3.add(dp, p, [0, 0, e]);\n          var vz = getVelocity(dp);\n          vec3.subtract(vz, vz, v0);\n          vec3.scale(vz, vz, 1 / e);\n          vec3.add(dp, vx, vy);\n          vec3.add(dp, dp, vz);\n          return dp;\n        };\n\n        var streams = [];\n        var minX = bounds[0][0],\n            minY = bounds[0][1],\n            minZ = bounds[0][2];\n        var maxX = bounds[1][0],\n            maxY = bounds[1][1],\n            maxZ = bounds[1][2];\n\n        var inBounds = function inBounds(p) {\n          var x = p[0];\n          var y = p[1];\n          var z = p[2];\n          return !(x < minX || x > maxX || y < minY || y > maxY || z < minZ || z > maxZ);\n        };\n\n        var boundsSize = vec3.distance(bounds[0], bounds[1]);\n        var maxStepSize = 10 * boundsSize / maxLength;\n        var maxStepSizeSq = maxStepSize * maxStepSize;\n        var minDistance = 1;\n        var maxDivergence = 0; // For component-wise divergence vec3.create();\n        // In case we need to do component-wise divergence visualization\n        // var tmp = vec3.create();\n\n        var len = positions.length;\n\n        if (len > 1) {\n          minDistance = calculateMinPositionDistance(positions);\n        }\n\n        for (var i = 0; i < len; i++) {\n          var p = vec3.create();\n          vec3.copy(p, positions[i]);\n          var stream = [p];\n          var velocities = [];\n          var v = getVelocity(p);\n          var op = p;\n          velocities.push(v);\n          var divergences = [];\n          var dv = getDivergence(p, v);\n          var dvLength = vec3.length(dv);\n\n          if (isFinite(dvLength) && dvLength > maxDivergence) {\n            maxDivergence = dvLength;\n          } // In case we need to do component-wise divergence visualization\n          // vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n          divergences.push(dvLength);\n          streams.push({\n            points: stream,\n            velocities: velocities,\n            divergences: divergences\n          });\n          var j = 0;\n\n          while (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n            j++;\n            var np = vec3.clone(v);\n            var sqLen = vec3.squaredLength(np);\n\n            if (sqLen === 0) {\n              break;\n            } else if (sqLen > maxStepSizeSq) {\n              vec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n            }\n\n            vec3.add(np, np, p);\n            v = getVelocity(np);\n\n            if (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n              stream.push(np);\n              op = np;\n              velocities.push(v);\n              var dv = getDivergence(np, v);\n              var dvLength = vec3.length(dv);\n\n              if (isFinite(dvLength) && dvLength > maxDivergence) {\n                maxDivergence = dvLength;\n              } // In case we need to do component-wise divergence visualization\n              //vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\n\n              divergences.push(dvLength);\n            }\n\n            p = np;\n          }\n        }\n\n        var tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n\n        if (absoluteTubeSize) {\n          tubes.tubeScale = absoluteTubeSize;\n        } else {\n          // Avoid division by zero.\n          if (maxDivergence === 0) {\n            maxDivergence = 1;\n          }\n\n          tubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n        }\n\n        return tubes;\n      };\n\n      var shaders = _glvis_('./lib/shaders');\n\n      var createMesh = _glvis_('gl-cone3d').createMesh;\n\n      module.exports.createTubeMesh = function (gl, params) {\n        return createMesh(gl, params, {\n          shaders: shaders,\n          traceType: 'streamtube'\n        });\n      };\n    }, {\n      \"./lib/shaders\": 142,\n      \"gl-cone3d\": 79,\n      \"gl-vec3\": 169,\n      \"gl-vec4\": 205\n    }],\n    144: [function (_glvis_, module, exports) {\n      var createShader = _glvis_('gl-shader');\n\n      var glslify = _glvis_('glslify');\n\n      var vertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec4 uv;\\nattribute vec3 f;\\nattribute vec3 normal;\\n\\nuniform vec3 objectOffset;\\nuniform mat4 model, view, projection, inverseModel;\\nuniform vec3 lightPosition, eyePosition;\\nuniform sampler2D colormap;\\n\\nvarying float value, kill;\\nvarying vec3 worldCoordinate;\\nvarying vec2 planeCoordinate;\\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  vec3 localCoordinate = vec3(uv.zw, f.x);\\n  worldCoordinate = objectOffset + localCoordinate;\\n  vec4 worldPosition = model * vec4(worldCoordinate, 1.0);\\n  vec4 clipPosition = projection * view * worldPosition;\\n  gl_Position = clipPosition;\\n  kill = f.y;\\n  value = f.z;\\n  planeCoordinate = uv.xy;\\n\\n  vColor = texture2D(colormap, vec2(value, value));\\n\\n  //Lighting geometry parameters\\n  vec4 cameraCoordinate = view * worldPosition;\\n  cameraCoordinate.xyz /= cameraCoordinate.w;\\n  lightDirection = lightPosition - cameraCoordinate.xyz;\\n  eyeDirection   = eyePosition - cameraCoordinate.xyz;\\n  surfaceNormal  = normalize((vec4(normal,0) * inverseModel).xyz);\\n}\\n\"]);\n      var fragSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nfloat beckmannDistribution(float x, float roughness) {\\n  float NdotH = max(x, 0.0001);\\n  float cos2Alpha = NdotH * NdotH;\\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\\n  float roughness2 = roughness * roughness;\\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\\n  return exp(tan2Alpha / roughness2) / denom;\\n}\\n\\nfloat beckmannSpecular(\\n  vec3 lightDirection,\\n  vec3 viewDirection,\\n  vec3 surfaceNormal,\\n  float roughness) {\\n  return beckmannDistribution(dot(surfaceNormal, normalize(lightDirection + viewDirection)), roughness);\\n}\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec3 lowerBound, upperBound;\\nuniform float contourTint;\\nuniform vec4 contourColor;\\nuniform sampler2D colormap;\\nuniform vec3 clipBounds[2];\\nuniform float roughness, fresnel, kambient, kdiffuse, kspecular, opacity;\\nuniform float vertexColor;\\n\\nvarying float value, kill;\\nvarying vec3 worldCoordinate;\\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  if (\\n    kill > 0.0 ||\\n    vColor.a == 0.0 ||\\n    outOfRange(clipBounds[0], clipBounds[1], worldCoordinate)\\n  ) discard;\\n\\n  vec3 N = normalize(surfaceNormal);\\n  vec3 V = normalize(eyeDirection);\\n  vec3 L = normalize(lightDirection);\\n\\n  if(gl_FrontFacing) {\\n    N = -N;\\n  }\\n\\n  float specular = max(beckmannSpecular(L, V, N, roughness), 0.);\\n  float diffuse  = min(kambient + kdiffuse * max(dot(N, L), 0.0), 1.0);\\n\\n  //decide how to interpolate color  in vertex or in fragment\\n  vec4 surfaceColor =\\n    step(vertexColor, .5) * texture2D(colormap, vec2(value, value)) +\\n    step(.5, vertexColor) * vColor;\\n\\n  vec4 litColor = surfaceColor.a * vec4(diffuse * surfaceColor.rgb + kspecular * vec3(1,1,1) * specular,  1.0);\\n\\n  gl_FragColor = mix(litColor, contourColor, contourTint) * opacity;\\n}\\n\"]);\n      var contourVertSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec4 uv;\\nattribute float f;\\n\\nuniform vec3 objectOffset;\\nuniform mat3 permutation;\\nuniform mat4 model, view, projection;\\nuniform float height, zOffset;\\nuniform sampler2D colormap;\\n\\nvarying float value, kill;\\nvarying vec3 worldCoordinate;\\nvarying vec2 planeCoordinate;\\nvarying vec3 lightDirection, eyeDirection, surfaceNormal;\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  vec3 dataCoordinate = permutation * vec3(uv.xy, height);\\n  worldCoordinate = objectOffset + dataCoordinate;\\n  vec4 worldPosition = model * vec4(worldCoordinate, 1.0);\\n\\n  vec4 clipPosition = projection * view * worldPosition;\\n  clipPosition.z += zOffset;\\n\\n  gl_Position = clipPosition;\\n  value = f + objectOffset.z;\\n  kill = -1.0;\\n  planeCoordinate = uv.zw;\\n\\n  vColor = texture2D(colormap, vec2(value, value));\\n\\n  //Don't do lighting for contours\\n  surfaceNormal   = vec3(1,0,0);\\n  eyeDirection    = vec3(0,1,0);\\n  lightDirection  = vec3(0,0,1);\\n}\\n\"]);\n      var pickSrc = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nbool outOfRange(float a, float b, float p) {\\n  return ((p > max(a, b)) || \\n          (p < min(a, b)));\\n}\\n\\nbool outOfRange(vec2 a, vec2 b, vec2 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y));\\n}\\n\\nbool outOfRange(vec3 a, vec3 b, vec3 p) {\\n  return (outOfRange(a.x, b.x, p.x) ||\\n          outOfRange(a.y, b.y, p.y) ||\\n          outOfRange(a.z, b.z, p.z));\\n}\\n\\nbool outOfRange(vec4 a, vec4 b, vec4 p) {\\n  return outOfRange(a.xyz, b.xyz, p.xyz);\\n}\\n\\nuniform vec2 shape;\\nuniform vec3 clipBounds[2];\\nuniform float pickId;\\n\\nvarying float value, kill;\\nvarying vec3 worldCoordinate;\\nvarying vec2 planeCoordinate;\\nvarying vec3 surfaceNormal;\\n\\nvec2 splitFloat(float v) {\\n  float vh = 255.0 * v;\\n  float upper = floor(vh);\\n  float lower = fract(vh);\\n  return vec2(upper / 255.0, floor(lower * 16.0) / 16.0);\\n}\\n\\nvoid main() {\\n  if ((kill > 0.0) ||\\n      (outOfRange(clipBounds[0], clipBounds[1], worldCoordinate))) discard;\\n\\n  vec2 ux = splitFloat(planeCoordinate.x / shape.x);\\n  vec2 uy = splitFloat(planeCoordinate.y / shape.y);\\n  gl_FragColor = vec4(pickId, ux.x, uy.x, ux.y + (uy.y/16.0));\\n}\\n\"]);\n\n      exports.createShader = function (gl) {\n        var shader = createShader(gl, vertSrc, fragSrc, null, [{\n          name: 'uv',\n          type: 'vec4'\n        }, {\n          name: 'f',\n          type: 'vec3'\n        }, {\n          name: 'normal',\n          type: 'vec3'\n        }]);\n        shader.attributes.uv.location = 0;\n        shader.attributes.f.location = 1;\n        shader.attributes.normal.location = 2;\n        return shader;\n      };\n\n      exports.createPickShader = function (gl) {\n        var shader = createShader(gl, vertSrc, pickSrc, null, [{\n          name: 'uv',\n          type: 'vec4'\n        }, {\n          name: 'f',\n          type: 'vec3'\n        }, {\n          name: 'normal',\n          type: 'vec3'\n        }]);\n        shader.attributes.uv.location = 0;\n        shader.attributes.f.location = 1;\n        shader.attributes.normal.location = 2;\n        return shader;\n      };\n\n      exports.createContourShader = function (gl) {\n        var shader = createShader(gl, contourVertSrc, fragSrc, null, [{\n          name: 'uv',\n          type: 'vec4'\n        }, {\n          name: 'f',\n          type: 'float'\n        }]);\n        shader.attributes.uv.location = 0;\n        shader.attributes.f.location = 1;\n        return shader;\n      };\n\n      exports.createPickContourShader = function (gl) {\n        var shader = createShader(gl, contourVertSrc, pickSrc, null, [{\n          name: 'uv',\n          type: 'vec4'\n        }, {\n          name: 'f',\n          type: 'float'\n        }]);\n        shader.attributes.uv.location = 0;\n        shader.attributes.f.location = 1;\n        return shader;\n      };\n    }, {\n      \"gl-shader\": 132,\n      \"glslify\": 231\n    }],\n    145: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createSurfacePlot;\n\n      var bits = _glvis_('bit-twiddle');\n\n      var createBuffer = _glvis_('gl-buffer');\n\n      var createVAO = _glvis_('gl-vao');\n\n      var createTexture = _glvis_('gl-texture2d');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var colormap = _glvis_('colormap');\n\n      var ops = _glvis_('ndarray-ops');\n\n      var pack = _glvis_('ndarray-pack');\n\n      var ndarray = _glvis_('ndarray');\n\n      var surfaceNets = _glvis_('surface-nets');\n\n      var multiply = _glvis_('gl-mat4/multiply');\n\n      var invert = _glvis_('gl-mat4/invert');\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var gradient = _glvis_('ndarray-gradient');\n\n      var shaders = _glvis_('./lib/shaders');\n\n      var createShader = shaders.createShader;\n      var createContourShader = shaders.createContourShader;\n      var createPickShader = shaders.createPickShader;\n      var createPickContourShader = shaders.createPickContourShader;\n      var SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);\n      var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n      var QUAD = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 0], [0, 1]];\n      var PERMUTATIONS = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\n      (function () {\n        for (var i = 0; i < 3; ++i) {\n          var p = PERMUTATIONS[i];\n          var u = (i + 1) % 3;\n          var v = (i + 2) % 3;\n          p[u + 0] = 1;\n          p[v + 3] = 1;\n          p[i + 6] = 1;\n        }\n      })();\n\n      function SurfacePickResult(position, index, uv, level, dataCoordinate) {\n        this.position = position;\n        this.index = index;\n        this.uv = uv;\n        this.level = level;\n        this.dataCoordinate = dataCoordinate;\n      }\n\n      var N_COLORS = 256;\n\n      function SurfacePlot(gl, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {\n        this.gl = gl;\n        this.shape = shape;\n        this.bounds = bounds;\n        this.objectOffset = objectOffset;\n        this.intensityBounds = [];\n        this._shader = shader;\n        this._pickShader = pickShader;\n        this._coordinateBuffer = coordinates;\n        this._vao = vao;\n        this._colorMap = colorMap;\n        this._contourShader = contourShader;\n        this._contourPickShader = contourPickShader;\n        this._contourBuffer = contourBuffer;\n        this._contourVAO = contourVAO;\n        this._contourOffsets = [[], [], []];\n        this._contourCounts = [[], [], []];\n        this._vertexCount = 0;\n        this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);\n        this._dynamicBuffer = dynamicBuffer;\n        this._dynamicVAO = dynamicVAO;\n        this._dynamicOffsets = [0, 0, 0];\n        this._dynamicCounts = [0, 0, 0];\n        this.contourWidth = [1, 1, 1];\n        this.contourLevels = [[1], [1], [1]];\n        this.contourTint = [0, 0, 0];\n        this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];\n        this.showContour = true;\n        this.showSurface = true;\n        this.enableHighlight = [true, true, true];\n        this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.highlightTint = [1, 1, 1];\n        this.highlightLevel = [-1, -1, -1]; // Dynamic contour options\n\n        this.enableDynamic = [true, true, true];\n        this.dynamicLevel = [NaN, NaN, NaN];\n        this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n        this.dynamicTint = [1, 1, 1];\n        this.dynamicWidth = [1, 1, 1];\n        this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n        this.surfaceProject = [false, false, false];\n        this.contourProject = [[false, false, false], [false, false, false], [false, false, false]];\n        this.colorBounds = [false, false]; // Store xyz fields, need this for picking\n\n        this._field = [ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0])];\n        this.pickId = 1;\n        this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n        this.snapToData = false;\n        this.pixelRatio = 1;\n        this.opacity = 1.0;\n        this.lightPosition = [10, 10000, 0];\n        this.ambientLight = 0.8;\n        this.diffuseLight = 0.8;\n        this.specularLight = 2.0;\n        this.roughness = 0.5;\n        this.fresnel = 1.5;\n        this.vertexColor = 0;\n        this.dirty = true;\n      }\n\n      var proto = SurfacePlot.prototype;\n\n      proto.genColormap = function (name, opacityscale) {\n        var hasAlpha = false;\n        var x = pack([colormap({\n          colormap: name,\n          nshades: N_COLORS,\n          format: 'rgba'\n        }).map(function (c, i) {\n          var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : c[3];\n          if (a < 1) hasAlpha = true;\n          return [c[0], c[1], c[2], 255 * a];\n        })]);\n        ops.divseq(x, 255.0);\n        this.hasAlphaScale = hasAlpha;\n        return x;\n      };\n\n      proto.isTransparent = function () {\n        return this.opacity < 1 || this.hasAlphaScale;\n      };\n\n      proto.isOpaque = function () {\n        return !this.isTransparent();\n      };\n\n      proto.pickSlots = 1;\n\n      proto.setPickBase = function (id) {\n        this.pickId = id;\n      };\n\n      function getOpacityFromScale(ratio, opacityscale) {\n        // copied form gl-mesh3d\n        if (!opacityscale) return 1;\n        if (!opacityscale.length) return 1;\n\n        for (var i = 0; i < opacityscale.length; ++i) {\n          if (opacityscale.length < 2) return 1;\n          if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n\n          if (opacityscale[i][0] > ratio && i > 0) {\n            var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n            return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n          }\n        }\n\n        return 1;\n      }\n\n      var ZERO_VEC = [0, 0, 0];\n      var PROJECT_DATA = {\n        showSurface: false,\n        showContour: false,\n        projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n        clipBounds: [[[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]]\n      };\n\n      function computeProjectionData(camera, obj) {\n        var i, j, k; // Compute cube properties\n\n        var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;\n        var showSurface = obj.showSurface;\n        var showContour = obj.showContour;\n\n        for (i = 0; i < 3; ++i) {\n          showSurface = showSurface || obj.surfaceProject[i];\n\n          for (j = 0; j < 3; ++j) {\n            showContour = showContour || obj.contourProject[i][j];\n          }\n        }\n\n        for (i = 0; i < 3; ++i) {\n          // Construct projection onto axis\n          var axisSquish = PROJECT_DATA.projections[i];\n\n          for (j = 0; j < 16; ++j) {\n            axisSquish[j] = 0;\n          }\n\n          for (j = 0; j < 4; ++j) {\n            axisSquish[5 * j] = 1;\n          }\n\n          axisSquish[5 * i] = 0;\n          axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];\n          multiply(axisSquish, camera.model, axisSquish);\n          var nclipBounds = PROJECT_DATA.clipBounds[i];\n\n          for (k = 0; k < 2; ++k) {\n            for (j = 0; j < 3; ++j) {\n              nclipBounds[k][j] = camera.clipBounds[k][j];\n            }\n          }\n\n          nclipBounds[0][i] = -1e8;\n          nclipBounds[1][i] = 1e8;\n        }\n\n        PROJECT_DATA.showSurface = showSurface;\n        PROJECT_DATA.showContour = showContour;\n        return PROJECT_DATA;\n      }\n\n      var UNIFORMS = {\n        model: IDENTITY,\n        view: IDENTITY,\n        projection: IDENTITY,\n        inverseModel: IDENTITY.slice(),\n        lowerBound: [0, 0, 0],\n        upperBound: [0, 0, 0],\n        colorMap: 0,\n        clipBounds: [[0, 0, 0], [0, 0, 0]],\n        height: 0.0,\n        contourTint: 0,\n        contourColor: [0, 0, 0, 1],\n        permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n        zOffset: -1e-4,\n        objectOffset: [0, 0, 0],\n        kambient: 1,\n        kdiffuse: 1,\n        kspecular: 1,\n        lightPosition: [1000, 1000, 1000],\n        eyePosition: [0, 0, 0],\n        roughness: 1,\n        fresnel: 1,\n        opacity: 1,\n        vertexColor: 0\n      };\n      var MATRIX_INVERSE = IDENTITY.slice();\n      var DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n      function drawCore(params, transparent) {\n        params = params || {};\n        var gl = this.gl;\n        gl.disable(gl.CULL_FACE);\n\n        this._colorMap.bind(0);\n\n        var uniforms = UNIFORMS;\n        uniforms.model = params.model || IDENTITY;\n        uniforms.view = params.view || IDENTITY;\n        uniforms.projection = params.projection || IDENTITY;\n        uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];\n        uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];\n        uniforms.objectOffset = this.objectOffset;\n        uniforms.contourColor = this.contourColor[0];\n        uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n\n        for (var i = 0; i < 2; ++i) {\n          var clipClamped = uniforms.clipBounds[i];\n\n          for (var j = 0; j < 3; ++j) {\n            clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n          }\n        }\n\n        uniforms.kambient = this.ambientLight;\n        uniforms.kdiffuse = this.diffuseLight;\n        uniforms.kspecular = this.specularLight;\n        uniforms.roughness = this.roughness;\n        uniforms.fresnel = this.fresnel;\n        uniforms.opacity = this.opacity;\n        uniforms.height = 0.0;\n        uniforms.permutation = DEFAULT_PERM;\n        uniforms.vertexColor = this.vertexColor; // Compute camera matrix inverse\n\n        var invCameraMatrix = MATRIX_INVERSE;\n        multiply(invCameraMatrix, uniforms.view, uniforms.model);\n        multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n        invert(invCameraMatrix, invCameraMatrix);\n\n        for (i = 0; i < 3; ++i) {\n          uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n        }\n\n        var w = invCameraMatrix[15];\n\n        for (i = 0; i < 3; ++i) {\n          w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n        }\n\n        for (i = 0; i < 3; ++i) {\n          var s = invCameraMatrix[12 + i];\n\n          for (j = 0; j < 3; ++j) {\n            s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n          }\n\n          uniforms.lightPosition[i] = s / w;\n        }\n\n        var projectData = computeProjectionData(uniforms, this);\n\n        if (projectData.showSurface) {\n          // Set up uniforms\n          this._shader.bind();\n\n          this._shader.uniforms = uniforms; // Draw it\n\n          this._vao.bind();\n\n          if (this.showSurface && this._vertexCount) {\n            this._vao.draw(gl.TRIANGLES, this._vertexCount);\n          } // Draw projections of surface\n\n\n          for (i = 0; i < 3; ++i) {\n            if (!this.surfaceProject[i] || !this.vertexCount) {\n              continue;\n            }\n\n            this._shader.uniforms.model = projectData.projections[i];\n            this._shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n            this._vao.draw(gl.TRIANGLES, this._vertexCount);\n          }\n\n          this._vao.unbind();\n        }\n\n        if (projectData.showContour) {\n          var shader = this._contourShader; // Don't apply lighting to contours\n\n          uniforms.kambient = 1.0;\n          uniforms.kdiffuse = 0.0;\n          uniforms.kspecular = 0.0;\n          uniforms.opacity = 1.0;\n          shader.bind();\n          shader.uniforms = uniforms; // Draw contour lines\n\n          var vao = this._contourVAO;\n          vao.bind(); // Draw contour levels\n\n          for (i = 0; i < 3; ++i) {\n            shader.uniforms.permutation = PERMUTATIONS[i];\n            gl.lineWidth(this.contourWidth[i] * this.pixelRatio);\n\n            for (j = 0; j < this.contourLevels[i].length; ++j) {\n              if (j === this.highlightLevel[i]) {\n                shader.uniforms.contourColor = this.highlightColor[i];\n                shader.uniforms.contourTint = this.highlightTint[i];\n              } else if (j === 0 || j - 1 === this.highlightLevel[i]) {\n                shader.uniforms.contourColor = this.contourColor[i];\n                shader.uniforms.contourTint = this.contourTint[i];\n              }\n\n              if (!this._contourCounts[i][j]) {\n                continue;\n              }\n\n              shader.uniforms.height = this.contourLevels[i][j];\n              vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);\n            }\n          } // Draw projections of surface\n\n\n          for (i = 0; i < 3; ++i) {\n            shader.uniforms.model = projectData.projections[i];\n            shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n            for (j = 0; j < 3; ++j) {\n              if (!this.contourProject[i][j]) {\n                continue;\n              }\n\n              shader.uniforms.permutation = PERMUTATIONS[j];\n              gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n              for (var k = 0; k < this.contourLevels[j].length; ++k) {\n                if (k === this.highlightLevel[j]) {\n                  shader.uniforms.contourColor = this.highlightColor[j];\n                  shader.uniforms.contourTint = this.highlightTint[j];\n                } else if (k === 0 || k - 1 === this.highlightLevel[j]) {\n                  shader.uniforms.contourColor = this.contourColor[j];\n                  shader.uniforms.contourTint = this.contourTint[j];\n                }\n\n                if (!this._contourCounts[j][k]) {\n                  continue;\n                }\n\n                shader.uniforms.height = this.contourLevels[j][k];\n                vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n              }\n            }\n          }\n\n          vao.unbind(); // Draw dynamic contours\n\n          vao = this._dynamicVAO;\n          vao.bind(); // Draw contour levels\n\n          for (i = 0; i < 3; ++i) {\n            if (this._dynamicCounts[i] === 0) {\n              continue;\n            }\n\n            shader.uniforms.model = uniforms.model;\n            shader.uniforms.clipBounds = uniforms.clipBounds;\n            shader.uniforms.permutation = PERMUTATIONS[i];\n            gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio);\n            shader.uniforms.contourColor = this.dynamicColor[i];\n            shader.uniforms.contourTint = this.dynamicTint[i];\n            shader.uniforms.height = this.dynamicLevel[i];\n            vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n\n            for (j = 0; j < 3; ++j) {\n              if (!this.contourProject[j][i]) {\n                continue;\n              }\n\n              shader.uniforms.model = projectData.projections[j];\n              shader.uniforms.clipBounds = projectData.clipBounds[j];\n              vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n            }\n          }\n\n          vao.unbind();\n        }\n      }\n\n      proto.draw = function (params) {\n        return drawCore.call(this, params, false);\n      };\n\n      proto.drawTransparent = function (params) {\n        return drawCore.call(this, params, true);\n      };\n\n      var PICK_UNIFORMS = {\n        model: IDENTITY,\n        view: IDENTITY,\n        projection: IDENTITY,\n        inverseModel: IDENTITY,\n        clipBounds: [[0, 0, 0], [0, 0, 0]],\n        height: 0.0,\n        shape: [0, 0],\n        pickId: 0,\n        lowerBound: [0, 0, 0],\n        upperBound: [0, 0, 0],\n        zOffset: 0.0,\n        objectOffset: [0, 0, 0],\n        permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n        lightPosition: [0, 0, 0],\n        eyePosition: [0, 0, 0]\n      };\n\n      proto.drawPick = function (params) {\n        params = params || {};\n        var gl = this.gl;\n        gl.disable(gl.CULL_FACE);\n        var uniforms = PICK_UNIFORMS;\n        uniforms.model = params.model || IDENTITY;\n        uniforms.view = params.view || IDENTITY;\n        uniforms.projection = params.projection || IDENTITY;\n        uniforms.shape = this._field[2].shape;\n        uniforms.pickId = this.pickId / 255.0;\n        uniforms.lowerBound = this.bounds[0];\n        uniforms.upperBound = this.bounds[1];\n        uniforms.objectOffset = this.objectOffset;\n        uniforms.permutation = DEFAULT_PERM;\n\n        for (var i = 0; i < 2; ++i) {\n          var clipClamped = uniforms.clipBounds[i];\n\n          for (var j = 0; j < 3; ++j) {\n            clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n          }\n        }\n\n        var projectData = computeProjectionData(uniforms, this);\n\n        if (projectData.showSurface) {\n          // Set up uniforms\n          this._pickShader.bind();\n\n          this._pickShader.uniforms = uniforms; // Draw it\n\n          this._vao.bind();\n\n          this._vao.draw(gl.TRIANGLES, this._vertexCount); // Draw projections of surface\n\n\n          for (i = 0; i < 3; ++i) {\n            if (!this.surfaceProject[i]) {\n              continue;\n            }\n\n            this._pickShader.uniforms.model = projectData.projections[i];\n            this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];\n\n            this._vao.draw(gl.TRIANGLES, this._vertexCount);\n          }\n\n          this._vao.unbind();\n        }\n\n        if (projectData.showContour) {\n          var shader = this._contourPickShader;\n          shader.bind();\n          shader.uniforms = uniforms;\n          var vao = this._contourVAO;\n          vao.bind();\n\n          for (j = 0; j < 3; ++j) {\n            gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n            shader.uniforms.permutation = PERMUTATIONS[j];\n\n            for (i = 0; i < this.contourLevels[j].length; ++i) {\n              if (this._contourCounts[j][i]) {\n                shader.uniforms.height = this.contourLevels[j][i];\n                vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);\n              }\n            }\n          } // Draw projections of surface\n\n\n          for (i = 0; i < 3; ++i) {\n            shader.uniforms.model = projectData.projections[i];\n            shader.uniforms.clipBounds = projectData.clipBounds[i];\n\n            for (j = 0; j < 3; ++j) {\n              if (!this.contourProject[i][j]) {\n                continue;\n              }\n\n              shader.uniforms.permutation = PERMUTATIONS[j];\n              gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n\n              for (var k = 0; k < this.contourLevels[j].length; ++k) {\n                if (this._contourCounts[j][k]) {\n                  shader.uniforms.height = this.contourLevels[j][k];\n                  vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n                }\n              }\n            }\n          }\n\n          vao.unbind();\n        }\n      };\n\n      proto.pick = function (selection) {\n        if (!selection) {\n          return null;\n        }\n\n        if (selection.id !== this.pickId) {\n          return null;\n        }\n\n        var shape = this._field[2].shape;\n        var result = this._pickResult; // Compute uv coordinate\n\n        var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0;\n        var ix = Math.floor(x);\n        var fx = x - ix;\n        var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0;\n        var iy = Math.floor(y);\n        var fy = y - iy;\n        ix += 1;\n        iy += 1; // Compute xyz coordinate\n\n        var pos = result.position;\n        pos[0] = pos[1] = pos[2] = 0;\n\n        for (var dx = 0; dx < 2; ++dx) {\n          var s = dx ? fx : 1.0 - fx;\n\n          for (var dy = 0; dy < 2; ++dy) {\n            var t = dy ? fy : 1.0 - fy;\n            var r = ix + dx;\n            var c = iy + dy;\n            var w = s * t;\n\n            for (var i = 0; i < 3; ++i) {\n              pos[i] += this._field[i].get(r, c) * w;\n            }\n          }\n        } // Find closest level\n\n\n        var levelIndex = this._pickResult.level;\n\n        for (var j = 0; j < 3; ++j) {\n          levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);\n\n          if (levelIndex[j] < 0) {\n            if (this.contourLevels[j].length > 0) {\n              levelIndex[j] = 0;\n            }\n          } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n            var a = this.contourLevels[j][levelIndex[j]];\n            var b = this.contourLevels[j][levelIndex[j] + 1];\n\n            if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n              levelIndex[j] += 1;\n            }\n          }\n        }\n\n        result.index[0] = fx < 0.5 ? ix : ix + 1;\n        result.index[1] = fy < 0.5 ? iy : iy + 1;\n        result.uv[0] = x / shape[0];\n        result.uv[1] = y / shape[1];\n\n        for (i = 0; i < 3; ++i) {\n          result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);\n        }\n\n        return result;\n      };\n\n      proto.padField = function (dstField, srcField) {\n        var srcShape = srcField.shape.slice();\n        var dstShape = dstField.shape.slice(); // Center\n\n        ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField); // Edges\n\n        ops.assign(dstField.lo(1).hi(srcShape[0], 1), srcField.hi(srcShape[0], 1));\n        ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1), srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1));\n        ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]), srcField.hi(1));\n        ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]), srcField.lo(srcShape[0] - 1)); // Corners\n\n        dstField.set(0, 0, srcField.get(0, 0));\n        dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));\n        dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));\n        dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));\n      };\n\n      function handleArray(param, ctor) {\n        if (Array.isArray(param)) {\n          return [ctor(param[0]), ctor(param[1]), ctor(param[2])];\n        }\n\n        return [ctor(param), ctor(param), ctor(param)];\n      }\n\n      function toColor(x) {\n        if (Array.isArray(x)) {\n          if (x.length === 3) {\n            return [x[0], x[1], x[2], 1];\n          }\n\n          return [x[0], x[1], x[2], x[3]];\n        }\n\n        return [0, 0, 0, 1];\n      }\n\n      function handleColor(param) {\n        if (Array.isArray(param)) {\n          if (Array.isArray(param)) {\n            return [toColor(param[0]), toColor(param[1]), toColor(param[2])];\n          } else {\n            var c = toColor(param);\n            return [c.slice(), c.slice(), c.slice()];\n          }\n        }\n      }\n\n      proto.update = function (params) {\n        params = params || {};\n        this.objectOffset = params.objectOffset || this.objectOffset;\n        this.dirty = true;\n\n        if ('contourWidth' in params) {\n          this.contourWidth = handleArray(params.contourWidth, Number);\n        }\n\n        if ('showContour' in params) {\n          this.showContour = handleArray(params.showContour, Boolean);\n        }\n\n        if ('showSurface' in params) {\n          this.showSurface = !!params.showSurface;\n        }\n\n        if ('contourTint' in params) {\n          this.contourTint = handleArray(params.contourTint, Boolean);\n        }\n\n        if ('contourColor' in params) {\n          this.contourColor = handleColor(params.contourColor);\n        }\n\n        if ('contourProject' in params) {\n          this.contourProject = handleArray(params.contourProject, function (x) {\n            return handleArray(x, Boolean);\n          });\n        }\n\n        if ('surfaceProject' in params) {\n          this.surfaceProject = params.surfaceProject;\n        }\n\n        if ('dynamicColor' in params) {\n          this.dynamicColor = handleColor(params.dynamicColor);\n        }\n\n        if ('dynamicTint' in params) {\n          this.dynamicTint = handleArray(params.dynamicTint, Number);\n        }\n\n        if ('dynamicWidth' in params) {\n          this.dynamicWidth = handleArray(params.dynamicWidth, Number);\n        }\n\n        if ('opacity' in params) {\n          this.opacity = params.opacity;\n        }\n\n        if ('opacityscale' in params) {\n          this.opacityscale = params.opacityscale;\n        }\n\n        if ('colorBounds' in params) {\n          this.colorBounds = params.colorBounds;\n        }\n\n        if ('vertexColor' in params) {\n          this.vertexColor = params.vertexColor ? 1 : 0;\n        }\n\n        if ('colormap' in params) {\n          this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale));\n        }\n\n        var field = params.field || params.coords && params.coords[2] || null;\n        var levelsChanged = false;\n\n        if (!field) {\n          if (this._field[2].shape[0] || this._field[2].shape[2]) {\n            field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);\n          } else {\n            field = this._field[2].hi(0, 0);\n          }\n        } // Update field\n\n\n        if ('field' in params || 'coords' in params) {\n          var fsize = (field.shape[0] + 2) * (field.shape[1] + 2); // Resize if necessary\n\n          if (fsize > this._field[2].data.length) {\n            pool.freeFloat(this._field[2].data);\n            this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));\n          } // Pad field\n\n\n          this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);\n          this.padField(this._field[2], field); // Save shape of field\n\n          this.shape = field.shape.slice();\n          var shape = this.shape; // Resize coordinate fields if necessary\n\n          for (var i = 0; i < 2; ++i) {\n            if (this._field[2].size > this._field[i].data.length) {\n              pool.freeFloat(this._field[i].data);\n              this._field[i].data = pool.mallocFloat(this._field[2].size);\n            }\n\n            this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);\n          } // Generate x/y coordinates\n\n\n          if (params.coords) {\n            var coords = params.coords;\n\n            if (!Array.isArray(coords) || coords.length !== 3) {\n              throw new Error('gl-surface: invalid coordinates for x/y');\n            }\n\n            for (i = 0; i < 2; ++i) {\n              var coord = coords[i];\n\n              for (j = 0; j < 2; ++j) {\n                if (coord.shape[j] !== shape[j]) {\n                  throw new Error('gl-surface: coords have incorrect shape');\n                }\n              }\n\n              this.padField(this._field[i], coord);\n            }\n          } else if (params.ticks) {\n            var ticks = params.ticks;\n\n            if (!Array.isArray(ticks) || ticks.length !== 2) {\n              throw new Error('gl-surface: invalid ticks');\n            }\n\n            for (i = 0; i < 2; ++i) {\n              var tick = ticks[i];\n\n              if (Array.isArray(tick) || tick.length) {\n                tick = ndarray(tick);\n              }\n\n              if (tick.shape[0] !== shape[i]) {\n                throw new Error('gl-surface: invalid tick length');\n              } // Make a copy view of the tick array\n\n\n              var tick2 = ndarray(tick.data, shape);\n              tick2.stride[i] = tick.stride[0];\n              tick2.stride[i ^ 1] = 0; // Fill in field array\n\n              this.padField(this._field[i], tick2);\n            }\n          } else {\n            for (i = 0; i < 2; ++i) {\n              var offset = [0, 0];\n              offset[i] = 1;\n              this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);\n            }\n\n            this._field[0].set(0, 0, 0);\n\n            for (var j = 0; j < shape[0]; ++j) {\n              this._field[0].set(j + 1, 0, j);\n            }\n\n            this._field[0].set(shape[0] + 1, 0, shape[0] - 1);\n\n            this._field[1].set(0, 0, 0);\n\n            for (j = 0; j < shape[1]; ++j) {\n              this._field[1].set(0, j + 1, j);\n            }\n\n            this._field[1].set(0, shape[1] + 1, shape[1] - 1);\n          } // Save shape\n\n\n          var fields = this._field; // Compute surface normals\n\n          var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);\n\n          for (i = 0; i < 3; ++i) {\n            gradient(dfields.pick(i), fields[i], 'mirror');\n          }\n\n          var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);\n\n          for (i = 0; i < shape[0] + 2; ++i) {\n            for (j = 0; j < shape[1] + 2; ++j) {\n              var dxdu = dfields.get(0, i, j, 0);\n              var dxdv = dfields.get(0, i, j, 1);\n              var dydu = dfields.get(1, i, j, 0);\n              var dydv = dfields.get(1, i, j, 1);\n              var dzdu = dfields.get(2, i, j, 0);\n              var dzdv = dfields.get(2, i, j, 1);\n              var nx = dydu * dzdv - dydv * dzdu;\n              var ny = dzdu * dxdv - dzdv * dxdu;\n              var nz = dxdu * dydv - dxdv * dydu;\n              var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n              if (nl < 1e-8) {\n                nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));\n\n                if (nl < 1e-8) {\n                  nz = 1.0;\n                  ny = nx = 0.0;\n                  nl = 1.0;\n                } else {\n                  nl = 1.0 / nl;\n                }\n              } else {\n                nl = 1.0 / Math.sqrt(nl);\n              }\n\n              normals.set(i, j, 0, nx * nl);\n              normals.set(i, j, 1, ny * nl);\n              normals.set(i, j, 2, nz * nl);\n            }\n          }\n\n          pool.free(dfields.data); // Initialize surface\n\n          var lo = [Infinity, Infinity, Infinity];\n          var hi = [-Infinity, -Infinity, -Infinity];\n          var lo_intensity = Infinity;\n          var hi_intensity = -Infinity;\n          var count = (shape[0] - 1) * (shape[1] - 1) * 6;\n          var tverts = pool.mallocFloat(bits.nextPow2(10 * count));\n          var tptr = 0;\n          var vertexCount = 0;\n\n          for (i = 0; i < shape[0] - 1; ++i) {\n            j_loop: for (j = 0; j < shape[1] - 1; ++j) {\n              // Test for NaNs\n              for (var dx = 0; dx < 2; ++dx) {\n                for (var dy = 0; dy < 2; ++dy) {\n                  for (var k = 0; k < 3; ++k) {\n                    var f = this._field[k].get(1 + i + dx, 1 + j + dy);\n\n                    if (isNaN(f) || !isFinite(f)) {\n                      continue j_loop;\n                    }\n                  }\n                }\n              }\n\n              for (k = 0; k < 6; ++k) {\n                var r = i + QUAD[k][0];\n                var c = j + QUAD[k][1];\n\n                var tx = this._field[0].get(r + 1, c + 1);\n\n                var ty = this._field[1].get(r + 1, c + 1);\n\n                f = this._field[2].get(r + 1, c + 1);\n                nx = normals.get(r + 1, c + 1, 0);\n                ny = normals.get(r + 1, c + 1, 1);\n                nz = normals.get(r + 1, c + 1, 2);\n\n                if (params.intensity) {\n                  vf = params.intensity.get(r, c);\n                }\n\n                var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];\n                tverts[tptr++] = r;\n                tverts[tptr++] = c;\n                tverts[tptr++] = tx;\n                tverts[tptr++] = ty;\n                tverts[tptr++] = f;\n                tverts[tptr++] = 0;\n                tverts[tptr++] = vf;\n                tverts[tptr++] = nx;\n                tverts[tptr++] = ny;\n                tverts[tptr++] = nz;\n                lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);\n                lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);\n                lo[2] = Math.min(lo[2], f + this.objectOffset[2]);\n                lo_intensity = Math.min(lo_intensity, vf);\n                hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);\n                hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);\n                hi[2] = Math.max(hi[2], f + this.objectOffset[2]);\n                hi_intensity = Math.max(hi_intensity, vf);\n                vertexCount += 1;\n              }\n            }\n          }\n\n          if (params.intensityBounds) {\n            lo_intensity = +params.intensityBounds[0];\n            hi_intensity = +params.intensityBounds[1];\n          } // Scale all vertex intensities\n\n\n          for (i = 6; i < tptr; i += 10) {\n            tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);\n          }\n\n          this._vertexCount = vertexCount;\n\n          this._coordinateBuffer.update(tverts.subarray(0, tptr));\n\n          pool.freeFloat(tverts);\n          pool.free(normals.data); // Update bounds\n\n          this.bounds = [lo, hi]; // Save intensity\n\n          this.intensity = params.intensity || this._field[2];\n\n          if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n            levelsChanged = true;\n          } // Save intensity bound\n\n\n          this.intensityBounds = [lo_intensity, hi_intensity];\n        } // Update level crossings\n\n\n        if ('levels' in params) {\n          var levels = params.levels;\n\n          if (!Array.isArray(levels[0])) {\n            levels = [[], [], levels];\n          } else {\n            levels = levels.slice();\n          }\n\n          for (i = 0; i < 3; ++i) {\n            levels[i] = levels[i].slice();\n            levels[i].sort(function (a, b) {\n              return a - b;\n            });\n          }\n\n          for (i = 0; i < 3; ++i) {\n            for (j = 0; j < levels[i].length; ++j) {\n              levels[i][j] -= this.objectOffset[i];\n            }\n          }\n\n          change_test: for (i = 0; i < 3; ++i) {\n            if (levels[i].length !== this.contourLevels[i].length) {\n              levelsChanged = true;\n              break;\n            }\n\n            for (j = 0; j < levels[i].length; ++j) {\n              if (levels[i][j] !== this.contourLevels[i][j]) {\n                levelsChanged = true;\n                break change_test;\n              }\n            }\n          }\n\n          this.contourLevels = levels;\n        }\n\n        if (levelsChanged) {\n          fields = this._field;\n          shape = this.shape; // Update contour lines\n\n          var contourVerts = [];\n\n          for (var dim = 0; dim < 3; ++dim) {\n            var contourLevel = this.contourLevels[dim];\n            var levelOffsets = [];\n            var levelCounts = [];\n            var parts = [0, 0, 0];\n\n            for (i = 0; i < contourLevel.length; ++i) {\n              var graph = surfaceNets(this._field[dim], contourLevel[i]);\n              levelOffsets.push(contourVerts.length / 5 | 0);\n              vertexCount = 0;\n\n              edge_loop: for (j = 0; j < graph.cells.length; ++j) {\n                var e = graph.cells[j];\n\n                for (k = 0; k < 2; ++k) {\n                  var p = graph.positions[e[k]];\n                  var x = p[0];\n                  var ix = Math.floor(x) | 0;\n                  var fx = x - ix;\n                  var y = p[1];\n                  var iy = Math.floor(y) | 0;\n                  var fy = y - iy;\n                  var hole = false;\n\n                  axis_loop: for (var axis = 0; axis < 3; ++axis) {\n                    parts[axis] = 0.0;\n                    var iu = (dim + axis + 1) % 3;\n\n                    for (dx = 0; dx < 2; ++dx) {\n                      var s = dx ? fx : 1.0 - fx;\n                      r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;\n\n                      for (dy = 0; dy < 2; ++dy) {\n                        var t = dy ? fy : 1.0 - fy;\n                        c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;\n\n                        if (axis < 2) {\n                          f = this._field[iu].get(r, c);\n                        } else {\n                          f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);\n                        }\n\n                        if (!isFinite(f) || isNaN(f)) {\n                          hole = true;\n                          break axis_loop;\n                        }\n\n                        var w = s * t;\n                        parts[axis] += w * f;\n                      }\n                    }\n                  }\n\n                  if (!hole) {\n                    contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2]);\n                    vertexCount += 1;\n                  } else {\n                    if (k > 0) {\n                      // If we already added first edge, pop off verts\n                      for (var l = 0; l < 5; ++l) {\n                        contourVerts.pop();\n                      }\n\n                      vertexCount -= 1;\n                    }\n\n                    continue edge_loop;\n                  }\n                }\n              }\n\n              levelCounts.push(vertexCount);\n            } // Store results\n\n\n            this._contourOffsets[dim] = levelOffsets;\n            this._contourCounts[dim] = levelCounts;\n          }\n\n          var floatBuffer = pool.mallocFloat(contourVerts.length);\n\n          for (i = 0; i < contourVerts.length; ++i) {\n            floatBuffer[i] = contourVerts[i];\n          }\n\n          this._contourBuffer.update(floatBuffer);\n\n          pool.freeFloat(floatBuffer);\n        }\n      };\n\n      proto.dispose = function () {\n        this._shader.dispose();\n\n        this._vao.dispose();\n\n        this._coordinateBuffer.dispose();\n\n        this._colorMap.dispose();\n\n        this._contourBuffer.dispose();\n\n        this._contourVAO.dispose();\n\n        this._contourShader.dispose();\n\n        this._contourPickShader.dispose();\n\n        this._dynamicBuffer.dispose();\n\n        this._dynamicVAO.dispose();\n\n        for (var i = 0; i < 3; ++i) {\n          pool.freeFloat(this._field[i].data);\n        }\n      };\n\n      proto.highlight = function (selection) {\n        var i;\n\n        if (!selection) {\n          this._dynamicCounts = [0, 0, 0];\n          this.dyanamicLevel = [NaN, NaN, NaN];\n          this.highlightLevel = [-1, -1, -1];\n          return;\n        }\n\n        for (i = 0; i < 3; ++i) {\n          if (this.enableHighlight[i]) {\n            this.highlightLevel[i] = selection.level[i];\n          } else {\n            this.highlightLevel[i] = -1;\n          }\n        }\n\n        var levels;\n\n        if (this.snapToData) {\n          levels = selection.dataCoordinate;\n        } else {\n          levels = selection.position;\n        }\n\n        for (i = 0; i < 3; ++i) {\n          levels[i] -= this.objectOffset[i];\n        }\n\n        if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n          return;\n        }\n\n        var vertexCount = 0;\n        var shape = this.shape;\n        var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);\n\n        for (var d = 0; d < 3; ++d) {\n          if (!this.enableDynamic[d]) {\n            this.dynamicLevel[d] = NaN;\n            this._dynamicCounts[d] = 0;\n            continue;\n          }\n\n          this.dynamicLevel[d] = levels[d];\n          var u = (d + 1) % 3;\n          var v = (d + 2) % 3;\n          var f = this._field[d];\n          var g = this._field[u];\n          var h = this._field[v];\n          var graph = surfaceNets(f, levels[d]);\n          var edges = graph.cells;\n          var positions = graph.positions;\n          this._dynamicOffsets[d] = vertexCount;\n\n          for (i = 0; i < edges.length; ++i) {\n            var e = edges[i];\n\n            for (var j = 0; j < 2; ++j) {\n              var p = positions[e[j]];\n              var x = +p[0];\n              var ix = x | 0;\n              var jx = Math.min(ix + 1, shape[0]) | 0;\n              var fx = x - ix;\n              var hx = 1.0 - fx;\n              var y = +p[1];\n              var iy = y | 0;\n              var jy = Math.min(iy + 1, shape[1]) | 0;\n              var fy = y - iy;\n              var hy = 1.0 - fy;\n              var w00 = hx * hy;\n              var w01 = hx * fy;\n              var w10 = fx * hy;\n              var w11 = fx * fy;\n              var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);\n              var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);\n\n              if (isNaN(cu) || isNaN(cv)) {\n                if (j) {\n                  vertexCount -= 1;\n                }\n\n                break;\n              }\n\n              scratchBuffer[2 * vertexCount + 0] = cu;\n              scratchBuffer[2 * vertexCount + 1] = cv;\n              vertexCount += 1;\n            }\n          }\n\n          this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];\n        }\n\n        this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));\n\n        pool.freeFloat(scratchBuffer);\n      };\n\n      function createSurfacePlot(params) {\n        var gl = params.gl;\n        var shader = createShader(gl);\n        var pickShader = createPickShader(gl);\n        var contourShader = createContourShader(gl);\n        var contourPickShader = createPickContourShader(gl);\n        var coordinateBuffer = createBuffer(gl);\n        var vao = createVAO(gl, [{\n          buffer: coordinateBuffer,\n          size: 4,\n          stride: SURFACE_VERTEX_SIZE,\n          offset: 0\n        }, {\n          buffer: coordinateBuffer,\n          size: 3,\n          stride: SURFACE_VERTEX_SIZE,\n          offset: 16\n        }, {\n          buffer: coordinateBuffer,\n          size: 3,\n          stride: SURFACE_VERTEX_SIZE,\n          offset: 28\n        }]);\n        var contourBuffer = createBuffer(gl);\n        var contourVAO = createVAO(gl, [{\n          buffer: contourBuffer,\n          size: 4,\n          stride: 20,\n          offset: 0\n        }, {\n          buffer: contourBuffer,\n          size: 1,\n          stride: 20,\n          offset: 16\n        }]);\n        var dynamicBuffer = createBuffer(gl);\n        var dynamicVAO = createVAO(gl, [{\n          buffer: dynamicBuffer,\n          size: 2,\n          type: gl.FLOAT\n        }]);\n        var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE);\n        cmap.minFilter = gl.LINEAR;\n        cmap.magFilter = gl.LINEAR;\n        var surface = new SurfacePlot(gl, [0, 0], // shape\n        [[0, 0, 0], [0, 0, 0]], // bounds\n        shader, pickShader, coordinateBuffer, vao, cmap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, [0, 0, 0] // objectOffset\n        );\n        var nparams = {\n          levels: [[], [], []]\n        };\n\n        for (var id in params) {\n          nparams[id] = params[id];\n        }\n\n        nparams.colormap = nparams.colormap || 'jet';\n        surface.update(nparams);\n        return surface;\n      }\n    }, {\n      \"./lib/shaders\": 144,\n      \"binary-search-bounds\": 31,\n      \"bit-twiddle\": 32,\n      \"colormap\": 53,\n      \"gl-buffer\": 78,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/multiply\": 100,\n      \"gl-texture2d\": 146,\n      \"gl-vao\": 150,\n      \"ndarray\": 259,\n      \"ndarray-gradient\": 252,\n      \"ndarray-ops\": 254,\n      \"ndarray-pack\": 255,\n      \"surface-nets\": 302,\n      \"typedarray-pool\": 308\n    }],\n    146: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var ndarray = _glvis_('ndarray');\n\n      var ops = _glvis_('ndarray-ops');\n\n      var pool = _glvis_('typedarray-pool');\n\n      module.exports = createTexture2D;\n      var linearTypes = null;\n      var filterTypes = null;\n      var wrapTypes = null;\n\n      function lazyInitLinearTypes(gl) {\n        linearTypes = [gl.LINEAR, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_NEAREST];\n        filterTypes = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n        wrapTypes = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n      }\n\n      function acceptTextureDOM(obj) {\n        return 'undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement || 'undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement || 'undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement || 'undefined' != typeof ImageData && obj instanceof ImageData;\n      }\n\n      var convertFloatToUint8 = function convertFloatToUint8(out, inp) {\n        ops.muls(out, inp, 255.0);\n      };\n\n      function reshapeTexture(tex, w, h) {\n        var gl = tex.gl;\n        var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n        if (w < 0 || w > maxSize || h < 0 || h > maxSize) {\n          throw new Error('gl-texture2d: Invalid texture size');\n        }\n\n        tex._shape = [w, h];\n        tex.bind();\n        gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null);\n        tex._mipLevels = [0];\n        return tex;\n      }\n\n      function Texture2D(gl, handle, width, height, format, type) {\n        this.gl = gl;\n        this.handle = handle;\n        this.format = format;\n        this.type = type;\n        this._shape = [width, height];\n        this._mipLevels = [0];\n        this._magFilter = gl.NEAREST;\n        this._minFilter = gl.NEAREST;\n        this._wrapS = gl.CLAMP_TO_EDGE;\n        this._wrapT = gl.CLAMP_TO_EDGE;\n        this._anisoSamples = 1;\n        var parent = this;\n        var wrapVector = [this._wrapS, this._wrapT];\n        Object.defineProperties(wrapVector, [{\n          get: function get() {\n            return parent._wrapS;\n          },\n          set: function set(v) {\n            return parent.wrapS = v;\n          }\n        }, {\n          get: function get() {\n            return parent._wrapT;\n          },\n          set: function set(v) {\n            return parent.wrapT = v;\n          }\n        }]);\n        this._wrapVector = wrapVector;\n        var shapeVector = [this._shape[0], this._shape[1]];\n        Object.defineProperties(shapeVector, [{\n          get: function get() {\n            return parent._shape[0];\n          },\n          set: function set(v) {\n            return parent.width = v;\n          }\n        }, {\n          get: function get() {\n            return parent._shape[1];\n          },\n          set: function set(v) {\n            return parent.height = v;\n          }\n        }]);\n        this._shapeVector = shapeVector;\n      }\n\n      var proto = Texture2D.prototype;\n      Object.defineProperties(proto, {\n        minFilter: {\n          get: function get() {\n            return this._minFilter;\n          },\n          set: function set(v) {\n            this.bind();\n            var gl = this.gl;\n\n            if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {\n              if (!gl.getExtension('OES_texture_float_linear')) {\n                v = gl.NEAREST;\n              }\n            }\n\n            if (filterTypes.indexOf(v) < 0) {\n              throw new Error('gl-texture2d: Unknown filter mode ' + v);\n            }\n\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v);\n            return this._minFilter = v;\n          }\n        },\n        magFilter: {\n          get: function get() {\n            return this._magFilter;\n          },\n          set: function set(v) {\n            this.bind();\n            var gl = this.gl;\n\n            if (this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {\n              if (!gl.getExtension('OES_texture_float_linear')) {\n                v = gl.NEAREST;\n              }\n            }\n\n            if (filterTypes.indexOf(v) < 0) {\n              throw new Error('gl-texture2d: Unknown filter mode ' + v);\n            }\n\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v);\n            return this._magFilter = v;\n          }\n        },\n        mipSamples: {\n          get: function get() {\n            return this._anisoSamples;\n          },\n          set: function set(i) {\n            var psamples = this._anisoSamples;\n            this._anisoSamples = Math.max(i, 1) | 0;\n\n            if (psamples !== this._anisoSamples) {\n              var ext = this.gl.getExtension('EXT_texture_filter_anisotropic');\n\n              if (ext) {\n                this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples);\n              }\n            }\n\n            return this._anisoSamples;\n          }\n        },\n        wrapS: {\n          get: function get() {\n            return this._wrapS;\n          },\n          set: function set(v) {\n            this.bind();\n\n            if (wrapTypes.indexOf(v) < 0) {\n              throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n            }\n\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v);\n            return this._wrapS = v;\n          }\n        },\n        wrapT: {\n          get: function get() {\n            return this._wrapT;\n          },\n          set: function set(v) {\n            this.bind();\n\n            if (wrapTypes.indexOf(v) < 0) {\n              throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n            }\n\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v);\n            return this._wrapT = v;\n          }\n        },\n        wrap: {\n          get: function get() {\n            return this._wrapVector;\n          },\n          set: function set(v) {\n            if (!Array.isArray(v)) {\n              v = [v, v];\n            }\n\n            if (v.length !== 2) {\n              throw new Error('gl-texture2d: Must specify wrap mode for rows and columns');\n            }\n\n            for (var i = 0; i < 2; ++i) {\n              if (wrapTypes.indexOf(v[i]) < 0) {\n                throw new Error('gl-texture2d: Unknown wrap mode ' + v);\n              }\n            }\n\n            this._wrapS = v[0];\n            this._wrapT = v[1];\n            var gl = this.gl;\n            this.bind();\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);\n            return v;\n          }\n        },\n        shape: {\n          get: function get() {\n            return this._shapeVector;\n          },\n          set: function set(x) {\n            if (!Array.isArray(x)) {\n              x = [x | 0, x | 0];\n            } else {\n              if (x.length !== 2) {\n                throw new Error('gl-texture2d: Invalid texture shape');\n              }\n            }\n\n            reshapeTexture(this, x[0] | 0, x[1] | 0);\n            return [x[0] | 0, x[1] | 0];\n          }\n        },\n        width: {\n          get: function get() {\n            return this._shape[0];\n          },\n          set: function set(w) {\n            w = w | 0;\n            reshapeTexture(this, w, this._shape[1]);\n            return w;\n          }\n        },\n        height: {\n          get: function get() {\n            return this._shape[1];\n          },\n          set: function set(h) {\n            h = h | 0;\n            reshapeTexture(this, this._shape[0], h);\n            return h;\n          }\n        }\n      });\n\n      proto.bind = function (unit) {\n        var gl = this.gl;\n\n        if (unit !== undefined) {\n          gl.activeTexture(gl.TEXTURE0 + (unit | 0));\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, this.handle);\n\n        if (unit !== undefined) {\n          return unit | 0;\n        }\n\n        return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;\n      };\n\n      proto.dispose = function () {\n        this.gl.deleteTexture(this.handle);\n      };\n\n      proto.generateMipmap = function () {\n        this.bind();\n        this.gl.generateMipmap(this.gl.TEXTURE_2D); //Update mip levels\n\n        var l = Math.min(this._shape[0], this._shape[1]);\n\n        for (var i = 0; l > 0; ++i, l >>>= 1) {\n          if (this._mipLevels.indexOf(i) < 0) {\n            this._mipLevels.push(i);\n          }\n        }\n      };\n\n      proto.setPixels = function (data, x_off, y_off, mip_level) {\n        var gl = this.gl;\n        this.bind();\n\n        if (Array.isArray(x_off)) {\n          mip_level = y_off;\n          y_off = x_off[1] | 0;\n          x_off = x_off[0] | 0;\n        } else {\n          x_off = x_off || 0;\n          y_off = y_off || 0;\n        }\n\n        mip_level = mip_level || 0;\n        var directData = acceptTextureDOM(data) ? data : data.raw;\n\n        if (directData) {\n          var needsMip = this._mipLevels.indexOf(mip_level) < 0;\n\n          if (needsMip) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData);\n\n            this._mipLevels.push(mip_level);\n          } else {\n            gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData);\n          }\n        } else if (data.shape && data.stride && data.data) {\n          if (data.shape.length < 2 || x_off + data.shape[1] > this._shape[1] >>> mip_level || y_off + data.shape[0] > this._shape[0] >>> mip_level || x_off < 0 || y_off < 0) {\n            throw new Error('gl-texture2d: Texture dimensions are out of bounds');\n          }\n\n          texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data);\n        } else {\n          throw new Error('gl-texture2d: Unsupported data type');\n        }\n      };\n\n      function isPacked(shape, stride) {\n        if (shape.length === 3) {\n          return stride[2] === 1 && stride[1] === shape[0] * shape[2] && stride[0] === shape[2];\n        }\n\n        return stride[0] === 1 && stride[1] === shape[0];\n      }\n\n      function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {\n        var dtype = array.dtype;\n        var shape = array.shape.slice();\n\n        if (shape.length < 2 || shape.length > 3) {\n          throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d');\n        }\n\n        var type = 0,\n            format = 0;\n        var packed = isPacked(shape, array.stride.slice());\n\n        if (dtype === 'float32') {\n          type = gl.FLOAT;\n        } else if (dtype === 'float64') {\n          type = gl.FLOAT;\n          packed = false;\n          dtype = 'float32';\n        } else if (dtype === 'uint8') {\n          type = gl.UNSIGNED_BYTE;\n        } else {\n          type = gl.UNSIGNED_BYTE;\n          packed = false;\n          dtype = 'uint8';\n        }\n\n        var channels = 1;\n\n        if (shape.length === 2) {\n          format = gl.LUMINANCE;\n          shape = [shape[0], shape[1], 1];\n          array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);\n        } else if (shape.length === 3) {\n          if (shape[2] === 1) {\n            format = gl.ALPHA;\n          } else if (shape[2] === 2) {\n            format = gl.LUMINANCE_ALPHA;\n          } else if (shape[2] === 3) {\n            format = gl.RGB;\n          } else if (shape[2] === 4) {\n            format = gl.RGBA;\n          } else {\n            throw new Error('gl-texture2d: Invalid shape for pixel coords');\n          }\n\n          channels = shape[2];\n        } else {\n          throw new Error('gl-texture2d: Invalid shape for texture');\n        } //For 1-channel textures allow conversion between formats\n\n\n        if ((format === gl.LUMINANCE || format === gl.ALPHA) && (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {\n          format = cformat;\n        }\n\n        if (format !== cformat) {\n          throw new Error('gl-texture2d: Incompatible texture format for setPixels');\n        }\n\n        var size = array.size;\n        var needsMip = mipLevels.indexOf(mip_level) < 0;\n\n        if (needsMip) {\n          mipLevels.push(mip_level);\n        }\n\n        if (type === ctype && packed) {\n          //Array data types are compatible, can directly copy into texture\n          if (array.offset === 0 && array.data.length === size) {\n            if (needsMip) {\n              gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data);\n            } else {\n              gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data);\n            }\n          } else {\n            if (needsMip) {\n              gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset + size));\n            } else {\n              gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset + size));\n            }\n          }\n        } else {\n          //Need to do type conversion to pack data into buffer\n          var pack_buffer;\n\n          if (ctype === gl.FLOAT) {\n            pack_buffer = pool.mallocFloat32(size);\n          } else {\n            pack_buffer = pool.mallocUint8(size);\n          }\n\n          var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2] * shape[0], 1]);\n\n          if (type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {\n            convertFloatToUint8(pack_view, array);\n          } else {\n            ops.assign(pack_view, array);\n          }\n\n          if (needsMip) {\n            gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size));\n          } else {\n            gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size));\n          }\n\n          if (ctype === gl.FLOAT) {\n            pool.freeFloat32(pack_buffer);\n          } else {\n            pool.freeUint8(pack_buffer);\n          }\n        }\n      }\n\n      function initTexture(gl) {\n        var tex = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, tex);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        return tex;\n      }\n\n      function createTextureShape(gl, width, height, format, type) {\n        var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n        if (width < 0 || width > maxTextureSize || height < 0 || height > maxTextureSize) {\n          throw new Error('gl-texture2d: Invalid texture shape');\n        }\n\n        if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {\n          throw new Error('gl-texture2d: Floating point textures not supported on this platform');\n        }\n\n        var tex = initTexture(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);\n        return new Texture2D(gl, tex, width, height, format, type);\n      }\n\n      function createTextureDOM(gl, directData, width, height, format, type) {\n        var tex = initTexture(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData);\n        return new Texture2D(gl, tex, width, height, format, type);\n      } //Creates a texture from an ndarray\n\n\n      function createTextureArray(gl, array) {\n        var dtype = array.dtype;\n        var shape = array.shape.slice();\n        var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n        if (shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {\n          throw new Error('gl-texture2d: Invalid texture size');\n        }\n\n        var packed = isPacked(shape, array.stride.slice());\n        var type = 0;\n\n        if (dtype === 'float32') {\n          type = gl.FLOAT;\n        } else if (dtype === 'float64') {\n          type = gl.FLOAT;\n          packed = false;\n          dtype = 'float32';\n        } else if (dtype === 'uint8') {\n          type = gl.UNSIGNED_BYTE;\n        } else {\n          type = gl.UNSIGNED_BYTE;\n          packed = false;\n          dtype = 'uint8';\n        }\n\n        var format = 0;\n\n        if (shape.length === 2) {\n          format = gl.LUMINANCE;\n          shape = [shape[0], shape[1], 1];\n          array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset);\n        } else if (shape.length === 3) {\n          if (shape[2] === 1) {\n            format = gl.ALPHA;\n          } else if (shape[2] === 2) {\n            format = gl.LUMINANCE_ALPHA;\n          } else if (shape[2] === 3) {\n            format = gl.RGB;\n          } else if (shape[2] === 4) {\n            format = gl.RGBA;\n          } else {\n            throw new Error('gl-texture2d: Invalid shape for pixel coords');\n          }\n        } else {\n          throw new Error('gl-texture2d: Invalid shape for texture');\n        }\n\n        if (type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {\n          type = gl.UNSIGNED_BYTE;\n          packed = false;\n        }\n\n        var buffer, buf_store;\n        var size = array.size;\n\n        if (!packed) {\n          var stride = [shape[2], shape[2] * shape[0], 1];\n          buf_store = pool.malloc(size, dtype);\n          var buf_array = ndarray(buf_store, shape, stride, 0);\n\n          if ((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {\n            convertFloatToUint8(buf_array, array);\n          } else {\n            ops.assign(buf_array, array);\n          }\n\n          buffer = buf_store.subarray(0, size);\n        } else if (array.offset === 0 && array.data.length === size) {\n          buffer = array.data;\n        } else {\n          buffer = array.data.subarray(array.offset, array.offset + size);\n        }\n\n        var tex = initTexture(gl);\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer);\n\n        if (!packed) {\n          pool.free(buf_store);\n        }\n\n        return new Texture2D(gl, tex, shape[0], shape[1], format, type);\n      }\n\n      function createTexture2D(gl) {\n        if (arguments.length <= 1) {\n          throw new Error('gl-texture2d: Missing arguments for texture2d constructor');\n        }\n\n        if (!linearTypes) {\n          lazyInitLinearTypes(gl);\n        }\n\n        if (typeof arguments[1] === 'number') {\n          return createTextureShape(gl, arguments[1], arguments[2], arguments[3] || gl.RGBA, arguments[4] || gl.UNSIGNED_BYTE);\n        }\n\n        if (Array.isArray(arguments[1])) {\n          return createTextureShape(gl, arguments[1][0] | 0, arguments[1][1] | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);\n        }\n\n        if (typeof arguments[1] === 'object') {\n          var obj = arguments[1];\n          var directData = acceptTextureDOM(obj) ? obj : obj.raw;\n\n          if (directData) {\n            return createTextureDOM(gl, directData, obj.width | 0, obj.height | 0, arguments[2] || gl.RGBA, arguments[3] || gl.UNSIGNED_BYTE);\n          } else if (obj.shape && obj.data && obj.stride) {\n            return createTextureArray(gl, obj);\n          }\n        }\n\n        throw new Error('gl-texture2d: Invalid arguments for texture2d constructor');\n      }\n    }, {\n      \"ndarray\": 259,\n      \"ndarray-ops\": 254,\n      \"typedarray-pool\": 308\n    }],\n    147: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function doBind(gl, elements, attributes) {\n        if (elements) {\n          elements.bind();\n        } else {\n          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }\n\n        var nattribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS) | 0;\n\n        if (attributes) {\n          if (attributes.length > nattribs) {\n            throw new Error(\"gl-vao: Too many vertex attributes\");\n          }\n\n          for (var i = 0; i < attributes.length; ++i) {\n            var attrib = attributes[i];\n\n            if (attrib.buffer) {\n              var buffer = attrib.buffer;\n              var size = attrib.size || 4;\n              var type = attrib.type || gl.FLOAT;\n              var normalized = !!attrib.normalized;\n              var stride = attrib.stride || 0;\n              var offset = attrib.offset || 0;\n              buffer.bind();\n              gl.enableVertexAttribArray(i);\n              gl.vertexAttribPointer(i, size, type, normalized, stride, offset);\n            } else {\n              if (typeof attrib === \"number\") {\n                gl.vertexAttrib1f(i, attrib);\n              } else if (attrib.length === 1) {\n                gl.vertexAttrib1f(i, attrib[0]);\n              } else if (attrib.length === 2) {\n                gl.vertexAttrib2f(i, attrib[0], attrib[1]);\n              } else if (attrib.length === 3) {\n                gl.vertexAttrib3f(i, attrib[0], attrib[1], attrib[2]);\n              } else if (attrib.length === 4) {\n                gl.vertexAttrib4f(i, attrib[0], attrib[1], attrib[2], attrib[3]);\n              } else {\n                throw new Error(\"gl-vao: Invalid vertex attribute\");\n              }\n\n              gl.disableVertexAttribArray(i);\n            }\n          }\n\n          for (; i < nattribs; ++i) {\n            gl.disableVertexAttribArray(i);\n          }\n        } else {\n          gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n          for (var i = 0; i < nattribs; ++i) {\n            gl.disableVertexAttribArray(i);\n          }\n        }\n      }\n\n      module.exports = doBind;\n    }, {}],\n    148: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var bindAttribs = _glvis_(\"./do-bind.js\");\n\n      function VAOEmulated(gl) {\n        this.gl = gl;\n        this._elements = null;\n        this._attributes = null;\n        this._elementsType = gl.UNSIGNED_SHORT;\n      }\n\n      VAOEmulated.prototype.bind = function () {\n        bindAttribs(this.gl, this._elements, this._attributes);\n      };\n\n      VAOEmulated.prototype.update = function (attributes, elements, elementsType) {\n        this._elements = elements;\n        this._attributes = attributes;\n        this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;\n      };\n\n      VAOEmulated.prototype.dispose = function () {};\n\n      VAOEmulated.prototype.unbind = function () {};\n\n      VAOEmulated.prototype.draw = function (mode, count, offset) {\n        offset = offset || 0;\n        var gl = this.gl;\n\n        if (this._elements) {\n          gl.drawElements(mode, count, this._elementsType, offset);\n        } else {\n          gl.drawArrays(mode, offset, count);\n        }\n      };\n\n      function createVAOEmulated(gl) {\n        return new VAOEmulated(gl);\n      }\n\n      module.exports = createVAOEmulated;\n    }, {\n      \"./do-bind.js\": 147\n    }],\n    149: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var bindAttribs = _glvis_(\"./do-bind.js\");\n\n      function VertexAttribute(location, dimension, a, b, c, d) {\n        this.location = location;\n        this.dimension = dimension;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n      }\n\n      VertexAttribute.prototype.bind = function (gl) {\n        switch (this.dimension) {\n          case 1:\n            gl.vertexAttrib1f(this.location, this.a);\n            break;\n\n          case 2:\n            gl.vertexAttrib2f(this.location, this.a, this.b);\n            break;\n\n          case 3:\n            gl.vertexAttrib3f(this.location, this.a, this.b, this.c);\n            break;\n\n          case 4:\n            gl.vertexAttrib4f(this.location, this.a, this.b, this.c, this.d);\n            break;\n        }\n      };\n\n      function VAONative(gl, ext, handle) {\n        this.gl = gl;\n        this._ext = ext;\n        this.handle = handle;\n        this._attribs = [];\n        this._useElements = false;\n        this._elementsType = gl.UNSIGNED_SHORT;\n      }\n\n      VAONative.prototype.bind = function () {\n        this._ext.bindVertexArrayOES(this.handle);\n\n        for (var i = 0; i < this._attribs.length; ++i) {\n          this._attribs[i].bind(this.gl);\n        }\n      };\n\n      VAONative.prototype.unbind = function () {\n        this._ext.bindVertexArrayOES(null);\n      };\n\n      VAONative.prototype.dispose = function () {\n        this._ext.deleteVertexArrayOES(this.handle);\n      };\n\n      VAONative.prototype.update = function (attributes, elements, elementsType) {\n        this.bind();\n        bindAttribs(this.gl, elements, attributes);\n        this.unbind();\n        this._attribs.length = 0;\n        if (attributes) for (var i = 0; i < attributes.length; ++i) {\n          var a = attributes[i];\n\n          if (typeof a === \"number\") {\n            this._attribs.push(new VertexAttribute(i, 1, a));\n          } else if (Array.isArray(a)) {\n            this._attribs.push(new VertexAttribute(i, a.length, a[0], a[1], a[2], a[3]));\n          }\n        }\n        this._useElements = !!elements;\n        this._elementsType = elementsType || this.gl.UNSIGNED_SHORT;\n      };\n\n      VAONative.prototype.draw = function (mode, count, offset) {\n        offset = offset || 0;\n        var gl = this.gl;\n\n        if (this._useElements) {\n          gl.drawElements(mode, count, this._elementsType, offset);\n        } else {\n          gl.drawArrays(mode, offset, count);\n        }\n      };\n\n      function createVAONative(gl, ext) {\n        return new VAONative(gl, ext, ext.createVertexArrayOES());\n      }\n\n      module.exports = createVAONative;\n    }, {\n      \"./do-bind.js\": 147\n    }],\n    150: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var createVAONative = _glvis_(\"./lib/vao-native.js\");\n\n      var createVAOEmulated = _glvis_(\"./lib/vao-emulated.js\");\n\n      function ExtensionShim(gl) {\n        this.bindVertexArrayOES = gl.bindVertexArray.bind(gl);\n        this.createVertexArrayOES = gl.createVertexArray.bind(gl);\n        this.deleteVertexArrayOES = gl.deleteVertexArray.bind(gl);\n      }\n\n      function createVAO(gl, attributes, elements, elementsType) {\n        var ext = gl.createVertexArray ? new ExtensionShim(gl) : gl.getExtension('OES_vertex_array_object');\n        var vao;\n\n        if (ext) {\n          vao = createVAONative(gl, ext);\n        } else {\n          vao = createVAOEmulated(gl);\n        }\n\n        vao.update(attributes, elements, elementsType);\n        return vao;\n      }\n\n      module.exports = createVAO;\n    }, {\n      \"./lib/vao-emulated.js\": 148,\n      \"./lib/vao-native.js\": 149\n    }],\n    151: [function (_glvis_, module, exports) {\n      module.exports = add;\n      /**\n       * Adds two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function add(out, a, b) {\n        out[0] = a[0] + b[0];\n        out[1] = a[1] + b[1];\n        out[2] = a[2] + b[2];\n        return out;\n      }\n    }, {}],\n    152: [function (_glvis_, module, exports) {\n      module.exports = angle;\n\n      var fromValues = _glvis_('./fromValues');\n\n      var normalize = _glvis_('./normalize');\n\n      var dot = _glvis_('./dot');\n      /**\n       * Get the angle between two 3D vectors\n       * @param {vec3} a The first operand\n       * @param {vec3} b The second operand\n       * @returns {Number} The angle in radians\n       */\n\n\n      function angle(a, b) {\n        var tempA = fromValues(a[0], a[1], a[2]);\n        var tempB = fromValues(b[0], b[1], b[2]);\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n        var cosine = dot(tempA, tempB);\n\n        if (cosine > 1.0) {\n          return 0;\n        } else {\n          return Math.acos(cosine);\n        }\n      }\n    }, {\n      \"./dot\": 162,\n      \"./fromValues\": 168,\n      \"./normalize\": 179\n    }],\n    153: [function (_glvis_, module, exports) {\n      module.exports = ceil;\n      /**\n       * Math.ceil the components of a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to ceil\n       * @returns {vec3} out\n       */\n\n      function ceil(out, a) {\n        out[0] = Math.ceil(a[0]);\n        out[1] = Math.ceil(a[1]);\n        out[2] = Math.ceil(a[2]);\n        return out;\n      }\n    }, {}],\n    154: [function (_glvis_, module, exports) {\n      module.exports = clone;\n      /**\n       * Creates a new vec3 initialized with values from an existing vector\n       *\n       * @param {vec3} a vector to clone\n       * @returns {vec3} a new 3D vector\n       */\n\n      function clone(a) {\n        var out = new Float32Array(3);\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        return out;\n      }\n    }, {}],\n    155: [function (_glvis_, module, exports) {\n      module.exports = copy;\n      /**\n       * Copy the values from one vec3 to another\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the source vector\n       * @returns {vec3} out\n       */\n\n      function copy(out, a) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        return out;\n      }\n    }, {}],\n    156: [function (_glvis_, module, exports) {\n      module.exports = create;\n      /**\n       * Creates a new, empty vec3\n       *\n       * @returns {vec3} a new 3D vector\n       */\n\n      function create() {\n        var out = new Float32Array(3);\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n        return out;\n      }\n    }, {}],\n    157: [function (_glvis_, module, exports) {\n      module.exports = cross;\n      /**\n       * Computes the cross product of two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function cross(out, a, b) {\n        var ax = a[0],\n            ay = a[1],\n            az = a[2],\n            bx = b[0],\n            by = b[1],\n            bz = b[2];\n        out[0] = ay * bz - az * by;\n        out[1] = az * bx - ax * bz;\n        out[2] = ax * by - ay * bx;\n        return out;\n      }\n    }, {}],\n    158: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./distance');\n    }, {\n      \"./distance\": 159\n    }],\n    159: [function (_glvis_, module, exports) {\n      module.exports = distance;\n      /**\n       * Calculates the euclidian distance between two vec3's\n       *\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {Number} distance between a and b\n       */\n\n      function distance(a, b) {\n        var x = b[0] - a[0],\n            y = b[1] - a[1],\n            z = b[2] - a[2];\n        return Math.sqrt(x * x + y * y + z * z);\n      }\n    }, {}],\n    160: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./divide');\n    }, {\n      \"./divide\": 161\n    }],\n    161: [function (_glvis_, module, exports) {\n      module.exports = divide;\n      /**\n       * Divides two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function divide(out, a, b) {\n        out[0] = a[0] / b[0];\n        out[1] = a[1] / b[1];\n        out[2] = a[2] / b[2];\n        return out;\n      }\n    }, {}],\n    162: [function (_glvis_, module, exports) {\n      module.exports = dot;\n      /**\n       * Calculates the dot product of two vec3's\n       *\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {Number} dot product of a and b\n       */\n\n      function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n      }\n    }, {}],\n    163: [function (_glvis_, module, exports) {\n      module.exports = 0.000001;\n    }, {}],\n    164: [function (_glvis_, module, exports) {\n      module.exports = equals;\n\n      var EPSILON = _glvis_('./epsilon');\n      /**\n       * Returns whether or not the vectors have approximately the same elements in the same position.\n       *\n       * @param {vec3} a The first vector.\n       * @param {vec3} b The second vector.\n       * @returns {Boolean} True if the vectors are equal, false otherwise.\n       */\n\n\n      function equals(a, b) {\n        var a0 = a[0];\n        var a1 = a[1];\n        var a2 = a[2];\n        var b0 = b[0];\n        var b1 = b[1];\n        var b2 = b[2];\n        return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n      }\n    }, {\n      \"./epsilon\": 163\n    }],\n    165: [function (_glvis_, module, exports) {\n      module.exports = exactEquals;\n      /**\n       * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n       *\n       * @param {vec3} a The first vector.\n       * @param {vec3} b The second vector.\n       * @returns {Boolean} True if the vectors are equal, false otherwise.\n       */\n\n      function exactEquals(a, b) {\n        return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n      }\n    }, {}],\n    166: [function (_glvis_, module, exports) {\n      module.exports = floor;\n      /**\n       * Math.floor the components of a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to floor\n       * @returns {vec3} out\n       */\n\n      function floor(out, a) {\n        out[0] = Math.floor(a[0]);\n        out[1] = Math.floor(a[1]);\n        out[2] = Math.floor(a[2]);\n        return out;\n      }\n    }, {}],\n    167: [function (_glvis_, module, exports) {\n      module.exports = forEach;\n\n      var vec = _glvis_('./create')();\n      /**\n       * Perform some operation over an array of vec3s.\n       *\n       * @param {Array} a the array of vectors to iterate over\n       * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n       * @param {Number} offset Number of elements to skip at the beginning of the array\n       * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n       * @param {Function} fn Function to call for each vector in the array\n       * @param {Object} [arg] additional argument to pass to fn\n       * @returns {Array} a\n       * @function\n       */\n\n\n      function forEach(a, stride, offset, count, fn, arg) {\n        var i, l;\n\n        if (!stride) {\n          stride = 3;\n        }\n\n        if (!offset) {\n          offset = 0;\n        }\n\n        if (count) {\n          l = Math.min(count * stride + offset, a.length);\n        } else {\n          l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n          vec[0] = a[i];\n          vec[1] = a[i + 1];\n          vec[2] = a[i + 2];\n          fn(vec, vec, arg);\n          a[i] = vec[0];\n          a[i + 1] = vec[1];\n          a[i + 2] = vec[2];\n        }\n\n        return a;\n      }\n    }, {\n      \"./create\": 156\n    }],\n    168: [function (_glvis_, module, exports) {\n      module.exports = fromValues;\n      /**\n       * Creates a new vec3 initialized with the given values\n       *\n       * @param {Number} x X component\n       * @param {Number} y Y component\n       * @param {Number} z Z component\n       * @returns {vec3} a new 3D vector\n       */\n\n      function fromValues(x, y, z) {\n        var out = new Float32Array(3);\n        out[0] = x;\n        out[1] = y;\n        out[2] = z;\n        return out;\n      }\n    }, {}],\n    169: [function (_glvis_, module, exports) {\n      module.exports = {\n        EPSILON: _glvis_('./epsilon'),\n        create: _glvis_('./create'),\n        clone: _glvis_('./clone'),\n        angle: _glvis_('./angle'),\n        fromValues: _glvis_('./fromValues'),\n        copy: _glvis_('./copy'),\n        set: _glvis_('./set'),\n        equals: _glvis_('./equals'),\n        exactEquals: _glvis_('./exactEquals'),\n        add: _glvis_('./add'),\n        subtract: _glvis_('./subtract'),\n        sub: _glvis_('./sub'),\n        multiply: _glvis_('./multiply'),\n        mul: _glvis_('./mul'),\n        divide: _glvis_('./divide'),\n        div: _glvis_('./div'),\n        min: _glvis_('./min'),\n        max: _glvis_('./max'),\n        floor: _glvis_('./floor'),\n        ceil: _glvis_('./ceil'),\n        round: _glvis_('./round'),\n        scale: _glvis_('./scale'),\n        scaleAndAdd: _glvis_('./scaleAndAdd'),\n        distance: _glvis_('./distance'),\n        dist: _glvis_('./dist'),\n        squaredDistance: _glvis_('./squaredDistance'),\n        sqrDist: _glvis_('./sqrDist'),\n        length: _glvis_('./length'),\n        len: _glvis_('./len'),\n        squaredLength: _glvis_('./squaredLength'),\n        sqrLen: _glvis_('./sqrLen'),\n        negate: _glvis_('./negate'),\n        inverse: _glvis_('./inverse'),\n        normalize: _glvis_('./normalize'),\n        dot: _glvis_('./dot'),\n        cross: _glvis_('./cross'),\n        lerp: _glvis_('./lerp'),\n        random: _glvis_('./random'),\n        transformMat4: _glvis_('./transformMat4'),\n        transformMat3: _glvis_('./transformMat3'),\n        transformQuat: _glvis_('./transformQuat'),\n        rotateX: _glvis_('./rotateX'),\n        rotateY: _glvis_('./rotateY'),\n        rotateZ: _glvis_('./rotateZ'),\n        forEach: _glvis_('./forEach')\n      };\n    }, {\n      \"./add\": 151,\n      \"./angle\": 152,\n      \"./ceil\": 153,\n      \"./clone\": 154,\n      \"./copy\": 155,\n      \"./create\": 156,\n      \"./cross\": 157,\n      \"./dist\": 158,\n      \"./distance\": 159,\n      \"./div\": 160,\n      \"./divide\": 161,\n      \"./dot\": 162,\n      \"./epsilon\": 163,\n      \"./equals\": 164,\n      \"./exactEquals\": 165,\n      \"./floor\": 166,\n      \"./forEach\": 167,\n      \"./fromValues\": 168,\n      \"./inverse\": 170,\n      \"./len\": 171,\n      \"./length\": 172,\n      \"./lerp\": 173,\n      \"./max\": 174,\n      \"./min\": 175,\n      \"./mul\": 176,\n      \"./multiply\": 177,\n      \"./negate\": 178,\n      \"./normalize\": 179,\n      \"./random\": 180,\n      \"./rotateX\": 181,\n      \"./rotateY\": 182,\n      \"./rotateZ\": 183,\n      \"./round\": 184,\n      \"./scale\": 185,\n      \"./scaleAndAdd\": 186,\n      \"./set\": 187,\n      \"./sqrDist\": 188,\n      \"./sqrLen\": 189,\n      \"./squaredDistance\": 190,\n      \"./squaredLength\": 191,\n      \"./sub\": 192,\n      \"./subtract\": 193,\n      \"./transformMat3\": 194,\n      \"./transformMat4\": 195,\n      \"./transformQuat\": 196\n    }],\n    170: [function (_glvis_, module, exports) {\n      module.exports = inverse;\n      /**\n       * Returns the inverse of the components of a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to invert\n       * @returns {vec3} out\n       */\n\n      function inverse(out, a) {\n        out[0] = 1.0 / a[0];\n        out[1] = 1.0 / a[1];\n        out[2] = 1.0 / a[2];\n        return out;\n      }\n    }, {}],\n    171: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./length');\n    }, {\n      \"./length\": 172\n    }],\n    172: [function (_glvis_, module, exports) {\n      module.exports = length;\n      /**\n       * Calculates the length of a vec3\n       *\n       * @param {vec3} a vector to calculate length of\n       * @returns {Number} length of a\n       */\n\n      function length(a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2];\n        return Math.sqrt(x * x + y * y + z * z);\n      }\n    }, {}],\n    173: [function (_glvis_, module, exports) {\n      module.exports = lerp;\n      /**\n       * Performs a linear interpolation between two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @param {Number} t interpolation amount between the two inputs\n       * @returns {vec3} out\n       */\n\n      function lerp(out, a, b, t) {\n        var ax = a[0],\n            ay = a[1],\n            az = a[2];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        return out;\n      }\n    }, {}],\n    174: [function (_glvis_, module, exports) {\n      module.exports = max;\n      /**\n       * Returns the maximum of two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function max(out, a, b) {\n        out[0] = Math.max(a[0], b[0]);\n        out[1] = Math.max(a[1], b[1]);\n        out[2] = Math.max(a[2], b[2]);\n        return out;\n      }\n    }, {}],\n    175: [function (_glvis_, module, exports) {\n      module.exports = min;\n      /**\n       * Returns the minimum of two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function min(out, a, b) {\n        out[0] = Math.min(a[0], b[0]);\n        out[1] = Math.min(a[1], b[1]);\n        out[2] = Math.min(a[2], b[2]);\n        return out;\n      }\n    }, {}],\n    176: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./multiply');\n    }, {\n      \"./multiply\": 177\n    }],\n    177: [function (_glvis_, module, exports) {\n      module.exports = multiply;\n      /**\n       * Multiplies two vec3's\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function multiply(out, a, b) {\n        out[0] = a[0] * b[0];\n        out[1] = a[1] * b[1];\n        out[2] = a[2] * b[2];\n        return out;\n      }\n    }, {}],\n    178: [function (_glvis_, module, exports) {\n      module.exports = negate;\n      /**\n       * Negates the components of a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to negate\n       * @returns {vec3} out\n       */\n\n      function negate(out, a) {\n        out[0] = -a[0];\n        out[1] = -a[1];\n        out[2] = -a[2];\n        return out;\n      }\n    }, {}],\n    179: [function (_glvis_, module, exports) {\n      module.exports = normalize;\n      /**\n       * Normalize a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to normalize\n       * @returns {vec3} out\n       */\n\n      function normalize(out, a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2];\n        var len = x * x + y * y + z * z;\n\n        if (len > 0) {\n          //TODO: evaluate use of glm_invsqrt here?\n          len = 1 / Math.sqrt(len);\n          out[0] = a[0] * len;\n          out[1] = a[1] * len;\n          out[2] = a[2] * len;\n        }\n\n        return out;\n      }\n    }, {}],\n    180: [function (_glvis_, module, exports) {\n      module.exports = random;\n      /**\n       * Generates a random vector with the given scale\n       *\n       * @param {vec3} out the receiving vector\n       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n       * @returns {vec3} out\n       */\n\n      function random(out, scale) {\n        scale = scale || 1.0;\n        var r = Math.random() * 2.0 * Math.PI;\n        var z = Math.random() * 2.0 - 1.0;\n        var zScale = Math.sqrt(1.0 - z * z) * scale;\n        out[0] = Math.cos(r) * zScale;\n        out[1] = Math.sin(r) * zScale;\n        out[2] = z * scale;\n        return out;\n      }\n    }, {}],\n    181: [function (_glvis_, module, exports) {\n      module.exports = rotateX;\n      /**\n       * Rotate a 3D vector around the x-axis\n       * @param {vec3} out The receiving vec3\n       * @param {vec3} a The vec3 point to rotate\n       * @param {vec3} b The origin of the rotation\n       * @param {Number} c The angle of rotation\n       * @returns {vec3} out\n       */\n\n      function rotateX(out, a, b, c) {\n        var by = b[1];\n        var bz = b[2]; // Translate point to the origin\n\n        var py = a[1] - by;\n        var pz = a[2] - bz;\n        var sc = Math.sin(c);\n        var cc = Math.cos(c); // perform rotation and translate to correct position\n\n        out[0] = a[0];\n        out[1] = by + py * cc - pz * sc;\n        out[2] = bz + py * sc + pz * cc;\n        return out;\n      }\n    }, {}],\n    182: [function (_glvis_, module, exports) {\n      module.exports = rotateY;\n      /**\n       * Rotate a 3D vector around the y-axis\n       * @param {vec3} out The receiving vec3\n       * @param {vec3} a The vec3 point to rotate\n       * @param {vec3} b The origin of the rotation\n       * @param {Number} c The angle of rotation\n       * @returns {vec3} out\n       */\n\n      function rotateY(out, a, b, c) {\n        var bx = b[0];\n        var bz = b[2]; // translate point to the origin\n\n        var px = a[0] - bx;\n        var pz = a[2] - bz;\n        var sc = Math.sin(c);\n        var cc = Math.cos(c); // perform rotation and translate to correct position\n\n        out[0] = bx + pz * sc + px * cc;\n        out[1] = a[1];\n        out[2] = bz + pz * cc - px * sc;\n        return out;\n      }\n    }, {}],\n    183: [function (_glvis_, module, exports) {\n      module.exports = rotateZ;\n      /**\n       * Rotate a 3D vector around the z-axis\n       * @param {vec3} out The receiving vec3\n       * @param {vec3} a The vec3 point to rotate\n       * @param {vec3} b The origin of the rotation\n       * @param {Number} c The angle of rotation\n       * @returns {vec3} out\n       */\n\n      function rotateZ(out, a, b, c) {\n        var bx = b[0];\n        var by = b[1]; //Translate point to the origin\n\n        var px = a[0] - bx;\n        var py = a[1] - by;\n        var sc = Math.sin(c);\n        var cc = Math.cos(c); // perform rotation and translate to correct position\n\n        out[0] = bx + px * cc - py * sc;\n        out[1] = by + px * sc + py * cc;\n        out[2] = a[2];\n        return out;\n      }\n    }, {}],\n    184: [function (_glvis_, module, exports) {\n      module.exports = round;\n      /**\n       * Math.round the components of a vec3\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a vector to round\n       * @returns {vec3} out\n       */\n\n      function round(out, a) {\n        out[0] = Math.round(a[0]);\n        out[1] = Math.round(a[1]);\n        out[2] = Math.round(a[2]);\n        return out;\n      }\n    }, {}],\n    185: [function (_glvis_, module, exports) {\n      module.exports = scale;\n      /**\n       * Scales a vec3 by a scalar number\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the vector to scale\n       * @param {Number} b amount to scale the vector by\n       * @returns {vec3} out\n       */\n\n      function scale(out, a, b) {\n        out[0] = a[0] * b;\n        out[1] = a[1] * b;\n        out[2] = a[2] * b;\n        return out;\n      }\n    }, {}],\n    186: [function (_glvis_, module, exports) {\n      module.exports = scaleAndAdd;\n      /**\n       * Adds two vec3's after scaling the second operand by a scalar value\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @param {Number} scale the amount to scale b by before adding\n       * @returns {vec3} out\n       */\n\n      function scaleAndAdd(out, a, b, scale) {\n        out[0] = a[0] + b[0] * scale;\n        out[1] = a[1] + b[1] * scale;\n        out[2] = a[2] + b[2] * scale;\n        return out;\n      }\n    }, {}],\n    187: [function (_glvis_, module, exports) {\n      module.exports = set;\n      /**\n       * Set the components of a vec3 to the given values\n       *\n       * @param {vec3} out the receiving vector\n       * @param {Number} x X component\n       * @param {Number} y Y component\n       * @param {Number} z Z component\n       * @returns {vec3} out\n       */\n\n      function set(out, x, y, z) {\n        out[0] = x;\n        out[1] = y;\n        out[2] = z;\n        return out;\n      }\n    }, {}],\n    188: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./squaredDistance');\n    }, {\n      \"./squaredDistance\": 190\n    }],\n    189: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./squaredLength');\n    }, {\n      \"./squaredLength\": 191\n    }],\n    190: [function (_glvis_, module, exports) {\n      module.exports = squaredDistance;\n      /**\n       * Calculates the squared euclidian distance between two vec3's\n       *\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {Number} squared distance between a and b\n       */\n\n      function squaredDistance(a, b) {\n        var x = b[0] - a[0],\n            y = b[1] - a[1],\n            z = b[2] - a[2];\n        return x * x + y * y + z * z;\n      }\n    }, {}],\n    191: [function (_glvis_, module, exports) {\n      module.exports = squaredLength;\n      /**\n       * Calculates the squared length of a vec3\n       *\n       * @param {vec3} a vector to calculate squared length of\n       * @returns {Number} squared length of a\n       */\n\n      function squaredLength(a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2];\n        return x * x + y * y + z * z;\n      }\n    }, {}],\n    192: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('./subtract');\n    }, {\n      \"./subtract\": 193\n    }],\n    193: [function (_glvis_, module, exports) {\n      module.exports = subtract;\n      /**\n       * Subtracts vector b from vector a\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the first operand\n       * @param {vec3} b the second operand\n       * @returns {vec3} out\n       */\n\n      function subtract(out, a, b) {\n        out[0] = a[0] - b[0];\n        out[1] = a[1] - b[1];\n        out[2] = a[2] - b[2];\n        return out;\n      }\n    }, {}],\n    194: [function (_glvis_, module, exports) {\n      module.exports = transformMat3;\n      /**\n       * Transforms the vec3 with a mat3.\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the vector to transform\n       * @param {mat4} m the 3x3 matrix to transform with\n       * @returns {vec3} out\n       */\n\n      function transformMat3(out, a, m) {\n        var x = a[0],\n            y = a[1],\n            z = a[2];\n        out[0] = x * m[0] + y * m[3] + z * m[6];\n        out[1] = x * m[1] + y * m[4] + z * m[7];\n        out[2] = x * m[2] + y * m[5] + z * m[8];\n        return out;\n      }\n    }, {}],\n    195: [function (_glvis_, module, exports) {\n      module.exports = transformMat4;\n      /**\n       * Transforms the vec3 with a mat4.\n       * 4th vector component is implicitly '1'\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the vector to transform\n       * @param {mat4} m matrix to transform with\n       * @returns {vec3} out\n       */\n\n      function transformMat4(out, a, m) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = m[3] * x + m[7] * y + m[11] * z + m[15];\n        w = w || 1.0;\n        out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n        out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n        out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n        return out;\n      }\n    }, {}],\n    196: [function (_glvis_, module, exports) {\n      module.exports = transformQuat;\n      /**\n       * Transforms the vec3 with a quat\n       *\n       * @param {vec3} out the receiving vector\n       * @param {vec3} a the vector to transform\n       * @param {quat} q quaternion to transform with\n       * @returns {vec3} out\n       */\n\n      function transformQuat(out, a, q) {\n        // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            qx = q[0],\n            qy = q[1],\n            qz = q[2],\n            qw = q[3],\n            // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n            iy = qw * y + qz * x - qx * z,\n            iz = qw * z + qx * y - qy * x,\n            iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return out;\n      }\n    }, {}],\n    197: [function (_glvis_, module, exports) {\n      module.exports = add;\n      /**\n       * Adds two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function add(out, a, b) {\n        out[0] = a[0] + b[0];\n        out[1] = a[1] + b[1];\n        out[2] = a[2] + b[2];\n        out[3] = a[3] + b[3];\n        return out;\n      }\n    }, {}],\n    198: [function (_glvis_, module, exports) {\n      module.exports = clone;\n      /**\n       * Creates a new vec4 initialized with values from an existing vector\n       *\n       * @param {vec4} a vector to clone\n       * @returns {vec4} a new 4D vector\n       */\n\n      function clone(a) {\n        var out = new Float32Array(4);\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        return out;\n      }\n    }, {}],\n    199: [function (_glvis_, module, exports) {\n      module.exports = copy;\n      /**\n       * Copy the values from one vec4 to another\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the source vector\n       * @returns {vec4} out\n       */\n\n      function copy(out, a) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        return out;\n      }\n    }, {}],\n    200: [function (_glvis_, module, exports) {\n      module.exports = create;\n      /**\n       * Creates a new, empty vec4\n       *\n       * @returns {vec4} a new 4D vector\n       */\n\n      function create() {\n        var out = new Float32Array(4);\n        out[0] = 0;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        return out;\n      }\n    }, {}],\n    201: [function (_glvis_, module, exports) {\n      module.exports = distance;\n      /**\n       * Calculates the euclidian distance between two vec4's\n       *\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {Number} distance between a and b\n       */\n\n      function distance(a, b) {\n        var x = b[0] - a[0],\n            y = b[1] - a[1],\n            z = b[2] - a[2],\n            w = b[3] - a[3];\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n      }\n    }, {}],\n    202: [function (_glvis_, module, exports) {\n      module.exports = divide;\n      /**\n       * Divides two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function divide(out, a, b) {\n        out[0] = a[0] / b[0];\n        out[1] = a[1] / b[1];\n        out[2] = a[2] / b[2];\n        out[3] = a[3] / b[3];\n        return out;\n      }\n    }, {}],\n    203: [function (_glvis_, module, exports) {\n      module.exports = dot;\n      /**\n       * Calculates the dot product of two vec4's\n       *\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {Number} dot product of a and b\n       */\n\n      function dot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n      }\n    }, {}],\n    204: [function (_glvis_, module, exports) {\n      module.exports = fromValues;\n      /**\n       * Creates a new vec4 initialized with the given values\n       *\n       * @param {Number} x X component\n       * @param {Number} y Y component\n       * @param {Number} z Z component\n       * @param {Number} w W component\n       * @returns {vec4} a new 4D vector\n       */\n\n      function fromValues(x, y, z, w) {\n        var out = new Float32Array(4);\n        out[0] = x;\n        out[1] = y;\n        out[2] = z;\n        out[3] = w;\n        return out;\n      }\n    }, {}],\n    205: [function (_glvis_, module, exports) {\n      module.exports = {\n        create: _glvis_('./create'),\n        clone: _glvis_('./clone'),\n        fromValues: _glvis_('./fromValues'),\n        copy: _glvis_('./copy'),\n        set: _glvis_('./set'),\n        add: _glvis_('./add'),\n        subtract: _glvis_('./subtract'),\n        multiply: _glvis_('./multiply'),\n        divide: _glvis_('./divide'),\n        min: _glvis_('./min'),\n        max: _glvis_('./max'),\n        scale: _glvis_('./scale'),\n        scaleAndAdd: _glvis_('./scaleAndAdd'),\n        distance: _glvis_('./distance'),\n        squaredDistance: _glvis_('./squaredDistance'),\n        length: _glvis_('./length'),\n        squaredLength: _glvis_('./squaredLength'),\n        negate: _glvis_('./negate'),\n        inverse: _glvis_('./inverse'),\n        normalize: _glvis_('./normalize'),\n        dot: _glvis_('./dot'),\n        lerp: _glvis_('./lerp'),\n        random: _glvis_('./random'),\n        transformMat4: _glvis_('./transformMat4'),\n        transformQuat: _glvis_('./transformQuat')\n      };\n    }, {\n      \"./add\": 197,\n      \"./clone\": 198,\n      \"./copy\": 199,\n      \"./create\": 200,\n      \"./distance\": 201,\n      \"./divide\": 202,\n      \"./dot\": 203,\n      \"./fromValues\": 204,\n      \"./inverse\": 206,\n      \"./length\": 207,\n      \"./lerp\": 208,\n      \"./max\": 209,\n      \"./min\": 210,\n      \"./multiply\": 211,\n      \"./negate\": 212,\n      \"./normalize\": 213,\n      \"./random\": 214,\n      \"./scale\": 215,\n      \"./scaleAndAdd\": 216,\n      \"./set\": 217,\n      \"./squaredDistance\": 218,\n      \"./squaredLength\": 219,\n      \"./subtract\": 220,\n      \"./transformMat4\": 221,\n      \"./transformQuat\": 222\n    }],\n    206: [function (_glvis_, module, exports) {\n      module.exports = inverse;\n      /**\n       * Returns the inverse of the components of a vec4\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a vector to invert\n       * @returns {vec4} out\n       */\n\n      function inverse(out, a) {\n        out[0] = 1.0 / a[0];\n        out[1] = 1.0 / a[1];\n        out[2] = 1.0 / a[2];\n        out[3] = 1.0 / a[3];\n        return out;\n      }\n    }, {}],\n    207: [function (_glvis_, module, exports) {\n      module.exports = length;\n      /**\n       * Calculates the length of a vec4\n       *\n       * @param {vec4} a vector to calculate length of\n       * @returns {Number} length of a\n       */\n\n      function length(a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = a[3];\n        return Math.sqrt(x * x + y * y + z * z + w * w);\n      }\n    }, {}],\n    208: [function (_glvis_, module, exports) {\n      module.exports = lerp;\n      /**\n       * Performs a linear interpolation between two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @param {Number} t interpolation amount between the two inputs\n       * @returns {vec4} out\n       */\n\n      function lerp(out, a, b, t) {\n        var ax = a[0],\n            ay = a[1],\n            az = a[2],\n            aw = a[3];\n        out[0] = ax + t * (b[0] - ax);\n        out[1] = ay + t * (b[1] - ay);\n        out[2] = az + t * (b[2] - az);\n        out[3] = aw + t * (b[3] - aw);\n        return out;\n      }\n    }, {}],\n    209: [function (_glvis_, module, exports) {\n      module.exports = max;\n      /**\n       * Returns the maximum of two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function max(out, a, b) {\n        out[0] = Math.max(a[0], b[0]);\n        out[1] = Math.max(a[1], b[1]);\n        out[2] = Math.max(a[2], b[2]);\n        out[3] = Math.max(a[3], b[3]);\n        return out;\n      }\n    }, {}],\n    210: [function (_glvis_, module, exports) {\n      module.exports = min;\n      /**\n       * Returns the minimum of two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function min(out, a, b) {\n        out[0] = Math.min(a[0], b[0]);\n        out[1] = Math.min(a[1], b[1]);\n        out[2] = Math.min(a[2], b[2]);\n        out[3] = Math.min(a[3], b[3]);\n        return out;\n      }\n    }, {}],\n    211: [function (_glvis_, module, exports) {\n      module.exports = multiply;\n      /**\n       * Multiplies two vec4's\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function multiply(out, a, b) {\n        out[0] = a[0] * b[0];\n        out[1] = a[1] * b[1];\n        out[2] = a[2] * b[2];\n        out[3] = a[3] * b[3];\n        return out;\n      }\n    }, {}],\n    212: [function (_glvis_, module, exports) {\n      module.exports = negate;\n      /**\n       * Negates the components of a vec4\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a vector to negate\n       * @returns {vec4} out\n       */\n\n      function negate(out, a) {\n        out[0] = -a[0];\n        out[1] = -a[1];\n        out[2] = -a[2];\n        out[3] = -a[3];\n        return out;\n      }\n    }, {}],\n    213: [function (_glvis_, module, exports) {\n      module.exports = normalize;\n      /**\n       * Normalize a vec4\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a vector to normalize\n       * @returns {vec4} out\n       */\n\n      function normalize(out, a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = a[3];\n        var len = x * x + y * y + z * z + w * w;\n\n        if (len > 0) {\n          len = 1 / Math.sqrt(len);\n          out[0] = x * len;\n          out[1] = y * len;\n          out[2] = z * len;\n          out[3] = w * len;\n        }\n\n        return out;\n      }\n    }, {}],\n    214: [function (_glvis_, module, exports) {\n      var vecNormalize = _glvis_('./normalize');\n\n      var vecScale = _glvis_('./scale');\n\n      module.exports = random;\n      /**\n       * Generates a random vector with the given scale\n       *\n       * @param {vec4} out the receiving vector\n       * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n       * @returns {vec4} out\n       */\n\n      function random(out, scale) {\n        scale = scale || 1.0; // TODO: This is a pretty awful way of doing this. Find something better.\n\n        out[0] = Math.random();\n        out[1] = Math.random();\n        out[2] = Math.random();\n        out[3] = Math.random();\n        vecNormalize(out, out);\n        vecScale(out, out, scale);\n        return out;\n      }\n    }, {\n      \"./normalize\": 213,\n      \"./scale\": 215\n    }],\n    215: [function (_glvis_, module, exports) {\n      module.exports = scale;\n      /**\n       * Scales a vec4 by a scalar number\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the vector to scale\n       * @param {Number} b amount to scale the vector by\n       * @returns {vec4} out\n       */\n\n      function scale(out, a, b) {\n        out[0] = a[0] * b;\n        out[1] = a[1] * b;\n        out[2] = a[2] * b;\n        out[3] = a[3] * b;\n        return out;\n      }\n    }, {}],\n    216: [function (_glvis_, module, exports) {\n      module.exports = scaleAndAdd;\n      /**\n       * Adds two vec4's after scaling the second operand by a scalar value\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @param {Number} scale the amount to scale b by before adding\n       * @returns {vec4} out\n       */\n\n      function scaleAndAdd(out, a, b, scale) {\n        out[0] = a[0] + b[0] * scale;\n        out[1] = a[1] + b[1] * scale;\n        out[2] = a[2] + b[2] * scale;\n        out[3] = a[3] + b[3] * scale;\n        return out;\n      }\n    }, {}],\n    217: [function (_glvis_, module, exports) {\n      module.exports = set;\n      /**\n       * Set the components of a vec4 to the given values\n       *\n       * @param {vec4} out the receiving vector\n       * @param {Number} x X component\n       * @param {Number} y Y component\n       * @param {Number} z Z component\n       * @param {Number} w W component\n       * @returns {vec4} out\n       */\n\n      function set(out, x, y, z, w) {\n        out[0] = x;\n        out[1] = y;\n        out[2] = z;\n        out[3] = w;\n        return out;\n      }\n    }, {}],\n    218: [function (_glvis_, module, exports) {\n      module.exports = squaredDistance;\n      /**\n       * Calculates the squared euclidian distance between two vec4's\n       *\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {Number} squared distance between a and b\n       */\n\n      function squaredDistance(a, b) {\n        var x = b[0] - a[0],\n            y = b[1] - a[1],\n            z = b[2] - a[2],\n            w = b[3] - a[3];\n        return x * x + y * y + z * z + w * w;\n      }\n    }, {}],\n    219: [function (_glvis_, module, exports) {\n      module.exports = squaredLength;\n      /**\n       * Calculates the squared length of a vec4\n       *\n       * @param {vec4} a vector to calculate squared length of\n       * @returns {Number} squared length of a\n       */\n\n      function squaredLength(a) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = a[3];\n        return x * x + y * y + z * z + w * w;\n      }\n    }, {}],\n    220: [function (_glvis_, module, exports) {\n      module.exports = subtract;\n      /**\n       * Subtracts vector b from vector a\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the first operand\n       * @param {vec4} b the second operand\n       * @returns {vec4} out\n       */\n\n      function subtract(out, a, b) {\n        out[0] = a[0] - b[0];\n        out[1] = a[1] - b[1];\n        out[2] = a[2] - b[2];\n        out[3] = a[3] - b[3];\n        return out;\n      }\n    }, {}],\n    221: [function (_glvis_, module, exports) {\n      module.exports = transformMat4;\n      /**\n       * Transforms the vec4 with a mat4.\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the vector to transform\n       * @param {mat4} m matrix to transform with\n       * @returns {vec4} out\n       */\n\n      function transformMat4(out, a, m) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = a[3];\n        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n        return out;\n      }\n    }, {}],\n    222: [function (_glvis_, module, exports) {\n      module.exports = transformQuat;\n      /**\n       * Transforms the vec4 with a quat\n       *\n       * @param {vec4} out the receiving vector\n       * @param {vec4} a the vector to transform\n       * @param {quat} q quaternion to transform with\n       * @returns {vec4} out\n       */\n\n      function transformQuat(out, a, q) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            qx = q[0],\n            qy = q[1],\n            qz = q[2],\n            qw = q[3],\n            // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n            iy = qw * y + qz * x - qx * z,\n            iz = qw * z + qx * y - qy * x,\n            iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n        out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        out[3] = a[3];\n        return out;\n      }\n    }, {}],\n    223: [function (_glvis_, module, exports) {\n      var tokenize = _glvis_('glsl-tokenizer');\n\n      var atob = _glvis_('atob-lite');\n\n      module.exports = getName;\n\n      function getName(src) {\n        var tokens = Array.isArray(src) ? src : tokenize(src);\n\n        for (var i = 0; i < tokens.length; i++) {\n          var token = tokens[i];\n          if (token.type !== 'preprocessor') continue;\n          var match = token.data.match(/\\#define\\s+SHADER_NAME(_B64)?\\s+(.+)$/);\n          if (!match) continue;\n          if (!match[2]) continue;\n          var b64 = match[1];\n          var name = match[2];\n          return (b64 ? atob(name) : name).trim();\n        }\n      }\n    }, {\n      \"atob-lite\": 13,\n      \"glsl-tokenizer\": 230\n    }],\n    224: [function (_glvis_, module, exports) {\n      module.exports = tokenize;\n\n      var literals100 = _glvis_('./lib/literals'),\n          operators = _glvis_('./lib/operators'),\n          builtins100 = _glvis_('./lib/builtins'),\n          literals300es = _glvis_('./lib/literals-300es'),\n          builtins300es = _glvis_('./lib/builtins-300es');\n\n      var NORMAL = 999 // <-- never emitted\n      ,\n          TOKEN = 9999 // <-- never emitted\n      ,\n          BLOCK_COMMENT = 0,\n          LINE_COMMENT = 1,\n          PREPROCESSOR = 2,\n          OPERATOR = 3,\n          INTEGER = 4,\n          FLOAT = 5,\n          IDENT = 6,\n          BUILTIN = 7,\n          KEYWORD = 8,\n          WHITESPACE = 9,\n          EOF = 10,\n          HEX = 11;\n      var map = ['block-comment', 'line-comment', 'preprocessor', 'operator', 'integer', 'float', 'ident', 'builtin', 'keyword', 'whitespace', 'eof', 'integer'];\n\n      function tokenize(opt) {\n        var i = 0,\n            total = 0,\n            mode = NORMAL,\n            c,\n            last,\n            content = [],\n            tokens = [],\n            token_idx = 0,\n            token_offs = 0,\n            line = 1,\n            col = 0,\n            start = 0,\n            isnum = false,\n            isoperator = false,\n            input = '',\n            len;\n        opt = opt || {};\n        var allBuiltins = builtins100;\n        var allLiterals = literals100;\n\n        if (opt.version === '300 es') {\n          allBuiltins = builtins300es;\n          allLiterals = literals300es;\n        } // cache by name\n\n\n        var builtinsDict = {},\n            literalsDict = {};\n\n        for (var i = 0; i < allBuiltins.length; i++) {\n          builtinsDict[allBuiltins[i]] = true;\n        }\n\n        for (var i = 0; i < allLiterals.length; i++) {\n          literalsDict[allLiterals[i]] = true;\n        }\n\n        return function (data) {\n          tokens = [];\n          if (data !== null) return write(data);\n          return end();\n        };\n\n        function token(data) {\n          if (data.length) {\n            tokens.push({\n              type: map[mode],\n              data: data,\n              position: start,\n              line: line,\n              column: col\n            });\n          }\n        }\n\n        function write(chunk) {\n          i = 0;\n          if (chunk.toString) chunk = chunk.toString();\n          input += chunk.replace(/\\r\\n/g, '\\n');\n          len = input.length;\n          var last;\n\n          while (c = input[i], i < len) {\n            last = i;\n\n            switch (mode) {\n              case BLOCK_COMMENT:\n                i = block_comment();\n                break;\n\n              case LINE_COMMENT:\n                i = line_comment();\n                break;\n\n              case PREPROCESSOR:\n                i = preprocessor();\n                break;\n\n              case OPERATOR:\n                i = operator();\n                break;\n\n              case INTEGER:\n                i = integer();\n                break;\n\n              case HEX:\n                i = hex();\n                break;\n\n              case FLOAT:\n                i = decimal();\n                break;\n\n              case TOKEN:\n                i = readtoken();\n                break;\n\n              case WHITESPACE:\n                i = whitespace();\n                break;\n\n              case NORMAL:\n                i = normal();\n                break;\n            }\n\n            if (last !== i) {\n              switch (input[last]) {\n                case '\\n':\n                  col = 0;\n                  ++line;\n                  break;\n\n                default:\n                  ++col;\n                  break;\n              }\n            }\n          }\n\n          total += i;\n          input = input.slice(i);\n          return tokens;\n        }\n\n        function end(chunk) {\n          if (content.length) {\n            token(content.join(''));\n          }\n\n          mode = EOF;\n          token('(eof)');\n          return tokens;\n        }\n\n        function normal() {\n          content = content.length ? [] : content;\n\n          if (last === '/' && c === '*') {\n            start = total + i - 1;\n            mode = BLOCK_COMMENT;\n            last = c;\n            return i + 1;\n          }\n\n          if (last === '/' && c === '/') {\n            start = total + i - 1;\n            mode = LINE_COMMENT;\n            last = c;\n            return i + 1;\n          }\n\n          if (c === '#') {\n            mode = PREPROCESSOR;\n            start = total + i;\n            return i;\n          }\n\n          if (/\\s/.test(c)) {\n            mode = WHITESPACE;\n            start = total + i;\n            return i;\n          }\n\n          isnum = /\\d/.test(c);\n          isoperator = /[^\\w_]/.test(c);\n          start = total + i;\n          mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;\n          return i;\n        }\n\n        function whitespace() {\n          if (/[^\\s]/g.test(c)) {\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function preprocessor() {\n          if ((c === '\\r' || c === '\\n') && last !== '\\\\') {\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function line_comment() {\n          return preprocessor();\n        }\n\n        function block_comment() {\n          if (c === '/' && last === '*') {\n            content.push(c);\n            token(content.join(''));\n            mode = NORMAL;\n            return i + 1;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function operator() {\n          if (last === '.' && /\\d/.test(c)) {\n            mode = FLOAT;\n            return i;\n          }\n\n          if (last === '/' && c === '*') {\n            mode = BLOCK_COMMENT;\n            return i;\n          }\n\n          if (last === '/' && c === '/') {\n            mode = LINE_COMMENT;\n            return i;\n          }\n\n          if (c === '.' && content.length) {\n            while (determine_operator(content)) {\n              ;\n            }\n\n            mode = FLOAT;\n            return i;\n          }\n\n          if (c === ';' || c === ')' || c === '(') {\n            if (content.length) while (determine_operator(content)) {\n              ;\n            }\n            token(c);\n            mode = NORMAL;\n            return i + 1;\n          }\n\n          var is_composite_operator = content.length === 2 && c !== '=';\n\n          if (/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\n            while (determine_operator(content)) {\n              ;\n            }\n\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function determine_operator(buf) {\n          var j = 0,\n              idx,\n              res;\n\n          do {\n            idx = operators.indexOf(buf.slice(0, buf.length + j).join(''));\n            res = operators[idx];\n\n            if (idx === -1) {\n              if (j-- + buf.length > 0) continue;\n              res = buf.slice(0, 1).join('');\n            }\n\n            token(res);\n            start += res.length;\n            content = content.slice(res.length);\n            return content.length;\n          } while (1);\n        }\n\n        function hex() {\n          if (/[^a-fA-F0-9]/.test(c)) {\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function integer() {\n          if (c === '.') {\n            content.push(c);\n            mode = FLOAT;\n            last = c;\n            return i + 1;\n          }\n\n          if (/[eE]/.test(c)) {\n            content.push(c);\n            mode = FLOAT;\n            last = c;\n            return i + 1;\n          }\n\n          if (c === 'x' && content.length === 1 && content[0] === '0') {\n            mode = HEX;\n            content.push(c);\n            last = c;\n            return i + 1;\n          }\n\n          if (/[^\\d]/.test(c)) {\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function decimal() {\n          if (c === 'f') {\n            content.push(c);\n            last = c;\n            i += 1;\n          }\n\n          if (/[eE]/.test(c)) {\n            content.push(c);\n            last = c;\n            return i + 1;\n          }\n\n          if ((c === '-' || c === '+') && /[eE]/.test(last)) {\n            content.push(c);\n            last = c;\n            return i + 1;\n          }\n\n          if (/[^\\d]/.test(c)) {\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n\n        function readtoken() {\n          if (/[^\\d\\w_]/.test(c)) {\n            var contentstr = content.join('');\n\n            if (literalsDict[contentstr]) {\n              mode = KEYWORD;\n            } else if (builtinsDict[contentstr]) {\n              mode = BUILTIN;\n            } else {\n              mode = IDENT;\n            }\n\n            token(content.join(''));\n            mode = NORMAL;\n            return i;\n          }\n\n          content.push(c);\n          last = c;\n          return i + 1;\n        }\n      }\n    }, {\n      \"./lib/builtins\": 226,\n      \"./lib/builtins-300es\": 225,\n      \"./lib/literals\": 228,\n      \"./lib/literals-300es\": 227,\n      \"./lib/operators\": 229\n    }],\n    225: [function (_glvis_, module, exports) {\n      // 300es builtins/reserved words that were previously valid in v100\n      var v100 = _glvis_('./builtins'); // The texture2D|Cube functions have been removed\n      // And the gl_ features are updated\n\n\n      v100 = v100.slice().filter(function (b) {\n        return !/^(gl\\_|texture)/.test(b);\n      });\n      module.exports = v100.concat([// the updated gl_ constants\n      'gl_VertexID', 'gl_InstanceID', 'gl_Position', 'gl_PointSize', 'gl_FragCoord', 'gl_FrontFacing', 'gl_FragDepth', 'gl_PointCoord', 'gl_MaxVertexAttribs', 'gl_MaxVertexUniformVectors', 'gl_MaxVertexOutputVectors', 'gl_MaxFragmentInputVectors', 'gl_MaxVertexTextureImageUnits', 'gl_MaxCombinedTextureImageUnits', 'gl_MaxTextureImageUnits', 'gl_MaxFragmentUniformVectors', 'gl_MaxDrawBuffers', 'gl_MinProgramTexelOffset', 'gl_MaxProgramTexelOffset', 'gl_DepthRangeParameters', 'gl_DepthRange' // other builtins\n      , 'trunc', 'round', 'roundEven', 'isnan', 'isinf', 'floatBitsToInt', 'floatBitsToUint', 'intBitsToFloat', 'uintBitsToFloat', 'packSnorm2x16', 'unpackSnorm2x16', 'packUnorm2x16', 'unpackUnorm2x16', 'packHalf2x16', 'unpackHalf2x16', 'outerProduct', 'transpose', 'determinant', 'inverse', 'texture', 'textureSize', 'textureProj', 'textureLod', 'textureOffset', 'texelFetch', 'texelFetchOffset', 'textureProjOffset', 'textureLodOffset', 'textureProjLod', 'textureProjLodOffset', 'textureGrad', 'textureGradOffset', 'textureProjGrad', 'textureProjGradOffset']);\n    }, {\n      \"./builtins\": 226\n    }],\n    226: [function (_glvis_, module, exports) {\n      module.exports = [// Keep this list sorted\n      'abs', 'acos', 'all', 'any', 'asin', 'atan', 'ceil', 'clamp', 'cos', 'cross', 'dFdx', 'dFdy', 'degrees', 'distance', 'dot', 'equal', 'exp', 'exp2', 'faceforward', 'floor', 'fract', 'gl_BackColor', 'gl_BackLightModelProduct', 'gl_BackLightProduct', 'gl_BackMaterial', 'gl_BackSecondaryColor', 'gl_ClipPlane', 'gl_ClipVertex', 'gl_Color', 'gl_DepthRange', 'gl_DepthRangeParameters', 'gl_EyePlaneQ', 'gl_EyePlaneR', 'gl_EyePlaneS', 'gl_EyePlaneT', 'gl_Fog', 'gl_FogCoord', 'gl_FogFragCoord', 'gl_FogParameters', 'gl_FragColor', 'gl_FragCoord', 'gl_FragData', 'gl_FragDepth', 'gl_FragDepthEXT', 'gl_FrontColor', 'gl_FrontFacing', 'gl_FrontLightModelProduct', 'gl_FrontLightProduct', 'gl_FrontMaterial', 'gl_FrontSecondaryColor', 'gl_LightModel', 'gl_LightModelParameters', 'gl_LightModelProducts', 'gl_LightProducts', 'gl_LightSource', 'gl_LightSourceParameters', 'gl_MaterialParameters', 'gl_MaxClipPlanes', 'gl_MaxCombinedTextureImageUnits', 'gl_MaxDrawBuffers', 'gl_MaxFragmentUniformComponents', 'gl_MaxLights', 'gl_MaxTextureCoords', 'gl_MaxTextureImageUnits', 'gl_MaxTextureUnits', 'gl_MaxVaryingFloats', 'gl_MaxVertexAttribs', 'gl_MaxVertexTextureImageUnits', 'gl_MaxVertexUniformComponents', 'gl_ModelViewMatrix', 'gl_ModelViewMatrixInverse', 'gl_ModelViewMatrixInverseTranspose', 'gl_ModelViewMatrixTranspose', 'gl_ModelViewProjectionMatrix', 'gl_ModelViewProjectionMatrixInverse', 'gl_ModelViewProjectionMatrixInverseTranspose', 'gl_ModelViewProjectionMatrixTranspose', 'gl_MultiTexCoord0', 'gl_MultiTexCoord1', 'gl_MultiTexCoord2', 'gl_MultiTexCoord3', 'gl_MultiTexCoord4', 'gl_MultiTexCoord5', 'gl_MultiTexCoord6', 'gl_MultiTexCoord7', 'gl_Normal', 'gl_NormalMatrix', 'gl_NormalScale', 'gl_ObjectPlaneQ', 'gl_ObjectPlaneR', 'gl_ObjectPlaneS', 'gl_ObjectPlaneT', 'gl_Point', 'gl_PointCoord', 'gl_PointParameters', 'gl_PointSize', 'gl_Position', 'gl_ProjectionMatrix', 'gl_ProjectionMatrixInverse', 'gl_ProjectionMatrixInverseTranspose', 'gl_ProjectionMatrixTranspose', 'gl_SecondaryColor', 'gl_TexCoord', 'gl_TextureEnvColor', 'gl_TextureMatrix', 'gl_TextureMatrixInverse', 'gl_TextureMatrixInverseTranspose', 'gl_TextureMatrixTranspose', 'gl_Vertex', 'greaterThan', 'greaterThanEqual', 'inversesqrt', 'length', 'lessThan', 'lessThanEqual', 'log', 'log2', 'matrixCompMult', 'max', 'min', 'mix', 'mod', 'normalize', 'not', 'notEqual', 'pow', 'radians', 'reflect', 'refract', 'sign', 'sin', 'smoothstep', 'sqrt', 'step', 'tan', 'texture2D', 'texture2DLod', 'texture2DProj', 'texture2DProjLod', 'textureCube', 'textureCubeLod', 'texture2DLodEXT', 'texture2DProjLodEXT', 'textureCubeLodEXT', 'texture2DGradEXT', 'texture2DProjGradEXT', 'textureCubeGradEXT'];\n    }, {}],\n    227: [function (_glvis_, module, exports) {\n      var v100 = _glvis_('./literals');\n\n      module.exports = v100.slice().concat(['layout', 'centroid', 'smooth', 'case', 'mat2x2', 'mat2x3', 'mat2x4', 'mat3x2', 'mat3x3', 'mat3x4', 'mat4x2', 'mat4x3', 'mat4x4', 'uvec2', 'uvec3', 'uvec4', 'samplerCubeShadow', 'sampler2DArray', 'sampler2DArrayShadow', 'isampler2D', 'isampler3D', 'isamplerCube', 'isampler2DArray', 'usampler2D', 'usampler3D', 'usamplerCube', 'usampler2DArray', 'coherent', 'restrict', 'readonly', 'writeonly', 'resource', 'atomic_uint', 'noperspective', 'patch', 'sample', 'subroutine', 'common', 'partition', 'active', 'filter', 'image1D', 'image2D', 'image3D', 'imageCube', 'iimage1D', 'iimage2D', 'iimage3D', 'iimageCube', 'uimage1D', 'uimage2D', 'uimage3D', 'uimageCube', 'image1DArray', 'image2DArray', 'iimage1DArray', 'iimage2DArray', 'uimage1DArray', 'uimage2DArray', 'image1DShadow', 'image2DShadow', 'image1DArrayShadow', 'image2DArrayShadow', 'imageBuffer', 'iimageBuffer', 'uimageBuffer', 'sampler1DArray', 'sampler1DArrayShadow', 'isampler1D', 'isampler1DArray', 'usampler1D', 'usampler1DArray', 'isampler2DRect', 'usampler2DRect', 'samplerBuffer', 'isamplerBuffer', 'usamplerBuffer', 'sampler2DMS', 'isampler2DMS', 'usampler2DMS', 'sampler2DMSArray', 'isampler2DMSArray', 'usampler2DMSArray']);\n    }, {\n      \"./literals\": 228\n    }],\n    228: [function (_glvis_, module, exports) {\n      module.exports = [// current\n      'precision', 'highp', 'mediump', 'lowp', 'attribute', 'const', 'uniform', 'varying', 'break', 'continue', 'do', 'for', 'while', 'if', 'else', 'in', 'out', 'inout', 'float', 'int', 'uint', 'void', 'bool', 'true', 'false', 'discard', 'return', 'mat2', 'mat3', 'mat4', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bvec2', 'bvec3', 'bvec4', 'sampler1D', 'sampler2D', 'sampler3D', 'samplerCube', 'sampler1DShadow', 'sampler2DShadow', 'struct' // future\n      , 'asm', 'class', 'union', 'enum', 'typedef', 'template', 'this', 'packed', 'goto', 'switch', 'default', 'inline', 'noinline', 'volatile', 'public', 'static', 'extern', 'external', 'interface', 'long', 'short', 'double', 'half', 'fixed', 'unsigned', 'input', 'output', 'hvec2', 'hvec3', 'hvec4', 'dvec2', 'dvec3', 'dvec4', 'fvec2', 'fvec3', 'fvec4', 'sampler2DRect', 'sampler3DRect', 'sampler2DRectShadow', 'sizeof', 'cast', 'namespace', 'using'];\n    }, {}],\n    229: [function (_glvis_, module, exports) {\n      module.exports = ['<<=', '>>=', '++', '--', '<<', '>>', '<=', '>=', '==', '!=', '&&', '||', '+=', '-=', '*=', '/=', '%=', '&=', '^^', '^=', '|=', '(', ')', '[', ']', '.', '!', '~', '*', '/', '%', '+', '-', '<', '>', '&', '^', '|', '?', ':', '=', ',', ';', '{', '}'];\n    }, {}],\n    230: [function (_glvis_, module, exports) {\n      var tokenize = _glvis_('./index');\n\n      module.exports = tokenizeString;\n\n      function tokenizeString(str, opt) {\n        var generator = tokenize(opt);\n        var tokens = [];\n        tokens = tokens.concat(generator(str));\n        tokens = tokens.concat(generator(null));\n        return tokens;\n      }\n    }, {\n      \"./index\": 224\n    }],\n    231: [function (_glvis_, module, exports) {\n      module.exports = function (strings) {\n        if (typeof strings === 'string') strings = [strings];\n        var exprs = [].slice.call(arguments, 1);\n        var parts = [];\n\n        for (var i = 0; i < strings.length - 1; i++) {\n          parts.push(strings[i], exprs[i] || '');\n        }\n\n        parts.push(strings[i]);\n        return parts.join('');\n      };\n    }, {}],\n    232: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var isBrowser = _glvis_('is-browser');\n\n      function detect() {\n        var supported = false;\n\n        try {\n          var opts = Object.defineProperty({}, 'passive', {\n            get: function get() {\n              supported = true;\n            }\n          });\n          window.addEventListener('test', null, opts);\n          window.removeEventListener('test', null, opts);\n        } catch (e) {\n          supported = false;\n        }\n\n        return supported;\n      }\n\n      module.exports = isBrowser && detect();\n    }, {\n      \"is-browser\": 236\n    }],\n    233: [function (_glvis_, module, exports) {\n      \"use strict\"; //High level idea:\n      // 1. Use Clarkson's incremental construction to find convex hull\n      // 2. Point location in triangulation by jump and walk\n\n      module.exports = incrementalConvexHull;\n\n      var orient = _glvis_(\"robust-orientation\");\n\n      var compareCell = _glvis_(\"simplicial-complex\").compareCells;\n\n      function Simplex(vertices, adjacent, boundary) {\n        this.vertices = vertices;\n        this.adjacent = adjacent;\n        this.boundary = boundary;\n        this.lastVisited = -1;\n      }\n\n      Simplex.prototype.flip = function () {\n        var t = this.vertices[0];\n        this.vertices[0] = this.vertices[1];\n        this.vertices[1] = t;\n        var u = this.adjacent[0];\n        this.adjacent[0] = this.adjacent[1];\n        this.adjacent[1] = u;\n      };\n\n      function GlueFacet(vertices, cell, index) {\n        this.vertices = vertices;\n        this.cell = cell;\n        this.index = index;\n      }\n\n      function compareGlue(a, b) {\n        return compareCell(a.vertices, b.vertices);\n      }\n\n      function wrapper(test) {\n        return function () {\n          var tuple = this.tuple;\n          return test.apply(this, tuple);\n        };\n      }\n\n      function bakeOrient(d) {\n        var test = orient[d + 1];\n\n        if (!test) {\n          test = orient;\n        }\n\n        return wrapper(test);\n      }\n\n      var BAKED = [];\n\n      function Triangulation(dimension, vertices, simplices) {\n        this.dimension = dimension;\n        this.vertices = vertices;\n        this.simplices = simplices;\n        this.interior = simplices.filter(function (c) {\n          return !c.boundary;\n        });\n        this.tuple = new Array(dimension + 1);\n\n        for (var i = 0; i <= dimension; ++i) {\n          this.tuple[i] = this.vertices[i];\n        }\n\n        var o = BAKED[dimension];\n\n        if (!o) {\n          o = BAKED[dimension] = bakeOrient(dimension);\n        }\n\n        this.orient = o;\n      }\n\n      var proto = Triangulation.prototype; //Degenerate situation where we are on boundary, but coplanar to face\n\n      proto.handleBoundaryDegeneracy = function (cell, point) {\n        var d = this.dimension;\n        var n = this.vertices.length - 1;\n        var tuple = this.tuple;\n        var verts = this.vertices; //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n\n        var toVisit = [cell];\n        cell.lastVisited = -n;\n\n        while (toVisit.length > 0) {\n          cell = toVisit.pop();\n          var cellAdj = cell.adjacent;\n\n          for (var i = 0; i <= d; ++i) {\n            var neighbor = cellAdj[i];\n\n            if (!neighbor.boundary || neighbor.lastVisited <= -n) {\n              continue;\n            }\n\n            var nv = neighbor.vertices;\n\n            for (var j = 0; j <= d; ++j) {\n              var vv = nv[j];\n\n              if (vv < 0) {\n                tuple[j] = point;\n              } else {\n                tuple[j] = verts[vv];\n              }\n            }\n\n            var o = this.orient();\n\n            if (o > 0) {\n              return neighbor;\n            }\n\n            neighbor.lastVisited = -n;\n\n            if (o === 0) {\n              toVisit.push(neighbor);\n            }\n          }\n        }\n\n        return null;\n      };\n\n      proto.walk = function (point, random) {\n        //Alias local properties\n        var n = this.vertices.length - 1;\n        var d = this.dimension;\n        var verts = this.vertices;\n        var tuple = this.tuple; //Compute initial jump cell\n\n        var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;\n        var cell = this.interior[initIndex]; //Start walking\n\n        outerLoop: while (!cell.boundary) {\n          var cellVerts = cell.vertices;\n          var cellAdj = cell.adjacent;\n\n          for (var i = 0; i <= d; ++i) {\n            tuple[i] = verts[cellVerts[i]];\n          }\n\n          cell.lastVisited = n; //Find farthest adjacent cell\n\n          for (var i = 0; i <= d; ++i) {\n            var neighbor = cellAdj[i];\n\n            if (neighbor.lastVisited >= n) {\n              continue;\n            }\n\n            var prev = tuple[i];\n            tuple[i] = point;\n            var o = this.orient();\n            tuple[i] = prev;\n\n            if (o < 0) {\n              cell = neighbor;\n              continue outerLoop;\n            } else {\n              if (!neighbor.boundary) {\n                neighbor.lastVisited = n;\n              } else {\n                neighbor.lastVisited = -n;\n              }\n            }\n          }\n\n          return;\n        }\n\n        return cell;\n      };\n\n      proto.addPeaks = function (point, cell) {\n        var n = this.vertices.length - 1;\n        var d = this.dimension;\n        var verts = this.vertices;\n        var tuple = this.tuple;\n        var interior = this.interior;\n        var simplices = this.simplices; //Walking finished at boundary, time to add peaks\n\n        var tovisit = [cell]; //Stretch initial boundary cell into a peak\n\n        cell.lastVisited = n;\n        cell.vertices[cell.vertices.indexOf(-1)] = n;\n        cell.boundary = false;\n        interior.push(cell); //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n\n        var glueFacets = []; //Do a traversal of the boundary walking outward from starting peak\n\n        while (tovisit.length > 0) {\n          //Pop off peak and walk over adjacent cells\n          var cell = tovisit.pop();\n          var cellVerts = cell.vertices;\n          var cellAdj = cell.adjacent;\n          var indexOfN = cellVerts.indexOf(n);\n\n          if (indexOfN < 0) {\n            continue;\n          }\n\n          for (var i = 0; i <= d; ++i) {\n            if (i === indexOfN) {\n              continue;\n            } //For each boundary neighbor of the cell\n\n\n            var neighbor = cellAdj[i];\n\n            if (!neighbor.boundary || neighbor.lastVisited >= n) {\n              continue;\n            }\n\n            var nv = neighbor.vertices; //Test if neighbor is a peak\n\n            if (neighbor.lastVisited !== -n) {\n              //Compute orientation of p relative to each boundary peak\n              var indexOfNeg1 = 0;\n\n              for (var j = 0; j <= d; ++j) {\n                if (nv[j] < 0) {\n                  indexOfNeg1 = j;\n                  tuple[j] = point;\n                } else {\n                  tuple[j] = verts[nv[j]];\n                }\n              }\n\n              var o = this.orient(); //Test if neighbor cell is also a peak\n\n              if (o > 0) {\n                nv[indexOfNeg1] = n;\n                neighbor.boundary = false;\n                interior.push(neighbor);\n                tovisit.push(neighbor);\n                neighbor.lastVisited = n;\n                continue;\n              } else {\n                neighbor.lastVisited = -n;\n              }\n            }\n\n            var na = neighbor.adjacent; //Otherwise, replace neighbor with new face\n\n            var vverts = cellVerts.slice();\n            var vadj = cellAdj.slice();\n            var ncell = new Simplex(vverts, vadj, true);\n            simplices.push(ncell); //Connect to neighbor\n\n            var opposite = na.indexOf(cell);\n\n            if (opposite < 0) {\n              continue;\n            }\n\n            na[opposite] = ncell;\n            vadj[indexOfN] = neighbor; //Connect to cell\n\n            vverts[i] = -1;\n            vadj[i] = cell;\n            cellAdj[i] = ncell; //Flip facet\n\n            ncell.flip(); //Add to glue list\n\n            for (var j = 0; j <= d; ++j) {\n              var uu = vverts[j];\n\n              if (uu < 0 || uu === n) {\n                continue;\n              }\n\n              var nface = new Array(d - 1);\n              var nptr = 0;\n\n              for (var k = 0; k <= d; ++k) {\n                var vv = vverts[k];\n\n                if (vv < 0 || k === j) {\n                  continue;\n                }\n\n                nface[nptr++] = vv;\n              }\n\n              glueFacets.push(new GlueFacet(nface, ncell, j));\n            }\n          }\n        } //Glue boundary facets together\n\n\n        glueFacets.sort(compareGlue);\n\n        for (var i = 0; i + 1 < glueFacets.length; i += 2) {\n          var a = glueFacets[i];\n          var b = glueFacets[i + 1];\n          var ai = a.index;\n          var bi = b.index;\n\n          if (ai < 0 || bi < 0) {\n            continue;\n          }\n\n          a.cell.adjacent[a.index] = b.cell;\n          b.cell.adjacent[b.index] = a.cell;\n        }\n      };\n\n      proto.insert = function (point, random) {\n        //Add point\n        var verts = this.vertices;\n        verts.push(point);\n        var cell = this.walk(point, random);\n\n        if (!cell) {\n          return;\n        } //Alias local properties\n\n\n        var d = this.dimension;\n        var tuple = this.tuple; //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n\n        for (var i = 0; i <= d; ++i) {\n          var vv = cell.vertices[i];\n\n          if (vv < 0) {\n            tuple[i] = point;\n          } else {\n            tuple[i] = verts[vv];\n          }\n        }\n\n        var o = this.orient(tuple);\n\n        if (o < 0) {\n          return;\n        } else if (o === 0) {\n          cell = this.handleBoundaryDegeneracy(cell, point);\n\n          if (!cell) {\n            return;\n          }\n        } //Add peaks\n\n\n        this.addPeaks(point, cell);\n      }; //Extract all boundary cells\n\n\n      proto.boundary = function () {\n        var d = this.dimension;\n        var boundary = [];\n        var cells = this.simplices;\n        var nc = cells.length;\n\n        for (var i = 0; i < nc; ++i) {\n          var c = cells[i];\n\n          if (c.boundary) {\n            var bcell = new Array(d);\n            var cv = c.vertices;\n            var ptr = 0;\n            var parity = 0;\n\n            for (var j = 0; j <= d; ++j) {\n              if (cv[j] >= 0) {\n                bcell[ptr++] = cv[j];\n              } else {\n                parity = j & 1;\n              }\n            }\n\n            if (parity === (d & 1)) {\n              var t = bcell[0];\n              bcell[0] = bcell[1];\n              bcell[1] = t;\n            }\n\n            boundary.push(bcell);\n          }\n        }\n\n        return boundary;\n      };\n\n      function incrementalConvexHull(points, randomSearch) {\n        var n = points.length;\n\n        if (n === 0) {\n          throw new Error(\"Must have at least d+1 points\");\n        }\n\n        var d = points[0].length;\n\n        if (n <= d) {\n          throw new Error(\"Must input at least d+1 points\");\n        } //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n\n\n        var initialSimplex = points.slice(0, d + 1); //Make sure initial simplex is positively oriented\n\n        var o = orient.apply(void 0, initialSimplex);\n\n        if (o === 0) {\n          throw new Error(\"Input not in general position\");\n        }\n\n        var initialCoords = new Array(d + 1);\n\n        for (var i = 0; i <= d; ++i) {\n          initialCoords[i] = i;\n        }\n\n        if (o < 0) {\n          initialCoords[0] = 1;\n          initialCoords[1] = 0;\n        } //Create initial topological index, glue pointers together (kind of messy)\n\n\n        var initialCell = new Simplex(initialCoords, new Array(d + 1), false);\n        var boundary = initialCell.adjacent;\n        var list = new Array(d + 2);\n\n        for (var i = 0; i <= d; ++i) {\n          var verts = initialCoords.slice();\n\n          for (var j = 0; j <= d; ++j) {\n            if (j === i) {\n              verts[j] = -1;\n            }\n          }\n\n          var t = verts[0];\n          verts[0] = verts[1];\n          verts[1] = t;\n          var cell = new Simplex(verts, new Array(d + 1), true);\n          boundary[i] = cell;\n          list[i] = cell;\n        }\n\n        list[d + 1] = initialCell;\n\n        for (var i = 0; i <= d; ++i) {\n          var verts = boundary[i].vertices;\n          var adj = boundary[i].adjacent;\n\n          for (var j = 0; j <= d; ++j) {\n            var v = verts[j];\n\n            if (v < 0) {\n              adj[j] = initialCell;\n              continue;\n            }\n\n            for (var k = 0; k <= d; ++k) {\n              if (boundary[k].vertices.indexOf(v) < 0) {\n                adj[j] = boundary[k];\n              }\n            }\n          }\n        } //Initialize triangles\n\n\n        var triangles = new Triangulation(d, initialSimplex, list); //Insert remaining points\n\n        var useRandom = !!randomSearch;\n\n        for (var i = d + 1; i < n; ++i) {\n          triangles.insert(points[i], useRandom);\n        } //Extract boundary cells\n\n\n        return triangles.boundary();\n      }\n    }, {\n      \"robust-orientation\": 284,\n      \"simplicial-complex\": 293\n    }],\n    234: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var bounds = _glvis_(\"binary-search-bounds\");\n\n      var NOT_FOUND = 0;\n      var SUCCESS = 1;\n      var EMPTY = 2;\n      module.exports = createWrapper;\n\n      function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {\n        this.mid = mid;\n        this.left = left;\n        this.right = right;\n        this.leftPoints = leftPoints;\n        this.rightPoints = rightPoints;\n        this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;\n      }\n\n      var proto = IntervalTreeNode.prototype;\n\n      function copy(a, b) {\n        a.mid = b.mid;\n        a.left = b.left;\n        a.right = b.right;\n        a.leftPoints = b.leftPoints;\n        a.rightPoints = b.rightPoints;\n        a.count = b.count;\n      }\n\n      function rebuild(node, intervals) {\n        var ntree = createIntervalTree(intervals);\n        node.mid = ntree.mid;\n        node.left = ntree.left;\n        node.right = ntree.right;\n        node.leftPoints = ntree.leftPoints;\n        node.rightPoints = ntree.rightPoints;\n        node.count = ntree.count;\n      }\n\n      function rebuildWithInterval(node, interval) {\n        var intervals = node.intervals([]);\n        intervals.push(interval);\n        rebuild(node, intervals);\n      }\n\n      function rebuildWithoutInterval(node, interval) {\n        var intervals = node.intervals([]);\n        var idx = intervals.indexOf(interval);\n\n        if (idx < 0) {\n          return NOT_FOUND;\n        }\n\n        intervals.splice(idx, 1);\n        rebuild(node, intervals);\n        return SUCCESS;\n      }\n\n      proto.intervals = function (result) {\n        result.push.apply(result, this.leftPoints);\n\n        if (this.left) {\n          this.left.intervals(result);\n        }\n\n        if (this.right) {\n          this.right.intervals(result);\n        }\n\n        return result;\n      };\n\n      proto.insert = function (interval) {\n        var weight = this.count - this.leftPoints.length;\n        this.count += 1;\n\n        if (interval[1] < this.mid) {\n          if (this.left) {\n            if (4 * (this.left.count + 1) > 3 * (weight + 1)) {\n              rebuildWithInterval(this, interval);\n            } else {\n              this.left.insert(interval);\n            }\n          } else {\n            this.left = createIntervalTree([interval]);\n          }\n        } else if (interval[0] > this.mid) {\n          if (this.right) {\n            if (4 * (this.right.count + 1) > 3 * (weight + 1)) {\n              rebuildWithInterval(this, interval);\n            } else {\n              this.right.insert(interval);\n            }\n          } else {\n            this.right = createIntervalTree([interval]);\n          }\n        } else {\n          var l = bounds.ge(this.leftPoints, interval, compareBegin);\n          var r = bounds.ge(this.rightPoints, interval, compareEnd);\n          this.leftPoints.splice(l, 0, interval);\n          this.rightPoints.splice(r, 0, interval);\n        }\n      };\n\n      proto.remove = function (interval) {\n        var weight = this.count - this.leftPoints;\n\n        if (interval[1] < this.mid) {\n          if (!this.left) {\n            return NOT_FOUND;\n          }\n\n          var rw = this.right ? this.right.count : 0;\n\n          if (4 * rw > 3 * (weight - 1)) {\n            return rebuildWithoutInterval(this, interval);\n          }\n\n          var r = this.left.remove(interval);\n\n          if (r === EMPTY) {\n            this.left = null;\n            this.count -= 1;\n            return SUCCESS;\n          } else if (r === SUCCESS) {\n            this.count -= 1;\n          }\n\n          return r;\n        } else if (interval[0] > this.mid) {\n          if (!this.right) {\n            return NOT_FOUND;\n          }\n\n          var lw = this.left ? this.left.count : 0;\n\n          if (4 * lw > 3 * (weight - 1)) {\n            return rebuildWithoutInterval(this, interval);\n          }\n\n          var r = this.right.remove(interval);\n\n          if (r === EMPTY) {\n            this.right = null;\n            this.count -= 1;\n            return SUCCESS;\n          } else if (r === SUCCESS) {\n            this.count -= 1;\n          }\n\n          return r;\n        } else {\n          if (this.count === 1) {\n            if (this.leftPoints[0] === interval) {\n              return EMPTY;\n            } else {\n              return NOT_FOUND;\n            }\n          }\n\n          if (this.leftPoints.length === 1 && this.leftPoints[0] === interval) {\n            if (this.left && this.right) {\n              var p = this;\n              var n = this.left;\n\n              while (n.right) {\n                p = n;\n                n = n.right;\n              }\n\n              if (p === this) {\n                n.right = this.right;\n              } else {\n                var l = this.left;\n                var r = this.right;\n                p.count -= n.count;\n                p.right = n.left;\n                n.left = l;\n                n.right = r;\n              }\n\n              copy(this, n);\n              this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;\n            } else if (this.left) {\n              copy(this, this.left);\n            } else {\n              copy(this, this.right);\n            }\n\n            return SUCCESS;\n          }\n\n          for (var l = bounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length; ++l) {\n            if (this.leftPoints[l][0] !== interval[0]) {\n              break;\n            }\n\n            if (this.leftPoints[l] === interval) {\n              this.count -= 1;\n              this.leftPoints.splice(l, 1);\n\n              for (var r = bounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length; ++r) {\n                if (this.rightPoints[r][1] !== interval[1]) {\n                  break;\n                } else if (this.rightPoints[r] === interval) {\n                  this.rightPoints.splice(r, 1);\n                  return SUCCESS;\n                }\n              }\n            }\n          }\n\n          return NOT_FOUND;\n        }\n      };\n\n      function reportLeftRange(arr, hi, cb) {\n        for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {\n          var r = cb(arr[i]);\n\n          if (r) {\n            return r;\n          }\n        }\n      }\n\n      function reportRightRange(arr, lo, cb) {\n        for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {\n          var r = cb(arr[i]);\n\n          if (r) {\n            return r;\n          }\n        }\n      }\n\n      function reportRange(arr, cb) {\n        for (var i = 0; i < arr.length; ++i) {\n          var r = cb(arr[i]);\n\n          if (r) {\n            return r;\n          }\n        }\n      }\n\n      proto.queryPoint = function (x, cb) {\n        if (x < this.mid) {\n          if (this.left) {\n            var r = this.left.queryPoint(x, cb);\n\n            if (r) {\n              return r;\n            }\n          }\n\n          return reportLeftRange(this.leftPoints, x, cb);\n        } else if (x > this.mid) {\n          if (this.right) {\n            var r = this.right.queryPoint(x, cb);\n\n            if (r) {\n              return r;\n            }\n          }\n\n          return reportRightRange(this.rightPoints, x, cb);\n        } else {\n          return reportRange(this.leftPoints, cb);\n        }\n      };\n\n      proto.queryInterval = function (lo, hi, cb) {\n        if (lo < this.mid && this.left) {\n          var r = this.left.queryInterval(lo, hi, cb);\n\n          if (r) {\n            return r;\n          }\n        }\n\n        if (hi > this.mid && this.right) {\n          var r = this.right.queryInterval(lo, hi, cb);\n\n          if (r) {\n            return r;\n          }\n        }\n\n        if (hi < this.mid) {\n          return reportLeftRange(this.leftPoints, hi, cb);\n        } else if (lo > this.mid) {\n          return reportRightRange(this.rightPoints, lo, cb);\n        } else {\n          return reportRange(this.leftPoints, cb);\n        }\n      };\n\n      function compareNumbers(a, b) {\n        return a - b;\n      }\n\n      function compareBegin(a, b) {\n        var d = a[0] - b[0];\n\n        if (d) {\n          return d;\n        }\n\n        return a[1] - b[1];\n      }\n\n      function compareEnd(a, b) {\n        var d = a[1] - b[1];\n\n        if (d) {\n          return d;\n        }\n\n        return a[0] - b[0];\n      }\n\n      function createIntervalTree(intervals) {\n        if (intervals.length === 0) {\n          return null;\n        }\n\n        var pts = [];\n\n        for (var i = 0; i < intervals.length; ++i) {\n          pts.push(intervals[i][0], intervals[i][1]);\n        }\n\n        pts.sort(compareNumbers);\n        var mid = pts[pts.length >> 1];\n        var leftIntervals = [];\n        var rightIntervals = [];\n        var centerIntervals = [];\n\n        for (var i = 0; i < intervals.length; ++i) {\n          var s = intervals[i];\n\n          if (s[1] < mid) {\n            leftIntervals.push(s);\n          } else if (mid < s[0]) {\n            rightIntervals.push(s);\n          } else {\n            centerIntervals.push(s);\n          }\n        } //Split center intervals\n\n\n        var leftPoints = centerIntervals;\n        var rightPoints = centerIntervals.slice();\n        leftPoints.sort(compareBegin);\n        rightPoints.sort(compareEnd);\n        return new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);\n      } //User friendly wrapper that makes it possible to support empty trees\n\n\n      function IntervalTree(root) {\n        this.root = root;\n      }\n\n      var tproto = IntervalTree.prototype;\n\n      tproto.insert = function (interval) {\n        if (this.root) {\n          this.root.insert(interval);\n        } else {\n          this.root = new IntervalTreeNode(interval[0], null, null, [interval], [interval]);\n        }\n      };\n\n      tproto.remove = function (interval) {\n        if (this.root) {\n          var r = this.root.remove(interval);\n\n          if (r === EMPTY) {\n            this.root = null;\n          }\n\n          return r !== NOT_FOUND;\n        }\n\n        return false;\n      };\n\n      tproto.queryPoint = function (p, cb) {\n        if (this.root) {\n          return this.root.queryPoint(p, cb);\n        }\n      };\n\n      tproto.queryInterval = function (lo, hi, cb) {\n        if (lo <= hi && this.root) {\n          return this.root.queryInterval(lo, hi, cb);\n        }\n      };\n\n      Object.defineProperty(tproto, \"count\", {\n        get: function get() {\n          if (this.root) {\n            return this.root.count;\n          }\n\n          return 0;\n        }\n      });\n      Object.defineProperty(tproto, \"intervals\", {\n        get: function get() {\n          if (this.root) {\n            return this.root.intervals([]);\n          }\n\n          return [];\n        }\n      });\n\n      function createWrapper(intervals) {\n        if (!intervals || intervals.length === 0) {\n          return new IntervalTree(null);\n        }\n\n        return new IntervalTree(createIntervalTree(intervals));\n      }\n    }, {\n      \"binary-search-bounds\": 31\n    }],\n    235: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function iota(n) {\n        var result = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          result[i] = i;\n        }\n\n        return result;\n      }\n\n      module.exports = iota;\n    }, {}],\n    236: [function (_glvis_, module, exports) {\n      module.exports = true;\n    }, {}],\n    237: [function (_glvis_, module, exports) {\n      /*!\n       * Determine if an object is a Buffer\n       *\n       * @author   Feross Aboukhadijeh <https://feross.org>\n       * @license  MIT\n       */\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      } // For Node v0.10 support. Remove this eventually.\n\n\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n    }, {}],\n    238: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = isMobile;\n      module.exports.isMobile = isMobile;\n      module.exports.default = isMobile;\n      var mobileRE = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series[46]0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;\n      var tabletRE = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series[46]0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino|android|ipad|playbook|silk/i;\n\n      function isMobile(opts) {\n        if (!opts) opts = {};\n        var ua = opts.ua;\n        if (!ua && typeof navigator !== 'undefined') ua = navigator.userAgent;\n\n        if (ua && ua.headers && typeof ua.headers['user-agent'] === 'string') {\n          ua = ua.headers['user-agent'];\n        }\n\n        if (typeof ua !== 'string') return false;\n        var result = opts.tablet ? tabletRE.test(ua) : mobileRE.test(ua);\n\n        if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf('Macintosh') !== -1 && ua.indexOf('Safari') !== -1) {\n          result = true;\n        }\n\n        return result;\n      }\n    }, {}],\n    239: [function (_glvis_, module, exports) {\n      'use strict';\n      /**\r\n       * Is this string all whitespace?\r\n       * This solution kind of makes my brain hurt, but it's significantly faster\r\n       * than !str.trim() or any other solution I could find.\r\n       *\r\n       * whitespace codes from: http://en.wikipedia.org/wiki/Whitespace_character\r\n       * and verified with:\r\n       *\r\n       *  for(var i = 0; i < 65536; i++) {\r\n       *      var s = String.fromCharCode(i);\r\n       *      if(+s===0 && !s.trim()) console.log(i, s);\r\n       *  }\r\n       *\r\n       * which counts a couple of these as *not* whitespace, but finds nothing else\r\n       * that *is* whitespace. Note that charCodeAt stops at 16 bits, but it appears\r\n       * that there are no whitespace characters above this, and code points above\r\n       * this do not map onto white space characters.\r\n       */\n\n      module.exports = function (str) {\n        var l = str.length,\n            a;\n\n        for (var i = 0; i < l; i++) {\n          a = str.charCodeAt(i);\n\n          if ((a < 9 || a > 13) && a !== 32 && a !== 133 && a !== 160 && a !== 5760 && a !== 6158 && (a < 8192 || a > 8205) && a !== 8232 && a !== 8233 && a !== 8239 && a !== 8287 && a !== 8288 && a !== 12288 && a !== 65279) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n    }, {}],\n    240: [function (_glvis_, module, exports) {\n      function lerp(v0, v1, t) {\n        return v0 * (1 - t) + v1 * t;\n      }\n\n      module.exports = lerp;\n    }, {}],\n    241: [function (_glvis_, module, exports) {\n      /*jshint unused:true*/\n\n      /*\n      Input:  matrix      ; a 4x4 matrix\n      Output: translation ; a 3 component vector\n              scale       ; a 3 component vector\n              skew        ; skew factors XY,XZ,YZ represented as a 3 component vector\n              perspective ; a 4 component vector\n              quaternion  ; a 4 component vector\n      Returns false if the matrix cannot be decomposed, true if it can\n      \n      \n      References:\n      https://github.com/kamicane/matrix3d/blob/master/lib/Matrix3d.js\n      https://github.com/ChromiumWebApps/chromium/blob/master/ui/gfx/transform_util.cc\n      http://www.w3.org/TR/css3-transforms/#decomposing-a-3d-matrix\n      */\n      var normalize = _glvis_('./normalize');\n\n      var create = _glvis_('gl-mat4/create');\n\n      var clone = _glvis_('gl-mat4/clone');\n\n      var determinant = _glvis_('gl-mat4/determinant');\n\n      var invert = _glvis_('gl-mat4/invert');\n\n      var transpose = _glvis_('gl-mat4/transpose');\n\n      var vec3 = {\n        length: _glvis_('gl-vec3/length'),\n        normalize: _glvis_('gl-vec3/normalize'),\n        dot: _glvis_('gl-vec3/dot'),\n        cross: _glvis_('gl-vec3/cross')\n      };\n      var tmp = create();\n      var perspectiveMatrix = create();\n      var tmpVec4 = [0, 0, 0, 0];\n      var row = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n      var pdum3 = [0, 0, 0];\n\n      module.exports = function decomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {\n        if (!translation) translation = [0, 0, 0];\n        if (!scale) scale = [0, 0, 0];\n        if (!skew) skew = [0, 0, 0];\n        if (!perspective) perspective = [0, 0, 0, 1];\n        if (!quaternion) quaternion = [0, 0, 0, 1]; //normalize, if not possible then bail out early\n\n        if (!normalize(tmp, matrix)) return false; // perspectiveMatrix is used to solve for perspective, but it also provides\n        // an easy way to test for singularity of the upper 3x3 component.\n\n        clone(perspectiveMatrix, tmp);\n        perspectiveMatrix[3] = 0;\n        perspectiveMatrix[7] = 0;\n        perspectiveMatrix[11] = 0;\n        perspectiveMatrix[15] = 1; // If the perspectiveMatrix is not invertible, we are also unable to\n        // decompose, so we'll bail early. Constant taken from SkMatrix44::invert.\n\n        if (Math.abs(determinant(perspectiveMatrix) < 1e-8)) return false;\n        var a03 = tmp[3],\n            a13 = tmp[7],\n            a23 = tmp[11],\n            a30 = tmp[12],\n            a31 = tmp[13],\n            a32 = tmp[14],\n            a33 = tmp[15]; // First, isolate perspective.\n\n        if (a03 !== 0 || a13 !== 0 || a23 !== 0) {\n          tmpVec4[0] = a03;\n          tmpVec4[1] = a13;\n          tmpVec4[2] = a23;\n          tmpVec4[3] = a33; // Solve the equation by inverting perspectiveMatrix and multiplying\n          // rightHandSide by the inverse.\n          // resuing the perspectiveMatrix here since it's no longer needed\n\n          var ret = invert(perspectiveMatrix, perspectiveMatrix);\n          if (!ret) return false;\n          transpose(perspectiveMatrix, perspectiveMatrix); //multiply by transposed inverse perspective matrix, into perspective vec4\n\n          vec4multMat4(perspective, tmpVec4, perspectiveMatrix);\n        } else {\n          //no perspective\n          perspective[0] = perspective[1] = perspective[2] = 0;\n          perspective[3] = 1;\n        } // Next take care of translation\n\n\n        translation[0] = a30;\n        translation[1] = a31;\n        translation[2] = a32; // Now get scale and shear. 'row' is a 3 element array of 3 component vectors\n\n        mat3from4(row, tmp); // Compute X scale factor and normalize first row.\n\n        scale[0] = vec3.length(row[0]);\n        vec3.normalize(row[0], row[0]); // Compute XY shear factor and make 2nd row orthogonal to 1st.\n\n        skew[0] = vec3.dot(row[0], row[1]);\n        combine(row[1], row[1], row[0], 1.0, -skew[0]); // Now, compute Y scale and normalize 2nd row.\n\n        scale[1] = vec3.length(row[1]);\n        vec3.normalize(row[1], row[1]);\n        skew[0] /= scale[1]; // Compute XZ and YZ shears, orthogonalize 3rd row\n\n        skew[1] = vec3.dot(row[0], row[2]);\n        combine(row[2], row[2], row[0], 1.0, -skew[1]);\n        skew[2] = vec3.dot(row[1], row[2]);\n        combine(row[2], row[2], row[1], 1.0, -skew[2]); // Next, get Z scale and normalize 3rd row.\n\n        scale[2] = vec3.length(row[2]);\n        vec3.normalize(row[2], row[2]);\n        skew[1] /= scale[2];\n        skew[2] /= scale[2]; // At this point, the matrix (in rows) is orthonormal.\n        // Check for a coordinate system flip.  If the determinant\n        // is -1, then negate the matrix and the scaling factors.\n\n        vec3.cross(pdum3, row[1], row[2]);\n\n        if (vec3.dot(row[0], pdum3) < 0) {\n          for (var i = 0; i < 3; i++) {\n            scale[i] *= -1;\n            row[i][0] *= -1;\n            row[i][1] *= -1;\n            row[i][2] *= -1;\n          }\n        } // Now, get the rotations out\n\n\n        quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));\n        quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));\n        quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));\n        quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));\n        if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];\n        if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];\n        if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];\n        return true;\n      }; //will be replaced by gl-vec4 eventually\n\n\n      function vec4multMat4(out, a, m) {\n        var x = a[0],\n            y = a[1],\n            z = a[2],\n            w = a[3];\n        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n        return out;\n      } //gets upper-left of a 4x4 matrix into a 3x3 of vectors\n\n\n      function mat3from4(out, mat4x4) {\n        out[0][0] = mat4x4[0];\n        out[0][1] = mat4x4[1];\n        out[0][2] = mat4x4[2];\n        out[1][0] = mat4x4[4];\n        out[1][1] = mat4x4[5];\n        out[1][2] = mat4x4[6];\n        out[2][0] = mat4x4[8];\n        out[2][1] = mat4x4[9];\n        out[2][2] = mat4x4[10];\n      }\n\n      function combine(out, a, b, scale1, scale2) {\n        out[0] = a[0] * scale1 + b[0] * scale2;\n        out[1] = a[1] * scale1 + b[1] * scale2;\n        out[2] = a[2] * scale1 + b[2] * scale2;\n      }\n    }, {\n      \"./normalize\": 242,\n      \"gl-mat4/clone\": 92,\n      \"gl-mat4/create\": 93,\n      \"gl-mat4/determinant\": 94,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/transpose\": 109,\n      \"gl-vec3/cross\": 157,\n      \"gl-vec3/dot\": 162,\n      \"gl-vec3/length\": 172,\n      \"gl-vec3/normalize\": 179\n    }],\n    242: [function (_glvis_, module, exports) {\n      module.exports = function normalize(out, mat) {\n        var m44 = mat[15]; // Cannot normalize.\n\n        if (m44 === 0) return false;\n        var scale = 1 / m44;\n\n        for (var i = 0; i < 16; i++) {\n          out[i] = mat[i] * scale;\n        }\n\n        return true;\n      };\n    }, {}],\n    243: [function (_glvis_, module, exports) {\n      var lerp = _glvis_('gl-vec3/lerp');\n\n      var recompose = _glvis_('mat4-recompose');\n\n      var decompose = _glvis_('mat4-decompose');\n\n      var determinant = _glvis_('gl-mat4/determinant');\n\n      var slerp = _glvis_('quat-slerp');\n\n      var state0 = state();\n      var state1 = state();\n      var tmp = state();\n      module.exports = interpolate;\n\n      function interpolate(out, start, end, alpha) {\n        if (determinant(start) === 0 || determinant(end) === 0) return false; //decompose the start and end matrices into individual components\n\n        var r0 = decompose(start, state0.translate, state0.scale, state0.skew, state0.perspective, state0.quaternion);\n        var r1 = decompose(end, state1.translate, state1.scale, state1.skew, state1.perspective, state1.quaternion);\n        if (!r0 || !r1) return false; //now lerp/slerp the start and end components into a temporary     lerp(tmptranslate, state0.translate, state1.translate, alpha)\n\n        lerp(tmp.translate, state0.translate, state1.translate, alpha);\n        lerp(tmp.skew, state0.skew, state1.skew, alpha);\n        lerp(tmp.scale, state0.scale, state1.scale, alpha);\n        lerp(tmp.perspective, state0.perspective, state1.perspective, alpha);\n        slerp(tmp.quaternion, state0.quaternion, state1.quaternion, alpha); //and recompose into our 'out' matrix\n\n        recompose(out, tmp.translate, tmp.scale, tmp.skew, tmp.perspective, tmp.quaternion);\n        return true;\n      }\n\n      function state() {\n        return {\n          translate: vec3(),\n          scale: vec3(1),\n          skew: vec3(),\n          perspective: vec4(),\n          quaternion: vec4()\n        };\n      }\n\n      function vec3(n) {\n        return [n || 0, n || 0, n || 0];\n      }\n\n      function vec4() {\n        return [0, 0, 0, 1];\n      }\n    }, {\n      \"gl-mat4/determinant\": 94,\n      \"gl-vec3/lerp\": 173,\n      \"mat4-decompose\": 241,\n      \"mat4-recompose\": 244,\n      \"quat-slerp\": 271\n    }],\n    244: [function (_glvis_, module, exports) {\n      /*\n      Input:  translation ; a 3 component vector\n              scale       ; a 3 component vector\n              skew        ; skew factors XY,XZ,YZ represented as a 3 component vector\n              perspective ; a 4 component vector\n              quaternion  ; a 4 component vector\n      Output: matrix      ; a 4x4 matrix\n      \n      From: http://www.w3.org/TR/css3-transforms/#recomposing-to-a-3d-matrix\n      */\n      var mat4 = {\n        identity: _glvis_('gl-mat4/identity'),\n        translate: _glvis_('gl-mat4/translate'),\n        multiply: _glvis_('gl-mat4/multiply'),\n        create: _glvis_('gl-mat4/create'),\n        scale: _glvis_('gl-mat4/scale'),\n        fromRotationTranslation: _glvis_('gl-mat4/fromRotationTranslation')\n      };\n      var rotationMatrix = mat4.create();\n      var temp = mat4.create();\n\n      module.exports = function recomposeMat4(matrix, translation, scale, skew, perspective, quaternion) {\n        mat4.identity(matrix); //apply translation & rotation\n\n        mat4.fromRotationTranslation(matrix, quaternion, translation); //apply perspective\n\n        matrix[3] = perspective[0];\n        matrix[7] = perspective[1];\n        matrix[11] = perspective[2];\n        matrix[15] = perspective[3]; // apply skew\n        // temp is a identity 4x4 matrix initially\n\n        mat4.identity(temp);\n\n        if (skew[2] !== 0) {\n          temp[9] = skew[2];\n          mat4.multiply(matrix, matrix, temp);\n        }\n\n        if (skew[1] !== 0) {\n          temp[9] = 0;\n          temp[8] = skew[1];\n          mat4.multiply(matrix, matrix, temp);\n        }\n\n        if (skew[0] !== 0) {\n          temp[8] = 0;\n          temp[4] = skew[0];\n          mat4.multiply(matrix, matrix, temp);\n        } //apply scale\n\n\n        mat4.scale(matrix, matrix, scale);\n        return matrix;\n      };\n    }, {\n      \"gl-mat4/create\": 93,\n      \"gl-mat4/fromRotationTranslation\": 96,\n      \"gl-mat4/identity\": 97,\n      \"gl-mat4/multiply\": 100,\n      \"gl-mat4/scale\": 107,\n      \"gl-mat4/translate\": 108\n    }],\n    245: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      var m4interp = _glvis_('mat4-interpolate');\n\n      var invert44 = _glvis_('gl-mat4/invert');\n\n      var rotateX = _glvis_('gl-mat4/rotateX');\n\n      var rotateY = _glvis_('gl-mat4/rotateY');\n\n      var rotateZ = _glvis_('gl-mat4/rotateZ');\n\n      var lookAt = _glvis_('gl-mat4/lookAt');\n\n      var translate = _glvis_('gl-mat4/translate');\n\n      var scale = _glvis_('gl-mat4/scale');\n\n      var normalize = _glvis_('gl-vec3/normalize');\n\n      var DEFAULT_CENTER = [0, 0, 0];\n      module.exports = createMatrixCameraController;\n\n      function MatrixCameraController(initialMatrix) {\n        this._components = initialMatrix.slice();\n        this._time = [0];\n        this.prevMatrix = initialMatrix.slice();\n        this.nextMatrix = initialMatrix.slice();\n        this.computedMatrix = initialMatrix.slice();\n        this.computedInverse = initialMatrix.slice();\n        this.computedEye = [0, 0, 0];\n        this.computedUp = [0, 0, 0];\n        this.computedCenter = [0, 0, 0];\n        this.computedRadius = [0];\n        this._limits = [-Infinity, Infinity];\n      }\n\n      var proto = MatrixCameraController.prototype;\n\n      proto.recalcMatrix = function (t) {\n        var time = this._time;\n        var tidx = bsearch.le(time, t);\n        var mat = this.computedMatrix;\n\n        if (tidx < 0) {\n          return;\n        }\n\n        var comps = this._components;\n\n        if (tidx === time.length - 1) {\n          var ptr = 16 * tidx;\n\n          for (var i = 0; i < 16; ++i) {\n            mat[i] = comps[ptr++];\n          }\n        } else {\n          var dt = time[tidx + 1] - time[tidx];\n          var ptr = 16 * tidx;\n          var prev = this.prevMatrix;\n          var allEqual = true;\n\n          for (var i = 0; i < 16; ++i) {\n            prev[i] = comps[ptr++];\n          }\n\n          var next = this.nextMatrix;\n\n          for (var i = 0; i < 16; ++i) {\n            next[i] = comps[ptr++];\n            allEqual = allEqual && prev[i] === next[i];\n          }\n\n          if (dt < 1e-6 || allEqual) {\n            for (var i = 0; i < 16; ++i) {\n              mat[i] = prev[i];\n            }\n          } else {\n            m4interp(mat, prev, next, (t - time[tidx]) / dt);\n          }\n        }\n\n        var up = this.computedUp;\n        up[0] = mat[1];\n        up[1] = mat[5];\n        up[2] = mat[9];\n        normalize(up, up);\n        var imat = this.computedInverse;\n        invert44(imat, mat);\n        var eye = this.computedEye;\n        var w = imat[15];\n        eye[0] = imat[12] / w;\n        eye[1] = imat[13] / w;\n        eye[2] = imat[14] / w;\n        var center = this.computedCenter;\n        var radius = Math.exp(this.computedRadius[0]);\n\n        for (var i = 0; i < 3; ++i) {\n          center[i] = eye[i] - mat[2 + 4 * i] * radius;\n        }\n      };\n\n      proto.idle = function (t) {\n        if (t < this.lastT()) {\n          return;\n        }\n\n        var mc = this._components;\n        var ptr = mc.length - 16;\n\n        for (var i = 0; i < 16; ++i) {\n          mc.push(mc[ptr++]);\n        }\n\n        this._time.push(t);\n      };\n\n      proto.flush = function (t) {\n        var idx = bsearch.gt(this._time, t) - 2;\n\n        if (idx < 0) {\n          return;\n        }\n\n        this._time.splice(0, idx);\n\n        this._components.splice(0, 16 * idx);\n      };\n\n      proto.lastT = function () {\n        return this._time[this._time.length - 1];\n      };\n\n      proto.lookAt = function (t, eye, center, up) {\n        this.recalcMatrix(t);\n        eye = eye || this.computedEye;\n        center = center || DEFAULT_CENTER;\n        up = up || this.computedUp;\n        this.setMatrix(t, lookAt(this.computedMatrix, eye, center, up));\n        var d2 = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          d2 += Math.pow(center[i] - eye[i], 2);\n        }\n\n        d2 = Math.log(Math.sqrt(d2));\n        this.computedRadius[0] = d2;\n      };\n\n      proto.rotate = function (t, yaw, pitch, roll) {\n        this.recalcMatrix(t);\n        var mat = this.computedInverse;\n        if (yaw) rotateY(mat, mat, yaw);\n        if (pitch) rotateX(mat, mat, pitch);\n        if (roll) rotateZ(mat, mat, roll);\n        this.setMatrix(t, invert44(this.computedMatrix, mat));\n      };\n\n      var tvec = [0, 0, 0];\n\n      proto.pan = function (t, dx, dy, dz) {\n        tvec[0] = -(dx || 0.0);\n        tvec[1] = -(dy || 0.0);\n        tvec[2] = -(dz || 0.0);\n        this.recalcMatrix(t);\n        var mat = this.computedInverse;\n        translate(mat, mat, tvec);\n        this.setMatrix(t, invert44(mat, mat));\n      };\n\n      proto.translate = function (t, dx, dy, dz) {\n        tvec[0] = dx || 0.0;\n        tvec[1] = dy || 0.0;\n        tvec[2] = dz || 0.0;\n        this.recalcMatrix(t);\n        var mat = this.computedMatrix;\n        translate(mat, mat, tvec);\n        this.setMatrix(t, mat);\n      };\n\n      proto.setMatrix = function (t, mat) {\n        if (t < this.lastT()) {\n          return;\n        }\n\n        this._time.push(t);\n\n        for (var i = 0; i < 16; ++i) {\n          this._components.push(mat[i]);\n        }\n      };\n\n      proto.setDistance = function (t, d) {\n        this.computedRadius[0] = d;\n      };\n\n      proto.setDistanceLimits = function (a, b) {\n        var lim = this._limits;\n        lim[0] = a;\n        lim[1] = b;\n      };\n\n      proto.getDistanceLimits = function (out) {\n        var lim = this._limits;\n\n        if (out) {\n          out[0] = lim[0];\n          out[1] = lim[1];\n          return out;\n        }\n\n        return lim;\n      };\n\n      function createMatrixCameraController(options) {\n        options = options || {};\n        var matrix = options.matrix || [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        return new MatrixCameraController(matrix);\n      }\n    }, {\n      \"binary-search-bounds\": 31,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/lookAt\": 99,\n      \"gl-mat4/rotateX\": 104,\n      \"gl-mat4/rotateY\": 105,\n      \"gl-mat4/rotateZ\": 106,\n      \"gl-mat4/scale\": 107,\n      \"gl-mat4/translate\": 108,\n      \"gl-vec3/normalize\": 179,\n      \"mat4-interpolate\": 243\n    }],\n    246: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = monotoneConvexHull2D;\n\n      var orient = _glvis_('robust-orientation')[3];\n\n      function monotoneConvexHull2D(points) {\n        var n = points.length;\n\n        if (n < 3) {\n          var result = new Array(n);\n\n          for (var i = 0; i < n; ++i) {\n            result[i] = i;\n          }\n\n          if (n === 2 && points[0][0] === points[1][0] && points[0][1] === points[1][1]) {\n            return [0];\n          }\n\n          return result;\n        } //Sort point indices along x-axis\n\n\n        var sorted = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          sorted[i] = i;\n        }\n\n        sorted.sort(function (a, b) {\n          var d = points[a][0] - points[b][0];\n\n          if (d) {\n            return d;\n          }\n\n          return points[a][1] - points[b][1];\n        }); //Construct upper and lower hulls\n\n        var lower = [sorted[0], sorted[1]];\n        var upper = [sorted[0], sorted[1]];\n\n        for (var i = 2; i < n; ++i) {\n          var idx = sorted[i];\n          var p = points[idx]; //Insert into lower list\n\n          var m = lower.length;\n\n          while (m > 1 && orient(points[lower[m - 2]], points[lower[m - 1]], p) <= 0) {\n            m -= 1;\n            lower.pop();\n          }\n\n          lower.push(idx); //Insert into upper list\n\n          m = upper.length;\n\n          while (m > 1 && orient(points[upper[m - 2]], points[upper[m - 1]], p) >= 0) {\n            m -= 1;\n            upper.pop();\n          }\n\n          upper.push(idx);\n        } //Merge lists together\n\n\n        var result = new Array(upper.length + lower.length - 2);\n        var ptr = 0;\n\n        for (var i = 0, nl = lower.length; i < nl; ++i) {\n          result[ptr++] = lower[i];\n        }\n\n        for (var j = upper.length - 2; j > 0; --j) {\n          result[ptr++] = upper[j];\n        } //Return result\n\n\n        return result;\n      }\n    }, {\n      \"robust-orientation\": 284\n    }],\n    247: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = mouseListen;\n\n      var mouse = _glvis_('mouse-event');\n\n      function mouseListen(element, callback) {\n        if (!callback) {\n          callback = element;\n          element = window;\n        }\n\n        var buttonState = 0;\n        var x = 0;\n        var y = 0;\n        var mods = {\n          shift: false,\n          alt: false,\n          control: false,\n          meta: false\n        };\n        var attached = false;\n\n        function updateMods(ev) {\n          var changed = false;\n\n          if ('altKey' in ev) {\n            changed = changed || ev.altKey !== mods.alt;\n            mods.alt = !!ev.altKey;\n          }\n\n          if ('shiftKey' in ev) {\n            changed = changed || ev.shiftKey !== mods.shift;\n            mods.shift = !!ev.shiftKey;\n          }\n\n          if ('ctrlKey' in ev) {\n            changed = changed || ev.ctrlKey !== mods.control;\n            mods.control = !!ev.ctrlKey;\n          }\n\n          if ('metaKey' in ev) {\n            changed = changed || ev.metaKey !== mods.meta;\n            mods.meta = !!ev.metaKey;\n          }\n\n          return changed;\n        }\n\n        function handleEvent(nextButtons, ev) {\n          var nextX = mouse.x(ev);\n          var nextY = mouse.y(ev);\n\n          if ('buttons' in ev) {\n            nextButtons = ev.buttons | 0;\n          }\n\n          if (nextButtons !== buttonState || nextX !== x || nextY !== y || updateMods(ev)) {\n            buttonState = nextButtons | 0;\n            x = nextX || 0;\n            y = nextY || 0;\n            callback && callback(buttonState, x, y, mods);\n          }\n        }\n\n        function clearState(ev) {\n          handleEvent(0, ev);\n        }\n\n        function handleBlur() {\n          if (buttonState || x || y || mods.shift || mods.alt || mods.meta || mods.control) {\n            x = y = 0;\n            buttonState = 0;\n            mods.shift = mods.alt = mods.control = mods.meta = false;\n            callback && callback(0, 0, 0, mods);\n          }\n        }\n\n        function handleMods(ev) {\n          if (updateMods(ev)) {\n            callback && callback(buttonState, x, y, mods);\n          }\n        }\n\n        function handleMouseMove(ev) {\n          if (mouse.buttons(ev) === 0) {\n            handleEvent(0, ev);\n          } else {\n            handleEvent(buttonState, ev);\n          }\n        }\n\n        function handleMouseDown(ev) {\n          handleEvent(buttonState | mouse.buttons(ev), ev);\n        }\n\n        function handleMouseUp(ev) {\n          handleEvent(buttonState & ~mouse.buttons(ev), ev);\n        }\n\n        function attachListeners() {\n          if (attached) {\n            return;\n          }\n\n          attached = true;\n          element.addEventListener('mousemove', handleMouseMove);\n          element.addEventListener('mousedown', handleMouseDown);\n          element.addEventListener('mouseup', handleMouseUp);\n          element.addEventListener('mouseleave', clearState);\n          element.addEventListener('mouseenter', clearState);\n          element.addEventListener('mouseout', clearState);\n          element.addEventListener('mouseover', clearState);\n          element.addEventListener('blur', handleBlur);\n          element.addEventListener('keyup', handleMods);\n          element.addEventListener('keydown', handleMods);\n          element.addEventListener('keypress', handleMods);\n\n          if (element !== window) {\n            window.addEventListener('blur', handleBlur);\n            window.addEventListener('keyup', handleMods);\n            window.addEventListener('keydown', handleMods);\n            window.addEventListener('keypress', handleMods);\n          }\n        }\n\n        function detachListeners() {\n          if (!attached) {\n            return;\n          }\n\n          attached = false;\n          element.removeEventListener('mousemove', handleMouseMove);\n          element.removeEventListener('mousedown', handleMouseDown);\n          element.removeEventListener('mouseup', handleMouseUp);\n          element.removeEventListener('mouseleave', clearState);\n          element.removeEventListener('mouseenter', clearState);\n          element.removeEventListener('mouseout', clearState);\n          element.removeEventListener('mouseover', clearState);\n          element.removeEventListener('blur', handleBlur);\n          element.removeEventListener('keyup', handleMods);\n          element.removeEventListener('keydown', handleMods);\n          element.removeEventListener('keypress', handleMods);\n\n          if (element !== window) {\n            window.removeEventListener('blur', handleBlur);\n            window.removeEventListener('keyup', handleMods);\n            window.removeEventListener('keydown', handleMods);\n            window.removeEventListener('keypress', handleMods);\n          }\n        } // Attach listeners\n\n\n        attachListeners();\n        var result = {\n          element: element\n        };\n        Object.defineProperties(result, {\n          enabled: {\n            get: function get() {\n              return attached;\n            },\n            set: function set(f) {\n              if (f) {\n                attachListeners();\n              } else {\n                detachListeners();\n              }\n            },\n            enumerable: true\n          },\n          buttons: {\n            get: function get() {\n              return buttonState;\n            },\n            enumerable: true\n          },\n          x: {\n            get: function get() {\n              return x;\n            },\n            enumerable: true\n          },\n          y: {\n            get: function get() {\n              return y;\n            },\n            enumerable: true\n          },\n          mods: {\n            get: function get() {\n              return mods;\n            },\n            enumerable: true\n          }\n        });\n        return result;\n      }\n    }, {\n      \"mouse-event\": 249\n    }],\n    248: [function (_glvis_, module, exports) {\n      var rootPosition = {\n        left: 0,\n        top: 0\n      };\n      module.exports = mouseEventOffset;\n\n      function mouseEventOffset(ev, target, out) {\n        target = target || ev.currentTarget || ev.srcElement;\n\n        if (!Array.isArray(out)) {\n          out = [0, 0];\n        }\n\n        var cx = ev.clientX || 0;\n        var cy = ev.clientY || 0;\n        var rect = getBoundingClientOffset(target);\n        out[0] = cx - rect.left;\n        out[1] = cy - rect.top;\n        return out;\n      }\n\n      function getBoundingClientOffset(element) {\n        if (element === window || element === document || element === document.body) {\n          return rootPosition;\n        } else {\n          return element.getBoundingClientRect();\n        }\n      }\n    }, {}],\n    249: [function (_glvis_, module, exports) {\n      'use strict';\n\n      function mouseButtons(ev) {\n        if (typeof ev === 'object') {\n          if ('buttons' in ev) {\n            return ev.buttons;\n          } else if ('which' in ev) {\n            var b = ev.which;\n\n            if (b === 2) {\n              return 4;\n            } else if (b === 3) {\n              return 2;\n            } else if (b > 0) {\n              return 1 << b - 1;\n            }\n          } else if ('button' in ev) {\n            var b = ev.button;\n\n            if (b === 1) {\n              return 4;\n            } else if (b === 2) {\n              return 2;\n            } else if (b >= 0) {\n              return 1 << b;\n            }\n          }\n        }\n\n        return 0;\n      }\n\n      exports.buttons = mouseButtons;\n\n      function mouseElement(ev) {\n        return ev.target || ev.srcElement || window;\n      }\n\n      exports.element = mouseElement;\n\n      function mouseRelativeX(ev) {\n        if (typeof ev === 'object') {\n          if ('offsetX' in ev) {\n            return ev.offsetX;\n          }\n\n          var target = mouseElement(ev);\n          var bounds = target.getBoundingClientRect();\n          return ev.clientX - bounds.left;\n        }\n\n        return 0;\n      }\n\n      exports.x = mouseRelativeX;\n\n      function mouseRelativeY(ev) {\n        if (typeof ev === 'object') {\n          if ('offsetY' in ev) {\n            return ev.offsetY;\n          }\n\n          var target = mouseElement(ev);\n          var bounds = target.getBoundingClientRect();\n          return ev.clientY - bounds.top;\n        }\n\n        return 0;\n      }\n\n      exports.y = mouseRelativeY;\n    }, {}],\n    250: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var toPX = _glvis_('to-px');\n\n      module.exports = mouseWheelListen;\n\n      function mouseWheelListen(element, callback, noScroll) {\n        if (typeof element === 'function') {\n          noScroll = !!callback;\n          callback = element;\n          element = window;\n        }\n\n        var lineHeight = toPX('ex', element);\n\n        var listener = function listener(ev) {\n          if (noScroll) {\n            ev.preventDefault();\n          }\n\n          var dx = ev.deltaX || 0;\n          var dy = ev.deltaY || 0;\n          var dz = ev.deltaZ || 0;\n          var mode = ev.deltaMode;\n          var scale = 1;\n\n          switch (mode) {\n            case 1:\n              scale = lineHeight;\n              break;\n\n            case 2:\n              scale = window.innerHeight;\n              break;\n          }\n\n          dx *= scale;\n          dy *= scale;\n          dz *= scale;\n\n          if (dx || dy || dz) {\n            return callback(dx, dy, dz, ev);\n          }\n        };\n\n        element.addEventListener('wheel', listener);\n        return listener;\n      }\n    }, {\n      \"to-px\": 304\n    }],\n    251: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var pool = _glvis_(\"typedarray-pool\");\n\n      module.exports = createSurfaceExtractor;\n      var allFns = {\n        \"false,0,1\": function surfaceProcedure(vertex, face, phase, mallocUint32, freeUint32) {\n          return function extractContour0_1(a0, x0, x1, x2) {\n            var s0 = a0.shape[0] | 0,\n                s1 = a0.shape[1] | 0,\n                d0 = a0.data,\n                o0 = a0.offset | 0,\n                t0_0 = a0.stride[0] | 0,\n                t0_1 = a0.stride[1] | 0,\n                p0 = o0,\n                c0_0,\n                d0_1 = -t0_0 | 0,\n                c0_1 = 0,\n                d0_2 = -t0_1 | 0,\n                c0_2 = 0,\n                d0_3 = -t0_0 - t0_1 | 0,\n                c0_3 = 0,\n                u0_0 = t0_0 | 0,\n                u0_1 = t0_1 - t0_0 * s0 | 0,\n                i0 = 0,\n                i1 = 0,\n                N = 0,\n                Q = 2 * s0 | 0,\n                P = mallocUint32(Q),\n                V = mallocUint32(Q),\n                X = 0,\n                b0 = 0,\n                e1 = -1 | 0,\n                y1 = -1 | 0,\n                b1 = 0,\n                e2 = -s0 | 0,\n                y2 = s0 | 0,\n                b2 = 0,\n                e3 = -s0 - 1 | 0,\n                y3 = s0 - 1 | 0,\n                b3 = 0,\n                v0 = 0,\n                T = 0;\n\n            for (i0 = 0; i0 < s0; ++i0) {\n              P[X++] = phase(d0[p0], x0, x1, x2);\n              p0 += u0_0;\n            }\n\n            p0 += u0_1;\n\n            if (s1 > 0) {\n              i1 = 1;\n              P[X++] = phase(d0[p0], x0, x1, x2);\n              p0 += u0_0;\n\n              if (s0 > 0) {\n                i0 = 1;\n                c0_0 = d0[p0];\n                b0 = P[X] = phase(c0_0, x0, x1, x2);\n                b1 = P[X + e1];\n                b2 = P[X + e2];\n                b3 = P[X + e3];\n\n                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                  c0_1 = d0[p0 + d0_1];\n                  c0_2 = d0[p0 + d0_2];\n                  c0_3 = d0[p0 + d0_3];\n                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                  v0 = V[X] = N++;\n                }\n\n                X += 1;\n                p0 += u0_0;\n\n                for (i0 = 2; i0 < s0; ++i0) {\n                  c0_0 = d0[p0];\n                  b0 = P[X] = phase(c0_0, x0, x1, x2);\n                  b1 = P[X + e1];\n                  b2 = P[X + e2];\n                  b3 = P[X + e3];\n\n                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                    c0_1 = d0[p0 + d0_1];\n                    c0_2 = d0[p0 + d0_2];\n                    c0_3 = d0[p0 + d0_3];\n                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                    v0 = V[X] = N++;\n\n                    if (b3 !== b1) {\n                      face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);\n                    }\n                  }\n\n                  X += 1;\n                  p0 += u0_0;\n                }\n              }\n\n              p0 += u0_1;\n              X = 0;\n              T = e1;\n              e1 = y1;\n              y1 = T;\n              T = e2;\n              e2 = y2;\n              y2 = T;\n              T = e3;\n              e3 = y3;\n              y3 = T;\n\n              for (i1 = 2; i1 < s1; ++i1) {\n                P[X++] = phase(d0[p0], x0, x1, x2);\n                p0 += u0_0;\n\n                if (s0 > 0) {\n                  i0 = 1;\n                  c0_0 = d0[p0];\n                  b0 = P[X] = phase(c0_0, x0, x1, x2);\n                  b1 = P[X + e1];\n                  b2 = P[X + e2];\n                  b3 = P[X + e3];\n\n                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                    c0_1 = d0[p0 + d0_1];\n                    c0_2 = d0[p0 + d0_2];\n                    c0_3 = d0[p0 + d0_3];\n                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                    v0 = V[X] = N++;\n\n                    if (b3 !== b2) {\n                      face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);\n                    }\n                  }\n\n                  X += 1;\n                  p0 += u0_0;\n\n                  for (i0 = 2; i0 < s0; ++i0) {\n                    c0_0 = d0[p0];\n                    b0 = P[X] = phase(c0_0, x0, x1, x2);\n                    b1 = P[X + e1];\n                    b2 = P[X + e2];\n                    b3 = P[X + e3];\n\n                    if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                      c0_1 = d0[p0 + d0_1];\n                      c0_2 = d0[p0 + d0_2];\n                      c0_3 = d0[p0 + d0_3];\n                      vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                      v0 = V[X] = N++;\n\n                      if (b3 !== b2) {\n                        face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);\n                      }\n\n                      if (b3 !== b1) {\n                        face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);\n                      }\n                    }\n\n                    X += 1;\n                    p0 += u0_0;\n                  }\n                }\n\n                if (i1 & 1) {\n                  X = 0;\n                }\n\n                T = e1;\n                e1 = y1;\n                y1 = T;\n                T = e2;\n                e2 = y2;\n                y2 = T;\n                T = e3;\n                e3 = y3;\n                y3 = T;\n                p0 += u0_1;\n              }\n            }\n\n            freeUint32(V);\n            freeUint32(P);\n          };\n        },\n        \"false,1,0\": function anonymous(vertex, face, phase, mallocUint32, freeUint32) {\n          return function extractContour1_0(a0, x0, x1, x2) {\n            var s0 = a0.shape[0] | 0,\n                s1 = a0.shape[1] | 0,\n                d0 = a0.data,\n                o0 = a0.offset | 0,\n                t0_0 = a0.stride[0] | 0,\n                t0_1 = a0.stride[1] | 0,\n                p0 = o0,\n                c0_0,\n                d0_1 = -t0_0 | 0,\n                c0_1 = 0,\n                d0_2 = -t0_1 | 0,\n                c0_2 = 0,\n                d0_3 = -t0_0 - t0_1 | 0,\n                c0_3 = 0,\n                u0_1 = t0_1 | 0,\n                u0_0 = t0_0 - t0_1 * s1 | 0,\n                i0 = 0,\n                i1 = 0,\n                N = 0,\n                Q = 2 * s1 | 0,\n                P = mallocUint32(Q),\n                V = mallocUint32(Q),\n                X = 0,\n                b0 = 0,\n                e2 = -1 | 0,\n                y2 = -1 | 0,\n                b2 = 0,\n                e1 = -s1 | 0,\n                y1 = s1 | 0,\n                b1 = 0,\n                e3 = -s1 - 1 | 0,\n                y3 = s1 - 1 | 0,\n                b3 = 0,\n                v0 = 0,\n                T = 0;\n\n            for (i1 = 0; i1 < s1; ++i1) {\n              P[X++] = phase(d0[p0], x0, x1, x2);\n              p0 += u0_1;\n            }\n\n            p0 += u0_0;\n\n            if (s0 > 0) {\n              i0 = 1;\n              P[X++] = phase(d0[p0], x0, x1, x2);\n              p0 += u0_1;\n\n              if (s1 > 0) {\n                i1 = 1;\n                c0_0 = d0[p0];\n                b0 = P[X] = phase(c0_0, x0, x1, x2);\n                b1 = P[X + e1];\n                b2 = P[X + e2];\n                b3 = P[X + e3];\n\n                if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                  c0_1 = d0[p0 + d0_1];\n                  c0_2 = d0[p0 + d0_2];\n                  c0_3 = d0[p0 + d0_3];\n                  vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                  v0 = V[X] = N++;\n                }\n\n                X += 1;\n                p0 += u0_1;\n\n                for (i1 = 2; i1 < s1; ++i1) {\n                  c0_0 = d0[p0];\n                  b0 = P[X] = phase(c0_0, x0, x1, x2);\n                  b1 = P[X + e1];\n                  b2 = P[X + e2];\n                  b3 = P[X + e3];\n\n                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                    c0_1 = d0[p0 + d0_1];\n                    c0_2 = d0[p0 + d0_2];\n                    c0_3 = d0[p0 + d0_3];\n                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                    v0 = V[X] = N++;\n\n                    if (b3 !== b2) {\n                      face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);\n                    }\n                  }\n\n                  X += 1;\n                  p0 += u0_1;\n                }\n              }\n\n              p0 += u0_0;\n              X = 0;\n              T = e1;\n              e1 = y1;\n              y1 = T;\n              T = e2;\n              e2 = y2;\n              y2 = T;\n              T = e3;\n              e3 = y3;\n              y3 = T;\n\n              for (i0 = 2; i0 < s0; ++i0) {\n                P[X++] = phase(d0[p0], x0, x1, x2);\n                p0 += u0_1;\n\n                if (s1 > 0) {\n                  i1 = 1;\n                  c0_0 = d0[p0];\n                  b0 = P[X] = phase(c0_0, x0, x1, x2);\n                  b1 = P[X + e1];\n                  b2 = P[X + e2];\n                  b3 = P[X + e3];\n\n                  if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                    c0_1 = d0[p0 + d0_1];\n                    c0_2 = d0[p0 + d0_2];\n                    c0_3 = d0[p0 + d0_3];\n                    vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                    v0 = V[X] = N++;\n\n                    if (b3 !== b1) {\n                      face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);\n                    }\n                  }\n\n                  X += 1;\n                  p0 += u0_1;\n\n                  for (i1 = 2; i1 < s1; ++i1) {\n                    c0_0 = d0[p0];\n                    b0 = P[X] = phase(c0_0, x0, x1, x2);\n                    b1 = P[X + e1];\n                    b2 = P[X + e2];\n                    b3 = P[X + e3];\n\n                    if (b0 !== b1 || b0 !== b2 || b0 !== b3) {\n                      c0_1 = d0[p0 + d0_1];\n                      c0_2 = d0[p0 + d0_2];\n                      c0_3 = d0[p0 + d0_3];\n                      vertex(i0, i1, c0_0, c0_1, c0_2, c0_3, b0, b1, b2, b3, x0, x1, x2);\n                      v0 = V[X] = N++;\n\n                      if (b3 !== b2) {\n                        face(V[X + e2], v0, c0_2, c0_3, b2, b3, x0, x1, x2);\n                      }\n\n                      if (b3 !== b1) {\n                        face(V[X + e1], v0, c0_3, c0_1, b3, b1, x0, x1, x2);\n                      }\n                    }\n\n                    X += 1;\n                    p0 += u0_1;\n                  }\n                }\n\n                if (i0 & 1) {\n                  X = 0;\n                }\n\n                T = e1;\n                e1 = y1;\n                y1 = T;\n                T = e2;\n                e2 = y2;\n                y2 = T;\n                T = e3;\n                e3 = y3;\n                y3 = T;\n                p0 += u0_0;\n              }\n            }\n\n            freeUint32(V);\n            freeUint32(P);\n          };\n        } //Generates the surface procedure\n\n      };\n\n      function compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n        var key = [typesig, order].join(',');\n        var proc = allFns[key];\n        return proc(vertexFunc, faceFunc, phaseFunc, pool.mallocUint32, pool.freeUint32);\n      }\n\n      function createSurfaceExtractor(args) {\n        function error(msg) {\n          throw new Error(\"ndarray-extract-contour: \" + msg);\n        }\n\n        if (typeof args !== \"object\") {\n          error(\"Must specify arguments\");\n        }\n\n        var order = args.order;\n\n        if (!Array.isArray(order)) {\n          error(\"Must specify order\");\n        }\n\n        var arrays = args.arrayArguments || 1;\n\n        if (arrays < 1) {\n          error(\"Must have at least one array argument\");\n        }\n\n        var scalars = args.scalarArguments || 0;\n\n        if (scalars < 0) {\n          error(\"Scalar arg count must be > 0\");\n        }\n\n        if (typeof args.vertex !== \"function\") {\n          error(\"Must specify vertex creation function\");\n        }\n\n        if (typeof args.cell !== \"function\") {\n          error(\"Must specify cell creation function\");\n        }\n\n        if (typeof args.phase !== \"function\") {\n          error(\"Must specify phase function\");\n        }\n\n        var getters = args.getters || [];\n        var typesig = new Array(arrays);\n\n        for (var i = 0; i < arrays; ++i) {\n          if (getters.indexOf(i) >= 0) {\n            typesig[i] = true;\n          } else {\n            typesig[i] = false;\n          }\n        }\n\n        return compileSurfaceProcedure(args.vertex, args.cell, args.phase, scalars, order, typesig);\n      }\n    }, {\n      \"typedarray-pool\": 308\n    }],\n    252: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var dup = _glvis_('dup');\n\n      var CACHED_CWiseOp = {\n        zero: function zero(SS, a0, t0, p0) {\n          var s0 = SS[0],\n              t0p0 = t0[0];\n          p0 |= 0;\n          var i0 = 0,\n              d0s0 = t0p0;\n\n          for (i0 = 0; i0 < s0; ++i0) {\n            a0[p0] = 0;\n            p0 += d0s0;\n          }\n        },\n        fdTemplate1: function fdTemplate1(SS, a0, t0, p0, a1, t1, p1) {\n          var s0 = SS[0],\n              t0p0 = t0[0],\n              t1p0 = t1[0],\n              q0 = -1 * t0p0,\n              q1 = t0p0;\n          p0 |= 0;\n          p1 |= 0;\n          var i0 = 0,\n              d0s0 = t0p0,\n              d1s0 = t1p0;\n\n          for (i0 = 0; i0 < s0; ++i0) {\n            a1[p1] = 0.5 * (a0[p0 + q0] - a0[p0 + q1]);\n            p0 += d0s0;\n            p1 += d1s0;\n          }\n        },\n        fdTemplate2: function fdTemplate2(SS, a0, t0, p0, a1, t1, p1, a2, t2, p2) {\n          var s0 = SS[0],\n              s1 = SS[1],\n              t0p0 = t0[0],\n              t0p1 = t0[1],\n              t1p0 = t1[0],\n              t1p1 = t1[1],\n              t2p0 = t2[0],\n              t2p1 = t2[1],\n              q0 = -1 * t0p0,\n              q1 = t0p0,\n              q2 = -1 * t0p1,\n              q3 = t0p1;\n          p0 |= 0;\n          p1 |= 0;\n          p2 |= 0;\n          var i0 = 0,\n              i1 = 0,\n              d0s0 = t0p1,\n              d0s1 = t0p0 - s1 * t0p1,\n              d1s0 = t1p1,\n              d1s1 = t1p0 - s1 * t1p1,\n              d2s0 = t2p1,\n              d2s1 = t2p0 - s1 * t2p1;\n\n          for (i1 = 0; i1 < s0; ++i1) {\n            for (i0 = 0; i0 < s1; ++i0) {\n              a1[p1] = 0.5 * (a0[p0 + q0] - a0[p0 + q1]);\n              a2[p2] = 0.5 * (a0[p0 + q2] - a0[p0 + q3]);\n              p0 += d0s0;\n              p1 += d1s0;\n              p2 += d2s0;\n            }\n\n            p0 += d0s1;\n            p1 += d1s1;\n            p2 += d2s1;\n          }\n        }\n      };\n      var CACHED_thunk = {\n        cdiff: function cdiff(compile) {\n          var CACHED = {};\n          return function cdiff_cwise_thunk(array0, array1, array2) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                t2 = array2.dtype,\n                r2 = array2.order,\n                type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1, t2, r2]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array2.data, array2.stride, array2.offset | 0);\n          };\n        },\n        zero: function zero(compile) {\n          var CACHED = {};\n          return function zero_cwise_thunk(array0) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                type = [t0, r0.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0);\n          };\n        },\n        fdTemplate1: function fdTemplate1(compile) {\n          var CACHED = {};\n          return function fdTemplate1_cwise_thunk(array0, array1) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                type = [t0, r0.join(), t1, r1.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0);\n          };\n        },\n        fdTemplate2: function fdTemplate2(compile) {\n          var CACHED = {};\n          return function fdTemplate2_cwise_thunk(array0, array1, array4) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                t4 = array4.dtype,\n                r4 = array4.order,\n                type = [t0, r0.join(), t1, r1.join(), t4, r4.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1, t4, r4]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array4.data, array4.stride, array4.offset | 0);\n          };\n        }\n      };\n\n      function createThunk(proc) {\n        var thunk = CACHED_thunk[proc.funcName];\n        return thunk(compile.bind(undefined, proc));\n      }\n\n      function compile(proc) {\n        return CACHED_CWiseOp[proc.funcName];\n      }\n\n      function cwiseCompiler(user_args) {\n        return createThunk({\n          funcName: user_args.funcName\n        });\n      }\n\n      var TEMPLATE_CACHE = {};\n      var GRADIENT_CACHE = {};\n      var EmptyProc = {\n        body: \"\",\n        args: [],\n        thisVars: [],\n        localVars: []\n      };\n      var centralDiff = cwiseCompiler({\n        funcName: 'cdiff'\n      });\n      var zeroOut = cwiseCompiler({\n        funcName: 'zero'\n      });\n\n      function generateTemplate(d) {\n        if (d in TEMPLATE_CACHE) {\n          return TEMPLATE_CACHE[d];\n        }\n\n        return TEMPLATE_CACHE[d] = cwiseCompiler({\n          funcName: 'fdTemplate' + d\n        });\n      }\n\n      function CACHED_link(diff, zero, grad1, grad2) {\n        return function (dst, src) {\n          var s = src.shape.slice();\n\n          if (1 && s[0] > 2 && s[1] > 2) {\n            grad2(src.pick(-1, -1).lo(1, 1).hi(s[0] - 2, s[1] - 2), dst.pick(-1, -1, 0).lo(1, 1).hi(s[0] - 2, s[1] - 2), dst.pick(-1, -1, 1).lo(1, 1).hi(s[0] - 2, s[1] - 2));\n          }\n\n          if (1 && s[1] > 2) {\n            grad1(src.pick(0, -1).lo(1).hi(s[1] - 2), dst.pick(0, -1, 1).lo(1).hi(s[1] - 2));\n            zero(dst.pick(0, -1, 0).lo(1).hi(s[1] - 2));\n          }\n\n          if (1 && s[1] > 2) {\n            grad1(src.pick(s[0] - 1, -1).lo(1).hi(s[1] - 2), dst.pick(s[0] - 1, -1, 1).lo(1).hi(s[1] - 2));\n            zero(dst.pick(s[0] - 1, -1, 0).lo(1).hi(s[1] - 2));\n          }\n\n          if (1 && s[0] > 2) {\n            grad1(src.pick(-1, 0).lo(1).hi(s[0] - 2), dst.pick(-1, 0, 0).lo(1).hi(s[0] - 2));\n            zero(dst.pick(-1, 0, 1).lo(1).hi(s[0] - 2));\n          }\n\n          if (1 && s[0] > 2) {\n            grad1(src.pick(-1, s[1] - 1).lo(1).hi(s[0] - 2), dst.pick(-1, s[1] - 1, 0).lo(1).hi(s[0] - 2));\n            zero(dst.pick(-1, s[1] - 1, 1).lo(1).hi(s[0] - 2));\n          }\n\n          dst.set(0, 0, 0, 0);\n          dst.set(0, 0, 1, 0);\n          dst.set(s[0] - 1, 0, 0, 0);\n          dst.set(s[0] - 1, 0, 1, 0);\n          dst.set(0, s[1] - 1, 0, 0);\n          dst.set(0, s[1] - 1, 1, 0);\n          dst.set(s[0] - 1, s[1] - 1, 0, 0);\n          dst.set(s[0] - 1, s[1] - 1, 1, 0);\n          return dst;\n        };\n      }\n\n      function generateGradient(boundaryConditions) {\n        var token = boundaryConditions.join();\n        var proc = GRADIENT_CACHE[token];\n\n        if (proc) {\n          return proc;\n        }\n\n        var d = boundaryConditions.length;\n        var linkArgs = [centralDiff, zeroOut];\n\n        for (var i = 1; i <= d; ++i) {\n          linkArgs.push(generateTemplate(i));\n        }\n\n        var link = CACHED_link;\n        var proc = link.apply(void 0, linkArgs);\n        GRADIENT_CACHE[token] = proc;\n        return proc;\n      }\n\n      module.exports = function gradient(out, inp, bc) {\n        if (!Array.isArray(bc)) {\n          if (typeof bc === 'string') {\n            bc = dup(inp.dimension, bc);\n          } else {\n            bc = dup(inp.dimension, 'clamp');\n          }\n        }\n\n        if (inp.size === 0) {\n          return out;\n        }\n\n        if (inp.dimension === 0) {\n          out.set(0);\n          return out;\n        }\n\n        var cached = generateGradient(bc);\n        return cached(out, inp);\n      };\n    }, {\n      \"dup\": 65\n    }],\n    253: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function interp1d(arr, x) {\n        var ix = Math.floor(x),\n            fx = x - ix,\n            s0 = 0 <= ix && ix < arr.shape[0],\n            s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],\n            w0 = s0 ? +arr.get(ix) : 0.0,\n            w1 = s1 ? +arr.get(ix + 1) : 0.0;\n        return (1.0 - fx) * w0 + fx * w1;\n      }\n\n      function interp2d(arr, x, y) {\n        var ix = Math.floor(x),\n            fx = x - ix,\n            s0 = 0 <= ix && ix < arr.shape[0],\n            s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],\n            iy = Math.floor(y),\n            fy = y - iy,\n            t0 = 0 <= iy && iy < arr.shape[1],\n            t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],\n            w00 = s0 && t0 ? arr.get(ix, iy) : 0.0,\n            w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0.0,\n            w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0.0,\n            w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0.0;\n        return (1.0 - fy) * ((1.0 - fx) * w00 + fx * w10) + fy * ((1.0 - fx) * w01 + fx * w11);\n      }\n\n      function interp3d(arr, x, y, z) {\n        var ix = Math.floor(x),\n            fx = x - ix,\n            s0 = 0 <= ix && ix < arr.shape[0],\n            s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],\n            iy = Math.floor(y),\n            fy = y - iy,\n            t0 = 0 <= iy && iy < arr.shape[1],\n            t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],\n            iz = Math.floor(z),\n            fz = z - iz,\n            u0 = 0 <= iz && iz < arr.shape[2],\n            u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2],\n            w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0.0,\n            w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0.0,\n            w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0.0,\n            w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0.0,\n            w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0.0,\n            w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0.0,\n            w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0.0,\n            w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0.0;\n        return (1.0 - fz) * ((1.0 - fy) * ((1.0 - fx) * w000 + fx * w100) + fy * ((1.0 - fx) * w010 + fx * w110)) + fz * ((1.0 - fy) * ((1.0 - fx) * w001 + fx * w101) + fy * ((1.0 - fx) * w011 + fx * w111));\n      }\n\n      function interpNd(arr) {\n        var d = arr.shape.length | 0,\n            ix = new Array(d),\n            fx = new Array(d),\n            s0 = new Array(d),\n            s1 = new Array(d),\n            i,\n            t;\n\n        for (i = 0; i < d; ++i) {\n          t = +arguments[i + 1];\n          ix[i] = Math.floor(t);\n          fx[i] = t - ix[i];\n          s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];\n          s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];\n        }\n\n        var r = 0.0,\n            j,\n            w,\n            idx;\n\n        i_loop: for (i = 0; i < 1 << d; ++i) {\n          w = 1.0;\n          idx = arr.offset;\n\n          for (j = 0; j < d; ++j) {\n            if (i & 1 << j) {\n              if (!s1[j]) {\n                continue i_loop;\n              }\n\n              w *= fx[j];\n              idx += arr.stride[j] * (ix[j] + 1);\n            } else {\n              if (!s0[j]) {\n                continue i_loop;\n              }\n\n              w *= 1.0 - fx[j];\n              idx += arr.stride[j] * ix[j];\n            }\n          }\n\n          r += w * arr.data[idx];\n        }\n\n        return r;\n      }\n\n      function interpolate(arr, x, y, z) {\n        switch (arr.shape.length) {\n          case 0:\n            return 0.0;\n\n          case 1:\n            return interp1d(arr, x);\n\n          case 2:\n            return interp2d(arr, x, y);\n\n          case 3:\n            return interp3d(arr, x, y, z);\n\n          default:\n            return interpNd.apply(undefined, arguments);\n        }\n      }\n\n      module.exports = interpolate;\n      module.exports.d1 = interp1d;\n      module.exports.d2 = interp2d;\n      module.exports.d3 = interp3d;\n    }, {}],\n    254: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var CACHED_CWiseOp = {\n        'float64,2,1,0': function float64210() {\n          return function divseq_cwise_loop_2s1s0m3f64(SS, a0, t0, p0, Y0) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                s2 = SS[2],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t0p2 = t0[2];\n            p0 |= 0;\n            var i0 = 0,\n                i1 = 0,\n                i2 = 0,\n                d0s0 = t0p2,\n                d0s1 = t0p1 - s2 * t0p2,\n                d0s2 = t0p0 - s1 * t0p1;\n\n            for (i2 = 0; i2 < s0; ++i2) {\n              for (i1 = 0; i1 < s1; ++i1) {\n                for (i0 = 0; i0 < s2; ++i0) {\n                  a0[p0] /= Y0;\n                  p0 += d0s0;\n                }\n\n                p0 += d0s1;\n              }\n\n              p0 += d0s2;\n            }\n          };\n        },\n        'uint8,2,0,1,float64,2,1,0': function uint8201Float64210() {\n          return function muls_cwise_loop_2s0s1m1u8f64(SS, a0, t0, p0, a1, t1, p1, Y0) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                s2 = SS[2],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t0p2 = t0[2],\n                t1p0 = t1[0],\n                t1p1 = t1[1],\n                t1p2 = t1[2];\n            p0 |= 0;\n            p1 |= 0;\n            var offset0 = p0;\n            var offset1 = p1;\n\n            for (var j1 = SS[0] | 0; j1 > 0;) {\n              if (j1 < 64) {\n                s0 = j1;\n                j1 = 0;\n              } else {\n                s0 = 64;\n                j1 -= 64;\n              }\n\n              for (var j2 = SS[1] | 0; j2 > 0;) {\n                if (j2 < 64) {\n                  s1 = j2;\n                  j2 = 0;\n                } else {\n                  s1 = 64;\n                  j2 -= 64;\n                }\n\n                p0 = offset0 + j1 * t0p0 + j2 * t0p1;\n                p1 = offset1 + j1 * t1p0 + j2 * t1p1;\n                var i0 = 0,\n                    i1 = 0,\n                    i2 = 0,\n                    d0s0 = t0p2,\n                    d0s1 = t0p0 - s2 * t0p2,\n                    d0s2 = t0p1 - s0 * t0p0,\n                    d1s0 = t1p2,\n                    d1s1 = t1p0 - s2 * t1p2,\n                    d1s2 = t1p1 - s0 * t1p0;\n\n                for (i2 = 0; i2 < s1; ++i2) {\n                  for (i1 = 0; i1 < s0; ++i1) {\n                    for (i0 = 0; i0 < s2; ++i0) {\n                      a0[p0] = a1[p1] * Y0;\n                      p0 += d0s0;\n                      p1 += d1s0;\n                    }\n\n                    p0 += d0s1;\n                    p1 += d1s1;\n                  }\n\n                  p0 += d0s2;\n                  p1 += d1s2;\n                }\n              }\n            }\n          };\n        },\n        'float32,1,0,float32,1,0': function float3210Float3210() {\n          return function assign_cwise_loop_1s0m2f32(SS, a0, t0, p0, a1, t1, p1) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t1p0 = t1[0],\n                t1p1 = t1[1];\n            p0 |= 0;\n            p1 |= 0;\n            var i0 = 0,\n                i1 = 0,\n                d0s0 = t0p1,\n                d0s1 = t0p0 - s1 * t0p1,\n                d1s0 = t1p1,\n                d1s1 = t1p0 - s1 * t1p1;\n\n            for (i1 = 0; i1 < s0; ++i1) {\n              for (i0 = 0; i0 < s1; ++i0) {\n                a0[p0] = a1[p1];\n                p0 += d0s0;\n                p1 += d1s0;\n              }\n\n              p0 += d0s1;\n              p1 += d1s1;\n            }\n          };\n        },\n        'float32,1,0,float32,0,1': function float3210Float3201() {\n          return function assign_cwise_loop_1s0m0f32(SS, a0, t0, p0, a1, t1, p1) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t1p0 = t1[0],\n                t1p1 = t1[1];\n            p0 |= 0;\n            p1 |= 0;\n            var offset0 = p0;\n            var offset1 = p1;\n\n            for (var j0 = SS[1] | 0; j0 > 0;) {\n              if (j0 < 64) {\n                s1 = j0;\n                j0 = 0;\n              } else {\n                s1 = 64;\n                j0 -= 64;\n              }\n\n              for (var j1 = SS[0] | 0; j1 > 0;) {\n                if (j1 < 64) {\n                  s0 = j1;\n                  j1 = 0;\n                } else {\n                  s0 = 64;\n                  j1 -= 64;\n                }\n\n                p0 = offset0 + j0 * t0p1 + j1 * t0p0;\n                p1 = offset1 + j0 * t1p1 + j1 * t1p0;\n                var i0 = 0,\n                    i1 = 0,\n                    d0s0 = t0p1,\n                    d0s1 = t0p0 - s1 * t0p1,\n                    d1s0 = t1p1,\n                    d1s1 = t1p0 - s1 * t1p1;\n\n                for (i1 = 0; i1 < s0; ++i1) {\n                  for (i0 = 0; i0 < s1; ++i0) {\n                    a0[p0] = a1[p1];\n                    p0 += d0s0;\n                    p1 += d1s0;\n                  }\n\n                  p0 += d0s1;\n                  p1 += d1s1;\n                }\n              }\n            }\n          };\n        },\n        'uint8,2,0,1,uint8,1,2,0': function uint8201Uint8120() {\n          return function assign_cwise_loop_2s0s1m0u8(SS, a0, t0, p0, a1, t1, p1) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                s2 = SS[2],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t0p2 = t0[2],\n                t1p0 = t1[0],\n                t1p1 = t1[1],\n                t1p2 = t1[2];\n            p0 |= 0;\n            p1 |= 0;\n            var offset0 = p0;\n            var offset1 = p1;\n\n            for (var j0 = SS[2] | 0; j0 > 0;) {\n              if (j0 < 64) {\n                s2 = j0;\n                j0 = 0;\n              } else {\n                s2 = 64;\n                j0 -= 64;\n              }\n\n              for (var j1 = SS[0] | 0; j1 > 0;) {\n                if (j1 < 64) {\n                  s0 = j1;\n                  j1 = 0;\n                } else {\n                  s0 = 64;\n                  j1 -= 64;\n                }\n\n                for (var j2 = SS[1] | 0; j2 > 0;) {\n                  if (j2 < 64) {\n                    s1 = j2;\n                    j2 = 0;\n                  } else {\n                    s1 = 64;\n                    j2 -= 64;\n                  }\n\n                  p0 = offset0 + j0 * t0p2 + j1 * t0p0 + j2 * t0p1;\n                  p1 = offset1 + j0 * t1p2 + j1 * t1p0 + j2 * t1p1;\n                  var i0 = 0,\n                      i1 = 0,\n                      i2 = 0,\n                      d0s0 = t0p2,\n                      d0s1 = t0p0 - s2 * t0p2,\n                      d0s2 = t0p1 - s0 * t0p0,\n                      d1s0 = t1p2,\n                      d1s1 = t1p0 - s2 * t1p2,\n                      d1s2 = t1p1 - s0 * t1p0;\n\n                  for (i2 = 0; i2 < s1; ++i2) {\n                    for (i1 = 0; i1 < s0; ++i1) {\n                      for (i0 = 0; i0 < s2; ++i0) {\n                        a0[p0] = a1[p1];\n                        p0 += d0s0;\n                        p1 += d1s0;\n                      }\n\n                      p0 += d0s1;\n                      p1 += d1s1;\n                    }\n\n                    p0 += d0s2;\n                    p1 += d1s2;\n                  }\n                }\n              }\n            }\n          };\n        },\n        'uint8,2,0,1,array,2,0,1': function uint8201Array201() {\n          return function assign_cwise_loop_2s0s1m3u8a(SS, a0, t0, p0, a1, t1, p1) {\n            var s0 = SS[0],\n                s1 = SS[1],\n                s2 = SS[2],\n                t0p0 = t0[0],\n                t0p1 = t0[1],\n                t0p2 = t0[2],\n                t1p0 = t1[0],\n                t1p1 = t1[1],\n                t1p2 = t1[2];\n            p0 |= 0;\n            p1 |= 0;\n            var i0 = 0,\n                i1 = 0,\n                i2 = 0,\n                d0s0 = t0p2,\n                d0s1 = t0p0 - s2 * t0p2,\n                d0s2 = t0p1 - s0 * t0p0,\n                d1s0 = t1p2,\n                d1s1 = t1p0 - s2 * t1p2,\n                d1s2 = t1p1 - s0 * t1p0;\n\n            for (i2 = 0; i2 < s1; ++i2) {\n              for (i1 = 0; i1 < s0; ++i1) {\n                for (i0 = 0; i0 < s2; ++i0) {\n                  a0[p0] = a1[p1];\n                  p0 += d0s0;\n                  p1 += d1s0;\n                }\n\n                p0 += d0s1;\n                p1 += d1s1;\n              }\n\n              p0 += d0s2;\n              p1 += d1s2;\n            }\n          };\n        } //Generates a cwise operator\n\n      };\n\n      function generateCWiseOp(proc, typesig) {\n        var key = typesig.join(',');\n        var f = CACHED_CWiseOp[key];\n        return f();\n      }\n\n      var compile = generateCWiseOp;\n      var CACHED_thunk = {\n        mul: function mul(compile) {\n          var CACHED = {};\n          return function mul_cwise_thunk(array0, array1, array2) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                t2 = array2.dtype,\n                r2 = array2.order,\n                type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1, t2, r2]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array2.data, array2.stride, array2.offset | 0);\n          };\n        },\n        muls: function muls(compile) {\n          var CACHED = {};\n          return function muls_cwise_thunk(array0, array1, scalar2) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                type = [t0, r0.join(), t1, r1.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, scalar2);\n          };\n        },\n        mulseq: function mulseq(compile) {\n          var CACHED = {};\n          return function mulseq_cwise_thunk(array0, scalar1) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                type = [t0, r0.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar1);\n          };\n        },\n        div: function div(compile) {\n          var CACHED = {};\n          return function div_cwise_thunk(array0, array1, array2) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                t2 = array2.dtype,\n                r2 = array2.order,\n                type = [t0, r0.join(), t1, r1.join(), t2, r2.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1, t2, r2]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, array2.data, array2.stride, array2.offset | 0);\n          };\n        },\n        divs: function divs(compile) {\n          var CACHED = {};\n          return function divs_cwise_thunk(array0, array1, scalar2) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                type = [t0, r0.join(), t1, r1.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0, scalar2);\n          };\n        },\n        divseq: function divseq(compile) {\n          var CACHED = {};\n          return function divseq_cwise_thunk(array0, scalar1) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                type = [t0, r0.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar1);\n          };\n        },\n        assign: function assign(compile) {\n          var CACHED = {};\n          return function assign_cwise_thunk(array0, array1) {\n            var t0 = array0.dtype,\n                r0 = array0.order,\n                t1 = array1.dtype,\n                r1 = array1.order,\n                type = [t0, r0.join(), t1, r1.join()].join(),\n                proc = CACHED[type];\n\n            if (!proc) {\n              CACHED[type] = proc = compile([t0, r0, t1, r1]);\n            }\n\n            return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, array1.data, array1.stride, array1.offset | 0);\n          };\n        }\n      };\n\n      function createThunk(proc) {\n        var thunk = CACHED_thunk[proc.funcName];\n        return thunk(compile.bind(undefined, proc));\n      }\n\n      function makeOp(user_args) {\n        return createThunk({\n          funcName: user_args.funcName\n        });\n      }\n\n      var assign_ops = {\n        mul: \"*\",\n        div: \"/\"\n      };\n\n      (function () {\n        for (var id in assign_ops) {\n          exports[id] = makeOp({\n            funcName: id\n          });\n          exports[id + \"s\"] = makeOp({\n            funcName: id + \"s\"\n          });\n          exports[id + \"seq\"] = makeOp({\n            funcName: id + \"seq\"\n          });\n        }\n      })();\n\n      exports.assign = makeOp({\n        funcName: \"assign\"\n      });\n    }, {}],\n    255: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var ndarray = _glvis_(\"ndarray\");\n\n      var do_convert = _glvis_(\"./doConvert.js\");\n\n      module.exports = function convert(arr, result) {\n        var shape = [],\n            c = arr,\n            sz = 1;\n\n        while (Array.isArray(c)) {\n          shape.push(c.length);\n          sz *= c.length;\n          c = c[0];\n        }\n\n        if (shape.length === 0) {\n          return ndarray();\n        }\n\n        if (!result) {\n          result = ndarray(new Float64Array(sz), shape);\n        }\n\n        do_convert(result, arr);\n        return result;\n      };\n    }, {\n      \"./doConvert.js\": 256,\n      \"ndarray\": 259\n    }],\n    256: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function CwiseOp() {\n        return function (SS, a0, t0, p0, Y0) {\n          var s0 = SS[0],\n              s1 = SS[1],\n              s2 = SS[2],\n              t0p0 = t0[0],\n              t0p1 = t0[1],\n              t0p2 = t0[2],\n              index = [0, 0, 0];\n          p0 |= 0;\n          var i0 = 0,\n              i1 = 0,\n              i2 = 0,\n              d0s0 = t0p2,\n              d0s1 = t0p1 - s2 * t0p2,\n              d0s2 = t0p0 - s1 * t0p1;\n\n          for (i2 = 0; i2 < s0; ++i2) {\n            for (i1 = 0; i1 < s1; ++i1) {\n              for (i0 = 0; i0 < s2; ++i0) {\n                {\n                  var _inline_1_v = Y0,\n                      _inline_1_i;\n\n                  for (_inline_1_i = 0; _inline_1_i < index.length - 1; ++_inline_1_i) {\n                    _inline_1_v = _inline_1_v[index[_inline_1_i]];\n                  }\n\n                  a0[p0] = _inline_1_v[index[index.length - 1]];\n                }\n                p0 += d0s0;\n                ++index[2];\n              }\n\n              p0 += d0s1;\n              index[2] -= s2;\n              ++index[1];\n            }\n\n            p0 += d0s2;\n            index[1] -= s1;\n            ++index[0];\n          }\n        };\n      } //Generates a cwise operator\n\n\n      function generateCWiseOp() {\n        return CwiseOp();\n      }\n\n      var compile = generateCWiseOp;\n\n      function thunk(compile) {\n        var CACHED = {};\n        return function convert_cwise_thunk(array0, scalar1) {\n          var t0 = array0.dtype,\n              r0 = array0.order,\n              type = [t0, r0.join()].join(),\n              proc = CACHED[type];\n\n          if (!proc) {\n            CACHED[type] = proc = compile([t0, r0]);\n          }\n\n          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar1);\n        };\n      }\n\n      function createThunk(proc) {\n        return thunk(compile.bind(undefined, proc));\n      }\n\n      function compileCwise(user_args) {\n        return createThunk({\n          funcName: user_args.funcName\n        });\n      }\n\n      module.exports = compileCwise({\n        funcName: \"convert\"\n      });\n    }, {}],\n    257: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var pool = _glvis_(\"typedarray-pool\");\n\n      function getMallocFree(dtype) {\n        switch (dtype) {\n          case \"uint32\":\n            return [pool.mallocUint32, pool.freeUint32];\n\n          default:\n            return null;\n        }\n      }\n\n      var CACHED_insertionSort = {\n        \"uint32,1,0\": function uint3210(malloc, free) {\n          return function ndarrayInsertionSort1d0uint32(left, right, data, offset, s0, s1, n0, n1, d1, e1, f1) {\n            var i,\n                j,\n                cptr,\n                ptr = left * s0 + offset,\n                i1,\n                scratch = malloc(n1),\n                dptr,\n                sptr,\n                a,\n                b;\n\n            for (i = left + 1; i <= right; ++i) {\n              j = i;\n              ptr += s0;\n              cptr = ptr;\n              dptr = 0;\n              sptr = ptr;\n\n              for (i1 = 0; i1 < n1; ++i1) {\n                scratch[dptr++] = data[sptr];\n                sptr += d1;\n              }\n\n              __g: while (j-- > left) {\n                dptr = 0;\n                sptr = cptr - s0;\n\n                __l: for (i1 = 0; i1 < n1; ++i1) {\n                  a = data[sptr];\n                  b = scratch[dptr];\n\n                  if (a < b) {\n                    break __g;\n                  }\n\n                  if (a > b) {\n                    break __l;\n                  }\n\n                  sptr += e1;\n                  dptr += f1;\n                }\n\n                dptr = cptr;\n                sptr = cptr - s0;\n\n                for (i1 = 0; i1 < n1; ++i1) {\n                  data[dptr] = data[sptr];\n                  dptr += d1;\n                  sptr += d1;\n                }\n\n                cptr -= s0;\n              }\n\n              dptr = cptr;\n              sptr = 0;\n\n              for (i1 = 0; i1 < n1; ++i1) {\n                data[dptr] = scratch[sptr++];\n                dptr += d1;\n              }\n            }\n\n            free(scratch);\n          };\n        }\n      };\n\n      function createInsertionSort(order, dtype) {\n        var allocator = getMallocFree(dtype);\n        var key = [dtype, order].join(',');\n        var result = CACHED_insertionSort[key];\n\n        if (allocator) {\n          return result(allocator[0], allocator[1]);\n        } else {\n          return result();\n        }\n      }\n\n      var CACHED_quickSort = {\n        \"uint32,1,0\": function uint3210(insertionSort, malloc, free) {\n          return function ndarrayQuickSort1d0uint32(left, right, data, offset, s0, s1, n0, n1, d1, e1, f1) {\n            var sixth = (right - left + 1) / 6 | 0,\n                index1 = left + sixth,\n                index5 = right - sixth,\n                index3 = left + right >> 1,\n                index2 = index3 - sixth,\n                index4 = index3 + sixth,\n                el1 = index1,\n                el2 = index2,\n                el3 = index3,\n                el4 = index4,\n                el5 = index5,\n                less = left + 1,\n                great = right - 1,\n                pivots_are_equal = true,\n                tmp,\n                tmp0,\n                x,\n                y,\n                z,\n                k,\n                ptr0,\n                ptr1,\n                ptr2,\n                comp_pivot1 = 0,\n                comp_pivot2 = 0,\n                comp = 0,\n                i1,\n                b_ptr0,\n                b_ptr1,\n                b_ptr2,\n                b_ptr3,\n                b_ptr4,\n                b_ptr5,\n                b_ptr6,\n                b_ptr7,\n                ptr3,\n                ptr4,\n                ptr5,\n                ptr6,\n                ptr7,\n                pivot_ptr,\n                ptr_shift,\n                elementSize = n1,\n                pivot1 = malloc(elementSize),\n                pivot2 = malloc(elementSize);\n            b_ptr0 = s0 * el1;\n            b_ptr1 = s0 * el2;\n            ptr_shift = offset;\n\n            __l1: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el1;\n                el1 = el2;\n                el2 = tmp0;\n                break __l1;\n              }\n\n              if (comp < 0) {\n                break __l1;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el4;\n            b_ptr1 = s0 * el5;\n            ptr_shift = offset;\n\n            __l2: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el4;\n                el4 = el5;\n                el5 = tmp0;\n                break __l2;\n              }\n\n              if (comp < 0) {\n                break __l2;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el1;\n            b_ptr1 = s0 * el3;\n            ptr_shift = offset;\n\n            __l3: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el1;\n                el1 = el3;\n                el3 = tmp0;\n                break __l3;\n              }\n\n              if (comp < 0) {\n                break __l3;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el2;\n            b_ptr1 = s0 * el3;\n            ptr_shift = offset;\n\n            __l4: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el2;\n                el2 = el3;\n                el3 = tmp0;\n                break __l4;\n              }\n\n              if (comp < 0) {\n                break __l4;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el1;\n            b_ptr1 = s0 * el4;\n            ptr_shift = offset;\n\n            __l5: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el1;\n                el1 = el4;\n                el4 = tmp0;\n                break __l5;\n              }\n\n              if (comp < 0) {\n                break __l5;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el3;\n            b_ptr1 = s0 * el4;\n            ptr_shift = offset;\n\n            __l6: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el3;\n                el3 = el4;\n                el4 = tmp0;\n                break __l6;\n              }\n\n              if (comp < 0) {\n                break __l6;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el2;\n            b_ptr1 = s0 * el5;\n            ptr_shift = offset;\n\n            __l7: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el2;\n                el2 = el5;\n                el5 = tmp0;\n                break __l7;\n              }\n\n              if (comp < 0) {\n                break __l7;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el2;\n            b_ptr1 = s0 * el3;\n            ptr_shift = offset;\n\n            __l8: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el2;\n                el2 = el3;\n                el3 = tmp0;\n                break __l8;\n              }\n\n              if (comp < 0) {\n                break __l8;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el4;\n            b_ptr1 = s0 * el5;\n            ptr_shift = offset;\n\n            __l9: for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              comp = data[ptr0] - data[ptr1];\n\n              if (comp > 0) {\n                tmp0 = el4;\n                el4 = el5;\n                el5 = tmp0;\n                break __l9;\n              }\n\n              if (comp < 0) {\n                break __l9;\n              }\n\n              ptr_shift += e1;\n            }\n\n            b_ptr0 = s0 * el1;\n            b_ptr1 = s0 * el2;\n            b_ptr2 = s0 * el3;\n            b_ptr3 = s0 * el4;\n            b_ptr4 = s0 * el5;\n            b_ptr5 = s0 * index1;\n            b_ptr6 = s0 * index3;\n            b_ptr7 = s0 * index5;\n            pivot_ptr = 0;\n            ptr_shift = offset;\n\n            for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              ptr2 = b_ptr2 + ptr_shift;\n              ptr3 = b_ptr3 + ptr_shift;\n              ptr4 = b_ptr4 + ptr_shift;\n              ptr5 = b_ptr5 + ptr_shift;\n              ptr6 = b_ptr6 + ptr_shift;\n              ptr7 = b_ptr7 + ptr_shift;\n              pivot1[pivot_ptr] = data[ptr1];\n              pivot2[pivot_ptr] = data[ptr3];\n              pivots_are_equal = pivots_are_equal && pivot1[pivot_ptr] === pivot2[pivot_ptr];\n              x = data[ptr0];\n              y = data[ptr2];\n              z = data[ptr4];\n              data[ptr5] = x;\n              data[ptr6] = y;\n              data[ptr7] = z;\n              ++pivot_ptr;\n              ptr_shift += d1;\n            }\n\n            b_ptr0 = s0 * index2;\n            b_ptr1 = s0 * left;\n            ptr_shift = offset;\n\n            for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              data[ptr0] = data[ptr1];\n              ptr_shift += d1;\n            }\n\n            b_ptr0 = s0 * index4;\n            b_ptr1 = s0 * right;\n            ptr_shift = offset;\n\n            for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              data[ptr0] = data[ptr1];\n              ptr_shift += d1;\n            }\n\n            if (pivots_are_equal) {\n              for (k = less; k <= great; ++k) {\n                ptr0 = offset + k * s0;\n                pivot_ptr = 0;\n\n                __l10: for (i1 = 0; i1 < n1; ++i1) {\n                  comp = data[ptr0] - pivot1[pivot_ptr];\n\n                  if (comp !== 0) {\n                    break __l10;\n                  }\n\n                  pivot_ptr += f1;\n                  ptr0 += e1;\n                }\n\n                if (comp === 0) {\n                  continue;\n                }\n\n                if (comp < 0) {\n                  if (k !== less) {\n                    b_ptr0 = s0 * k;\n                    b_ptr1 = s0 * less;\n                    ptr_shift = offset;\n\n                    for (i1 = 0; i1 < n1; ++i1) {\n                      ptr0 = b_ptr0 + ptr_shift;\n                      ptr1 = b_ptr1 + ptr_shift;\n                      tmp = data[ptr0];\n                      data[ptr0] = data[ptr1];\n                      data[ptr1] = tmp;\n                      ptr_shift += d1;\n                    }\n                  }\n\n                  ++less;\n                } else {\n                  while (true) {\n                    ptr0 = offset + great * s0;\n                    pivot_ptr = 0;\n\n                    __l11: for (i1 = 0; i1 < n1; ++i1) {\n                      comp = data[ptr0] - pivot1[pivot_ptr];\n\n                      if (comp !== 0) {\n                        break __l11;\n                      }\n\n                      pivot_ptr += f1;\n                      ptr0 += e1;\n                    }\n\n                    if (comp > 0) {\n                      great--;\n                    } else if (comp < 0) {\n                      b_ptr0 = s0 * k;\n                      b_ptr1 = s0 * less;\n                      b_ptr2 = s0 * great;\n                      ptr_shift = offset;\n\n                      for (i1 = 0; i1 < n1; ++i1) {\n                        ptr0 = b_ptr0 + ptr_shift;\n                        ptr1 = b_ptr1 + ptr_shift;\n                        ptr2 = b_ptr2 + ptr_shift;\n                        tmp = data[ptr0];\n                        data[ptr0] = data[ptr1];\n                        data[ptr1] = data[ptr2];\n                        data[ptr2] = tmp;\n                        ptr_shift += d1;\n                      }\n\n                      ++less;\n                      --great;\n                      break;\n                    } else {\n                      b_ptr0 = s0 * k;\n                      b_ptr1 = s0 * great;\n                      ptr_shift = offset;\n\n                      for (i1 = 0; i1 < n1; ++i1) {\n                        ptr0 = b_ptr0 + ptr_shift;\n                        ptr1 = b_ptr1 + ptr_shift;\n                        tmp = data[ptr0];\n                        data[ptr0] = data[ptr1];\n                        data[ptr1] = tmp;\n                        ptr_shift += d1;\n                      }\n\n                      --great;\n                      break;\n                    }\n                  }\n                }\n              }\n            } else {\n              for (k = less; k <= great; ++k) {\n                ptr0 = offset + k * s0;\n                pivot_ptr = 0;\n\n                __l12: for (i1 = 0; i1 < n1; ++i1) {\n                  comp_pivot1 = data[ptr0] - pivot1[pivot_ptr];\n\n                  if (comp_pivot1 !== 0) {\n                    break __l12;\n                  }\n\n                  pivot_ptr += f1;\n                  ptr0 += e1;\n                }\n\n                if (comp_pivot1 < 0) {\n                  if (k !== less) {\n                    b_ptr0 = s0 * k;\n                    b_ptr1 = s0 * less;\n                    ptr_shift = offset;\n\n                    for (i1 = 0; i1 < n1; ++i1) {\n                      ptr0 = b_ptr0 + ptr_shift;\n                      ptr1 = b_ptr1 + ptr_shift;\n                      tmp = data[ptr0];\n                      data[ptr0] = data[ptr1];\n                      data[ptr1] = tmp;\n                      ptr_shift += d1;\n                    }\n                  }\n\n                  ++less;\n                } else {\n                  ptr0 = offset + k * s0;\n                  pivot_ptr = 0;\n\n                  __l13: for (i1 = 0; i1 < n1; ++i1) {\n                    comp_pivot2 = data[ptr0] - pivot2[pivot_ptr];\n\n                    if (comp_pivot2 !== 0) {\n                      break __l13;\n                    }\n\n                    pivot_ptr += f1;\n                    ptr0 += e1;\n                  }\n\n                  if (comp_pivot2 > 0) {\n                    while (true) {\n                      ptr0 = offset + great * s0;\n                      pivot_ptr = 0;\n\n                      __l14: for (i1 = 0; i1 < n1; ++i1) {\n                        comp = data[ptr0] - pivot2[pivot_ptr];\n\n                        if (comp !== 0) {\n                          break __l14;\n                        }\n\n                        pivot_ptr += f1;\n                        ptr0 += e1;\n                      }\n\n                      if (comp > 0) {\n                        if (--great < k) {\n                          break;\n                        }\n\n                        continue;\n                      } else {\n                        ptr0 = offset + great * s0;\n                        pivot_ptr = 0;\n\n                        __l15: for (i1 = 0; i1 < n1; ++i1) {\n                          comp = data[ptr0] - pivot1[pivot_ptr];\n\n                          if (comp !== 0) {\n                            break __l15;\n                          }\n\n                          pivot_ptr += f1;\n                          ptr0 += e1;\n                        }\n\n                        if (comp < 0) {\n                          b_ptr0 = s0 * k;\n                          b_ptr1 = s0 * less;\n                          b_ptr2 = s0 * great;\n                          ptr_shift = offset;\n\n                          for (i1 = 0; i1 < n1; ++i1) {\n                            ptr0 = b_ptr0 + ptr_shift;\n                            ptr1 = b_ptr1 + ptr_shift;\n                            ptr2 = b_ptr2 + ptr_shift;\n                            tmp = data[ptr0];\n                            data[ptr0] = data[ptr1];\n                            data[ptr1] = data[ptr2];\n                            data[ptr2] = tmp;\n                            ptr_shift += d1;\n                          }\n\n                          ++less;\n                          --great;\n                        } else {\n                          b_ptr0 = s0 * k;\n                          b_ptr1 = s0 * great;\n                          ptr_shift = offset;\n\n                          for (i1 = 0; i1 < n1; ++i1) {\n                            ptr0 = b_ptr0 + ptr_shift;\n                            ptr1 = b_ptr1 + ptr_shift;\n                            tmp = data[ptr0];\n                            data[ptr0] = data[ptr1];\n                            data[ptr1] = tmp;\n                            ptr_shift += d1;\n                          }\n\n                          --great;\n                        }\n\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            b_ptr0 = s0 * left;\n            b_ptr1 = s0 * (less - 1);\n            pivot_ptr = 0;\n            ptr_shift = offset;\n\n            for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              data[ptr0] = data[ptr1];\n              data[ptr1] = pivot1[pivot_ptr];\n              ++pivot_ptr;\n              ptr_shift += d1;\n            }\n\n            b_ptr0 = s0 * right;\n            b_ptr1 = s0 * (great + 1);\n            pivot_ptr = 0;\n            ptr_shift = offset;\n\n            for (i1 = 0; i1 < n1; ++i1) {\n              ptr0 = b_ptr0 + ptr_shift;\n              ptr1 = b_ptr1 + ptr_shift;\n              data[ptr0] = data[ptr1];\n              data[ptr1] = pivot2[pivot_ptr];\n              ++pivot_ptr;\n              ptr_shift += d1;\n            }\n\n            if (less - 2 - left <= 32) {\n              insertionSort(left, less - 2, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            } else {\n              ndarrayQuickSort1d0uint32(left, less - 2, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            }\n\n            if (right - (great + 2) <= 32) {\n              insertionSort(great + 2, right, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            } else {\n              ndarrayQuickSort1d0uint32(great + 2, right, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            }\n\n            if (pivots_are_equal) {\n              free(pivot1);\n              free(pivot2);\n              return;\n            }\n\n            if (less < index1 && great > index5) {\n              __l16: while (true) {\n                ptr0 = offset + less * s0;\n                pivot_ptr = 0;\n                ptr_shift = offset;\n\n                for (i1 = 0; i1 < n1; ++i1) {\n                  if (data[ptr0] !== pivot1[pivot_ptr]) {\n                    break __l16;\n                  }\n\n                  ++pivot_ptr;\n                  ptr0 += d1;\n                }\n\n                ++less;\n              }\n\n              __l17: while (true) {\n                ptr0 = offset + great * s0;\n                pivot_ptr = 0;\n                ptr_shift = offset;\n\n                for (i1 = 0; i1 < n1; ++i1) {\n                  if (data[ptr0] !== pivot2[pivot_ptr]) {\n                    break __l17;\n                  }\n\n                  ++pivot_ptr;\n                  ptr0 += d1;\n                }\n\n                --great;\n              }\n\n              for (k = less; k <= great; ++k) {\n                ptr0 = offset + k * s0;\n                pivot_ptr = 0;\n\n                __l18: for (i1 = 0; i1 < n1; ++i1) {\n                  comp_pivot1 = data[ptr0] - pivot1[pivot_ptr];\n\n                  if (comp_pivot1 !== 0) {\n                    break __l18;\n                  }\n\n                  pivot_ptr += f1;\n                  ptr0 += e1;\n                }\n\n                if (comp_pivot1 === 0) {\n                  if (k !== less) {\n                    b_ptr0 = s0 * k;\n                    b_ptr1 = s0 * less;\n                    ptr_shift = offset;\n\n                    for (i1 = 0; i1 < n1; ++i1) {\n                      ptr0 = b_ptr0 + ptr_shift;\n                      ptr1 = b_ptr1 + ptr_shift;\n                      tmp = data[ptr0];\n                      data[ptr0] = data[ptr1];\n                      data[ptr1] = tmp;\n                      ptr_shift += d1;\n                    }\n                  }\n\n                  ++less;\n                } else {\n                  ptr0 = offset + k * s0;\n                  pivot_ptr = 0;\n\n                  __l19: for (i1 = 0; i1 < n1; ++i1) {\n                    comp_pivot2 = data[ptr0] - pivot2[pivot_ptr];\n\n                    if (comp_pivot2 !== 0) {\n                      break __l19;\n                    }\n\n                    pivot_ptr += f1;\n                    ptr0 += e1;\n                  }\n\n                  if (comp_pivot2 === 0) {\n                    while (true) {\n                      ptr0 = offset + great * s0;\n                      pivot_ptr = 0;\n\n                      __l20: for (i1 = 0; i1 < n1; ++i1) {\n                        comp = data[ptr0] - pivot2[pivot_ptr];\n\n                        if (comp !== 0) {\n                          break __l20;\n                        }\n\n                        pivot_ptr += f1;\n                        ptr0 += e1;\n                      }\n\n                      if (comp === 0) {\n                        if (--great < k) {\n                          break;\n                        }\n\n                        continue;\n                      } else {\n                        ptr0 = offset + great * s0;\n                        pivot_ptr = 0;\n\n                        __l21: for (i1 = 0; i1 < n1; ++i1) {\n                          comp = data[ptr0] - pivot1[pivot_ptr];\n\n                          if (comp !== 0) {\n                            break __l21;\n                          }\n\n                          pivot_ptr += f1;\n                          ptr0 += e1;\n                        }\n\n                        if (comp < 0) {\n                          b_ptr0 = s0 * k;\n                          b_ptr1 = s0 * less;\n                          b_ptr2 = s0 * great;\n                          ptr_shift = offset;\n\n                          for (i1 = 0; i1 < n1; ++i1) {\n                            ptr0 = b_ptr0 + ptr_shift;\n                            ptr1 = b_ptr1 + ptr_shift;\n                            ptr2 = b_ptr2 + ptr_shift;\n                            tmp = data[ptr0];\n                            data[ptr0] = data[ptr1];\n                            data[ptr1] = data[ptr2];\n                            data[ptr2] = tmp;\n                            ptr_shift += d1;\n                          }\n\n                          ++less;\n                          --great;\n                        } else {\n                          b_ptr0 = s0 * k;\n                          b_ptr1 = s0 * great;\n                          ptr_shift = offset;\n\n                          for (i1 = 0; i1 < n1; ++i1) {\n                            ptr0 = b_ptr0 + ptr_shift;\n                            ptr1 = b_ptr1 + ptr_shift;\n                            tmp = data[ptr0];\n                            data[ptr0] = data[ptr1];\n                            data[ptr1] = tmp;\n                            ptr_shift += d1;\n                          }\n\n                          --great;\n                        }\n\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            free(pivot1);\n            free(pivot2);\n\n            if (great - less <= 32) {\n              insertionSort(less, great, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            } else {\n              ndarrayQuickSort1d0uint32(less, great, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            }\n          };\n        }\n      };\n\n      function createQuickSort(order, dtype, insertionSort) {\n        var allocator = getMallocFree(dtype);\n        var key = [dtype, order].join(',');\n        var result = CACHED_quickSort[key];\n\n        if (order.length > 1 && allocator) {\n          return result(insertionSort, allocator[0], allocator[1]);\n        } else {\n          return result(insertionSort);\n        }\n      }\n\n      var CACHED_sort = {\n        \"uint32,1,0\": function uint3210(insertionSort, quickSort) {\n          return function (array) {\n            var data = array.data,\n                offset = array.offset | 0,\n                shape = array.shape,\n                stride = array.stride,\n                s0 = stride[0] | 0,\n                n0 = shape[0] | 0,\n                s1 = stride[1] | 0,\n                n1 = shape[1] | 0,\n                d1 = s1,\n                e1 = s1,\n                f1 = 1;\n\n            if (n0 <= 32) {\n              insertionSort(0, n0 - 1, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            } else {\n              quickSort(0, n0 - 1, data, offset, s0, s1, n0, n1, d1, e1, f1);\n            }\n          };\n        }\n      };\n\n      function compileSort(order, dtype) {\n        var key = [dtype, order].join(',');\n        var result = CACHED_sort[key];\n        var insertionSort = createInsertionSort(order, dtype);\n        var quickSort = createQuickSort(order, dtype, insertionSort);\n        return result(insertionSort, quickSort);\n      }\n\n      module.exports = compileSort;\n    }, {\n      \"typedarray-pool\": 308\n    }],\n    258: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var compile = _glvis_(\"./lib/compile_sort.js\");\n\n      var CACHE = {};\n\n      function sort(array) {\n        var order = array.order;\n        var dtype = array.dtype;\n        var typeSig = [order, dtype];\n        var typeName = typeSig.join(\":\");\n        var compiled = CACHE[typeName];\n\n        if (!compiled) {\n          CACHE[typeName] = compiled = compile(order, dtype);\n        }\n\n        compiled(array);\n        return array;\n      }\n\n      module.exports = sort;\n    }, {\n      \"./lib/compile_sort.js\": 257\n    }],\n    259: [function (_glvis_, module, exports) {\n      var isBuffer = _glvis_(\"is-buffer\");\n\n      var hasTypedArrays = typeof Float64Array !== \"undefined\";\n\n      function compare1st(a, b) {\n        return a[0] - b[0];\n      }\n\n      function order() {\n        var stride = this.stride;\n        var terms = new Array(stride.length);\n        var i;\n\n        for (i = 0; i < terms.length; ++i) {\n          terms[i] = [Math.abs(stride[i]), i];\n        }\n\n        terms.sort(compare1st);\n        var result = new Array(terms.length);\n\n        for (i = 0; i < result.length; ++i) {\n          result[i] = terms[i][1];\n        }\n\n        return result;\n      }\n\n      var allFns = {\n        // Special case for trivial arrays\n        T: function T(dtype) {\n          function View(a) {\n            this.data = a;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n\n          proto.index = function () {\n            return -1;\n          };\n\n          proto.size = 0;\n          proto.dimension = -1;\n          proto.shape = proto.stride = proto.order = [];\n\n          proto.lo = proto.hi = proto.transpose = proto.step = function () {\n            return new View(this.data);\n          };\n\n          proto.get = proto.set = function () {};\n\n          proto.pick = function () {\n            return null;\n          };\n\n          return function construct(a) {\n            return new View(a);\n          };\n        },\n        // Special case for 0d arrays\n        0: function _(dtype, TrivialArray) {\n          function View(a, d) {\n            this.data = a;\n            this.offset = d;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n\n          proto.index = function () {\n            return this.offset;\n          };\n\n          proto.dimension = 0;\n          proto.size = 1;\n          proto.shape = proto.stride = proto.order = [];\n\n          proto.lo = proto.hi = proto.transpose = proto.step = function copy() {\n            return new View(this.data, this.offset);\n          };\n\n          proto.pick = function pick() {\n            return TrivialArray(this.data);\n          };\n\n          proto.valueOf = proto.get = function get() {\n            return dtype === \"generic\" ? this.data.get(this.offset) : this.data[this.offset];\n          };\n\n          proto.set = function set(v) {\n            return dtype === \"generic\" ? this.data.set(this.offset, v) : this.data[this.offset] = v;\n          };\n\n          return function construct(a, b, c, d) {\n            return new View(a, d);\n          };\n        },\n        1: function _(dtype, CTOR_LIST, ORDER) {\n          function View(a, b0, c0, d) {\n            this.data = a;\n            this.shape = [b0];\n            this.stride = [c0];\n            this.offset = d | 0;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n          proto.dimension = 1;\n          Object.defineProperty(proto, \"size\", {\n            get: function size() {\n              return this.shape[0];\n            }\n          });\n          proto.order = [0];\n\n          proto.set = function set(i0, v) {\n            return dtype === \"generic\" ? this.data.set(this.offset + this.stride[0] * i0, v) : this.data[this.offset + this.stride[0] * i0] = v;\n          };\n\n          proto.get = function get(i0) {\n            return dtype === \"generic\" ? this.data.get(this.offset + this.stride[0] * i0) : this.data[this.offset + this.stride[0] * i0];\n          };\n\n          proto.index = function index(i0) {\n            return this.offset + this.stride[0] * i0;\n          };\n\n          proto.hi = function hi(i0) {\n            return new View(this.data, typeof i0 !== \"number\" || i0 < 0 ? this.shape[0] : i0 | 0, this.stride[0], this.offset);\n          };\n\n          proto.lo = function lo(i0) {\n            var b = this.offset,\n                d = 0,\n                a0 = this.shape[0],\n                c0 = this.stride[0];\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              d = i0 | 0;\n              b += c0 * d;\n              a0 -= d;\n            }\n\n            return new View(this.data, a0, c0, b);\n          };\n\n          proto.step = function step(i0) {\n            var a0 = this.shape[0],\n                b0 = this.stride[0],\n                c = this.offset,\n                d = 0,\n                ceil = Math.ceil;\n\n            if (typeof i0 === \"number\") {\n              d = i0 | 0;\n\n              if (d < 0) {\n                c += b0 * (a0 - 1);\n                a0 = ceil(-a0 / d);\n              } else {\n                a0 = ceil(a0 / d);\n              }\n\n              b0 *= d;\n            }\n\n            return new View(this.data, a0, b0, c);\n          };\n\n          proto.transpose = function transpose(i0) {\n            i0 = i0 === undefined ? 0 : i0 | 0;\n            var a = this.shape,\n                b = this.stride;\n            return new View(this.data, a[i0], b[i0], this.offset);\n          };\n\n          proto.pick = function pick(i0) {\n            var a = [],\n                b = [],\n                c = this.offset;\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              c = c + this.stride[0] * i0 | 0;\n            } else {\n              a.push(this.shape[0]);\n              b.push(this.stride[0]);\n            }\n\n            var ctor = CTOR_LIST[a.length + 1];\n            return ctor(this.data, a, b, c);\n          };\n\n          return function construct(data, shape, stride, offset) {\n            return new View(data, shape[0], stride[0], offset);\n          };\n        },\n        2: function _(dtype, CTOR_LIST, ORDER) {\n          function View(a, b0, b1, c0, c1, d) {\n            this.data = a;\n            this.shape = [b0, b1];\n            this.stride = [c0, c1];\n            this.offset = d | 0;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n          proto.dimension = 2;\n          Object.defineProperty(proto, \"size\", {\n            get: function size() {\n              return this.shape[0] * this.shape[1];\n            }\n          });\n          Object.defineProperty(proto, \"order\", {\n            get: function order() {\n              return Math.abs(this.stride[0]) > Math.abs(this.stride[1]) ? [1, 0] : [0, 1];\n            }\n          });\n\n          proto.set = function set(i0, i1, v) {\n            return dtype === \"generic\" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1] = v;\n          };\n\n          proto.get = function get(i0, i1) {\n            return dtype === \"generic\" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1];\n          };\n\n          proto.index = function index(i0, i1) {\n            return this.offset + this.stride[0] * i0 + this.stride[1] * i1;\n          };\n\n          proto.hi = function hi(i0, i1) {\n            return new View(this.data, typeof i0 !== \"number\" || i0 < 0 ? this.shape[0] : i0 | 0, typeof i1 !== \"number\" || i1 < 0 ? this.shape[1] : i1 | 0, this.stride[0], this.stride[1], this.offset);\n          };\n\n          proto.lo = function lo(i0, i1) {\n            var b = this.offset,\n                d = 0,\n                a0 = this.shape[0],\n                a1 = this.shape[1],\n                c0 = this.stride[0],\n                c1 = this.stride[1];\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              d = i0 | 0;\n              b += c0 * d;\n              a0 -= d;\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              d = i1 | 0;\n              b += c1 * d;\n              a1 -= d;\n            }\n\n            return new View(this.data, a0, a1, c0, c1, b);\n          };\n\n          proto.step = function step(i0, i1) {\n            var a0 = this.shape[0],\n                a1 = this.shape[1],\n                b0 = this.stride[0],\n                b1 = this.stride[1],\n                c = this.offset,\n                d = 0,\n                ceil = Math.ceil;\n\n            if (typeof i0 === \"number\") {\n              d = i0 | 0;\n\n              if (d < 0) {\n                c += b0 * (a0 - 1);\n                a0 = ceil(-a0 / d);\n              } else {\n                a0 = ceil(a0 / d);\n              }\n\n              b0 *= d;\n            }\n\n            if (typeof i1 === \"number\") {\n              d = i1 | 0;\n\n              if (d < 0) {\n                c += b1 * (a1 - 1);\n                a1 = ceil(-a1 / d);\n              } else {\n                a1 = ceil(a1 / d);\n              }\n\n              b1 *= d;\n            }\n\n            return new View(this.data, a0, a1, b0, b1, c);\n          };\n\n          proto.transpose = function transpose(i0, i1) {\n            i0 = i0 === undefined ? 0 : i0 | 0;\n            i1 = i1 === undefined ? 1 : i1 | 0;\n            var a = this.shape,\n                b = this.stride;\n            return new View(this.data, a[i0], a[i1], b[i0], b[i1], this.offset);\n          };\n\n          proto.pick = function pick(i0, i1) {\n            var a = [],\n                b = [],\n                c = this.offset;\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              c = c + this.stride[0] * i0 | 0;\n            } else {\n              a.push(this.shape[0]);\n              b.push(this.stride[0]);\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              c = c + this.stride[1] * i1 | 0;\n            } else {\n              a.push(this.shape[1]);\n              b.push(this.stride[1]);\n            }\n\n            var ctor = CTOR_LIST[a.length + 1];\n            return ctor(this.data, a, b, c);\n          };\n\n          return function construct(data, shape, stride, offset) {\n            return new View(data, shape[0], shape[1], stride[0], stride[1], offset);\n          };\n        },\n        3: function _(dtype, CTOR_LIST, ORDER) {\n          function View(a, b0, b1, b2, c0, c1, c2, d) {\n            this.data = a;\n            this.shape = [b0, b1, b2];\n            this.stride = [c0, c1, c2];\n            this.offset = d | 0;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n          proto.dimension = 3;\n          Object.defineProperty(proto, \"size\", {\n            get: function size() {\n              return this.shape[0] * this.shape[1] * this.shape[2];\n            }\n          });\n          Object.defineProperty(proto, \"order\", {\n            get: function order() {\n              var s0 = Math.abs(this.stride[0]),\n                  s1 = Math.abs(this.stride[1]),\n                  s2 = Math.abs(this.stride[2]);\n\n              if (s0 > s1) {\n                if (s1 > s2) {\n                  return [2, 1, 0];\n                } else if (s0 > s2) {\n                  return [1, 2, 0];\n                } else {\n                  return [1, 0, 2];\n                }\n              } else if (s0 > s2) {\n                return [2, 0, 1];\n              } else if (s2 > s1) {\n                return [0, 1, 2];\n              } else {\n                return [0, 2, 1];\n              }\n            }\n          });\n\n          proto.set = function set(i0, i1, i2, v) {\n            return dtype === \"generic\" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2] = v;\n          };\n\n          proto.get = function get(i0, i1, i2) {\n            return dtype === \"generic\" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2];\n          };\n\n          proto.index = function index(i0, i1, i2) {\n            return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2;\n          };\n\n          proto.hi = function hi(i0, i1, i2) {\n            return new View(this.data, typeof i0 !== \"number\" || i0 < 0 ? this.shape[0] : i0 | 0, typeof i1 !== \"number\" || i1 < 0 ? this.shape[1] : i1 | 0, typeof i2 !== \"number\" || i2 < 0 ? this.shape[2] : i2 | 0, this.stride[0], this.stride[1], this.stride[2], this.offset);\n          };\n\n          proto.lo = function lo(i0, i1, i2) {\n            var b = this.offset,\n                d = 0,\n                a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                c0 = this.stride[0],\n                c1 = this.stride[1],\n                c2 = this.stride[2];\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              d = i0 | 0;\n              b += c0 * d;\n              a0 -= d;\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              d = i1 | 0;\n              b += c1 * d;\n              a1 -= d;\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              d = i2 | 0;\n              b += c2 * d;\n              a2 -= d;\n            }\n\n            return new View(this.data, a0, a1, a2, c0, c1, c2, b);\n          };\n\n          proto.step = function step(i0, i1, i2) {\n            var a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                b0 = this.stride[0],\n                b1 = this.stride[1],\n                b2 = this.stride[2],\n                c = this.offset,\n                d = 0,\n                ceil = Math.ceil;\n\n            if (typeof i0 === \"number\") {\n              d = i0 | 0;\n\n              if (d < 0) {\n                c += b0 * (a0 - 1);\n                a0 = ceil(-a0 / d);\n              } else {\n                a0 = ceil(a0 / d);\n              }\n\n              b0 *= d;\n            }\n\n            if (typeof i1 === \"number\") {\n              d = i1 | 0;\n\n              if (d < 0) {\n                c += b1 * (a1 - 1);\n                a1 = ceil(-a1 / d);\n              } else {\n                a1 = ceil(a1 / d);\n              }\n\n              b1 *= d;\n            }\n\n            if (typeof i2 === \"number\") {\n              d = i2 | 0;\n\n              if (d < 0) {\n                c += b2 * (a2 - 1);\n                a2 = ceil(-a2 / d);\n              } else {\n                a2 = ceil(a2 / d);\n              }\n\n              b2 *= d;\n            }\n\n            return new View(this.data, a0, a1, a2, b0, b1, b2, c);\n          };\n\n          proto.transpose = function transpose(i0, i1, i2) {\n            i0 = i0 === undefined ? 0 : i0 | 0;\n            i1 = i1 === undefined ? 1 : i1 | 0;\n            i2 = i2 === undefined ? 2 : i2 | 0;\n            var a = this.shape,\n                b = this.stride;\n            return new View(this.data, a[i0], a[i1], a[i2], b[i0], b[i1], b[i2], this.offset);\n          };\n\n          proto.pick = function pick(i0, i1, i2) {\n            var a = [],\n                b = [],\n                c = this.offset;\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              c = c + this.stride[0] * i0 | 0;\n            } else {\n              a.push(this.shape[0]);\n              b.push(this.stride[0]);\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              c = c + this.stride[1] * i1 | 0;\n            } else {\n              a.push(this.shape[1]);\n              b.push(this.stride[1]);\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              c = c + this.stride[2] * i2 | 0;\n            } else {\n              a.push(this.shape[2]);\n              b.push(this.stride[2]);\n            }\n\n            var ctor = CTOR_LIST[a.length + 1];\n            return ctor(this.data, a, b, c);\n          };\n\n          return function construct(data, shape, stride, offset) {\n            return new View(data, shape[0], shape[1], shape[2], stride[0], stride[1], stride[2], offset);\n          };\n        },\n        4: function _(dtype, CTOR_LIST, ORDER) {\n          function View(a, b0, b1, b2, b3, c0, c1, c2, c3, d) {\n            this.data = a;\n            this.shape = [b0, b1, b2, b3];\n            this.stride = [c0, c1, c2, c3];\n            this.offset = d | 0;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n          proto.dimension = 4;\n          Object.defineProperty(proto, \"size\", {\n            get: function size() {\n              return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3];\n            }\n          });\n          Object.defineProperty(proto, \"order\", {\n            get: ORDER\n          });\n\n          proto.set = function set(i0, i1, i2, i3, v) {\n            return dtype === \"generic\" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3] = v;\n          };\n\n          proto.get = function get(i0, i1, i2, i3) {\n            return dtype === \"generic\" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3];\n          };\n\n          proto.index = function index(i0, i1, i2, i3) {\n            return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3;\n          };\n\n          proto.hi = function hi(i0, i1, i2, i3) {\n            return new View(this.data, typeof i0 !== \"number\" || i0 < 0 ? this.shape[0] : i0 | 0, typeof i1 !== \"number\" || i1 < 0 ? this.shape[1] : i1 | 0, typeof i2 !== \"number\" || i2 < 0 ? this.shape[2] : i2 | 0, typeof i3 !== \"number\" || i3 < 0 ? this.shape[3] : i3 | 0, this.stride[0], this.stride[1], this.stride[2], this.stride[3], this.offset);\n          };\n\n          proto.lo = function lo(i0, i1, i2, i3) {\n            var b = this.offset,\n                d = 0,\n                a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                a3 = this.shape[3],\n                c0 = this.stride[0],\n                c1 = this.stride[1],\n                c2 = this.stride[2],\n                c3 = this.stride[3];\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              d = i0 | 0;\n              b += c0 * d;\n              a0 -= d;\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              d = i1 | 0;\n              b += c1 * d;\n              a1 -= d;\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              d = i2 | 0;\n              b += c2 * d;\n              a2 -= d;\n            }\n\n            if (typeof i3 === \"number\" && i3 >= 0) {\n              d = i3 | 0;\n              b += c3 * d;\n              a3 -= d;\n            }\n\n            return new View(this.data, a0, a1, a2, a3, c0, c1, c2, c3, b);\n          };\n\n          proto.step = function step(i0, i1, i2, i3) {\n            var a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                a3 = this.shape[3],\n                b0 = this.stride[0],\n                b1 = this.stride[1],\n                b2 = this.stride[2],\n                b3 = this.stride[3],\n                c = this.offset,\n                d = 0,\n                ceil = Math.ceil;\n\n            if (typeof i0 === \"number\") {\n              d = i0 | 0;\n\n              if (d < 0) {\n                c += b0 * (a0 - 1);\n                a0 = ceil(-a0 / d);\n              } else {\n                a0 = ceil(a0 / d);\n              }\n\n              b0 *= d;\n            }\n\n            if (typeof i1 === \"number\") {\n              d = i1 | 0;\n\n              if (d < 0) {\n                c += b1 * (a1 - 1);\n                a1 = ceil(-a1 / d);\n              } else {\n                a1 = ceil(a1 / d);\n              }\n\n              b1 *= d;\n            }\n\n            if (typeof i2 === \"number\") {\n              d = i2 | 0;\n\n              if (d < 0) {\n                c += b2 * (a2 - 1);\n                a2 = ceil(-a2 / d);\n              } else {\n                a2 = ceil(a2 / d);\n              }\n\n              b2 *= d;\n            }\n\n            if (typeof i3 === \"number\") {\n              d = i3 | 0;\n\n              if (d < 0) {\n                c += b3 * (a3 - 1);\n                a3 = ceil(-a3 / d);\n              } else {\n                a3 = ceil(a3 / d);\n              }\n\n              b3 *= d;\n            }\n\n            return new View(this.data, a0, a1, a2, a3, b0, b1, b2, b3, c);\n          };\n\n          proto.transpose = function transpose(i0, i1, i2, i3) {\n            i0 = i0 === undefined ? 0 : i0 | 0;\n            i1 = i1 === undefined ? 1 : i1 | 0;\n            i2 = i2 === undefined ? 2 : i2 | 0;\n            i3 = i3 === undefined ? 3 : i3 | 0;\n            var a = this.shape,\n                b = this.stride;\n            return new View(this.data, a[i0], a[i1], a[i2], a[i3], b[i0], b[i1], b[i2], b[i3], this.offset);\n          };\n\n          proto.pick = function pick(i0, i1, i2, i3) {\n            var a = [],\n                b = [],\n                c = this.offset;\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              c = c + this.stride[0] * i0 | 0;\n            } else {\n              a.push(this.shape[0]);\n              b.push(this.stride[0]);\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              c = c + this.stride[1] * i1 | 0;\n            } else {\n              a.push(this.shape[1]);\n              b.push(this.stride[1]);\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              c = c + this.stride[2] * i2 | 0;\n            } else {\n              a.push(this.shape[2]);\n              b.push(this.stride[2]);\n            }\n\n            if (typeof i3 === \"number\" && i3 >= 0) {\n              c = c + this.stride[3] * i3 | 0;\n            } else {\n              a.push(this.shape[3]);\n              b.push(this.stride[3]);\n            }\n\n            var ctor = CTOR_LIST[a.length + 1];\n            return ctor(this.data, a, b, c);\n          };\n\n          return function construct(data, shape, stride, offset) {\n            return new View(data, shape[0], shape[1], shape[2], shape[3], stride[0], stride[1], stride[2], stride[3], offset);\n          };\n        },\n        5: function anonymous(dtype, CTOR_LIST, ORDER) {\n          function View(a, b0, b1, b2, b3, b4, c0, c1, c2, c3, c4, d) {\n            this.data = a;\n            this.shape = [b0, b1, b2, b3, b4];\n            this.stride = [c0, c1, c2, c3, c4];\n            this.offset = d | 0;\n          }\n\n          var proto = View.prototype;\n          proto.dtype = dtype;\n          proto.dimension = 5;\n          Object.defineProperty(proto, \"size\", {\n            get: function size() {\n              return this.shape[0] * this.shape[1] * this.shape[2] * this.shape[3] * this.shape[4];\n            }\n          });\n          Object.defineProperty(proto, \"order\", {\n            get: ORDER\n          });\n\n          proto.set = function set(i0, i1, i2, i3, i4, v) {\n            return dtype === \"generic\" ? this.data.set(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4, v) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4] = v;\n          };\n\n          proto.get = function get(i0, i1, i2, i3, i4) {\n            return dtype === \"generic\" ? this.data.get(this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4) : this.data[this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4];\n          };\n\n          proto.index = function index(i0, i1, i2, i3, i4) {\n            return this.offset + this.stride[0] * i0 + this.stride[1] * i1 + this.stride[2] * i2 + this.stride[3] * i3 + this.stride[4] * i4;\n          };\n\n          proto.hi = function hi(i0, i1, i2, i3, i4) {\n            return new View(this.data, typeof i0 !== \"number\" || i0 < 0 ? this.shape[0] : i0 | 0, typeof i1 !== \"number\" || i1 < 0 ? this.shape[1] : i1 | 0, typeof i2 !== \"number\" || i2 < 0 ? this.shape[2] : i2 | 0, typeof i3 !== \"number\" || i3 < 0 ? this.shape[3] : i3 | 0, typeof i4 !== \"number\" || i4 < 0 ? this.shape[4] : i4 | 0, this.stride[0], this.stride[1], this.stride[2], this.stride[3], this.stride[4], this.offset);\n          };\n\n          proto.lo = function lo(i0, i1, i2, i3, i4) {\n            var b = this.offset,\n                d = 0,\n                a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                a3 = this.shape[3],\n                a4 = this.shape[4],\n                c0 = this.stride[0],\n                c1 = this.stride[1],\n                c2 = this.stride[2],\n                c3 = this.stride[3],\n                c4 = this.stride[4];\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              d = i0 | 0;\n              b += c0 * d;\n              a0 -= d;\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              d = i1 | 0;\n              b += c1 * d;\n              a1 -= d;\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              d = i2 | 0;\n              b += c2 * d;\n              a2 -= d;\n            }\n\n            if (typeof i3 === \"number\" && i3 >= 0) {\n              d = i3 | 0;\n              b += c3 * d;\n              a3 -= d;\n            }\n\n            if (typeof i4 === \"number\" && i4 >= 0) {\n              d = i4 | 0;\n              b += c4 * d;\n              a4 -= d;\n            }\n\n            return new View(this.data, a0, a1, a2, a3, a4, c0, c1, c2, c3, c4, b);\n          };\n\n          proto.step = function step(i0, i1, i2, i3, i4) {\n            var a0 = this.shape[0],\n                a1 = this.shape[1],\n                a2 = this.shape[2],\n                a3 = this.shape[3],\n                a4 = this.shape[4],\n                b0 = this.stride[0],\n                b1 = this.stride[1],\n                b2 = this.stride[2],\n                b3 = this.stride[3],\n                b4 = this.stride[4],\n                c = this.offset,\n                d = 0,\n                ceil = Math.ceil;\n\n            if (typeof i0 === \"number\") {\n              d = i0 | 0;\n\n              if (d < 0) {\n                c += b0 * (a0 - 1);\n                a0 = ceil(-a0 / d);\n              } else {\n                a0 = ceil(a0 / d);\n              }\n\n              b0 *= d;\n            }\n\n            if (typeof i1 === \"number\") {\n              d = i1 | 0;\n\n              if (d < 0) {\n                c += b1 * (a1 - 1);\n                a1 = ceil(-a1 / d);\n              } else {\n                a1 = ceil(a1 / d);\n              }\n\n              b1 *= d;\n            }\n\n            if (typeof i2 === \"number\") {\n              d = i2 | 0;\n\n              if (d < 0) {\n                c += b2 * (a2 - 1);\n                a2 = ceil(-a2 / d);\n              } else {\n                a2 = ceil(a2 / d);\n              }\n\n              b2 *= d;\n            }\n\n            if (typeof i3 === \"number\") {\n              d = i3 | 0;\n\n              if (d < 0) {\n                c += b3 * (a3 - 1);\n                a3 = ceil(-a3 / d);\n              } else {\n                a3 = ceil(a3 / d);\n              }\n\n              b3 *= d;\n            }\n\n            if (typeof i4 === \"number\") {\n              d = i4 | 0;\n\n              if (d < 0) {\n                c += b4 * (a4 - 1);\n                a4 = ceil(-a4 / d);\n              } else {\n                a4 = ceil(a4 / d);\n              }\n\n              b4 *= d;\n            }\n\n            return new View(this.data, a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, c);\n          };\n\n          proto.transpose = function transpose(i0, i1, i2, i3, i4) {\n            i0 = i0 === undefined ? 0 : i0 | 0;\n            i1 = i1 === undefined ? 1 : i1 | 0;\n            i2 = i2 === undefined ? 2 : i2 | 0;\n            i3 = i3 === undefined ? 3 : i3 | 0;\n            i4 = i4 === undefined ? 4 : i4 | 0;\n            var a = this.shape,\n                b = this.stride;\n            return new View(this.data, a[i0], a[i1], a[i2], a[i3], a[i4], b[i0], b[i1], b[i2], b[i3], b[i4], this.offset);\n          };\n\n          proto.pick = function pick(i0, i1, i2, i3, i4) {\n            var a = [],\n                b = [],\n                c = this.offset;\n\n            if (typeof i0 === \"number\" && i0 >= 0) {\n              c = c + this.stride[0] * i0 | 0;\n            } else {\n              a.push(this.shape[0]);\n              b.push(this.stride[0]);\n            }\n\n            if (typeof i1 === \"number\" && i1 >= 0) {\n              c = c + this.stride[1] * i1 | 0;\n            } else {\n              a.push(this.shape[1]);\n              b.push(this.stride[1]);\n            }\n\n            if (typeof i2 === \"number\" && i2 >= 0) {\n              c = c + this.stride[2] * i2 | 0;\n            } else {\n              a.push(this.shape[2]);\n              b.push(this.stride[2]);\n            }\n\n            if (typeof i3 === \"number\" && i3 >= 0) {\n              c = c + this.stride[3] * i3 | 0;\n            } else {\n              a.push(this.shape[3]);\n              b.push(this.stride[3]);\n            }\n\n            if (typeof i4 === \"number\" && i4 >= 0) {\n              c = c + this.stride[4] * i4 | 0;\n            } else {\n              a.push(this.shape[4]);\n              b.push(this.stride[4]);\n            }\n\n            var ctor = CTOR_LIST[a.length + 1];\n            return ctor(this.data, a, b, c);\n          };\n\n          return function construct(data, shape, stride, offset) {\n            return new View(data, shape[0], shape[1], shape[2], shape[3], shape[4], stride[0], stride[1], stride[2], stride[3], stride[4], offset);\n          };\n        }\n      };\n\n      function compileConstructor(inType, inDimension) {\n        var dKey = inDimension === -1 ? 'T' : String(inDimension);\n        var procedure = allFns[dKey];\n\n        if (inDimension === -1) {\n          return procedure(inType);\n        } else if (inDimension === 0) {\n          return procedure(inType, CACHED_CONSTRUCTORS[inType][0]);\n        }\n\n        return procedure(inType, CACHED_CONSTRUCTORS[inType], order);\n      }\n\n      function arrayDType(data) {\n        if (isBuffer(data)) {\n          return \"buffer\";\n        }\n\n        if (hasTypedArrays) {\n          switch (Object.prototype.toString.call(data)) {\n            case \"[object Float64Array]\":\n              return \"float64\";\n\n            case \"[object Float32Array]\":\n              return \"float32\";\n\n            case \"[object Int8Array]\":\n              return \"int8\";\n\n            case \"[object Int16Array]\":\n              return \"int16\";\n\n            case \"[object Int32Array]\":\n              return \"int32\";\n\n            case \"[object Uint8ClampedArray]\":\n              return \"uint8_clamped\";\n\n            case \"[object Uint8Array]\":\n              return \"uint8\";\n\n            case \"[object Uint16Array]\":\n              return \"uint16\";\n\n            case \"[object Uint32Array]\":\n              return \"uint32\";\n\n            case \"[object BigInt64Array]\":\n              return \"bigint64\";\n\n            case \"[object BigUint64Array]\":\n              return \"biguint64\";\n          }\n        }\n\n        if (Array.isArray(data)) {\n          return \"array\";\n        }\n\n        return \"generic\";\n      }\n\n      var CACHED_CONSTRUCTORS = {\n        \"generic\": [],\n        \"buffer\": [],\n        \"array\": [],\n        // typed arrays\n        \"float32\": [],\n        \"float64\": [],\n        \"int8\": [],\n        \"int16\": [],\n        \"int32\": [],\n        \"uint8_clamped\": [],\n        \"uint8\": [],\n        \"uint16\": [],\n        \"uint32\": [],\n        \"bigint64\": [],\n        \"biguint64\": []\n      };\n\n      (function () {\n        for (var id in CACHED_CONSTRUCTORS) {\n          CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));\n        }\n      });\n\n      function wrappedNDArrayCtor(data, shape, stride, offset) {\n        if (data === undefined) {\n          var ctor = CACHED_CONSTRUCTORS.array[0];\n          return ctor([]);\n        } else if (typeof data === \"number\") {\n          data = [data];\n        }\n\n        if (shape === undefined) {\n          shape = [data.length];\n        }\n\n        var d = shape.length;\n\n        if (stride === undefined) {\n          stride = new Array(d);\n\n          for (var i = d - 1, sz = 1; i >= 0; --i) {\n            stride[i] = sz;\n            sz *= shape[i];\n          }\n        }\n\n        if (offset === undefined) {\n          offset = 0;\n\n          for (var i = 0; i < d; ++i) {\n            if (stride[i] < 0) {\n              offset -= (shape[i] - 1) * stride[i];\n            }\n          }\n        }\n\n        var inType = arrayDType(data);\n        var ctor_list = CACHED_CONSTRUCTORS[inType];\n\n        while (ctor_list.length <= d + 1) {\n          ctor_list.push(compileConstructor(inType, ctor_list.length - 1));\n        }\n\n        var ctor = ctor_list[d + 1];\n        return ctor(data, shape, stride, offset);\n      }\n\n      module.exports = wrappedNDArrayCtor;\n    }, {\n      \"is-buffer\": 237\n    }],\n    260: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var doubleBits = _glvis_(\"double-bits\");\n\n      var SMALLEST_DENORM = Math.pow(2, -1074);\n      var UINT_MAX = -1 >>> 0;\n      module.exports = nextafter;\n\n      function nextafter(x, y) {\n        if (isNaN(x) || isNaN(y)) {\n          return NaN;\n        }\n\n        if (x === y) {\n          return x;\n        }\n\n        if (x === 0) {\n          if (y < 0) {\n            return -SMALLEST_DENORM;\n          } else {\n            return SMALLEST_DENORM;\n          }\n        }\n\n        var hi = doubleBits.hi(x);\n        var lo = doubleBits.lo(x);\n\n        if (y > x === x > 0) {\n          if (lo === UINT_MAX) {\n            hi += 1;\n            lo = 0;\n          } else {\n            lo += 1;\n          }\n        } else {\n          if (lo === 0) {\n            lo = UINT_MAX;\n            hi -= 1;\n          } else {\n            lo -= 1;\n          }\n        }\n\n        return doubleBits.pack(lo, hi);\n      }\n    }, {\n      \"double-bits\": 64\n    }],\n    261: [function (_glvis_, module, exports) {\n      var DEFAULT_NORMALS_EPSILON = 1e-6;\n      var DEFAULT_FACE_EPSILON = 1e-6; //Estimate the vertex normals of a mesh\n\n      exports.vertexNormals = function (faces, positions, specifiedEpsilon) {\n        var N = positions.length;\n        var normals = new Array(N);\n        var epsilon = specifiedEpsilon === void 0 ? DEFAULT_NORMALS_EPSILON : specifiedEpsilon; //Initialize normal array\n\n        for (var i = 0; i < N; ++i) {\n          normals[i] = [0.0, 0.0, 0.0];\n        } //Walk over all the faces and add per-vertex contribution to normal weights\n\n\n        for (var i = 0; i < faces.length; ++i) {\n          var f = faces[i];\n          var p = 0;\n          var c = f[f.length - 1];\n          var n = f[0];\n\n          for (var j = 0; j < f.length; ++j) {\n            //Shift indices back\n            p = c;\n            c = n;\n            n = f[(j + 1) % f.length];\n            var v0 = positions[p];\n            var v1 = positions[c];\n            var v2 = positions[n]; //Compute infineteismal arcs\n\n            var d01 = new Array(3);\n            var m01 = 0.0;\n            var d21 = new Array(3);\n            var m21 = 0.0;\n\n            for (var k = 0; k < 3; ++k) {\n              d01[k] = v0[k] - v1[k];\n              m01 += d01[k] * d01[k];\n              d21[k] = v2[k] - v1[k];\n              m21 += d21[k] * d21[k];\n            } //Accumulate values in normal\n\n\n            if (m01 * m21 > epsilon) {\n              var norm = normals[c];\n              var w = 1.0 / Math.sqrt(m01 * m21);\n\n              for (var k = 0; k < 3; ++k) {\n                var u = (k + 1) % 3;\n                var v = (k + 2) % 3;\n                norm[k] += w * (d21[u] * d01[v] - d21[v] * d01[u]);\n              }\n            }\n          }\n        } //Scale all normals to unit length\n\n\n        for (var i = 0; i < N; ++i) {\n          var norm = normals[i];\n          var m = 0.0;\n\n          for (var k = 0; k < 3; ++k) {\n            m += norm[k] * norm[k];\n          }\n\n          if (m > epsilon) {\n            var w = 1.0 / Math.sqrt(m);\n\n            for (var k = 0; k < 3; ++k) {\n              norm[k] *= w;\n            }\n          } else {\n            for (var k = 0; k < 3; ++k) {\n              norm[k] = 0.0;\n            }\n          }\n        } //Return the resulting set of patches\n\n\n        return normals;\n      }; //Compute face normals of a mesh\n\n\n      exports.faceNormals = function (faces, positions, specifiedEpsilon) {\n        var N = faces.length;\n        var normals = new Array(N);\n        var epsilon = specifiedEpsilon === void 0 ? DEFAULT_FACE_EPSILON : specifiedEpsilon;\n\n        for (var i = 0; i < N; ++i) {\n          var f = faces[i];\n          var pos = new Array(3);\n\n          for (var j = 0; j < 3; ++j) {\n            pos[j] = positions[f[j]];\n          }\n\n          var d01 = new Array(3);\n          var d21 = new Array(3);\n\n          for (var j = 0; j < 3; ++j) {\n            d01[j] = pos[1][j] - pos[0][j];\n            d21[j] = pos[2][j] - pos[0][j];\n          }\n\n          var n = new Array(3);\n          var l = 0.0;\n\n          for (var j = 0; j < 3; ++j) {\n            var u = (j + 1) % 3;\n            var v = (j + 2) % 3;\n            n[j] = d01[u] * d21[v] - d01[v] * d21[u];\n            l += n[j] * n[j];\n          }\n\n          if (l > epsilon) {\n            l = 1.0 / Math.sqrt(l);\n          } else {\n            l = 0.0;\n          }\n\n          for (var j = 0; j < 3; ++j) {\n            n[j] *= l;\n          }\n\n          normals[i] = n;\n        }\n\n        return normals;\n      };\n    }, {}],\n    262: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = quatFromFrame;\n\n      function quatFromFrame(out, rx, ry, rz, ux, uy, uz, fx, fy, fz) {\n        var tr = rx + uy + fz;\n\n        if (l > 0) {\n          var l = Math.sqrt(tr + 1.0);\n          out[0] = 0.5 * (uz - fy) / l;\n          out[1] = 0.5 * (fx - rz) / l;\n          out[2] = 0.5 * (ry - uy) / l;\n          out[3] = 0.5 * l;\n        } else {\n          var tf = Math.max(rx, uy, fz);\n          var l = Math.sqrt(2 * tf - tr + 1.0);\n\n          if (rx >= tf) {\n            //x y z  order\n            out[0] = 0.5 * l;\n            out[1] = 0.5 * (ux + ry) / l;\n            out[2] = 0.5 * (fx + rz) / l;\n            out[3] = 0.5 * (uz - fy) / l;\n          } else if (uy >= tf) {\n            //y z x  order\n            out[0] = 0.5 * (ry + ux) / l;\n            out[1] = 0.5 * l;\n            out[2] = 0.5 * (fy + uz) / l;\n            out[3] = 0.5 * (fx - rz) / l;\n          } else {\n            //z x y  order\n            out[0] = 0.5 * (rz + fx) / l;\n            out[1] = 0.5 * (uz + fy) / l;\n            out[2] = 0.5 * l;\n            out[3] = 0.5 * (ry - ux) / l;\n          }\n        }\n\n        return out;\n      }\n    }, {}],\n    263: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createOrbitController;\n\n      var filterVector = _glvis_('filtered-vector');\n\n      var lookAt = _glvis_('gl-mat4/lookAt');\n\n      var mat4FromQuat = _glvis_('gl-mat4/fromQuat');\n\n      var invert44 = _glvis_('gl-mat4/invert');\n\n      var quatFromFrame = _glvis_('./lib/quatFromFrame');\n\n      function len3(x, y, z) {\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n      }\n\n      function len4(w, x, y, z) {\n        return Math.sqrt(Math.pow(w, 2) + Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n      }\n\n      function normalize4(out, a) {\n        var ax = a[0];\n        var ay = a[1];\n        var az = a[2];\n        var aw = a[3];\n        var al = len4(ax, ay, az, aw);\n\n        if (al > 1e-6) {\n          out[0] = ax / al;\n          out[1] = ay / al;\n          out[2] = az / al;\n          out[3] = aw / al;\n        } else {\n          out[0] = out[1] = out[2] = 0.0;\n          out[3] = 1.0;\n        }\n      }\n\n      function OrbitCameraController(initQuat, initCenter, initRadius) {\n        this.radius = filterVector([initRadius]);\n        this.center = filterVector(initCenter);\n        this.rotation = filterVector(initQuat);\n        this.computedRadius = this.radius.curve(0);\n        this.computedCenter = this.center.curve(0);\n        this.computedRotation = this.rotation.curve(0);\n        this.computedUp = [0.1, 0, 0];\n        this.computedEye = [0.1, 0, 0];\n        this.computedMatrix = [0.1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this.recalcMatrix(0);\n      }\n\n      var proto = OrbitCameraController.prototype;\n\n      proto.lastT = function () {\n        return Math.max(this.radius.lastT(), this.center.lastT(), this.rotation.lastT());\n      };\n\n      proto.recalcMatrix = function (t) {\n        this.radius.curve(t);\n        this.center.curve(t);\n        this.rotation.curve(t);\n        var quat = this.computedRotation;\n        normalize4(quat, quat);\n        var mat = this.computedMatrix;\n        mat4FromQuat(mat, quat);\n        var center = this.computedCenter;\n        var eye = this.computedEye;\n        var up = this.computedUp;\n        var radius = Math.exp(this.computedRadius[0]);\n        eye[0] = center[0] + radius * mat[2];\n        eye[1] = center[1] + radius * mat[6];\n        eye[2] = center[2] + radius * mat[10];\n        up[0] = mat[1];\n        up[1] = mat[5];\n        up[2] = mat[9];\n\n        for (var i = 0; i < 3; ++i) {\n          var rr = 0.0;\n\n          for (var j = 0; j < 3; ++j) {\n            rr += mat[i + 4 * j] * eye[j];\n          }\n\n          mat[12 + i] = -rr;\n        }\n      };\n\n      proto.getMatrix = function (t, result) {\n        this.recalcMatrix(t);\n        var m = this.computedMatrix;\n\n        if (result) {\n          for (var i = 0; i < 16; ++i) {\n            result[i] = m[i];\n          }\n\n          return result;\n        }\n\n        return m;\n      };\n\n      proto.idle = function (t) {\n        this.center.idle(t);\n        this.radius.idle(t);\n        this.rotation.idle(t);\n      };\n\n      proto.flush = function (t) {\n        this.center.flush(t);\n        this.radius.flush(t);\n        this.rotation.flush(t);\n      };\n\n      proto.pan = function (t, dx, dy, dz) {\n        dx = dx || 0.0;\n        dy = dy || 0.0;\n        dz = dz || 0.0;\n        this.recalcMatrix(t);\n        var mat = this.computedMatrix;\n        var ux = mat[1];\n        var uy = mat[5];\n        var uz = mat[9];\n        var ul = len3(ux, uy, uz);\n        ux /= ul;\n        uy /= ul;\n        uz /= ul;\n        var rx = mat[0];\n        var ry = mat[4];\n        var rz = mat[8];\n        var ru = rx * ux + ry * uy + rz * uz;\n        rx -= ux * ru;\n        ry -= uy * ru;\n        rz -= uz * ru;\n        var rl = len3(rx, ry, rz);\n        rx /= rl;\n        ry /= rl;\n        rz /= rl;\n        var fx = mat[2];\n        var fy = mat[6];\n        var fz = mat[10];\n        var fu = fx * ux + fy * uy + fz * uz;\n        var fr = fx * rx + fy * ry + fz * rz;\n        fx -= fu * ux + fr * rx;\n        fy -= fu * uy + fr * ry;\n        fz -= fu * uz + fr * rz;\n        var fl = len3(fx, fy, fz);\n        fx /= fl;\n        fy /= fl;\n        fz /= fl;\n        var vx = rx * dx + ux * dy;\n        var vy = ry * dx + uy * dy;\n        var vz = rz * dx + uz * dy;\n        this.center.move(t, vx, vy, vz); //Update z-component of radius\n\n        var radius = Math.exp(this.computedRadius[0]);\n        radius = Math.max(1e-4, radius + dz);\n        this.radius.set(t, Math.log(radius));\n      };\n\n      proto.rotate = function (t, dx, dy, dz) {\n        this.recalcMatrix(t);\n        dx = dx || 0.0;\n        dy = dy || 0.0;\n        var mat = this.computedMatrix;\n        var rx = mat[0];\n        var ry = mat[4];\n        var rz = mat[8];\n        var ux = mat[1];\n        var uy = mat[5];\n        var uz = mat[9];\n        var fx = mat[2];\n        var fy = mat[6];\n        var fz = mat[10];\n        var qx = dx * rx + dy * ux;\n        var qy = dx * ry + dy * uy;\n        var qz = dx * rz + dy * uz;\n        var bx = -(fy * qz - fz * qy);\n        var by = -(fz * qx - fx * qz);\n        var bz = -(fx * qy - fy * qx);\n        var bw = Math.sqrt(Math.max(0.0, 1.0 - Math.pow(bx, 2) - Math.pow(by, 2) - Math.pow(bz, 2)));\n        var bl = len4(bx, by, bz, bw);\n\n        if (bl > 1e-6) {\n          bx /= bl;\n          by /= bl;\n          bz /= bl;\n          bw /= bl;\n        } else {\n          bx = by = bz = 0.0;\n          bw = 1.0;\n        }\n\n        var rotation = this.computedRotation;\n        var ax = rotation[0];\n        var ay = rotation[1];\n        var az = rotation[2];\n        var aw = rotation[3];\n        var cx = ax * bw + aw * bx + ay * bz - az * by;\n        var cy = ay * bw + aw * by + az * bx - ax * bz;\n        var cz = az * bw + aw * bz + ax * by - ay * bx;\n        var cw = aw * bw - ax * bx - ay * by - az * bz; //Apply roll\n\n        if (dz) {\n          bx = fx;\n          by = fy;\n          bz = fz;\n          var s = Math.sin(dz) / len3(bx, by, bz);\n          bx *= s;\n          by *= s;\n          bz *= s;\n          bw = Math.cos(dx);\n          cx = cx * bw + cw * bx + cy * bz - cz * by;\n          cy = cy * bw + cw * by + cz * bx - cx * bz;\n          cz = cz * bw + cw * bz + cx * by - cy * bx;\n          cw = cw * bw - cx * bx - cy * by - cz * bz;\n        }\n\n        var cl = len4(cx, cy, cz, cw);\n\n        if (cl > 1e-6) {\n          cx /= cl;\n          cy /= cl;\n          cz /= cl;\n          cw /= cl;\n        } else {\n          cx = cy = cz = 0.0;\n          cw = 1.0;\n        }\n\n        this.rotation.set(t, cx, cy, cz, cw);\n      };\n\n      proto.lookAt = function (t, eye, center, up) {\n        this.recalcMatrix(t);\n        center = center || this.computedCenter;\n        eye = eye || this.computedEye;\n        up = up || this.computedUp;\n        var mat = this.computedMatrix;\n        lookAt(mat, eye, center, up);\n        var rotation = this.computedRotation;\n        quatFromFrame(rotation, mat[0], mat[1], mat[2], mat[4], mat[5], mat[6], mat[8], mat[9], mat[10]);\n        normalize4(rotation, rotation);\n        this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);\n        var fl = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          fl += Math.pow(center[i] - eye[i], 2);\n        }\n\n        this.radius.set(t, 0.5 * Math.log(Math.max(fl, 1e-6)));\n        this.center.set(t, center[0], center[1], center[2]);\n      };\n\n      proto.translate = function (t, dx, dy, dz) {\n        this.center.move(t, dx || 0.0, dy || 0.0, dz || 0.0);\n      };\n\n      proto.setMatrix = function (t, matrix) {\n        var rotation = this.computedRotation;\n        quatFromFrame(rotation, matrix[0], matrix[1], matrix[2], matrix[4], matrix[5], matrix[6], matrix[8], matrix[9], matrix[10]);\n        normalize4(rotation, rotation);\n        this.rotation.set(t, rotation[0], rotation[1], rotation[2], rotation[3]);\n        var mat = this.computedMatrix;\n        invert44(mat, matrix);\n        var w = mat[15];\n\n        if (Math.abs(w) > 1e-6) {\n          var cx = mat[12] / w;\n          var cy = mat[13] / w;\n          var cz = mat[14] / w;\n          this.recalcMatrix(t);\n          var r = Math.exp(this.computedRadius[0]);\n          this.center.set(t, cx - mat[2] * r, cy - mat[6] * r, cz - mat[10] * r);\n          this.radius.idle(t);\n        } else {\n          this.center.idle(t);\n          this.radius.idle(t);\n        }\n      };\n\n      proto.setDistance = function (t, d) {\n        if (d > 0) {\n          this.radius.set(t, Math.log(d));\n        }\n      };\n\n      proto.setDistanceLimits = function (lo, hi) {\n        if (lo > 0) {\n          lo = Math.log(lo);\n        } else {\n          lo = -Infinity;\n        }\n\n        if (hi > 0) {\n          hi = Math.log(hi);\n        } else {\n          hi = Infinity;\n        }\n\n        hi = Math.max(hi, lo);\n        this.radius.bounds[0][0] = lo;\n        this.radius.bounds[1][0] = hi;\n      };\n\n      proto.getDistanceLimits = function (out) {\n        var bounds = this.radius.bounds;\n\n        if (out) {\n          out[0] = Math.exp(bounds[0][0]);\n          out[1] = Math.exp(bounds[1][0]);\n          return out;\n        }\n\n        return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];\n      };\n\n      proto.toJSON = function () {\n        this.recalcMatrix(this.lastT());\n        return {\n          center: this.computedCenter.slice(),\n          rotation: this.computedRotation.slice(),\n          distance: Math.log(this.computedRadius[0]),\n          zoomMin: this.radius.bounds[0][0],\n          zoomMax: this.radius.bounds[1][0]\n        };\n      };\n\n      proto.fromJSON = function (options) {\n        var t = this.lastT();\n        var c = options.center;\n\n        if (c) {\n          this.center.set(t, c[0], c[1], c[2]);\n        }\n\n        var r = options.rotation;\n\n        if (r) {\n          this.rotation.set(t, r[0], r[1], r[2], r[3]);\n        }\n\n        var d = options.distance;\n\n        if (d && d > 0) {\n          this.radius.set(t, Math.log(d));\n        }\n\n        this.setDistanceLimits(options.zoomMin, options.zoomMax);\n      };\n\n      function createOrbitController(options) {\n        options = options || {};\n        var center = options.center || [0, 0, 0];\n        var rotation = options.rotation || [0, 0, 0, 1];\n        var radius = options.radius || 1.0;\n        center = [].slice.call(center, 0, 3);\n        rotation = [].slice.call(rotation, 0, 4);\n        normalize4(rotation, rotation);\n        var result = new OrbitCameraController(rotation, center, Math.log(radius));\n        result.setDistanceLimits(options.zoomMin, options.zoomMax);\n\n        if ('eye' in options || 'up' in options) {\n          result.lookAt(0, options.eye, options.center, options.up);\n        }\n\n        return result;\n      }\n    }, {\n      \"./lib/quatFromFrame\": 262,\n      \"filtered-vector\": 68,\n      \"gl-mat4/fromQuat\": 95,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/lookAt\": 99\n    }],\n    264: [function (_glvis_, module, exports) {\n      /*!\n       * pad-left <https://github.com/jonschlinkert/pad-left>\n       *\n       * Copyright (c) 2014-2015, Jon Schlinkert.\n       * Licensed under the MIT license.\n       */\n      'use strict';\n\n      var repeat = _glvis_('repeat-string');\n\n      module.exports = function padLeft(str, num, ch) {\n        ch = typeof ch !== 'undefined' ? ch + '' : ' ';\n        return repeat(ch, num) + str;\n      };\n    }, {\n      \"repeat-string\": 277\n    }],\n    265: [function (_glvis_, module, exports) {\n      module.exports = function parseUnit(str, out) {\n        if (!out) out = [0, ''];\n        str = String(str);\n        var num = parseFloat(str, 10);\n        out[0] = num;\n        out[1] = str.match(/[\\d.\\-\\+]*\\s*(.*)/)[1] || '';\n        return out;\n      };\n    }, {}],\n    266: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = planarDual;\n\n      var compareAngle = _glvis_(\"compare-angle\");\n\n      function planarDual(cells, positions) {\n        var numVertices = positions.length | 0;\n        var numEdges = cells.length;\n        var adj = [new Array(numVertices), new Array(numVertices)];\n\n        for (var i = 0; i < numVertices; ++i) {\n          adj[0][i] = [];\n          adj[1][i] = [];\n        }\n\n        for (var i = 0; i < numEdges; ++i) {\n          var c = cells[i];\n          adj[0][c[0]].push(c);\n          adj[1][c[1]].push(c);\n        }\n\n        var cycles = []; //Add isolated vertices as trivial case\n\n        for (var i = 0; i < numVertices; ++i) {\n          if (adj[0][i].length + adj[1][i].length === 0) {\n            cycles.push([i]);\n          }\n        } //Remove a half edge\n\n\n        function cut(c, i) {\n          var a = adj[i][c[i]];\n          a.splice(a.indexOf(c), 1);\n        } //Find next vertex and cut edge\n\n\n        function next(a, b, noCut) {\n          var nextCell, nextVertex, nextDir;\n\n          for (var i = 0; i < 2; ++i) {\n            if (adj[i][b].length > 0) {\n              nextCell = adj[i][b][0];\n              nextDir = i;\n              break;\n            }\n          }\n\n          nextVertex = nextCell[nextDir ^ 1];\n\n          for (var dir = 0; dir < 2; ++dir) {\n            var nbhd = adj[dir][b];\n\n            for (var k = 0; k < nbhd.length; ++k) {\n              var e = nbhd[k];\n              var p = e[dir ^ 1];\n              var cmp = compareAngle(positions[a], positions[b], positions[nextVertex], positions[p]);\n\n              if (cmp > 0) {\n                nextCell = e;\n                nextVertex = p;\n                nextDir = dir;\n              }\n            }\n          }\n\n          if (noCut) {\n            return nextVertex;\n          }\n\n          if (nextCell) {\n            cut(nextCell, nextDir);\n          }\n\n          return nextVertex;\n        }\n\n        function extractCycle(v, dir) {\n          var e0 = adj[dir][v][0];\n          var cycle = [v];\n          cut(e0, dir);\n          var u = e0[dir ^ 1];\n          var d0 = dir;\n\n          while (true) {\n            while (u !== v) {\n              cycle.push(u);\n              u = next(cycle[cycle.length - 2], u, false);\n            }\n\n            if (adj[0][v].length + adj[1][v].length === 0) {\n              break;\n            }\n\n            var a = cycle[cycle.length - 1];\n            var b = v;\n            var c = cycle[1];\n            var d = next(a, b, true);\n\n            if (compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n              break;\n            }\n\n            cycle.push(v);\n            u = next(a, b);\n          }\n\n          return cycle;\n        }\n\n        function shouldGlue(pcycle, ncycle) {\n          return ncycle[1] === ncycle[ncycle.length - 1];\n        }\n\n        for (var i = 0; i < numVertices; ++i) {\n          for (var j = 0; j < 2; ++j) {\n            var pcycle = [];\n\n            while (adj[j][i].length > 0) {\n              var ni = adj[0][i].length;\n              var ncycle = extractCycle(i, j);\n\n              if (shouldGlue(pcycle, ncycle)) {\n                //Glue together trivial cycles\n                pcycle.push.apply(pcycle, ncycle);\n              } else {\n                if (pcycle.length > 0) {\n                  cycles.push(pcycle);\n                }\n\n                pcycle = ncycle;\n              }\n            }\n\n            if (pcycle.length > 0) {\n              cycles.push(pcycle);\n            }\n          }\n        } //Combine paths and loops together\n\n\n        return cycles;\n      }\n    }, {\n      \"compare-angle\": 54\n    }],\n    267: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = trimLeaves;\n\n      var e2a = _glvis_('edges-to-adjacency-list');\n\n      function trimLeaves(edges, positions) {\n        var adj = e2a(edges, positions.length);\n        var live = new Array(positions.length);\n        var nbhd = new Array(positions.length);\n        var dead = [];\n\n        for (var i = 0; i < positions.length; ++i) {\n          var count = adj[i].length;\n          nbhd[i] = count;\n          live[i] = true;\n\n          if (count <= 1) {\n            dead.push(i);\n          }\n        }\n\n        while (dead.length > 0) {\n          var v = dead.pop();\n          live[v] = false;\n          var n = adj[v];\n\n          for (var i = 0; i < n.length; ++i) {\n            var u = n[i];\n\n            if (--nbhd[u] === 0) {\n              dead.push(u);\n            }\n          }\n        }\n\n        var newIndex = new Array(positions.length);\n        var npositions = [];\n\n        for (var i = 0; i < positions.length; ++i) {\n          if (live[i]) {\n            var v = npositions.length;\n            newIndex[i] = v;\n            npositions.push(positions[i]);\n          } else {\n            newIndex[i] = -1;\n          }\n        }\n\n        var nedges = [];\n\n        for (var i = 0; i < edges.length; ++i) {\n          var e = edges[i];\n\n          if (live[e[0]] && live[e[1]]) {\n            nedges.push([newIndex[e[0]], newIndex[e[1]]]);\n          }\n        }\n\n        return [nedges, npositions];\n      }\n    }, {\n      \"edges-to-adjacency-list\": 66\n    }],\n    268: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = planarGraphToPolyline;\n\n      var e2a = _glvis_('edges-to-adjacency-list');\n\n      var planarDual = _glvis_('planar-dual');\n\n      var preprocessPolygon = _glvis_('point-in-big-polygon');\n\n      var twoProduct = _glvis_('two-product');\n\n      var robustSum = _glvis_('robust-sum');\n\n      var uniq = _glvis_('uniq');\n\n      var trimLeaves = _glvis_('./lib/trim-leaves');\n\n      function makeArray(length, fill) {\n        var result = new Array(length);\n\n        for (var i = 0; i < length; ++i) {\n          result[i] = fill;\n        }\n\n        return result;\n      }\n\n      function makeArrayOfArrays(length) {\n        var result = new Array(length);\n\n        for (var i = 0; i < length; ++i) {\n          result[i] = [];\n        }\n\n        return result;\n      }\n\n      function planarGraphToPolyline(edges, positions) {\n        //Trim leaves\n        var result = trimLeaves(edges, positions);\n        edges = result[0];\n        positions = result[1];\n        var numVertices = positions.length;\n        var numEdges = edges.length; //Calculate adjacency list, check manifold\n\n        var adj = e2a(edges, positions.length);\n\n        for (var i = 0; i < numVertices; ++i) {\n          if (adj[i].length % 2 === 1) {\n            throw new Error('planar-graph-to-polyline: graph must be manifold');\n          }\n        } //Get faces\n\n\n        var faces = planarDual(edges, positions); //Check orientation of a polygon using exact arithmetic\n\n        function ccw(c) {\n          var n = c.length;\n          var area = [0];\n\n          for (var j = 0; j < n; ++j) {\n            var a = positions[c[j]];\n            var b = positions[c[(j + 1) % n]];\n            var t00 = twoProduct(-a[0], a[1]);\n            var t01 = twoProduct(-a[0], b[1]);\n            var t10 = twoProduct(b[0], a[1]);\n            var t11 = twoProduct(b[0], b[1]);\n            area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));\n          }\n\n          return area[area.length - 1] > 0;\n        } //Extract all clockwise faces\n\n\n        faces = faces.filter(ccw); //Detect which loops are contained in one another to handle parent-of relation\n\n        var numFaces = faces.length;\n        var parent = new Array(numFaces);\n        var containment = new Array(numFaces);\n\n        for (var i = 0; i < numFaces; ++i) {\n          parent[i] = i;\n          var row = new Array(numFaces);\n          var loopVertices = faces[i].map(function (v) {\n            return positions[v];\n          });\n          var pmc = preprocessPolygon([loopVertices]);\n          var count = 0;\n\n          outer: for (var j = 0; j < numFaces; ++j) {\n            row[j] = 0;\n\n            if (i === j) {\n              continue;\n            }\n\n            var c = faces[j];\n            var n = c.length;\n\n            for (var k = 0; k < n; ++k) {\n              var d = pmc(positions[c[k]]);\n\n              if (d !== 0) {\n                if (d < 0) {\n                  row[j] = 1;\n                  count += 1;\n                }\n\n                continue outer;\n              }\n            }\n\n            row[j] = 1;\n            count += 1;\n          }\n\n          containment[i] = [count, i, row];\n        }\n\n        containment.sort(function (a, b) {\n          return b[0] - a[0];\n        });\n\n        for (var i = 0; i < numFaces; ++i) {\n          var row = containment[i];\n          var idx = row[1];\n          var children = row[2];\n\n          for (var j = 0; j < numFaces; ++j) {\n            if (children[j]) {\n              parent[j] = idx;\n            }\n          }\n        } //Initialize face adjacency list\n\n\n        var fadj = makeArrayOfArrays(numFaces);\n\n        for (var i = 0; i < numFaces; ++i) {\n          fadj[i].push(parent[i]);\n          fadj[parent[i]].push(i);\n        } //Build adjacency matrix for edges\n\n\n        var edgeAdjacency = {};\n        var internalVertices = makeArray(numVertices, false);\n\n        for (var i = 0; i < numFaces; ++i) {\n          var c = faces[i];\n          var n = c.length;\n\n          for (var j = 0; j < n; ++j) {\n            var a = c[j];\n            var b = c[(j + 1) % n];\n            var key = Math.min(a, b) + \":\" + Math.max(a, b);\n\n            if (key in edgeAdjacency) {\n              var neighbor = edgeAdjacency[key];\n              fadj[neighbor].push(i);\n              fadj[i].push(neighbor);\n              internalVertices[a] = internalVertices[b] = true;\n            } else {\n              edgeAdjacency[key] = i;\n            }\n          }\n        }\n\n        function sharedBoundary(c) {\n          var n = c.length;\n\n          for (var i = 0; i < n; ++i) {\n            if (!internalVertices[c[i]]) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n\n        var toVisit = [];\n        var parity = makeArray(numFaces, -1);\n\n        for (var i = 0; i < numFaces; ++i) {\n          if (parent[i] === i && !sharedBoundary(faces[i])) {\n            toVisit.push(i);\n            parity[i] = 0;\n          } else {\n            parity[i] = -1;\n          }\n        } //Using face adjacency, classify faces as in/out\n\n\n        var result = [];\n\n        while (toVisit.length > 0) {\n          var top = toVisit.pop();\n          var nbhd = fadj[top];\n          uniq(nbhd, function (a, b) {\n            return a - b;\n          });\n          var nnbhr = nbhd.length;\n          var p = parity[top];\n          var polyline;\n\n          if (p === 0) {\n            var c = faces[top];\n            polyline = [c];\n          }\n\n          for (var i = 0; i < nnbhr; ++i) {\n            var f = nbhd[i];\n\n            if (parity[f] >= 0) {\n              continue;\n            }\n\n            parity[f] = p ^ 1;\n            toVisit.push(f);\n\n            if (p === 0) {\n              var c = faces[f];\n\n              if (!sharedBoundary(c)) {\n                c.reverse();\n                polyline.push(c);\n              }\n            }\n          }\n\n          if (p === 0) {\n            result.push(polyline);\n          }\n        }\n\n        return result;\n      }\n    }, {\n      \"./lib/trim-leaves\": 267,\n      \"edges-to-adjacency-list\": 66,\n      \"planar-dual\": 266,\n      \"point-in-big-polygon\": 269,\n      \"robust-sum\": 289,\n      \"two-product\": 306,\n      \"uniq\": 310\n    }],\n    269: [function (_glvis_, module, exports) {\n      module.exports = preprocessPolygon;\n\n      var orient = _glvis_('robust-orientation')[3];\n\n      var makeSlabs = _glvis_('slab-decomposition');\n\n      var makeIntervalTree = _glvis_('interval-tree-1d');\n\n      var bsearch = _glvis_('binary-search-bounds');\n\n      function visitInterval() {\n        return true;\n      }\n\n      function intervalSearch(table) {\n        return function (x, y) {\n          var tree = table[x];\n\n          if (tree) {\n            return !!tree.queryPoint(y, visitInterval);\n          }\n\n          return false;\n        };\n      }\n\n      function buildVerticalIndex(segments) {\n        var table = {};\n\n        for (var i = 0; i < segments.length; ++i) {\n          var s = segments[i];\n          var x = s[0][0];\n          var y0 = s[0][1];\n          var y1 = s[1][1];\n          var p = [Math.min(y0, y1), Math.max(y0, y1)];\n\n          if (x in table) {\n            table[x].push(p);\n          } else {\n            table[x] = [p];\n          }\n        }\n\n        var intervalTable = {};\n        var keys = Object.keys(table);\n\n        for (var i = 0; i < keys.length; ++i) {\n          var segs = table[keys[i]];\n          intervalTable[keys[i]] = makeIntervalTree(segs);\n        }\n\n        return intervalSearch(intervalTable);\n      }\n\n      function buildSlabSearch(slabs, coordinates) {\n        return function (p) {\n          var bucket = bsearch.le(coordinates, p[0]);\n\n          if (bucket < 0) {\n            return 1;\n          }\n\n          var root = slabs[bucket];\n\n          if (!root) {\n            if (bucket > 0 && coordinates[bucket] === p[0]) {\n              root = slabs[bucket - 1];\n            } else {\n              return 1;\n            }\n          }\n\n          var lastOrientation = 1;\n\n          while (root) {\n            var s = root.key;\n            var o = orient(p, s[0], s[1]);\n\n            if (s[0][0] < s[1][0]) {\n              if (o < 0) {\n                root = root.left;\n              } else if (o > 0) {\n                lastOrientation = -1;\n                root = root.right;\n              } else {\n                return 0;\n              }\n            } else {\n              if (o > 0) {\n                root = root.left;\n              } else if (o < 0) {\n                lastOrientation = 1;\n                root = root.right;\n              } else {\n                return 0;\n              }\n            }\n          }\n\n          return lastOrientation;\n        };\n      }\n\n      function classifyEmpty(p) {\n        return 1;\n      }\n\n      function createClassifyVertical(testVertical) {\n        return function classify(p) {\n          if (testVertical(p[0], p[1])) {\n            return 0;\n          }\n\n          return 1;\n        };\n      }\n\n      function createClassifyPointDegen(testVertical, testNormal) {\n        return function classify(p) {\n          if (testVertical(p[0], p[1])) {\n            return 0;\n          }\n\n          return testNormal(p);\n        };\n      }\n\n      function preprocessPolygon(loops) {\n        //Compute number of loops\n        var numLoops = loops.length; //Unpack segments\n\n        var segments = [];\n        var vsegments = [];\n        var ptr = 0;\n\n        for (var i = 0; i < numLoops; ++i) {\n          var loop = loops[i];\n          var numVertices = loop.length;\n\n          for (var s = numVertices - 1, t = 0; t < numVertices; s = t++) {\n            var a = loop[s];\n            var b = loop[t];\n\n            if (a[0] === b[0]) {\n              vsegments.push([a, b]);\n            } else {\n              segments.push([a, b]);\n            }\n          }\n        } //Degenerate case: All loops are empty\n\n\n        if (segments.length === 0) {\n          if (vsegments.length === 0) {\n            return classifyEmpty;\n          } else {\n            return createClassifyVertical(buildVerticalIndex(vsegments));\n          }\n        } //Build slab decomposition\n\n\n        var slabs = makeSlabs(segments);\n        var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);\n\n        if (vsegments.length === 0) {\n          return testSlab;\n        } else {\n          return createClassifyPointDegen(buildVerticalIndex(vsegments), testSlab);\n        }\n      }\n    }, {\n      \"binary-search-bounds\": 31,\n      \"interval-tree-1d\": 234,\n      \"robust-orientation\": 284,\n      \"slab-decomposition\": 299\n    }],\n    270: [function (_glvis_, module, exports) {\n      //Optimized version for triangle closest point\n      // Based on Eberly's WildMagick codes\n      // http://www.geometrictools.com/LibMathematics/Distance/Distance.html\n      \"use strict\";\n\n      var diff = new Float64Array(4);\n      var edge0 = new Float64Array(4);\n      var edge1 = new Float64Array(4);\n\n      function closestPoint2d(V0, V1, V2, point, result) {\n        //Reallocate buffers if necessary\n        if (diff.length < point.length) {\n          diff = new Float64Array(point.length);\n          edge0 = new Float64Array(point.length);\n          edge1 = new Float64Array(point.length);\n        } //Compute edges\n\n\n        for (var i = 0; i < point.length; ++i) {\n          diff[i] = V0[i] - point[i];\n          edge0[i] = V1[i] - V0[i];\n          edge1[i] = V2[i] - V0[i];\n        } //Compute coefficients for quadratic func\n\n\n        var a00 = 0.0,\n            a01 = 0.0,\n            a11 = 0.0,\n            b0 = 0.0,\n            b1 = 0.0,\n            c = 0.0;\n\n        for (var i = 0; i < point.length; ++i) {\n          var e0 = edge0[i],\n              e1 = edge1[i],\n              d = diff[i];\n          a00 += e0 * e0;\n          a01 += e0 * e1;\n          a11 += e1 * e1;\n          b0 += d * e0;\n          b1 += d * e1;\n          c += d * d;\n        } //Compute determinant/coeffs\n\n\n        var det = Math.abs(a00 * a11 - a01 * a01);\n        var s = a01 * b1 - a11 * b0;\n        var t = a01 * b0 - a00 * b1;\n        var sqrDistance; //Hardcoded Voronoi diagram classification\n\n        if (s + t <= det) {\n          if (s < 0) {\n            if (t < 0) {\n              // region 4\n              if (b0 < 0) {\n                t = 0;\n\n                if (-b0 >= a00) {\n                  s = 1.0;\n                  sqrDistance = a00 + 2.0 * b0 + c;\n                } else {\n                  s = -b0 / a00;\n                  sqrDistance = b0 * s + c;\n                }\n              } else {\n                s = 0;\n\n                if (b1 >= 0) {\n                  t = 0;\n                  sqrDistance = c;\n                } else if (-b1 >= a11) {\n                  t = 1;\n                  sqrDistance = a11 + 2.0 * b1 + c;\n                } else {\n                  t = -b1 / a11;\n                  sqrDistance = b1 * t + c;\n                }\n              }\n            } else {\n              // region 3\n              s = 0;\n\n              if (b1 >= 0) {\n                t = 0;\n                sqrDistance = c;\n              } else if (-b1 >= a11) {\n                t = 1;\n                sqrDistance = a11 + 2.0 * b1 + c;\n              } else {\n                t = -b1 / a11;\n                sqrDistance = b1 * t + c;\n              }\n            }\n          } else if (t < 0) {\n            // region 5\n            t = 0;\n\n            if (b0 >= 0) {\n              s = 0;\n              sqrDistance = c;\n            } else if (-b0 >= a00) {\n              s = 1;\n              sqrDistance = a00 + 2.0 * b0 + c;\n            } else {\n              s = -b0 / a00;\n              sqrDistance = b0 * s + c;\n            }\n          } else {\n            // region 0\n            // minimum at interior point\n            var invDet = 1.0 / det;\n            s *= invDet;\n            t *= invDet;\n            sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;\n          }\n        } else {\n          var tmp0, tmp1, numer, denom;\n\n          if (s < 0) {\n            // region 2\n            tmp0 = a01 + b0;\n            tmp1 = a11 + b1;\n\n            if (tmp1 > tmp0) {\n              numer = tmp1 - tmp0;\n              denom = a00 - 2.0 * a01 + a11;\n\n              if (numer >= denom) {\n                s = 1;\n                t = 0;\n                sqrDistance = a00 + 2.0 * b0 + c;\n              } else {\n                s = numer / denom;\n                t = 1 - s;\n                sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;\n              }\n            } else {\n              s = 0;\n\n              if (tmp1 <= 0) {\n                t = 1;\n                sqrDistance = a11 + 2.0 * b1 + c;\n              } else if (b1 >= 0) {\n                t = 0;\n                sqrDistance = c;\n              } else {\n                t = -b1 / a11;\n                sqrDistance = b1 * t + c;\n              }\n            }\n          } else if (t < 0) {\n            // region 6\n            tmp0 = a01 + b1;\n            tmp1 = a00 + b0;\n\n            if (tmp1 > tmp0) {\n              numer = tmp1 - tmp0;\n              denom = a00 - 2.0 * a01 + a11;\n\n              if (numer >= denom) {\n                t = 1;\n                s = 0;\n                sqrDistance = a11 + 2.0 * b1 + c;\n              } else {\n                t = numer / denom;\n                s = 1 - t;\n                sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;\n              }\n            } else {\n              t = 0;\n\n              if (tmp1 <= 0) {\n                s = 1;\n                sqrDistance = a00 + 2.0 * b0 + c;\n              } else if (b0 >= 0) {\n                s = 0;\n                sqrDistance = c;\n              } else {\n                s = -b0 / a00;\n                sqrDistance = b0 * s + c;\n              }\n            }\n          } else {\n            // region 1\n            numer = a11 + b1 - a01 - b0;\n\n            if (numer <= 0) {\n              s = 0;\n              t = 1;\n              sqrDistance = a11 + 2.0 * b1 + c;\n            } else {\n              denom = a00 - 2.0 * a01 + a11;\n\n              if (numer >= denom) {\n                s = 1;\n                t = 0;\n                sqrDistance = a00 + 2.0 * b0 + c;\n              } else {\n                s = numer / denom;\n                t = 1 - s;\n                sqrDistance = s * (a00 * s + a01 * t + 2.0 * b0) + t * (a01 * s + a11 * t + 2.0 * b1) + c;\n              }\n            }\n          }\n        }\n\n        var u = 1.0 - s - t;\n\n        for (var i = 0; i < point.length; ++i) {\n          result[i] = u * V0[i] + s * V1[i] + t * V2[i];\n        }\n\n        if (sqrDistance < 0) {\n          return 0;\n        }\n\n        return sqrDistance;\n      }\n\n      module.exports = closestPoint2d;\n    }, {}],\n    271: [function (_glvis_, module, exports) {\n      module.exports = _glvis_('gl-quat/slerp');\n    }, {\n      \"gl-quat/slerp\": 124\n    }],\n    272: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bnadd = _glvis_('big-rat/add');\n\n      module.exports = add;\n\n      function add(a, b) {\n        var n = a.length;\n        var r = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          r[i] = bnadd(a[i], b[i]);\n        }\n\n        return r;\n      }\n    }, {\n      \"big-rat/add\": 15\n    }],\n    273: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = float2rat;\n\n      var rat = _glvis_('big-rat');\n\n      function float2rat(v) {\n        var result = new Array(v.length);\n\n        for (var i = 0; i < v.length; ++i) {\n          result[i] = rat(v[i]);\n        }\n\n        return result;\n      }\n    }, {\n      \"big-rat\": 18\n    }],\n    274: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var rat = _glvis_('big-rat');\n\n      var mul = _glvis_('big-rat/mul');\n\n      module.exports = muls;\n\n      function muls(a, x) {\n        var s = rat(x);\n        var n = a.length;\n        var r = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          r[i] = mul(a[i], s);\n        }\n\n        return r;\n      }\n    }, {\n      \"big-rat\": 18,\n      \"big-rat/mul\": 27\n    }],\n    275: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var bnsub = _glvis_('big-rat/sub');\n\n      module.exports = sub;\n\n      function sub(a, b) {\n        var n = a.length;\n        var r = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          r[i] = bnsub(a[i], b[i]);\n        }\n\n        return r;\n      }\n    }, {\n      \"big-rat/sub\": 29\n    }],\n    276: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var compareCell = _glvis_('compare-cell');\n\n      var compareOrientedCell = _glvis_('compare-oriented-cell');\n\n      var orientation = _glvis_('cell-orientation');\n\n      module.exports = reduceCellComplex;\n\n      function reduceCellComplex(cells) {\n        cells.sort(compareOrientedCell);\n        var n = cells.length;\n        var ptr = 0;\n\n        for (var i = 0; i < n; ++i) {\n          var c = cells[i];\n          var o = orientation(c);\n\n          if (o === 0) {\n            continue;\n          }\n\n          if (ptr > 0) {\n            var f = cells[ptr - 1];\n\n            if (compareCell(c, f) === 0 && orientation(f) !== o) {\n              ptr -= 1;\n              continue;\n            }\n          }\n\n          cells[ptr++] = c;\n        }\n\n        cells.length = ptr;\n        return cells;\n      }\n    }, {\n      \"cell-orientation\": 47,\n      \"compare-cell\": 56,\n      \"compare-oriented-cell\": 57\n    }],\n    277: [function (_glvis_, module, exports) {\n      /*!\n       * repeat-string <https://github.com/jonschlinkert/repeat-string>\n       *\n       * Copyright (c) 2014-2015, Jon Schlinkert.\n       * Licensed under the MIT License.\n       */\n      'use strict';\n      /**\n       * Results cache\n       */\n\n      var res = '';\n      var cache;\n      /**\n       * Expose `repeat`\n       */\n\n      module.exports = repeat;\n      /**\n       * Repeat the given `string` the specified `number`\n       * of times.\n       *\n       * **Example:**\n       *\n       * ```js\n       * var repeat = require('repeat-string');\n       * repeat('A', 5);\n       * //=> AAAAA\n       * ```\n       *\n       * @param {String} `string` The string to repeat\n       * @param {Number} `number` The number of times to repeat the string\n       * @return {String} Repeated string\n       * @api public\n       */\n\n      function repeat(str, num) {\n        if (typeof str !== 'string') {\n          throw new TypeError('expected a string');\n        } // cover common, quick use cases\n\n\n        if (num === 1) return str;\n        if (num === 2) return str + str;\n        var max = str.length * num;\n\n        if (cache !== str || typeof cache === 'undefined') {\n          cache = str;\n          res = '';\n        } else if (res.length >= max) {\n          return res.substr(0, max);\n        }\n\n        while (max > res.length && num > 1) {\n          if (num & 1) {\n            res += str;\n          }\n\n          num >>= 1;\n          str += str;\n        }\n\n        res += str;\n        res = res.substr(0, max);\n        return res;\n      }\n    }, {}],\n    278: [function (_glvis_, module, exports) {\n      (function (global) {\n        (function () {\n          module.exports = global.performance && global.performance.now ? function now() {\n            return performance.now();\n          } : Date.now || function now() {\n            return +new Date();\n          };\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    279: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = compressExpansion;\n\n      function compressExpansion(e) {\n        var m = e.length;\n        var Q = e[e.length - 1];\n        var bottom = m;\n\n        for (var i = m - 2; i >= 0; --i) {\n          var a = Q;\n          var b = e[i];\n          Q = a + b;\n          var bv = Q - a;\n          var q = b - bv;\n\n          if (q) {\n            e[--bottom] = Q;\n            Q = q;\n          }\n        }\n\n        var top = 0;\n\n        for (var i = bottom; i < m; ++i) {\n          var a = e[i];\n          var b = Q;\n          Q = a + b;\n          var bv = Q - a;\n          var q = b - bv;\n\n          if (q) {\n            e[top++] = q;\n          }\n        }\n\n        e[top++] = Q;\n        e.length = top;\n        return e;\n      }\n    }, {}],\n    280: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var twoProduct = _glvis_(\"two-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      var robustScale = _glvis_(\"robust-scale\");\n\n      var compress = _glvis_(\"robust-compress\");\n\n      var NUM_EXPANDED = 6;\n\n      function determinant_2(sum, scale, prod, compress) {\n        return function robustDeterminant2(m) {\n          return compress(sum(prod(m[0][0], m[1][1]), prod(-m[0][1], m[1][0])));\n        };\n      }\n\n      function determinant_3(sum, scale, prod, compress) {\n        return function robustDeterminant3(m) {\n          return compress(sum(scale(sum(prod(m[1][1], m[2][2]), prod(-m[1][2], m[2][1])), m[0][0]), sum(scale(sum(prod(m[1][0], m[2][2]), prod(-m[1][2], m[2][0])), -m[0][1]), scale(sum(prod(m[1][0], m[2][1]), prod(-m[1][1], m[2][0])), m[0][2]))));\n        };\n      }\n\n      function determinant_4(sum, scale, prod, compress) {\n        return function robustDeterminant4(m) {\n          return compress(sum(sum(scale(sum(scale(sum(prod(m[2][2], m[3][3]), prod(-m[2][3], m[3][2])), m[1][1]), sum(scale(sum(prod(m[2][1], m[3][3]), prod(-m[2][3], m[3][1])), -m[1][2]), scale(sum(prod(m[2][1], m[3][2]), prod(-m[2][2], m[3][1])), m[1][3]))), m[0][0]), scale(sum(scale(sum(prod(m[2][2], m[3][3]), prod(-m[2][3], m[3][2])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][3]), prod(-m[2][3], m[3][0])), -m[1][2]), scale(sum(prod(m[2][0], m[3][2]), prod(-m[2][2], m[3][0])), m[1][3]))), -m[0][1])), sum(scale(sum(scale(sum(prod(m[2][1], m[3][3]), prod(-m[2][3], m[3][1])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][3]), prod(-m[2][3], m[3][0])), -m[1][1]), scale(sum(prod(m[2][0], m[3][1]), prod(-m[2][1], m[3][0])), m[1][3]))), m[0][2]), scale(sum(scale(sum(prod(m[2][1], m[3][2]), prod(-m[2][2], m[3][1])), m[1][0]), sum(scale(sum(prod(m[2][0], m[3][2]), prod(-m[2][2], m[3][0])), -m[1][1]), scale(sum(prod(m[2][0], m[3][1]), prod(-m[2][1], m[3][0])), m[1][2]))), -m[0][3]))));\n        };\n      }\n\n      function determinant_5(sum, scale, prod, compress) {\n        return function robustDeterminant5(m) {\n          return compress(sum(sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][2]), sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), -m[2][3]), scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][4]))), m[1][1]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][3]), scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][4]))), -m[1][2])), sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][3]))), -m[1][4]))), m[0][0]), scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][2]), sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), -m[2][3]), scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][3]), scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), m[2][4]))), -m[1][2])), sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][3]))), -m[1][4]))), -m[0][1])), sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][3]), scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][3], m[4][4]), prod(-m[3][4], m[4][3])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][3]), scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), m[2][4]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][4]))), m[1][3]), scale(sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][3]))), -m[1][4]))), m[0][2]), sum(scale(sum(sum(scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][4]))), m[1][0]), scale(sum(scale(sum(prod(m[3][2], m[4][4]), prod(-m[3][4], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][4]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][4]), prod(-m[3][4], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][4]), prod(-m[3][4], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][4]))), m[1][2]), scale(sum(scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][2]))), -m[1][4]))), -m[0][3]), scale(sum(sum(scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][1]), sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), -m[2][2]), scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][3]))), m[1][0]), scale(sum(scale(sum(prod(m[3][2], m[4][3]), prod(-m[3][3], m[4][2])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][2]), scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), m[2][3]))), -m[1][1])), sum(scale(sum(scale(sum(prod(m[3][1], m[4][3]), prod(-m[3][3], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][3]), prod(-m[3][3], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][3]))), m[1][2]), scale(sum(scale(sum(prod(m[3][1], m[4][2]), prod(-m[3][2], m[4][1])), m[2][0]), sum(scale(sum(prod(m[3][0], m[4][2]), prod(-m[3][2], m[4][0])), -m[2][1]), scale(sum(prod(m[3][0], m[4][1]), prod(-m[3][1], m[4][0])), m[2][2]))), -m[1][3]))), m[0][4])))));\n        };\n      }\n\n      function compileDeterminant(n) {\n        var fn = n === 2 ? determinant_2 : n === 3 ? determinant_3 : n === 4 ? determinant_4 : n === 5 ? determinant_5 : undefined;\n        return fn(robustSum, robustScale, twoProduct, compress);\n      }\n\n      var CACHE = [function robustDeterminant0() {\n        return [0];\n      }, function robustDeterminant1(m) {\n        return [m[0][0]];\n      }];\n\n      function proc(det0, det1, det2, det3, det4, det5, CACHE, gen) {\n        return function robustDeterminant(m) {\n          switch (m.length) {\n            case 0:\n              return det0(m);\n\n            case 1:\n              return det1(m);\n\n            case 2:\n              return det2(m);\n\n            case 3:\n              return det3(m);\n\n            case 4:\n              return det4(m);\n\n            case 5:\n              return det5(m);\n          }\n\n          var det = CACHE[m.length];\n          if (!det) det = CACHE[m.length] = gen(m.length);\n          return det(m);\n        };\n      }\n\n      function generateDispatch() {\n        while (CACHE.length < NUM_EXPANDED) {\n          CACHE.push(compileDeterminant(CACHE.length));\n        }\n\n        module.exports = proc.apply(undefined, CACHE.concat([CACHE, compileDeterminant]));\n\n        for (var i = 0; i < CACHE.length; ++i) {\n          module.exports[i] = CACHE[i];\n        }\n      }\n\n      generateDispatch();\n    }, {\n      \"robust-compress\": 279,\n      \"robust-scale\": 286,\n      \"robust-sum\": 289,\n      \"two-product\": 306\n    }],\n    281: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var twoProduct = _glvis_(\"two-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      module.exports = robustDotProduct;\n\n      function robustDotProduct(a, b) {\n        var r = twoProduct(a[0], b[0]);\n\n        for (var i = 1; i < a.length; ++i) {\n          r = robustSum(r, twoProduct(a[i], b[i]));\n        }\n\n        return r;\n      }\n    }, {\n      \"robust-sum\": 289,\n      \"two-product\": 306\n    }],\n    282: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var twoProduct = _glvis_(\"two-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      var robustDiff = _glvis_(\"robust-subtract\");\n\n      var robustScale = _glvis_(\"robust-scale\");\n\n      var NUM_EXPAND = 6;\n\n      function orientation(n) {\n        var fn = n === 3 ? inSphere3 : n === 4 ? inSphere4 : n === 5 ? inSphere5 : inSphere6;\n        return fn(robustSum, robustDiff, twoProduct, robustScale);\n      }\n\n      function inSphere0() {\n        return 0;\n      }\n\n      function inSphere1() {\n        return 0;\n      }\n\n      function inSphere2() {\n        return 0;\n      }\n\n      function inSphere3(sum, diff, prod, scale) {\n        function exactInSphere3(m0, m1, m2) {\n          var w0 = prod(m0[0], m0[0]);\n          var w0m1 = scale(w0, m1[0]);\n          var w0m2 = scale(w0, m2[0]);\n          var w1 = prod(m1[0], m1[0]);\n          var w1m0 = scale(w1, m0[0]);\n          var w1m2 = scale(w1, m2[0]);\n          var w2 = prod(m2[0], m2[0]);\n          var w2m0 = scale(w2, m0[0]);\n          var w2m1 = scale(w2, m1[0]);\n          var p = sum(diff(w2m1, w1m2), diff(w1m0, w0m1));\n          var n = diff(w2m0, w0m2);\n          var d = diff(p, n);\n          return d[d.length - 1];\n        }\n\n        return exactInSphere3;\n      }\n\n      function inSphere4(sum, diff, prod, scale) {\n        function exactInSphere4(m0, m1, m2, m3) {\n          var w0 = sum(prod(m0[0], m0[0]), prod(m0[1], m0[1]));\n          var w0m1 = scale(w0, m1[0]);\n          var w0m2 = scale(w0, m2[0]);\n          var w0m3 = scale(w0, m3[0]);\n          var w1 = sum(prod(m1[0], m1[0]), prod(m1[1], m1[1]));\n          var w1m0 = scale(w1, m0[0]);\n          var w1m2 = scale(w1, m2[0]);\n          var w1m3 = scale(w1, m3[0]);\n          var w2 = sum(prod(m2[0], m2[0]), prod(m2[1], m2[1]));\n          var w2m0 = scale(w2, m0[0]);\n          var w2m1 = scale(w2, m1[0]);\n          var w2m3 = scale(w2, m3[0]);\n          var w3 = sum(prod(m3[0], m3[0]), prod(m3[1], m3[1]));\n          var w3m0 = scale(w3, m0[0]);\n          var w3m1 = scale(w3, m1[0]);\n          var w3m2 = scale(w3, m2[0]);\n          var p = sum(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))));\n          var n = sum(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))));\n          var d = diff(p, n);\n          return d[d.length - 1];\n        }\n\n        return exactInSphere4;\n      }\n\n      function inSphere5(sum, diff, prod, scale) {\n        function exactInSphere5(m0, m1, m2, m3, m4) {\n          var w0 = sum(prod(m0[0], m0[0]), sum(prod(m0[1], m0[1]), prod(m0[2], m0[2])));\n          var w0m1 = scale(w0, m1[0]);\n          var w0m2 = scale(w0, m2[0]);\n          var w0m3 = scale(w0, m3[0]);\n          var w0m4 = scale(w0, m4[0]);\n          var w1 = sum(prod(m1[0], m1[0]), sum(prod(m1[1], m1[1]), prod(m1[2], m1[2])));\n          var w1m0 = scale(w1, m0[0]);\n          var w1m2 = scale(w1, m2[0]);\n          var w1m3 = scale(w1, m3[0]);\n          var w1m4 = scale(w1, m4[0]);\n          var w2 = sum(prod(m2[0], m2[0]), sum(prod(m2[1], m2[1]), prod(m2[2], m2[2])));\n          var w2m0 = scale(w2, m0[0]);\n          var w2m1 = scale(w2, m1[0]);\n          var w2m3 = scale(w2, m3[0]);\n          var w2m4 = scale(w2, m4[0]);\n          var w3 = sum(prod(m3[0], m3[0]), sum(prod(m3[1], m3[1]), prod(m3[2], m3[2])));\n          var w3m0 = scale(w3, m0[0]);\n          var w3m1 = scale(w3, m1[0]);\n          var w3m2 = scale(w3, m2[0]);\n          var w3m4 = scale(w3, m4[0]);\n          var w4 = sum(prod(m4[0], m4[0]), sum(prod(m4[1], m4[1]), prod(m4[2], m4[2])));\n          var w4m0 = scale(w4, m0[0]);\n          var w4m1 = scale(w4, m1[0]);\n          var w4m2 = scale(w4, m2[0]);\n          var w4m3 = scale(w4, m3[0]);\n          var p = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]), sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])))), sum(sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]))), sum(scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2]), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2])))));\n          var n = sum(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))));\n          var d = diff(p, n);\n          return d[d.length - 1];\n        }\n\n        return exactInSphere5;\n      }\n\n      function inSphere6(sum, diff, prod, scale) {\n        function exactInSphere6(m0, m1, m2, m3, m4, m5) {\n          var w0 = sum(sum(prod(m0[0], m0[0]), prod(m0[1], m0[1])), sum(prod(m0[2], m0[2]), prod(m0[3], m0[3])));\n          var w0m1 = scale(w0, m1[0]);\n          var w0m2 = scale(w0, m2[0]);\n          var w0m3 = scale(w0, m3[0]);\n          var w0m4 = scale(w0, m4[0]);\n          var w0m5 = scale(w0, m5[0]);\n          var w1 = sum(sum(prod(m1[0], m1[0]), prod(m1[1], m1[1])), sum(prod(m1[2], m1[2]), prod(m1[3], m1[3])));\n          var w1m0 = scale(w1, m0[0]);\n          var w1m2 = scale(w1, m2[0]);\n          var w1m3 = scale(w1, m3[0]);\n          var w1m4 = scale(w1, m4[0]);\n          var w1m5 = scale(w1, m5[0]);\n          var w2 = sum(sum(prod(m2[0], m2[0]), prod(m2[1], m2[1])), sum(prod(m2[2], m2[2]), prod(m2[3], m2[3])));\n          var w2m0 = scale(w2, m0[0]);\n          var w2m1 = scale(w2, m1[0]);\n          var w2m3 = scale(w2, m3[0]);\n          var w2m4 = scale(w2, m4[0]);\n          var w2m5 = scale(w2, m5[0]);\n          var w3 = sum(sum(prod(m3[0], m3[0]), prod(m3[1], m3[1])), sum(prod(m3[2], m3[2]), prod(m3[3], m3[3])));\n          var w3m0 = scale(w3, m0[0]);\n          var w3m1 = scale(w3, m1[0]);\n          var w3m2 = scale(w3, m2[0]);\n          var w3m4 = scale(w3, m4[0]);\n          var w3m5 = scale(w3, m5[0]);\n          var w4 = sum(sum(prod(m4[0], m4[0]), prod(m4[1], m4[1])), sum(prod(m4[2], m4[2]), prod(m4[3], m4[3])));\n          var w4m0 = scale(w4, m0[0]);\n          var w4m1 = scale(w4, m1[0]);\n          var w4m2 = scale(w4, m2[0]);\n          var w4m3 = scale(w4, m3[0]);\n          var w4m5 = scale(w4, m5[0]);\n          var w5 = sum(sum(prod(m5[0], m5[0]), prod(m5[1], m5[1])), sum(prod(m5[2], m5[2]), prod(m5[3], m5[3])));\n          var w5m0 = scale(w5, m0[0]);\n          var w5m1 = scale(w5, m1[0]);\n          var w5m2 = scale(w5, m2[0]);\n          var w5m3 = scale(w5, m3[0]);\n          var w5m4 = scale(w5, m4[0]);\n          var p = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m1[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m3[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m1[2]), scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m5[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m3[1]), scale(diff(w3m1, w1m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m5[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m5[3])))));\n          var n = sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m2[2]), scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), -m5[2]))), m0[3]), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m3[1]), sum(scale(diff(w5m3, w3m5), -m4[1]), scale(diff(w4m3, w3m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m3[2])), sum(scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), m4[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m5[2]))), -m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), m3[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m3, w3m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m3[1]), scale(diff(w3m2, w2m3), m5[1]))), m0[2]), scale(sum(scale(diff(w5m3, w3m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m3[1]), scale(diff(w3m0, w0m3), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m5[2]))), -m4[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), m5[3])), sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m1[2]), scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), -m5[2]))), m0[3]), scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m2[1]), sum(scale(diff(w5m2, w2m5), -m4[1]), scale(diff(w4m2, w2m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m2[2])), sum(scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), m4[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m5[2]))), -m1[3])))), sum(sum(sum(scale(sum(sum(scale(sum(scale(diff(w5m4, w4m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m4[1]), scale(diff(w4m1, w1m4), m5[1]))), m0[2]), scale(sum(scale(diff(w5m4, w4m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m4[1]), scale(diff(w4m0, w0m4), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m4[2]), scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), -m5[2]))), m2[3]), scale(sum(sum(scale(sum(scale(diff(w5m2, w2m5), m1[1]), sum(scale(diff(w5m1, w1m5), -m2[1]), scale(diff(w2m1, w1m2), m5[1]))), m0[2]), scale(sum(scale(diff(w5m2, w2m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m2[1]), scale(diff(w2m0, w0m2), m5[1]))), -m1[2])), sum(scale(sum(scale(diff(w5m1, w1m5), m0[1]), sum(scale(diff(w5m0, w0m5), -m1[1]), scale(diff(w1m0, w0m1), m5[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m5[2]))), -m4[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), m5[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m1[2]), scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), -m4[2]))), m0[3]))), sum(sum(scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m2[1]), sum(scale(diff(w4m2, w2m4), -m3[1]), scale(diff(w3m2, w2m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m2[2])), sum(scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), m3[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m4[2]))), -m1[3]), scale(sum(sum(scale(sum(scale(diff(w4m3, w3m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m3[1]), scale(diff(w3m1, w1m3), m4[1]))), m0[2]), scale(sum(scale(diff(w4m3, w3m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m3[1]), scale(diff(w3m0, w0m3), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m3[2]), scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), -m4[2]))), m2[3])), sum(scale(sum(sum(scale(sum(scale(diff(w4m2, w2m4), m1[1]), sum(scale(diff(w4m1, w1m4), -m2[1]), scale(diff(w2m1, w1m2), m4[1]))), m0[2]), scale(sum(scale(diff(w4m2, w2m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m2[1]), scale(diff(w2m0, w0m2), m4[1]))), -m1[2])), sum(scale(sum(scale(diff(w4m1, w1m4), m0[1]), sum(scale(diff(w4m0, w0m4), -m1[1]), scale(diff(w1m0, w0m1), m4[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m4[2]))), -m3[3]), scale(sum(sum(scale(sum(scale(diff(w3m2, w2m3), m1[1]), sum(scale(diff(w3m1, w1m3), -m2[1]), scale(diff(w2m1, w1m2), m3[1]))), m0[2]), scale(sum(scale(diff(w3m2, w2m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m2[1]), scale(diff(w2m0, w0m2), m3[1]))), -m1[2])), sum(scale(sum(scale(diff(w3m1, w1m3), m0[1]), sum(scale(diff(w3m0, w0m3), -m1[1]), scale(diff(w1m0, w0m1), m3[1]))), m2[2]), scale(sum(scale(diff(w2m1, w1m2), m0[1]), sum(scale(diff(w2m0, w0m2), -m1[1]), scale(diff(w1m0, w0m1), m2[1]))), -m3[2]))), m4[3])))));\n          var d = diff(p, n);\n          return d[d.length - 1];\n        }\n\n        return exactInSphere6;\n      }\n\n      var CACHED = [inSphere0, inSphere1, inSphere2];\n\n      function slowInSphere(args) {\n        var proc = CACHED[args.length];\n\n        if (!proc) {\n          proc = CACHED[args.length] = orientation(args.length);\n        }\n\n        return proc.apply(undefined, args);\n      }\n\n      function proc(slow, o0, o1, o2, o3, o4, o5, o6) {\n        function testInSphere(a0, a1, a2, a3, a4, a5) {\n          switch (arguments.length) {\n            case 0:\n            case 1:\n              return 0;\n\n            case 2:\n              return o2(a0, a1);\n\n            case 3:\n              return o3(a0, a1, a2);\n\n            case 4:\n              return o4(a0, a1, a2, a3);\n\n            case 5:\n              return o5(a0, a1, a2, a3, a4);\n\n            case 6:\n              return o6(a0, a1, a2, a3, a4, a5);\n          }\n\n          var s = new Array(arguments.length);\n\n          for (var i = 0; i < arguments.length; ++i) {\n            s[i] = arguments[i];\n          }\n\n          return slow(s);\n        }\n\n        return testInSphere;\n      }\n\n      function generateInSphereTest() {\n        while (CACHED.length <= NUM_EXPAND) {\n          CACHED.push(orientation(CACHED.length));\n        }\n\n        module.exports = proc.apply(undefined, [slowInSphere].concat(CACHED));\n\n        for (var i = 0; i <= NUM_EXPAND; ++i) {\n          module.exports[i] = CACHED[i];\n        }\n      }\n\n      generateInSphereTest();\n    }, {\n      \"robust-scale\": 286,\n      \"robust-subtract\": 288,\n      \"robust-sum\": 289,\n      \"two-product\": 306\n    }],\n    283: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var determinant = _glvis_(\"robust-determinant\");\n\n      var NUM_EXPAND = 6;\n\n      function generateSolver(n) {\n        var fn = n === 2 ? solve2d : n === 3 ? solve3d : n === 4 ? solve4d : n === 5 ? solve5d : solve6d;\n\n        if (n < 6) {\n          return fn(determinant[n]);\n        }\n\n        return fn(determinant);\n      }\n\n      function robustLinearSolve0d() {\n        return [[0]];\n      }\n\n      function robustLinearSolve1d(A, b) {\n        return [[b[0]], [A[0][0]]];\n      }\n\n      function solve2d(det) {\n        return function robustLinearSolve2d(A, b) {\n          return [det([[+b[0], +A[0][1]], [+b[1], +A[1][1]]]), det([[+A[0][0], +b[0]], [+A[1][0], +b[1]]]), det(A)];\n        };\n      }\n\n      function solve3d(det) {\n        return function robustLinearSolve3d(A, b) {\n          return [det([[+b[0], +A[0][1], +A[0][2]], [+b[1], +A[1][1], +A[1][2]], [+b[2], +A[2][1], +A[2][2]]]), det([[+A[0][0], +b[0], +A[0][2]], [+A[1][0], +b[1], +A[1][2]], [+A[2][0], +b[2], +A[2][2]]]), det([[+A[0][0], +A[0][1], +b[0]], [+A[1][0], +A[1][1], +b[1]], [+A[2][0], +A[2][1], +b[2]]]), det(A)];\n        };\n      }\n\n      function solve4d(det) {\n        return function robustLinearSolve4d(A, b) {\n          return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3]], [+b[1], +A[1][1], +A[1][2], +A[1][3]], [+b[2], +A[2][1], +A[2][2], +A[2][3]], [+b[3], +A[3][1], +A[3][2], +A[3][3]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3]], [+A[1][0], +b[1], +A[1][2], +A[1][3]], [+A[2][0], +b[2], +A[2][2], +A[2][3]], [+A[3][0], +b[3], +A[3][2], +A[3][3]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3]], [+A[1][0], +A[1][1], +b[1], +A[1][3]], [+A[2][0], +A[2][1], +b[2], +A[2][3]], [+A[3][0], +A[3][1], +b[3], +A[3][3]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +b[3]]]), det(A)];\n        };\n      }\n\n      function solve5d(det) {\n        return function robustLinearSolve5d(A, b) {\n          return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3], +A[0][4]], [+b[1], +A[1][1], +A[1][2], +A[1][3], +A[1][4]], [+b[2], +A[2][1], +A[2][2], +A[2][3], +A[2][4]], [+b[3], +A[3][1], +A[3][2], +A[3][3], +A[3][4]], [+b[4], +A[4][1], +A[4][2], +A[4][3], +A[4][4]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3], +A[0][4]], [+A[1][0], +b[1], +A[1][2], +A[1][3], +A[1][4]], [+A[2][0], +b[2], +A[2][2], +A[2][3], +A[2][4]], [+A[3][0], +b[3], +A[3][2], +A[3][3], +A[3][4]], [+A[4][0], +b[4], +A[4][2], +A[4][3], +A[4][4]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3], +A[0][4]], [+A[1][0], +A[1][1], +b[1], +A[1][3], +A[1][4]], [+A[2][0], +A[2][1], +b[2], +A[2][3], +A[2][4]], [+A[3][0], +A[3][1], +b[3], +A[3][3], +A[3][4]], [+A[4][0], +A[4][1], +b[4], +A[4][3], +A[4][4]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0], +A[0][4]], [+A[1][0], +A[1][1], +A[1][2], +b[1], +A[1][4]], [+A[2][0], +A[2][1], +A[2][2], +b[2], +A[2][4]], [+A[3][0], +A[3][1], +A[3][2], +b[3], +A[3][4]], [+A[4][0], +A[4][1], +A[4][2], +b[4], +A[4][4]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +b[3]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +b[4]]]), det(A)];\n        };\n      }\n\n      function solve6d(det) {\n        return function robustLinearSolve6d(A, b) {\n          return [det([[+b[0], +A[0][1], +A[0][2], +A[0][3], +A[0][4], +A[0][5]], [+b[1], +A[1][1], +A[1][2], +A[1][3], +A[1][4], +A[1][5]], [+b[2], +A[2][1], +A[2][2], +A[2][3], +A[2][4], +A[2][5]], [+b[3], +A[3][1], +A[3][2], +A[3][3], +A[3][4], +A[3][5]], [+b[4], +A[4][1], +A[4][2], +A[4][3], +A[4][4], +A[4][5]], [+b[5], +A[5][1], +A[5][2], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +b[0], +A[0][2], +A[0][3], +A[0][4], +A[0][5]], [+A[1][0], +b[1], +A[1][2], +A[1][3], +A[1][4], +A[1][5]], [+A[2][0], +b[2], +A[2][2], +A[2][3], +A[2][4], +A[2][5]], [+A[3][0], +b[3], +A[3][2], +A[3][3], +A[3][4], +A[3][5]], [+A[4][0], +b[4], +A[4][2], +A[4][3], +A[4][4], +A[4][5]], [+A[5][0], +b[5], +A[5][2], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +b[0], +A[0][3], +A[0][4], +A[0][5]], [+A[1][0], +A[1][1], +b[1], +A[1][3], +A[1][4], +A[1][5]], [+A[2][0], +A[2][1], +b[2], +A[2][3], +A[2][4], +A[2][5]], [+A[3][0], +A[3][1], +b[3], +A[3][3], +A[3][4], +A[3][5]], [+A[4][0], +A[4][1], +b[4], +A[4][3], +A[4][4], +A[4][5]], [+A[5][0], +A[5][1], +b[5], +A[5][3], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +b[0], +A[0][4], +A[0][5]], [+A[1][0], +A[1][1], +A[1][2], +b[1], +A[1][4], +A[1][5]], [+A[2][0], +A[2][1], +A[2][2], +b[2], +A[2][4], +A[2][5]], [+A[3][0], +A[3][1], +A[3][2], +b[3], +A[3][4], +A[3][5]], [+A[4][0], +A[4][1], +A[4][2], +b[4], +A[4][4], +A[4][5]], [+A[5][0], +A[5][1], +A[5][2], +b[5], +A[5][4], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +b[0], +A[0][5]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +b[1], +A[1][5]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +b[2], +A[2][5]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +b[3], +A[3][5]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +b[4], +A[4][5]], [+A[5][0], +A[5][1], +A[5][2], +A[5][3], +b[5], +A[5][5]]]), det([[+A[0][0], +A[0][1], +A[0][2], +A[0][3], +A[0][4], +b[0]], [+A[1][0], +A[1][1], +A[1][2], +A[1][3], +A[1][4], +b[1]], [+A[2][0], +A[2][1], +A[2][2], +A[2][3], +A[2][4], +b[2]], [+A[3][0], +A[3][1], +A[3][2], +A[3][3], +A[3][4], +b[3]], [+A[4][0], +A[4][1], +A[4][2], +A[4][3], +A[4][4], +b[4]], [+A[5][0], +A[5][1], +A[5][2], +A[5][3], +A[5][4], +b[5]]]), det(A)];\n        };\n      }\n\n      var CACHE = [robustLinearSolve0d, robustLinearSolve1d];\n\n      function proc(s0, s1, s2, s3, s4, s5, CACHE, g) {\n        return function dispatchLinearSolve(A, b) {\n          switch (A.length) {\n            case 0:\n              return s0(A, b);\n\n            case 1:\n              return s1(A, b);\n\n            case 2:\n              return s2(A, b);\n\n            case 3:\n              return s3(A, b);\n\n            case 4:\n              return s4(A, b);\n\n            case 5:\n              return s5(A, b);\n          }\n\n          var s = CACHE[A.length];\n          if (!s) s = CACHE[A.length] = g(A.length);\n          return s(A, b);\n        };\n      }\n\n      function generateDispatch() {\n        while (CACHE.length < NUM_EXPAND) {\n          CACHE.push(generateSolver(CACHE.length));\n        }\n\n        module.exports = proc.apply(undefined, CACHE.concat([CACHE, generateSolver]));\n\n        for (var i = 0; i < NUM_EXPAND; ++i) {\n          module.exports[i] = CACHE[i];\n        }\n      }\n\n      generateDispatch();\n    }, {\n      \"robust-determinant\": 280\n    }],\n    284: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var twoProduct = _glvis_(\"two-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      var robustScale = _glvis_(\"robust-scale\");\n\n      var robustSubtract = _glvis_(\"robust-subtract\");\n\n      var NUM_EXPAND = 5;\n      var EPSILON = 1.1102230246251565e-16;\n      var ERRBOUND3 = (3.0 + 16.0 * EPSILON) * EPSILON;\n      var ERRBOUND4 = (7.0 + 56.0 * EPSILON) * EPSILON;\n\n      function orientation_3(sum, prod, scale, sub) {\n        return function orientation3Exact(m0, m1, m2) {\n          var p = sum(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])));\n          var n = sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0]));\n          var d = sub(p, n);\n          return d[d.length - 1];\n        };\n      }\n\n      function orientation_4(sum, prod, scale, sub) {\n        return function orientation4Exact(m0, m1, m2, m3) {\n          var p = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))));\n          var n = sum(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))));\n          var d = sub(p, n);\n          return d[d.length - 1];\n        };\n      }\n\n      function orientation_5(sum, prod, scale, sub) {\n        return function orientation5Exact(m0, m1, m2, m3, m4) {\n          var p = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m1[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), -m2[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m3[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), -m4[3]), sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m3[2]), scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m1[3])))), sum(sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m3[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), -m4[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m3[2]))), m0[3]))), sum(scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m1[3]), sum(scale(sum(scale(sum(prod(m1[1], m3[0]), prod(-m3[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m3[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m3[3])))));\n          var n = sum(sum(sum(scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m2[2]), sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), -m3[2]), scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m3[1], m4[0]), prod(-m4[1], m3[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m3[2]), scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), m4[2]))), -m2[3])), sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), m3[3]), scale(sum(scale(sum(prod(m2[1], m3[0]), prod(-m3[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m3[0]), prod(-m3[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m3[2]))), -m4[3]))), sum(sum(scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m1[2]), sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), -m2[2]), scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m4[2]))), m0[3]), scale(sum(scale(sum(prod(m2[1], m4[0]), prod(-m4[1], m2[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m2[2]), scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), m4[2]))), -m1[3])), sum(scale(sum(scale(sum(prod(m1[1], m4[0]), prod(-m4[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m4[0]), prod(-m4[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m4[2]))), m2[3]), scale(sum(scale(sum(prod(m1[1], m2[0]), prod(-m2[1], m1[0])), m0[2]), sum(scale(sum(prod(m0[1], m2[0]), prod(-m2[1], m0[0])), -m1[2]), scale(sum(prod(m0[1], m1[0]), prod(-m1[1], m0[0])), m2[2]))), -m4[3]))));\n          var d = sub(p, n);\n          return d[d.length - 1];\n        };\n      }\n\n      function orientation(n) {\n        var fn = n === 3 ? orientation_3 : n === 4 ? orientation_4 : orientation_5;\n        return fn(robustSum, twoProduct, robustScale, robustSubtract);\n      }\n\n      var orientation3Exact = orientation(3);\n      var orientation4Exact = orientation(4);\n      var CACHED = [function orientation0() {\n        return 0;\n      }, function orientation1() {\n        return 0;\n      }, function orientation2(a, b) {\n        return b[0] - a[0];\n      }, function orientation3(a, b, c) {\n        var l = (a[1] - c[1]) * (b[0] - c[0]);\n        var r = (a[0] - c[0]) * (b[1] - c[1]);\n        var det = l - r;\n        var s;\n\n        if (l > 0) {\n          if (r <= 0) {\n            return det;\n          } else {\n            s = l + r;\n          }\n        } else if (l < 0) {\n          if (r >= 0) {\n            return det;\n          } else {\n            s = -(l + r);\n          }\n        } else {\n          return det;\n        }\n\n        var tol = ERRBOUND3 * s;\n\n        if (det >= tol || det <= -tol) {\n          return det;\n        }\n\n        return orientation3Exact(a, b, c);\n      }, function orientation4(a, b, c, d) {\n        var adx = a[0] - d[0];\n        var bdx = b[0] - d[0];\n        var cdx = c[0] - d[0];\n        var ady = a[1] - d[1];\n        var bdy = b[1] - d[1];\n        var cdy = c[1] - d[1];\n        var adz = a[2] - d[2];\n        var bdz = b[2] - d[2];\n        var cdz = c[2] - d[2];\n        var bdxcdy = bdx * cdy;\n        var cdxbdy = cdx * bdy;\n        var cdxady = cdx * ady;\n        var adxcdy = adx * cdy;\n        var adxbdy = adx * bdy;\n        var bdxady = bdx * ady;\n        var det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);\n        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);\n        var tol = ERRBOUND4 * permanent;\n\n        if (det > tol || -det > tol) {\n          return det;\n        }\n\n        return orientation4Exact(a, b, c, d);\n      }];\n\n      function slowOrient(args) {\n        var proc = CACHED[args.length];\n\n        if (!proc) {\n          proc = CACHED[args.length] = orientation(args.length);\n        }\n\n        return proc.apply(undefined, args);\n      }\n\n      function proc(slow, o0, o1, o2, o3, o4, o5) {\n        return function getOrientation(a0, a1, a2, a3, a4) {\n          switch (arguments.length) {\n            case 0:\n            case 1:\n              return 0;\n\n            case 2:\n              return o2(a0, a1);\n\n            case 3:\n              return o3(a0, a1, a2);\n\n            case 4:\n              return o4(a0, a1, a2, a3);\n\n            case 5:\n              return o5(a0, a1, a2, a3, a4);\n          }\n\n          var s = new Array(arguments.length);\n\n          for (var i = 0; i < arguments.length; ++i) {\n            s[i] = arguments[i];\n          }\n\n          return slow(s);\n        };\n      }\n\n      function generateOrientationProc() {\n        while (CACHED.length <= NUM_EXPAND) {\n          CACHED.push(orientation(CACHED.length));\n        }\n\n        module.exports = proc.apply(undefined, [slowOrient].concat(CACHED));\n\n        for (var i = 0; i <= NUM_EXPAND; ++i) {\n          module.exports[i] = CACHED[i];\n        }\n      }\n\n      generateOrientationProc();\n    }, {\n      \"robust-scale\": 286,\n      \"robust-subtract\": 288,\n      \"robust-sum\": 289,\n      \"two-product\": 306\n    }],\n    285: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      var robustScale = _glvis_(\"robust-scale\");\n\n      module.exports = robustProduct;\n\n      function robustProduct(a, b) {\n        if (a.length === 1) {\n          return robustScale(b, a[0]);\n        }\n\n        if (b.length === 1) {\n          return robustScale(a, b[0]);\n        }\n\n        if (a.length === 0 || b.length === 0) {\n          return [0];\n        }\n\n        var r = [0];\n\n        if (a.length < b.length) {\n          for (var i = 0; i < a.length; ++i) {\n            r = robustSum(r, robustScale(b, a[i]));\n          }\n        } else {\n          for (var i = 0; i < b.length; ++i) {\n            r = robustSum(r, robustScale(a, b[i]));\n          }\n        }\n\n        return r;\n      }\n    }, {\n      \"robust-scale\": 286,\n      \"robust-sum\": 289\n    }],\n    286: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var twoProduct = _glvis_(\"two-product\");\n\n      var twoSum = _glvis_(\"two-sum\");\n\n      module.exports = scaleLinearExpansion;\n\n      function scaleLinearExpansion(e, scale) {\n        var n = e.length;\n\n        if (n === 1) {\n          var ts = twoProduct(e[0], scale);\n\n          if (ts[0]) {\n            return ts;\n          }\n\n          return [ts[1]];\n        }\n\n        var g = new Array(2 * n);\n        var q = [0.1, 0.1];\n        var t = [0.1, 0.1];\n        var count = 0;\n        twoProduct(e[0], scale, q);\n\n        if (q[0]) {\n          g[count++] = q[0];\n        }\n\n        for (var i = 1; i < n; ++i) {\n          twoProduct(e[i], scale, t);\n          var pq = q[1];\n          twoSum(pq, t[0], q);\n\n          if (q[0]) {\n            g[count++] = q[0];\n          }\n\n          var a = t[1];\n          var b = q[1];\n          var x = a + b;\n          var bv = x - a;\n          var y = b - bv;\n          q[1] = x;\n\n          if (y) {\n            g[count++] = y;\n          }\n        }\n\n        if (q[1]) {\n          g[count++] = q[1];\n        }\n\n        if (count === 0) {\n          g[count++] = 0.0;\n        }\n\n        g.length = count;\n        return g;\n      }\n    }, {\n      \"two-product\": 306,\n      \"two-sum\": 307\n    }],\n    287: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = segmentsIntersect;\n\n      var orient = _glvis_(\"robust-orientation\")[3];\n\n      function checkCollinear(a0, a1, b0, b1) {\n        for (var d = 0; d < 2; ++d) {\n          var x0 = a0[d];\n          var y0 = a1[d];\n          var l0 = Math.min(x0, y0);\n          var h0 = Math.max(x0, y0);\n          var x1 = b0[d];\n          var y1 = b1[d];\n          var l1 = Math.min(x1, y1);\n          var h1 = Math.max(x1, y1);\n\n          if (h1 < l0 || h0 < l1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function segmentsIntersect(a0, a1, b0, b1) {\n        var x0 = orient(a0, b0, b1);\n        var y0 = orient(a1, b0, b1);\n\n        if (x0 > 0 && y0 > 0 || x0 < 0 && y0 < 0) {\n          return false;\n        }\n\n        var x1 = orient(b0, a0, a1);\n        var y1 = orient(b1, a0, a1);\n\n        if (x1 > 0 && y1 > 0 || x1 < 0 && y1 < 0) {\n          return false;\n        } //Check for degenerate collinear case\n\n\n        if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {\n          return checkCollinear(a0, a1, b0, b1);\n        }\n\n        return true;\n      }\n    }, {\n      \"robust-orientation\": 284\n    }],\n    288: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = robustSubtract; //Easy case: Add two scalars\n\n      function scalarScalar(a, b) {\n        var x = a + b;\n        var bv = x - a;\n        var av = x - bv;\n        var br = b - bv;\n        var ar = a - av;\n        var y = ar + br;\n\n        if (y) {\n          return [y, x];\n        }\n\n        return [x];\n      }\n\n      function robustSubtract(e, f) {\n        var ne = e.length | 0;\n        var nf = f.length | 0;\n\n        if (ne === 1 && nf === 1) {\n          return scalarScalar(e[0], -f[0]);\n        }\n\n        var n = ne + nf;\n        var g = new Array(n);\n        var count = 0;\n        var eptr = 0;\n        var fptr = 0;\n        var abs = Math.abs;\n        var ei = e[eptr];\n        var ea = abs(ei);\n        var fi = -f[fptr];\n        var fa = abs(fi);\n        var a, b;\n\n        if (ea < fa) {\n          b = ei;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n            ea = abs(ei);\n          }\n        } else {\n          b = fi;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = -f[fptr];\n            fa = abs(fi);\n          }\n        }\n\n        if (eptr < ne && ea < fa || fptr >= nf) {\n          a = ei;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n            ea = abs(ei);\n          }\n        } else {\n          a = fi;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = -f[fptr];\n            fa = abs(fi);\n          }\n        }\n\n        var x = a + b;\n        var bv = x - a;\n        var y = b - bv;\n        var q0 = y;\n        var q1 = x;\n\n        var _x, _bv, _av, _br, _ar;\n\n        while (eptr < ne && fptr < nf) {\n          if (ea < fa) {\n            a = ei;\n            eptr += 1;\n\n            if (eptr < ne) {\n              ei = e[eptr];\n              ea = abs(ei);\n            }\n          } else {\n            a = fi;\n            fptr += 1;\n\n            if (fptr < nf) {\n              fi = -f[fptr];\n              fa = abs(fi);\n            }\n          }\n\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n        }\n\n        while (eptr < ne) {\n          a = ei;\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n          }\n        }\n\n        while (fptr < nf) {\n          a = fi;\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = -f[fptr];\n          }\n        }\n\n        if (q0) {\n          g[count++] = q0;\n        }\n\n        if (q1) {\n          g[count++] = q1;\n        }\n\n        if (!count) {\n          g[count++] = 0.0;\n        }\n\n        g.length = count;\n        return g;\n      }\n    }, {}],\n    289: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = linearExpansionSum; //Easy case: Add two scalars\n\n      function scalarScalar(a, b) {\n        var x = a + b;\n        var bv = x - a;\n        var av = x - bv;\n        var br = b - bv;\n        var ar = a - av;\n        var y = ar + br;\n\n        if (y) {\n          return [y, x];\n        }\n\n        return [x];\n      }\n\n      function linearExpansionSum(e, f) {\n        var ne = e.length | 0;\n        var nf = f.length | 0;\n\n        if (ne === 1 && nf === 1) {\n          return scalarScalar(e[0], f[0]);\n        }\n\n        var n = ne + nf;\n        var g = new Array(n);\n        var count = 0;\n        var eptr = 0;\n        var fptr = 0;\n        var abs = Math.abs;\n        var ei = e[eptr];\n        var ea = abs(ei);\n        var fi = f[fptr];\n        var fa = abs(fi);\n        var a, b;\n\n        if (ea < fa) {\n          b = ei;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n            ea = abs(ei);\n          }\n        } else {\n          b = fi;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = f[fptr];\n            fa = abs(fi);\n          }\n        }\n\n        if (eptr < ne && ea < fa || fptr >= nf) {\n          a = ei;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n            ea = abs(ei);\n          }\n        } else {\n          a = fi;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = f[fptr];\n            fa = abs(fi);\n          }\n        }\n\n        var x = a + b;\n        var bv = x - a;\n        var y = b - bv;\n        var q0 = y;\n        var q1 = x;\n\n        var _x, _bv, _av, _br, _ar;\n\n        while (eptr < ne && fptr < nf) {\n          if (ea < fa) {\n            a = ei;\n            eptr += 1;\n\n            if (eptr < ne) {\n              ei = e[eptr];\n              ea = abs(ei);\n            }\n          } else {\n            a = fi;\n            fptr += 1;\n\n            if (fptr < nf) {\n              fi = f[fptr];\n              fa = abs(fi);\n            }\n          }\n\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n        }\n\n        while (eptr < ne) {\n          a = ei;\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n          eptr += 1;\n\n          if (eptr < ne) {\n            ei = e[eptr];\n          }\n        }\n\n        while (fptr < nf) {\n          a = fi;\n          b = q0;\n          x = a + b;\n          bv = x - a;\n          y = b - bv;\n\n          if (y) {\n            g[count++] = y;\n          }\n\n          _x = q1 + x;\n          _bv = _x - q1;\n          _av = _x - _bv;\n          _br = x - _bv;\n          _ar = q1 - _av;\n          q0 = _ar + _br;\n          q1 = _x;\n          fptr += 1;\n\n          if (fptr < nf) {\n            fi = f[fptr];\n          }\n        }\n\n        if (q0) {\n          g[count++] = q0;\n        }\n\n        if (q1) {\n          g[count++] = q1;\n        }\n\n        if (!count) {\n          g[count++] = 0.0;\n        }\n\n        g.length = count;\n        return g;\n      }\n    }, {}],\n    290: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = boundary;\n\n      var bnd = _glvis_('boundary-cells');\n\n      var reduce = _glvis_('reduce-simplicial-complex');\n\n      function boundary(cells) {\n        return reduce(bnd(cells));\n      }\n    }, {\n      \"boundary-cells\": 34,\n      \"reduce-simplicial-complex\": 276\n    }],\n    291: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = extractContour;\n\n      var ndarray = _glvis_('ndarray');\n\n      var pool = _glvis_('typedarray-pool');\n\n      var ndsort = _glvis_('ndarray-sort');\n\n      var contourAlgorithm = _glvis_('./lib/codegen');\n\n      function getDimension(cells) {\n        var numCells = cells.length;\n        var d = 0;\n\n        for (var i = 0; i < numCells; ++i) {\n          d = Math.max(d, cells[i].length) | 0;\n        }\n\n        return d - 1;\n      }\n\n      function getSigns(values, level) {\n        var numVerts = values.length;\n        var vertexSigns = pool.mallocUint8(numVerts);\n\n        for (var i = 0; i < numVerts; ++i) {\n          vertexSigns[i] = values[i] < level | 0;\n        }\n\n        return vertexSigns;\n      }\n\n      function getEdges(cells, d) {\n        var numCells = cells.length;\n        var maxEdges = d * (d + 1) / 2 * numCells | 0;\n        var edges = pool.mallocUint32(maxEdges * 2);\n        var ePtr = 0;\n\n        for (var i = 0; i < numCells; ++i) {\n          var c = cells[i];\n          var d = c.length;\n\n          for (var j = 0; j < d; ++j) {\n            for (var k = 0; k < j; ++k) {\n              var a = c[k];\n              var b = c[j];\n              edges[ePtr++] = Math.min(a, b) | 0;\n              edges[ePtr++] = Math.max(a, b) | 0;\n            }\n          }\n        }\n\n        var nedges = ePtr / 2 | 0;\n        ndsort(ndarray(edges, [nedges, 2]));\n        var ptr = 2;\n\n        for (var i = 2; i < ePtr; i += 2) {\n          if (edges[i - 2] === edges[i] && edges[i - 1] === edges[i + 1]) {\n            continue;\n          }\n\n          edges[ptr++] = edges[i];\n          edges[ptr++] = edges[i + 1];\n        }\n\n        return ndarray(edges, [ptr / 2 | 0, 2]);\n      }\n\n      function getCrossingWeights(edges, values, signs, level) {\n        var edata = edges.data;\n        var numEdges = edges.shape[0];\n        var weights = pool.mallocDouble(numEdges);\n        var ptr = 0;\n\n        for (var i = 0; i < numEdges; ++i) {\n          var a = edata[2 * i];\n          var b = edata[2 * i + 1];\n\n          if (signs[a] === signs[b]) {\n            continue;\n          }\n\n          var va = values[a];\n          var vb = values[b];\n          edata[2 * ptr] = a;\n          edata[2 * ptr + 1] = b;\n          weights[ptr++] = (vb - level) / (vb - va);\n        }\n\n        edges.shape[0] = ptr;\n        return ndarray(weights, [ptr]);\n      }\n\n      function getCascade(edges, numVerts) {\n        var result = pool.mallocInt32(numVerts * 2);\n        var numEdges = edges.shape[0];\n        var edata = edges.data;\n        result[0] = 0;\n        var lastV = 0;\n\n        for (var i = 0; i < numEdges; ++i) {\n          var a = edata[2 * i];\n\n          if (a !== lastV) {\n            result[2 * lastV + 1] = i;\n\n            while (++lastV < a) {\n              result[2 * lastV] = i;\n              result[2 * lastV + 1] = i;\n            }\n\n            result[2 * lastV] = i;\n          }\n        }\n\n        result[2 * lastV + 1] = numEdges;\n\n        while (++lastV < numVerts) {\n          result[2 * lastV] = result[2 * lastV + 1] = numEdges;\n        }\n\n        return result;\n      }\n\n      function unpackEdges(edges) {\n        var ne = edges.shape[0] | 0;\n        var edata = edges.data;\n        var result = new Array(ne);\n\n        for (var i = 0; i < ne; ++i) {\n          result[i] = [edata[2 * i], edata[2 * i + 1]];\n        }\n\n        return result;\n      }\n\n      function extractContour(cells, values, level, d) {\n        level = level || 0.0; //If user didn't specify `d`, use brute force scan\n\n        if (typeof d === 'undefined') {\n          d = getDimension(cells);\n        } //Count number of cells\n\n\n        var numCells = cells.length;\n\n        if (numCells === 0 || d < 1) {\n          return {\n            cells: [],\n            vertexIds: [],\n            vertexWeights: []\n          };\n        } //Read in vertex signs\n\n\n        var vertexSigns = getSigns(values, +level); //First get 1-skeleton, find all crossings\n\n        var edges = getEdges(cells, d);\n        var weights = getCrossingWeights(edges, values, vertexSigns, +level); //Build vertex cascade to speed up binary search\n\n        var vcascade = getCascade(edges, values.length | 0); //Then construct cells\n\n        var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns); //Unpack data into pretty format\n\n        var uedges = unpackEdges(edges);\n        var uweights = [].slice.call(weights.data, 0, weights.shape[0]); //Release data\n\n        pool.free(vertexSigns);\n        pool.free(edges.data);\n        pool.free(weights.data);\n        pool.free(vcascade);\n        return {\n          cells: faces,\n          vertexIds: uedges,\n          vertexWeights: uweights\n        };\n      }\n    }, {\n      \"./lib/codegen\": 292,\n      \"ndarray\": 259,\n      \"ndarray-sort\": 258,\n      \"typedarray-pool\": 308\n    }],\n    292: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = getPolygonizer;\n      var allFns = [function cellPolygonizer_0() {\n        function B(C, E, i, j) {\n          var a = Math.min(i, j) | 0,\n              b = Math.max(i, j) | 0,\n              l = C[2 * a],\n              h = C[2 * a + 1];\n\n          while (l < h) {\n            var m = l + h >> 1,\n                v = E[2 * m + 1];\n\n            if (v === b) {\n              return m;\n            }\n\n            if (b < v) {\n              h = m;\n            } else {\n              l = m + 1;\n            }\n          }\n\n          return l;\n        }\n\n        function getContour0d(F, E, C, S) {\n          var n = F.length,\n              R = [];\n\n          for (var i = 0; i < n; ++i) {\n            var c = F[i],\n                l = c.length;\n          }\n\n          return R;\n        }\n\n        return getContour0d;\n      }, function cellPolygonizer_1() {\n        function B(C, E, i, j) {\n          var a = Math.min(i, j) | 0,\n              b = Math.max(i, j) | 0,\n              l = C[2 * a],\n              h = C[2 * a + 1];\n\n          while (l < h) {\n            var m = l + h >> 1,\n                v = E[2 * m + 1];\n\n            if (v === b) {\n              return m;\n            }\n\n            if (b < v) {\n              h = m;\n            } else {\n              l = m + 1;\n            }\n          }\n\n          return l;\n        }\n\n        function getContour1d(F, E, C, S) {\n          var n = F.length,\n              R = [];\n\n          for (var i = 0; i < n; ++i) {\n            var c = F[i],\n                l = c.length;\n\n            if (l === 2) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1);\n\n              if (M === 0 || M === 3) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[1])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[0])]);\n                  break;\n\n                case 3:\n                  break;\n              }\n            }\n          }\n\n          return R;\n        }\n\n        return getContour1d;\n      }, function cellPolygonizer_2() {\n        function B(C, E, i, j) {\n          var a = Math.min(i, j) | 0,\n              b = Math.max(i, j) | 0,\n              l = C[2 * a],\n              h = C[2 * a + 1];\n\n          while (l < h) {\n            var m = l + h >> 1,\n                v = E[2 * m + 1];\n\n            if (v === b) {\n              return m;\n            }\n\n            if (b < v) {\n              h = m;\n            } else {\n              l = m + 1;\n            }\n          }\n\n          return l;\n        }\n\n        function getContour2d(F, E, C, S) {\n          var n = F.length,\n              R = [];\n\n          for (var i = 0; i < n; ++i) {\n            var c = F[i],\n                l = c.length;\n\n            if (l === 3) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2);\n\n              if (M === 0 || M === 7) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[2]), B(C, E, c[0], c[1])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[0]), B(C, E, c[1], c[2])]);\n                  break;\n\n                case 3:\n                  R.push([B(C, E, c[0], c[2]), B(C, E, c[1], c[2])]);\n                  break;\n\n                case 4:\n                  R.push([B(C, E, c[2], c[1]), B(C, E, c[2], c[0])]);\n                  break;\n\n                case 5:\n                  R.push([B(C, E, c[2], c[1]), B(C, E, c[0], c[1])]);\n                  break;\n\n                case 6:\n                  R.push([B(C, E, c[1], c[0]), B(C, E, c[2], c[0])]);\n                  break;\n\n                case 7:\n                  break;\n              }\n            } else if (l === 2) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1);\n\n              if (M === 0 || M === 3) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[1])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[0])]);\n                  break;\n\n                case 3:\n                  break;\n              }\n            }\n          }\n\n          return R;\n        }\n\n        return getContour2d;\n      }, function cellPolygonizer_3() {\n        function B(C, E, i, j) {\n          var a = Math.min(i, j) | 0,\n              b = Math.max(i, j) | 0,\n              l = C[2 * a],\n              h = C[2 * a + 1];\n\n          while (l < h) {\n            var m = l + h >> 1,\n                v = E[2 * m + 1];\n\n            if (v === b) {\n              return m;\n            }\n\n            if (b < v) {\n              h = m;\n            } else {\n              l = m + 1;\n            }\n          }\n\n          return l;\n        }\n\n        function getContour3d(F, E, C, S) {\n          var n = F.length,\n              R = [];\n\n          for (var i = 0; i < n; ++i) {\n            var c = F[i],\n                l = c.length;\n\n            if (l === 4) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2) + (S[c[3]] << 3);\n\n              if (M === 0 || M === 15) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[1]), B(C, E, c[0], c[2]), B(C, E, c[0], c[3])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[2]), B(C, E, c[1], c[0]), B(C, E, c[1], c[3])]);\n                  break;\n\n                case 3:\n                  R.push([B(C, E, c[1], c[2]), B(C, E, c[0], c[2]), B(C, E, c[0], c[3])], [B(C, E, c[1], c[3]), B(C, E, c[1], c[2]), B(C, E, c[0], c[3])]);\n                  break;\n\n                case 4:\n                  R.push([B(C, E, c[2], c[0]), B(C, E, c[2], c[1]), B(C, E, c[2], c[3])]);\n                  break;\n\n                case 5:\n                  R.push([B(C, E, c[0], c[1]), B(C, E, c[2], c[1]), B(C, E, c[0], c[3])], [B(C, E, c[2], c[1]), B(C, E, c[2], c[3]), B(C, E, c[0], c[3])]);\n                  break;\n\n                case 6:\n                  R.push([B(C, E, c[2], c[0]), B(C, E, c[1], c[0]), B(C, E, c[1], c[3])], [B(C, E, c[2], c[3]), B(C, E, c[2], c[0]), B(C, E, c[1], c[3])]);\n                  break;\n\n                case 7:\n                  R.push([B(C, E, c[0], c[3]), B(C, E, c[1], c[3]), B(C, E, c[2], c[3])]);\n                  break;\n\n                case 8:\n                  R.push([B(C, E, c[3], c[1]), B(C, E, c[3], c[0]), B(C, E, c[3], c[2])]);\n                  break;\n\n                case 9:\n                  R.push([B(C, E, c[3], c[1]), B(C, E, c[0], c[1]), B(C, E, c[0], c[2])], [B(C, E, c[3], c[2]), B(C, E, c[3], c[1]), B(C, E, c[0], c[2])]);\n                  break;\n\n                case 10:\n                  R.push([B(C, E, c[1], c[0]), B(C, E, c[3], c[0]), B(C, E, c[1], c[2])], [B(C, E, c[3], c[0]), B(C, E, c[3], c[2]), B(C, E, c[1], c[2])]);\n                  break;\n\n                case 11:\n                  R.push([B(C, E, c[1], c[2]), B(C, E, c[0], c[2]), B(C, E, c[3], c[2])]);\n                  break;\n\n                case 12:\n                  R.push([B(C, E, c[3], c[0]), B(C, E, c[2], c[0]), B(C, E, c[2], c[1])], [B(C, E, c[3], c[1]), B(C, E, c[3], c[0]), B(C, E, c[2], c[1])]);\n                  break;\n\n                case 13:\n                  R.push([B(C, E, c[0], c[1]), B(C, E, c[2], c[1]), B(C, E, c[3], c[1])]);\n                  break;\n\n                case 14:\n                  R.push([B(C, E, c[2], c[0]), B(C, E, c[1], c[0]), B(C, E, c[3], c[0])]);\n                  break;\n\n                case 15:\n                  break;\n              }\n            } else if (l === 3) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1) + (S[c[2]] << 2);\n\n              if (M === 0 || M === 7) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[2]), B(C, E, c[0], c[1])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[0]), B(C, E, c[1], c[2])]);\n                  break;\n\n                case 3:\n                  R.push([B(C, E, c[0], c[2]), B(C, E, c[1], c[2])]);\n                  break;\n\n                case 4:\n                  R.push([B(C, E, c[2], c[1]), B(C, E, c[2], c[0])]);\n                  break;\n\n                case 5:\n                  R.push([B(C, E, c[2], c[1]), B(C, E, c[0], c[1])]);\n                  break;\n\n                case 6:\n                  R.push([B(C, E, c[1], c[0]), B(C, E, c[2], c[0])]);\n                  break;\n\n                case 7:\n                  break;\n              }\n            } else if (l === 2) {\n              var M = (S[c[0]] << 0) + (S[c[1]] << 1);\n\n              if (M === 0 || M === 3) {\n                continue;\n              }\n\n              switch (M) {\n                case 0:\n                  break;\n\n                case 1:\n                  R.push([B(C, E, c[0], c[1])]);\n                  break;\n\n                case 2:\n                  R.push([B(C, E, c[1], c[0])]);\n                  break;\n\n                case 3:\n                  break;\n              }\n            }\n          }\n\n          return R;\n        }\n\n        return getContour3d;\n      }];\n\n      function getPolygonizer(d) {\n        return allFns[d]();\n      }\n    }, {}],\n    293: [function (_glvis_, module, exports) {\n      \"use strict\";\n      \"use restrict\";\n\n      var bits = _glvis_(\"bit-twiddle\"),\n          UnionFind = _glvis_(\"union-find\"); //Returns the dimension of a cell complex\n\n\n      function dimension(cells) {\n        var d = 0,\n            max = Math.max;\n\n        for (var i = 0, il = cells.length; i < il; ++i) {\n          d = max(d, cells[i].length);\n        }\n\n        return d - 1;\n      }\n\n      exports.dimension = dimension; //Counts the number of vertices in faces\n\n      function countVertices(cells) {\n        var vc = -1,\n            max = Math.max;\n\n        for (var i = 0, il = cells.length; i < il; ++i) {\n          var c = cells[i];\n\n          for (var j = 0, jl = c.length; j < jl; ++j) {\n            vc = max(vc, c[j]);\n          }\n        }\n\n        return vc + 1;\n      }\n\n      exports.countVertices = countVertices; //Returns a deep copy of cells\n\n      function cloneCells(cells) {\n        var ncells = new Array(cells.length);\n\n        for (var i = 0, il = cells.length; i < il; ++i) {\n          ncells[i] = cells[i].slice(0);\n        }\n\n        return ncells;\n      }\n\n      exports.cloneCells = cloneCells; //Ranks a pair of cells up to permutation\n\n      function compareCells(a, b) {\n        var n = a.length,\n            t = a.length - b.length,\n            min = Math.min;\n\n        if (t) {\n          return t;\n        }\n\n        switch (n) {\n          case 0:\n            return 0;\n\n          case 1:\n            return a[0] - b[0];\n\n          case 2:\n            var d = a[0] + a[1] - b[0] - b[1];\n\n            if (d) {\n              return d;\n            }\n\n            return min(a[0], a[1]) - min(b[0], b[1]);\n\n          case 3:\n            var l1 = a[0] + a[1],\n                m1 = b[0] + b[1];\n            d = l1 + a[2] - (m1 + b[2]);\n\n            if (d) {\n              return d;\n            }\n\n            var l0 = min(a[0], a[1]),\n                m0 = min(b[0], b[1]),\n                d = min(l0, a[2]) - min(m0, b[2]);\n\n            if (d) {\n              return d;\n            }\n\n            return min(l0 + a[2], l1) - min(m0 + b[2], m1);\n          //TODO: Maybe optimize n=4 as well?\n\n          default:\n            var as = a.slice(0);\n            as.sort();\n            var bs = b.slice(0);\n            bs.sort();\n\n            for (var i = 0; i < n; ++i) {\n              t = as[i] - bs[i];\n\n              if (t) {\n                return t;\n              }\n            }\n\n            return 0;\n        }\n      }\n\n      exports.compareCells = compareCells;\n\n      function compareZipped(a, b) {\n        return compareCells(a[0], b[0]);\n      } //Puts a cell complex into normal order for the purposes of findCell queries\n\n\n      function normalize(cells, attr) {\n        if (attr) {\n          var len = cells.length;\n          var zipped = new Array(len);\n\n          for (var i = 0; i < len; ++i) {\n            zipped[i] = [cells[i], attr[i]];\n          }\n\n          zipped.sort(compareZipped);\n\n          for (var i = 0; i < len; ++i) {\n            cells[i] = zipped[i][0];\n            attr[i] = zipped[i][1];\n          }\n\n          return cells;\n        } else {\n          cells.sort(compareCells);\n          return cells;\n        }\n      }\n\n      exports.normalize = normalize; //Removes all duplicate cells in the complex\n\n      function unique(cells) {\n        if (cells.length === 0) {\n          return [];\n        }\n\n        var ptr = 1,\n            len = cells.length;\n\n        for (var i = 1; i < len; ++i) {\n          var a = cells[i];\n\n          if (compareCells(a, cells[i - 1])) {\n            if (i === ptr) {\n              ptr++;\n              continue;\n            }\n\n            cells[ptr++] = a;\n          }\n        }\n\n        cells.length = ptr;\n        return cells;\n      }\n\n      exports.unique = unique; //Finds a cell in a normalized cell complex\n\n      function findCell(cells, c) {\n        var lo = 0,\n            hi = cells.length - 1,\n            r = -1;\n\n        while (lo <= hi) {\n          var mid = lo + hi >> 1,\n              s = compareCells(cells[mid], c);\n\n          if (s <= 0) {\n            if (s === 0) {\n              r = mid;\n            }\n\n            lo = mid + 1;\n          } else if (s > 0) {\n            hi = mid - 1;\n          }\n        }\n\n        return r;\n      }\n\n      exports.findCell = findCell; //Builds an index for an n-cell.  This is more general than dual, but less efficient\n\n      function incidence(from_cells, to_cells) {\n        var index = new Array(from_cells.length);\n\n        for (var i = 0, il = index.length; i < il; ++i) {\n          index[i] = [];\n        }\n\n        var b = [];\n\n        for (var i = 0, n = to_cells.length; i < n; ++i) {\n          var c = to_cells[i];\n          var cl = c.length;\n\n          for (var k = 1, kn = 1 << cl; k < kn; ++k) {\n            b.length = bits.popCount(k);\n            var l = 0;\n\n            for (var j = 0; j < cl; ++j) {\n              if (k & 1 << j) {\n                b[l++] = c[j];\n              }\n            }\n\n            var idx = findCell(from_cells, b);\n\n            if (idx < 0) {\n              continue;\n            }\n\n            while (true) {\n              index[idx++].push(i);\n\n              if (idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {\n                break;\n              }\n            }\n          }\n        }\n\n        return index;\n      }\n\n      exports.incidence = incidence; //Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices\n\n      function dual(cells, vertex_count) {\n        if (!vertex_count) {\n          return incidence(unique(skeleton(cells, 0)), cells, 0);\n        }\n\n        var res = new Array(vertex_count);\n\n        for (var i = 0; i < vertex_count; ++i) {\n          res[i] = [];\n        }\n\n        for (var i = 0, len = cells.length; i < len; ++i) {\n          var c = cells[i];\n\n          for (var j = 0, cl = c.length; j < cl; ++j) {\n            res[c[j]].push(i);\n          }\n        }\n\n        return res;\n      }\n\n      exports.dual = dual; //Enumerates all cells in the complex\n\n      function explode(cells) {\n        var result = [];\n\n        for (var i = 0, il = cells.length; i < il; ++i) {\n          var c = cells[i],\n              cl = c.length | 0;\n\n          for (var j = 1, jl = 1 << cl; j < jl; ++j) {\n            var b = [];\n\n            for (var k = 0; k < cl; ++k) {\n              if (j >>> k & 1) {\n                b.push(c[k]);\n              }\n            }\n\n            result.push(b);\n          }\n        }\n\n        return normalize(result);\n      }\n\n      exports.explode = explode; //Enumerates all of the n-cells of a cell complex\n\n      function skeleton(cells, n) {\n        if (n < 0) {\n          return [];\n        }\n\n        var result = [],\n            k0 = (1 << n + 1) - 1;\n\n        for (var i = 0; i < cells.length; ++i) {\n          var c = cells[i];\n\n          for (var k = k0; k < 1 << c.length; k = bits.nextCombination(k)) {\n            var b = new Array(n + 1),\n                l = 0;\n\n            for (var j = 0; j < c.length; ++j) {\n              if (k & 1 << j) {\n                b[l++] = c[j];\n              }\n            }\n\n            result.push(b);\n          }\n        }\n\n        return normalize(result);\n      }\n\n      exports.skeleton = skeleton; //Computes the boundary of all cells, does not remove duplicates\n\n      function boundary(cells) {\n        var res = [];\n\n        for (var i = 0, il = cells.length; i < il; ++i) {\n          var c = cells[i];\n\n          for (var j = 0, cl = c.length; j < cl; ++j) {\n            var b = new Array(c.length - 1);\n\n            for (var k = 0, l = 0; k < cl; ++k) {\n              if (k !== j) {\n                b[l++] = c[k];\n              }\n            }\n\n            res.push(b);\n          }\n        }\n\n        return normalize(res);\n      }\n\n      exports.boundary = boundary; //Computes connected components for a dense cell complex\n\n      function connectedComponents_dense(cells, vertex_count) {\n        var labels = new UnionFind(vertex_count);\n\n        for (var i = 0; i < cells.length; ++i) {\n          var c = cells[i];\n\n          for (var j = 0; j < c.length; ++j) {\n            for (var k = j + 1; k < c.length; ++k) {\n              labels.link(c[j], c[k]);\n            }\n          }\n        }\n\n        var components = [],\n            component_labels = labels.ranks;\n\n        for (var i = 0; i < component_labels.length; ++i) {\n          component_labels[i] = -1;\n        }\n\n        for (var i = 0; i < cells.length; ++i) {\n          var l = labels.find(cells[i][0]);\n\n          if (component_labels[l] < 0) {\n            component_labels[l] = components.length;\n            components.push([cells[i].slice(0)]);\n          } else {\n            components[component_labels[l]].push(cells[i].slice(0));\n          }\n        }\n\n        return components;\n      } //Computes connected components for a sparse graph\n\n\n      function connectedComponents_sparse(cells) {\n        var vertices = unique(normalize(skeleton(cells, 0))),\n            labels = new UnionFind(vertices.length);\n\n        for (var i = 0; i < cells.length; ++i) {\n          var c = cells[i];\n\n          for (var j = 0; j < c.length; ++j) {\n            var vj = findCell(vertices, [c[j]]);\n\n            for (var k = j + 1; k < c.length; ++k) {\n              labels.link(vj, findCell(vertices, [c[k]]));\n            }\n          }\n        }\n\n        var components = [],\n            component_labels = labels.ranks;\n\n        for (var i = 0; i < component_labels.length; ++i) {\n          component_labels[i] = -1;\n        }\n\n        for (var i = 0; i < cells.length; ++i) {\n          var l = labels.find(findCell(vertices, [cells[i][0]]));\n\n          if (component_labels[l] < 0) {\n            component_labels[l] = components.length;\n            components.push([cells[i].slice(0)]);\n          } else {\n            components[component_labels[l]].push(cells[i].slice(0));\n          }\n        }\n\n        return components;\n      } //Computes connected components for a cell complex\n\n\n      function connectedComponents(cells, vertex_count) {\n        if (vertex_count) {\n          return connectedComponents_dense(cells, vertex_count);\n        }\n\n        return connectedComponents_sparse(cells);\n      }\n\n      exports.connectedComponents = connectedComponents;\n    }, {\n      \"bit-twiddle\": 32,\n      \"union-find\": 309\n    }],\n    294: [function (_glvis_, module, exports) {\n      arguments[4][32][0].apply(exports, arguments);\n    }, {\n      \"dup\": 32\n    }],\n    295: [function (_glvis_, module, exports) {\n      arguments[4][293][0].apply(exports, arguments);\n    }, {\n      \"bit-twiddle\": 294,\n      \"dup\": 293,\n      \"union-find\": 296\n    }],\n    296: [function (_glvis_, module, exports) {\n      \"use strict\";\n      \"use restrict\";\n\n      module.exports = UnionFind;\n\n      function UnionFind(count) {\n        this.roots = new Array(count);\n        this.ranks = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          this.roots[i] = i;\n          this.ranks[i] = 0;\n        }\n      }\n\n      UnionFind.prototype.length = function () {\n        return this.roots.length;\n      };\n\n      UnionFind.prototype.makeSet = function () {\n        var n = this.roots.length;\n        this.roots.push(n);\n        this.ranks.push(0);\n        return n;\n      };\n\n      UnionFind.prototype.find = function (x) {\n        var roots = this.roots;\n\n        while (roots[x] !== x) {\n          var y = roots[x];\n          roots[x] = roots[y];\n          x = y;\n        }\n\n        return x;\n      };\n\n      UnionFind.prototype.link = function (x, y) {\n        var xr = this.find(x),\n            yr = this.find(y);\n\n        if (xr === yr) {\n          return;\n        }\n\n        var ranks = this.ranks,\n            roots = this.roots,\n            xd = ranks[xr],\n            yd = ranks[yr];\n\n        if (xd < yd) {\n          roots[xr] = yr;\n        } else if (yd < xd) {\n          roots[yr] = xr;\n        } else {\n          roots[yr] = xr;\n          ++ranks[xr];\n        }\n      };\n    }, {}],\n    297: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = simplifyPolygon;\n\n      var orient = _glvis_(\"robust-orientation\");\n\n      var sc = _glvis_(\"simplicial-complex\");\n\n      function errorWeight(base, a, b) {\n        var area = Math.abs(orient(base, a, b));\n        var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n        return area / perim;\n      }\n\n      function simplifyPolygon(cells, positions, minArea) {\n        var n = positions.length;\n        var nc = cells.length;\n        var inv = new Array(n);\n        var outv = new Array(n);\n        var weights = new Array(n);\n        var dead = new Array(n); //Initialize tables\n\n        for (var i = 0; i < n; ++i) {\n          inv[i] = outv[i] = -1;\n          weights[i] = Infinity;\n          dead[i] = false;\n        } //Compute neighbors\n\n\n        for (var i = 0; i < nc; ++i) {\n          var c = cells[i];\n\n          if (c.length !== 2) {\n            throw new Error(\"Input must be a graph\");\n          }\n\n          var s = c[1];\n          var t = c[0];\n\n          if (outv[t] !== -1) {\n            outv[t] = -2;\n          } else {\n            outv[t] = s;\n          }\n\n          if (inv[s] !== -1) {\n            inv[s] = -2;\n          } else {\n            inv[s] = t;\n          }\n        } //Updates the weight for vertex i\n\n\n        function computeWeight(i) {\n          if (dead[i]) {\n            return Infinity;\n          } //TODO: Check that the line segment doesn't cross once simplified\n\n\n          var s = inv[i];\n          var t = outv[i];\n\n          if (s < 0 || t < 0) {\n            return Infinity;\n          } else {\n            return errorWeight(positions[i], positions[s], positions[t]);\n          }\n        } //Swaps two nodes on the heap (i,j) are the index of the nodes\n\n\n        function heapSwap(i, j) {\n          var a = heap[i];\n          var b = heap[j];\n          heap[i] = b;\n          heap[j] = a;\n          index[a] = j;\n          index[b] = i;\n        } //Returns the weight of node i on the heap\n\n\n        function heapWeight(i) {\n          return weights[heap[i]];\n        }\n\n        function heapParent(i) {\n          if (i & 1) {\n            return i - 1 >> 1;\n          }\n\n          return (i >> 1) - 1;\n        } //Bubble element i down the heap\n\n\n        function heapDown(i) {\n          var w = heapWeight(i);\n\n          while (true) {\n            var tw = w;\n            var left = 2 * i + 1;\n            var right = 2 * (i + 1);\n            var next = i;\n\n            if (left < heapCount) {\n              var lw = heapWeight(left);\n\n              if (lw < tw) {\n                next = left;\n                tw = lw;\n              }\n            }\n\n            if (right < heapCount) {\n              var rw = heapWeight(right);\n\n              if (rw < tw) {\n                next = right;\n              }\n            }\n\n            if (next === i) {\n              return i;\n            }\n\n            heapSwap(i, next);\n            i = next;\n          }\n        } //Bubbles element i up the heap\n\n\n        function heapUp(i) {\n          var w = heapWeight(i);\n\n          while (i > 0) {\n            var parent = heapParent(i);\n\n            if (parent >= 0) {\n              var pw = heapWeight(parent);\n\n              if (w < pw) {\n                heapSwap(i, parent);\n                i = parent;\n                continue;\n              }\n            }\n\n            return i;\n          }\n        } //Pop minimum element\n\n\n        function heapPop() {\n          if (heapCount > 0) {\n            var head = heap[0];\n            heapSwap(0, heapCount - 1);\n            heapCount -= 1;\n            heapDown(0);\n            return head;\n          }\n\n          return -1;\n        } //Update heap item i\n\n\n        function heapUpdate(i, w) {\n          var a = heap[i];\n\n          if (weights[a] === w) {\n            return i;\n          }\n\n          weights[a] = -Infinity;\n          heapUp(i);\n          heapPop();\n          weights[a] = w;\n          heapCount += 1;\n          return heapUp(heapCount - 1);\n        } //Kills a vertex (assume vertex already removed from heap)\n\n\n        function kill(i) {\n          if (dead[i]) {\n            return;\n          } //Kill vertex\n\n\n          dead[i] = true; //Fixup topology\n\n          var s = inv[i];\n          var t = outv[i];\n\n          if (inv[t] >= 0) {\n            inv[t] = s;\n          }\n\n          if (outv[s] >= 0) {\n            outv[s] = t;\n          } //Update weights on s and t\n\n\n          if (index[s] >= 0) {\n            heapUpdate(index[s], computeWeight(s));\n          }\n\n          if (index[t] >= 0) {\n            heapUpdate(index[t], computeWeight(t));\n          }\n        } //Initialize weights and heap\n\n\n        var heap = [];\n        var index = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          var w = weights[i] = computeWeight(i);\n\n          if (w < Infinity) {\n            index[i] = heap.length;\n            heap.push(i);\n          } else {\n            index[i] = -1;\n          }\n        }\n\n        var heapCount = heap.length;\n\n        for (var i = heapCount >> 1; i >= 0; --i) {\n          heapDown(i);\n        } //Kill vertices\n\n\n        while (true) {\n          var hmin = heapPop();\n\n          if (hmin < 0 || weights[hmin] > minArea) {\n            break;\n          }\n\n          kill(hmin);\n        } //Build collapsed vertex table\n\n\n        var npositions = [];\n\n        for (var i = 0; i < n; ++i) {\n          if (!dead[i]) {\n            index[i] = npositions.length;\n            npositions.push(positions[i].slice());\n          }\n        }\n\n        var nv = npositions.length;\n\n        function tortoiseHare(seq, start) {\n          if (seq[start] < 0) {\n            return start;\n          }\n\n          var t = start;\n          var h = start;\n\n          do {\n            //Walk two steps with h\n            var nh = seq[h];\n\n            if (!dead[h] || nh < 0 || nh === h) {\n              break;\n            }\n\n            h = nh;\n            nh = seq[h];\n\n            if (!dead[h] || nh < 0 || nh === h) {\n              break;\n            }\n\n            h = nh; //Walk one step with t\n\n            t = seq[t];\n          } while (t !== h); //Compress cycles\n\n\n          for (var v = start; v !== h; v = seq[v]) {\n            seq[v] = h;\n          }\n\n          return h;\n        }\n\n        var ncells = [];\n        cells.forEach(function (c) {\n          var tin = tortoiseHare(inv, c[0]);\n          var tout = tortoiseHare(outv, c[1]);\n\n          if (tin >= 0 && tout >= 0 && tin !== tout) {\n            var cin = index[tin];\n            var cout = index[tout];\n\n            if (cin !== cout) {\n              ncells.push([cin, cout]);\n            }\n          }\n        }); //Normalize result\n\n        sc.unique(sc.normalize(ncells)); //Return final list of cells\n\n        return {\n          positions: npositions,\n          edges: ncells\n        };\n      }\n    }, {\n      \"robust-orientation\": 284,\n      \"simplicial-complex\": 295\n    }],\n    298: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = orderSegments;\n\n      var orient = _glvis_(\"robust-orientation\");\n\n      function horizontalOrder(a, b) {\n        var bl, br;\n\n        if (b[0][0] < b[1][0]) {\n          bl = b[0];\n          br = b[1];\n        } else if (b[0][0] > b[1][0]) {\n          bl = b[1];\n          br = b[0];\n        } else {\n          var alo = Math.min(a[0][1], a[1][1]);\n          var ahi = Math.max(a[0][1], a[1][1]);\n          var blo = Math.min(b[0][1], b[1][1]);\n          var bhi = Math.max(b[0][1], b[1][1]);\n\n          if (ahi < blo) {\n            return ahi - blo;\n          }\n\n          if (alo > bhi) {\n            return alo - bhi;\n          }\n\n          return ahi - bhi;\n        }\n\n        var al, ar;\n\n        if (a[0][1] < a[1][1]) {\n          al = a[0];\n          ar = a[1];\n        } else {\n          al = a[1];\n          ar = a[0];\n        }\n\n        var d = orient(br, bl, al);\n\n        if (d) {\n          return d;\n        }\n\n        d = orient(br, bl, ar);\n\n        if (d) {\n          return d;\n        }\n\n        return ar - br;\n      }\n\n      function orderSegments(b, a) {\n        var al, ar;\n\n        if (a[0][0] < a[1][0]) {\n          al = a[0];\n          ar = a[1];\n        } else if (a[0][0] > a[1][0]) {\n          al = a[1];\n          ar = a[0];\n        } else {\n          return horizontalOrder(a, b);\n        }\n\n        var bl, br;\n\n        if (b[0][0] < b[1][0]) {\n          bl = b[0];\n          br = b[1];\n        } else if (b[0][0] > b[1][0]) {\n          bl = b[1];\n          br = b[0];\n        } else {\n          return -horizontalOrder(b, a);\n        }\n\n        var d1 = orient(al, ar, br);\n        var d2 = orient(al, ar, bl);\n\n        if (d1 < 0) {\n          if (d2 <= 0) {\n            return d1;\n          }\n        } else if (d1 > 0) {\n          if (d2 >= 0) {\n            return d1;\n          }\n        } else if (d2) {\n          return d2;\n        }\n\n        d1 = orient(br, bl, ar);\n        d2 = orient(br, bl, al);\n\n        if (d1 < 0) {\n          if (d2 <= 0) {\n            return d1;\n          }\n        } else if (d1 > 0) {\n          if (d2 >= 0) {\n            return d1;\n          }\n        } else if (d2) {\n          return d2;\n        }\n\n        return ar[0] - br[0];\n      }\n    }, {\n      \"robust-orientation\": 284\n    }],\n    299: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = createSlabDecomposition;\n\n      var bounds = _glvis_(\"binary-search-bounds\");\n\n      var createRBTree = _glvis_(\"functional-red-black-tree\");\n\n      var orient = _glvis_(\"robust-orientation\");\n\n      var orderSegments = _glvis_(\"./lib/order-segments\");\n\n      function SlabDecomposition(slabs, coordinates, horizontal) {\n        this.slabs = slabs;\n        this.coordinates = coordinates;\n        this.horizontal = horizontal;\n      }\n\n      var proto = SlabDecomposition.prototype;\n\n      function compareHorizontal(e, y) {\n        return e.y - y;\n      }\n\n      function searchBucket(root, p) {\n        var lastNode = null;\n\n        while (root) {\n          var seg = root.key;\n          var l, r;\n\n          if (seg[0][0] < seg[1][0]) {\n            l = seg[0];\n            r = seg[1];\n          } else {\n            l = seg[1];\n            r = seg[0];\n          }\n\n          var o = orient(l, r, p);\n\n          if (o < 0) {\n            root = root.left;\n          } else if (o > 0) {\n            if (p[0] !== seg[1][0]) {\n              lastNode = root;\n              root = root.right;\n            } else {\n              var val = searchBucket(root.right, p);\n\n              if (val) {\n                return val;\n              }\n\n              root = root.left;\n            }\n          } else {\n            if (p[0] !== seg[1][0]) {\n              return root;\n            } else {\n              var val = searchBucket(root.right, p);\n\n              if (val) {\n                return val;\n              }\n\n              root = root.left;\n            }\n          }\n        }\n\n        return lastNode;\n      }\n\n      proto.castUp = function (p) {\n        var bucket = bounds.le(this.coordinates, p[0]);\n\n        if (bucket < 0) {\n          return -1;\n        }\n\n        var root = this.slabs[bucket];\n        var hitNode = searchBucket(this.slabs[bucket], p);\n        var lastHit = -1;\n\n        if (hitNode) {\n          lastHit = hitNode.value;\n        } //Edge case: need to handle horizontal segments (sucks)\n\n\n        if (this.coordinates[bucket] === p[0]) {\n          var lastSegment = null;\n\n          if (hitNode) {\n            lastSegment = hitNode.key;\n          }\n\n          if (bucket > 0) {\n            var otherHitNode = searchBucket(this.slabs[bucket - 1], p);\n\n            if (otherHitNode) {\n              if (lastSegment) {\n                if (orderSegments(otherHitNode.key, lastSegment) > 0) {\n                  lastSegment = otherHitNode.key;\n                  lastHit = otherHitNode.value;\n                }\n              } else {\n                lastHit = otherHitNode.value;\n                lastSegment = otherHitNode.key;\n              }\n            }\n          }\n\n          var horiz = this.horizontal[bucket];\n\n          if (horiz.length > 0) {\n            var hbucket = bounds.ge(horiz, p[1], compareHorizontal);\n\n            if (hbucket < horiz.length) {\n              var e = horiz[hbucket];\n\n              if (p[1] === e.y) {\n                if (e.closed) {\n                  return e.index;\n                } else {\n                  while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {\n                    hbucket = hbucket + 1;\n                    e = horiz[hbucket];\n\n                    if (e.closed) {\n                      return e.index;\n                    }\n                  }\n\n                  if (e.y === p[1] && !e.start) {\n                    hbucket = hbucket + 1;\n\n                    if (hbucket >= horiz.length) {\n                      return lastHit;\n                    }\n\n                    e = horiz[hbucket];\n                  }\n                }\n              } //Check if e is above/below last segment\n\n\n              if (e.start) {\n                if (lastSegment) {\n                  var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);\n\n                  if (lastSegment[0][0] > lastSegment[1][0]) {\n                    o = -o;\n                  }\n\n                  if (o > 0) {\n                    lastHit = e.index;\n                  }\n                } else {\n                  lastHit = e.index;\n                }\n              } else if (e.y !== p[1]) {\n                lastHit = e.index;\n              }\n            }\n          }\n        }\n\n        return lastHit;\n      };\n\n      function IntervalSegment(y, index, start, closed) {\n        this.y = y;\n        this.index = index;\n        this.start = start;\n        this.closed = closed;\n      }\n\n      function Event(x, segment, create, index) {\n        this.x = x;\n        this.segment = segment;\n        this.create = create;\n        this.index = index;\n      }\n\n      function createSlabDecomposition(segments) {\n        var numSegments = segments.length;\n        var numEvents = 2 * numSegments;\n        var events = new Array(numEvents);\n\n        for (var i = 0; i < numSegments; ++i) {\n          var s = segments[i];\n          var f = s[0][0] < s[1][0];\n          events[2 * i] = new Event(s[0][0], s, f, i);\n          events[2 * i + 1] = new Event(s[1][0], s, !f, i);\n        }\n\n        events.sort(function (a, b) {\n          var d = a.x - b.x;\n\n          if (d) {\n            return d;\n          }\n\n          d = a.create - b.create;\n\n          if (d) {\n            return d;\n          }\n\n          return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);\n        });\n        var tree = createRBTree(orderSegments);\n        var slabs = [];\n        var lines = [];\n        var horizontal = [];\n        var lastX = -Infinity;\n\n        for (var i = 0; i < numEvents;) {\n          var x = events[i].x;\n          var horiz = [];\n\n          while (i < numEvents) {\n            var e = events[i];\n\n            if (e.x !== x) {\n              break;\n            }\n\n            i += 1;\n\n            if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {\n              if (e.create) {\n                if (e.segment[0][1] < e.segment[1][1]) {\n                  horiz.push(new IntervalSegment(e.segment[0][1], e.index, true, true));\n                  horiz.push(new IntervalSegment(e.segment[1][1], e.index, false, false));\n                } else {\n                  horiz.push(new IntervalSegment(e.segment[1][1], e.index, true, false));\n                  horiz.push(new IntervalSegment(e.segment[0][1], e.index, false, true));\n                }\n              }\n            } else {\n              if (e.create) {\n                tree = tree.insert(e.segment, e.index);\n              } else {\n                tree = tree.remove(e.segment);\n              }\n            }\n          }\n\n          slabs.push(tree.root);\n          lines.push(x);\n          horizontal.push(horiz);\n        }\n\n        return new SlabDecomposition(slabs, lines, horizontal);\n      }\n    }, {\n      \"./lib/order-segments\": 298,\n      \"binary-search-bounds\": 31,\n      \"functional-red-black-tree\": 69,\n      \"robust-orientation\": 284\n    }],\n    300: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      var robustDot = _glvis_(\"robust-dot-product\");\n\n      var robustSum = _glvis_(\"robust-sum\");\n\n      module.exports = splitPolygon;\n      module.exports.positive = positive;\n      module.exports.negative = negative;\n\n      function planeT(p, plane) {\n        var r = robustSum(robustDot(p, plane), [plane[plane.length - 1]]);\n        return r[r.length - 1];\n      } //Can't do this exactly and emit a floating point result\n\n\n      function lerpW(a, wa, b, wb) {\n        var d = wb - wa;\n        var t = -wa / d;\n\n        if (t < 0.0) {\n          t = 0.0;\n        } else if (t > 1.0) {\n          t = 1.0;\n        }\n\n        var ti = 1.0 - t;\n        var n = a.length;\n        var r = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          r[i] = t * a[i] + ti * b[i];\n        }\n\n        return r;\n      }\n\n      function splitPolygon(points, plane) {\n        var pos = [];\n        var neg = [];\n        var a = planeT(points[points.length - 1], plane);\n\n        for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n          t = points[i];\n          var b = planeT(t, plane);\n\n          if (a < 0 && b > 0 || a > 0 && b < 0) {\n            var p = lerpW(s, b, t, a);\n            pos.push(p);\n            neg.push(p.slice());\n          }\n\n          if (b < 0) {\n            neg.push(t.slice());\n          } else if (b > 0) {\n            pos.push(t.slice());\n          } else {\n            pos.push(t.slice());\n            neg.push(t.slice());\n          }\n\n          a = b;\n        }\n\n        return {\n          positive: pos,\n          negative: neg\n        };\n      }\n\n      function positive(points, plane) {\n        var pos = [];\n        var a = planeT(points[points.length - 1], plane);\n\n        for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n          t = points[i];\n          var b = planeT(t, plane);\n\n          if (a < 0 && b > 0 || a > 0 && b < 0) {\n            pos.push(lerpW(s, b, t, a));\n          }\n\n          if (b >= 0) {\n            pos.push(t.slice());\n          }\n\n          a = b;\n        }\n\n        return pos;\n      }\n\n      function negative(points, plane) {\n        var neg = [];\n        var a = planeT(points[points.length - 1], plane);\n\n        for (var s = points[points.length - 1], t = points[0], i = 0; i < points.length; ++i, s = t) {\n          t = points[i];\n          var b = planeT(t, plane);\n\n          if (a < 0 && b > 0 || a > 0 && b < 0) {\n            neg.push(lerpW(s, b, t, a));\n          }\n\n          if (b <= 0) {\n            neg.push(t.slice());\n          }\n\n          a = b;\n        }\n\n        return neg;\n      }\n    }, {\n      \"robust-dot-product\": 281,\n      \"robust-sum\": 289\n    }],\n    301: [function (_glvis_, module, exports) {\n      /* global window, exports, define */\n      !function () {\n        'use strict';\n\n        var re = {\n          not_string: /[^s]/,\n          not_bool: /[^t]/,\n          not_type: /[^T]/,\n          not_primitive: /[^v]/,\n          number: /[diefg]/,\n          numeric_arg: /[bcdiefguxX]/,\n          json: /[j]/,\n          not_json: /[^j]/,\n          text: /^[^\\x25]+/,\n          modulo: /^\\x25{2}/,\n          placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n          key: /^([a-z_][a-z_\\d]*)/i,\n          key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n          index_access: /^\\[(\\d+)\\]/,\n          sign: /^[+-]/\n        };\n\n        function sprintf(key) {\n          // `arguments` is not an array, but should be fine for this call\n          return sprintf_format(sprintf_parse(key), arguments);\n        }\n\n        function vsprintf(fmt, argv) {\n          return sprintf.apply(null, [fmt].concat(argv || []));\n        }\n\n        function sprintf_format(parse_tree, argv) {\n          var cursor = 1,\n              tree_length = parse_tree.length,\n              arg,\n              output = '',\n              i,\n              k,\n              ph,\n              pad,\n              pad_character,\n              pad_length,\n              is_positive,\n              sign;\n\n          for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n              output += parse_tree[i];\n            } else if (typeof parse_tree[i] === 'object') {\n              ph = parse_tree[i]; // convenience purposes only\n\n              if (ph.keys) {\n                // keyword argument\n                arg = argv[cursor];\n\n                for (k = 0; k < ph.keys.length; k++) {\n                  if (arg == undefined) {\n                    throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k - 1]));\n                  }\n\n                  arg = arg[ph.keys[k]];\n                }\n              } else if (ph.param_no) {\n                // positional argument (explicit)\n                arg = argv[ph.param_no];\n              } else {\n                // positional argument (implicit)\n                arg = argv[cursor++];\n              }\n\n              if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                arg = arg();\n              }\n\n              if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {\n                throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));\n              }\n\n              if (re.number.test(ph.type)) {\n                is_positive = arg >= 0;\n              }\n\n              switch (ph.type) {\n                case 'b':\n                  arg = parseInt(arg, 10).toString(2);\n                  break;\n\n                case 'c':\n                  arg = String.fromCharCode(parseInt(arg, 10));\n                  break;\n\n                case 'd':\n                case 'i':\n                  arg = parseInt(arg, 10);\n                  break;\n\n                case 'j':\n                  arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);\n                  break;\n\n                case 'e':\n                  arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();\n                  break;\n\n                case 'f':\n                  arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);\n                  break;\n\n                case 'g':\n                  arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);\n                  break;\n\n                case 'o':\n                  arg = (parseInt(arg, 10) >>> 0).toString(8);\n                  break;\n\n                case 's':\n                  arg = String(arg);\n                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;\n                  break;\n\n                case 't':\n                  arg = String(!!arg);\n                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;\n                  break;\n\n                case 'T':\n                  arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();\n                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;\n                  break;\n\n                case 'u':\n                  arg = parseInt(arg, 10) >>> 0;\n                  break;\n\n                case 'v':\n                  arg = arg.valueOf();\n                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;\n                  break;\n\n                case 'x':\n                  arg = (parseInt(arg, 10) >>> 0).toString(16);\n                  break;\n\n                case 'X':\n                  arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();\n                  break;\n              }\n\n              if (re.json.test(ph.type)) {\n                output += arg;\n              } else {\n                if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                  sign = is_positive ? '+' : '-';\n                  arg = arg.toString().replace(re.sign, '');\n                } else {\n                  sign = '';\n                }\n\n                pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';\n                pad_length = ph.width - (sign + arg).length;\n                pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';\n                output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;\n              }\n            }\n          }\n\n          return output;\n        }\n\n        var sprintf_cache = Object.create(null);\n\n        function sprintf_parse(fmt) {\n          if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt];\n          }\n\n          var _fmt = fmt,\n              match,\n              parse_tree = [],\n              arg_names = 0;\n\n          while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n              parse_tree.push(match[0]);\n            } else if ((match = re.modulo.exec(_fmt)) !== null) {\n              parse_tree.push('%');\n            } else if ((match = re.placeholder.exec(_fmt)) !== null) {\n              if (match[2]) {\n                arg_names |= 1;\n                var field_list = [],\n                    replacement_field = match[2],\n                    field_match = [];\n\n                if ((field_match = re.key.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n\n                  while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                      field_list.push(field_match[1]);\n                    } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                      field_list.push(field_match[1]);\n                    } else {\n                      throw new SyntaxError('[sprintf] failed to parse named argument key');\n                    }\n                  }\n                } else {\n                  throw new SyntaxError('[sprintf] failed to parse named argument key');\n                }\n\n                match[2] = field_list;\n              } else {\n                arg_names |= 2;\n              }\n\n              if (arg_names === 3) {\n                throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');\n              }\n\n              parse_tree.push({\n                placeholder: match[0],\n                param_no: match[1],\n                keys: match[2],\n                sign: match[3],\n                pad_char: match[4],\n                align: match[5],\n                width: match[6],\n                precision: match[7],\n                type: match[8]\n              });\n            } else {\n              throw new SyntaxError('[sprintf] unexpected placeholder');\n            }\n\n            _fmt = _fmt.substring(match[0].length);\n          }\n\n          return sprintf_cache[fmt] = parse_tree;\n        }\n        /**\n         * export to either browser or node.js\n         */\n\n        /* eslint-disable quote-props */\n\n\n        if (typeof exports !== 'undefined') {\n          exports['sprintf'] = sprintf;\n          exports['vsprintf'] = vsprintf;\n        }\n\n        if (typeof window !== 'undefined') {\n          window['sprintf'] = sprintf;\n          window['vsprintf'] = vsprintf;\n\n          if (typeof define === 'function' && define['amd']) {\n            define(function () {\n              return {\n                'sprintf': sprintf,\n                'vsprintf': vsprintf\n              };\n            });\n          }\n        }\n        /* eslint-enable quote-props */\n\n      }(); // eslint-disable-line\n    }, {}],\n    302: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = surfaceNets;\n\n      var generateContourExtractor = _glvis_(\"ndarray-extract-contour\");\n\n      var zeroCrossings = _glvis_(\"zero-crossings\");\n\n      var allFns = {\n        \"2d\": function d(genContour, order, dtype) {\n          var contour = genContour({\n            order: order,\n            scalarArguments: 3,\n            getters: dtype === \"generic\" ? [0] : undefined,\n            phase: function phaseFunc(p, a, b, c) {\n              return p > c | 0;\n            },\n            vertex: function vertexFunc(d0, d1, v0, v1, v2, v3, p0, p1, p2, p3, a, b, c) {\n              var m = (p0 << 0) + (p1 << 1) + (p2 << 2) + (p3 << 3) | 0;\n\n              if (m === 0 || m === 15) {\n                return;\n              }\n\n              switch (m) {\n                case 0:\n                  a.push([d0 - 0.5, d1 - 0.5]);\n                  break;\n\n                case 1:\n                  a.push([d0 - 0.25 - 0.25 * (v1 + v0 - 2 * c) / (v0 - v1), d1 - 0.25 - 0.25 * (v2 + v0 - 2 * c) / (v0 - v2)]);\n                  break;\n\n                case 2:\n                  a.push([d0 - 0.75 - 0.25 * (-v1 - v0 + 2 * c) / (v1 - v0), d1 - 0.25 - 0.25 * (v3 + v1 - 2 * c) / (v1 - v3)]);\n                  break;\n\n                case 3:\n                  a.push([d0 - 0.5, d1 - 0.5 - 0.5 * (v2 + v0 + v3 + v1 - 4 * c) / (v0 - v2 + v1 - v3)]);\n                  break;\n\n                case 4:\n                  a.push([d0 - 0.25 - 0.25 * (v3 + v2 - 2 * c) / (v2 - v3), d1 - 0.75 - 0.25 * (-v2 - v0 + 2 * c) / (v2 - v0)]);\n                  break;\n\n                case 5:\n                  a.push([d0 - 0.5 - 0.5 * (v1 + v0 + v3 + v2 - 4 * c) / (v0 - v1 + v2 - v3), d1 - 0.5]);\n                  break;\n\n                case 6:\n                  a.push([d0 - 0.5 - 0.25 * (-v1 - v0 + v3 + v2) / (v1 - v0 + v2 - v3), d1 - 0.5 - 0.25 * (-v2 - v0 + v3 + v1) / (v2 - v0 + v1 - v3)]);\n                  break;\n\n                case 7:\n                  a.push([d0 - 0.75 - 0.25 * (v3 + v2 - 2 * c) / (v2 - v3), d1 - 0.75 - 0.25 * (v3 + v1 - 2 * c) / (v1 - v3)]);\n                  break;\n\n                case 8:\n                  a.push([d0 - 0.75 - 0.25 * (-v3 - v2 + 2 * c) / (v3 - v2), d1 - 0.75 - 0.25 * (-v3 - v1 + 2 * c) / (v3 - v1)]);\n                  break;\n\n                case 9:\n                  a.push([d0 - 0.5 - 0.25 * (v1 + v0 + -v3 - v2) / (v0 - v1 + v3 - v2), d1 - 0.5 - 0.25 * (v2 + v0 + -v3 - v1) / (v0 - v2 + v3 - v1)]);\n                  break;\n\n                case 10:\n                  a.push([d0 - 0.5 - 0.5 * (-v1 - v0 + -v3 - v2 + 4 * c) / (v1 - v0 + v3 - v2), d1 - 0.5]);\n                  break;\n\n                case 11:\n                  a.push([d0 - 0.25 - 0.25 * (-v3 - v2 + 2 * c) / (v3 - v2), d1 - 0.75 - 0.25 * (v2 + v0 - 2 * c) / (v0 - v2)]);\n                  break;\n\n                case 12:\n                  a.push([d0 - 0.5, d1 - 0.5 - 0.5 * (-v2 - v0 + -v3 - v1 + 4 * c) / (v2 - v0 + v3 - v1)]);\n                  break;\n\n                case 13:\n                  a.push([d0 - 0.75 - 0.25 * (v1 + v0 - 2 * c) / (v0 - v1), d1 - 0.25 - 0.25 * (-v3 - v1 + 2 * c) / (v3 - v1)]);\n                  break;\n\n                case 14:\n                  a.push([d0 - 0.25 - 0.25 * (-v1 - v0 + 2 * c) / (v1 - v0), d1 - 0.25 - 0.25 * (-v2 - v0 + 2 * c) / (v2 - v0)]);\n                  break;\n\n                case 15:\n                  a.push([d0 - 0.5, d1 - 0.5]);\n                  break;\n              }\n            },\n            cell: function cellFunc(v0, v1, c0, c1, p0, p1, a, b, c) {\n              if (p0) {\n                b.push([v0, v1]);\n              } else {\n                b.push([v1, v0]);\n              }\n            }\n          });\n          return function (array, level) {\n            var verts = [],\n                cells = [];\n            contour(array, verts, cells, level);\n            return {\n              positions: verts,\n              cells: cells\n            };\n          };\n        }\n      };\n\n      function buildSurfaceNets(order, dtype) {\n        var inKey = order.length + 'd';\n        var fn = allFns[inKey];\n        if (fn) return fn(generateContourExtractor, order, dtype);\n      } //1D case: Need to handle specially\n\n\n      function mesh1D(array, level) {\n        var zc = zeroCrossings(array, level);\n        var n = zc.length;\n        var npos = new Array(n);\n        var ncel = new Array(n);\n\n        for (var i = 0; i < n; ++i) {\n          npos[i] = [zc[i]];\n          ncel[i] = [i];\n        }\n\n        return {\n          positions: npos,\n          cells: ncel\n        };\n      }\n\n      var CACHE = {};\n\n      function surfaceNets(array, level) {\n        if (array.dimension <= 0) {\n          return {\n            positions: [],\n            cells: []\n          };\n        } else if (array.dimension === 1) {\n          return mesh1D(array, level);\n        }\n\n        var typesig = array.order.join() + \"-\" + array.dtype;\n        var proc = CACHE[typesig];\n        var level = +level || 0.0;\n\n        if (!proc) {\n          proc = CACHE[typesig] = buildSurfaceNets(array.order, array.dtype);\n        }\n\n        return proc(array, level);\n      }\n    }, {\n      \"ndarray-extract-contour\": 251,\n      \"zero-crossings\": 318\n    }],\n    303: [function (_glvis_, module, exports) {\n      (function (process) {\n        (function () {\n          'use strict';\n\n          module.exports = textGet;\n\n          var vectorizeText = _glvis_('vectorize-text');\n\n          var globals = window || process.global || {};\n\n          var __TEXT_CACHE = globals.__TEXT_CACHE || {};\n\n          globals.__TEXT_CACHE = {};\n\n          function unwrap(mesh) {\n            var cells = mesh.cells;\n            var positions = mesh.positions;\n            var data = new Float32Array(cells.length * 6);\n            var ptr = 0;\n            var shapeX = 0;\n\n            for (var i = 0; i < cells.length; ++i) {\n              var tri = cells[i];\n\n              for (var j = 0; j < 3; ++j) {\n                var point = positions[tri[j]];\n                data[ptr++] = point[0];\n                data[ptr++] = point[1] + 1.4;\n                shapeX = Math.max(point[0], shapeX);\n              }\n            }\n\n            return {\n              data: data,\n              shape: shapeX\n            };\n          }\n\n          function textGet(font, text, opts) {\n            var opts = opts || {};\n            var fontcache = __TEXT_CACHE[font];\n\n            if (!fontcache) {\n              fontcache = __TEXT_CACHE[font] = {\n                ' ': {\n                  data: new Float32Array(0),\n                  shape: 0.2\n                }\n              };\n            }\n\n            var mesh = fontcache[text];\n\n            if (!mesh) {\n              if (text.length <= 1 || !/\\d/.test(text)) {\n                mesh = fontcache[text] = unwrap(vectorizeText(text, {\n                  triangles: true,\n                  font: font,\n                  textAlign: opts.textAlign || 'left',\n                  textBaseline: 'alphabetic',\n                  styletags: {\n                    breaklines: true,\n                    bolds: true,\n                    italics: true,\n                    subscripts: true,\n                    superscripts: true\n                  }\n                }));\n              } else {\n                var parts = text.split(/(\\d|\\s)/);\n                var buffer = new Array(parts.length);\n                var bufferSize = 0;\n                var shapeX = 0;\n\n                for (var i = 0; i < parts.length; ++i) {\n                  buffer[i] = textGet(font, parts[i]);\n                  bufferSize += buffer[i].data.length;\n                  shapeX += buffer[i].shape;\n\n                  if (i > 0) {\n                    shapeX += 0.02;\n                  }\n                }\n\n                var data = new Float32Array(bufferSize);\n                var ptr = 0;\n                var xOffset = -0.5 * shapeX;\n\n                for (var i = 0; i < buffer.length; ++i) {\n                  var bdata = buffer[i].data;\n\n                  for (var j = 0; j < bdata.length; j += 2) {\n                    data[ptr++] = bdata[j] + xOffset;\n                    data[ptr++] = bdata[j + 1];\n                  }\n\n                  xOffset += buffer[i].shape + 0.02;\n                }\n\n                mesh = fontcache[text] = {\n                  data: data,\n                  shape: shapeX\n                };\n              }\n            }\n\n            return mesh;\n          }\n        }).call(this);\n      }).call(this, _glvis_('_process'));\n    }, {\n      \"_process\": 5,\n      \"vectorize-text\": 311\n    }],\n    304: [function (_glvis_, module, exports) {\n      'use strict';\n\n      var parseUnit = _glvis_('parse-unit');\n\n      module.exports = toPX;\n      var PIXELS_PER_INCH = 96;\n\n      function getPropertyInPX(element, prop) {\n        var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop));\n        return parts[0] * toPX(parts[1], element);\n      } //This brutal hack is needed\n\n\n      function getSizeBrutal(unit, element) {\n        var testDIV = document.createElement('div');\n        testDIV.style['font-size'] = '128' + unit;\n        element.appendChild(testDIV);\n        var size = getPropertyInPX(testDIV, 'font-size') / 128;\n        element.removeChild(testDIV);\n        return size;\n      }\n\n      function toPX(str, element) {\n        element = element || document.body;\n        str = (str || 'px').trim().toLowerCase();\n\n        if (element === window || element === document) {\n          element = document.body;\n        }\n\n        switch (str) {\n          case '%':\n            //Ambiguous, not sure if we should use width or height\n            return element.clientHeight / 100.0;\n\n          case 'ch':\n          case 'ex':\n            return getSizeBrutal(str, element);\n\n          case 'em':\n            return getPropertyInPX(element, 'font-size');\n\n          case 'rem':\n            return getPropertyInPX(document.body, 'font-size');\n\n          case 'vw':\n            return window.innerWidth / 100;\n\n          case 'vh':\n            return window.innerHeight / 100;\n\n          case 'vmin':\n            return Math.min(window.innerWidth, window.innerHeight) / 100;\n\n          case 'vmax':\n            return Math.max(window.innerWidth, window.innerHeight) / 100;\n\n          case 'in':\n            return PIXELS_PER_INCH;\n\n          case 'cm':\n            return PIXELS_PER_INCH / 2.54;\n\n          case 'mm':\n            return PIXELS_PER_INCH / 25.4;\n\n          case 'pt':\n            return PIXELS_PER_INCH / 72;\n\n          case 'pc':\n            return PIXELS_PER_INCH / 6;\n        }\n\n        return 1;\n      }\n    }, {\n      \"parse-unit\": 265\n    }],\n    305: [function (_glvis_, module, exports) {\n      'use strict';\n\n      module.exports = createTurntableController;\n\n      var filterVector = _glvis_('filtered-vector');\n\n      var invert44 = _glvis_('gl-mat4/invert');\n\n      var rotateM = _glvis_('gl-mat4/rotate');\n\n      var cross = _glvis_('gl-vec3/cross');\n\n      var normalize3 = _glvis_('gl-vec3/normalize');\n\n      var dot3 = _glvis_('gl-vec3/dot');\n\n      function len3(x, y, z) {\n        return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));\n      }\n\n      function clamp1(x) {\n        return Math.min(1.0, Math.max(-1.0, x));\n      }\n\n      function findOrthoPair(v) {\n        var vx = Math.abs(v[0]);\n        var vy = Math.abs(v[1]);\n        var vz = Math.abs(v[2]);\n        var u = [0, 0, 0];\n\n        if (vx > Math.max(vy, vz)) {\n          u[2] = 1;\n        } else if (vy > Math.max(vx, vz)) {\n          u[0] = 1;\n        } else {\n          u[1] = 1;\n        }\n\n        var vv = 0;\n        var uv = 0;\n\n        for (var i = 0; i < 3; ++i) {\n          vv += v[i] * v[i];\n          uv += u[i] * v[i];\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          u[i] -= uv / vv * v[i];\n        }\n\n        normalize3(u, u);\n        return u;\n      }\n\n      function TurntableController(zoomMin, zoomMax, center, up, right, radius, theta, phi) {\n        this.center = filterVector(center);\n        this.up = filterVector(up);\n        this.right = filterVector(right);\n        this.radius = filterVector([radius]);\n        this.angle = filterVector([theta, phi]);\n        this.angle.bounds = [[-Infinity, -Math.PI / 2], [Infinity, Math.PI / 2]];\n        this.setDistanceLimits(zoomMin, zoomMax);\n        this.computedCenter = this.center.curve(0);\n        this.computedUp = this.up.curve(0);\n        this.computedRight = this.right.curve(0);\n        this.computedRadius = this.radius.curve(0);\n        this.computedAngle = this.angle.curve(0);\n        this.computedToward = [0, 0, 0];\n        this.computedEye = [0, 0, 0];\n        this.computedMatrix = new Array(16);\n\n        for (var i = 0; i < 16; ++i) {\n          this.computedMatrix[i] = 0.5;\n        }\n\n        this.recalcMatrix(0);\n      }\n\n      var proto = TurntableController.prototype;\n\n      proto.setDistanceLimits = function (minDist, maxDist) {\n        if (minDist > 0) {\n          minDist = Math.log(minDist);\n        } else {\n          minDist = -Infinity;\n        }\n\n        if (maxDist > 0) {\n          maxDist = Math.log(maxDist);\n        } else {\n          maxDist = Infinity;\n        }\n\n        maxDist = Math.max(maxDist, minDist);\n        this.radius.bounds[0][0] = minDist;\n        this.radius.bounds[1][0] = maxDist;\n      };\n\n      proto.getDistanceLimits = function (out) {\n        var bounds = this.radius.bounds[0];\n\n        if (out) {\n          out[0] = Math.exp(bounds[0][0]);\n          out[1] = Math.exp(bounds[1][0]);\n          return out;\n        }\n\n        return [Math.exp(bounds[0][0]), Math.exp(bounds[1][0])];\n      };\n\n      proto.recalcMatrix = function (t) {\n        //Recompute curves\n        this.center.curve(t);\n        this.up.curve(t);\n        this.right.curve(t);\n        this.radius.curve(t);\n        this.angle.curve(t); //Compute frame for camera matrix\n\n        var up = this.computedUp;\n        var right = this.computedRight;\n        var uu = 0.0;\n        var ur = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          ur += up[i] * right[i];\n          uu += up[i] * up[i];\n        }\n\n        var ul = Math.sqrt(uu);\n        var rr = 0.0;\n\n        for (var i = 0; i < 3; ++i) {\n          right[i] -= up[i] * ur / uu;\n          rr += right[i] * right[i];\n          up[i] /= ul;\n        }\n\n        var rl = Math.sqrt(rr);\n\n        for (var i = 0; i < 3; ++i) {\n          right[i] /= rl;\n        } //Compute toward vector\n\n\n        var toward = this.computedToward;\n        cross(toward, up, right);\n        normalize3(toward, toward); //Compute angular parameters\n\n        var radius = Math.exp(this.computedRadius[0]);\n        var theta = this.computedAngle[0];\n        var phi = this.computedAngle[1];\n        var ctheta = Math.cos(theta);\n        var stheta = Math.sin(theta);\n        var cphi = Math.cos(phi);\n        var sphi = Math.sin(phi);\n        var center = this.computedCenter;\n        var wx = ctheta * cphi;\n        var wy = stheta * cphi;\n        var wz = sphi;\n        var sx = -ctheta * sphi;\n        var sy = -stheta * sphi;\n        var sz = cphi;\n        var eye = this.computedEye;\n        var mat = this.computedMatrix;\n\n        for (var i = 0; i < 3; ++i) {\n          var x = wx * right[i] + wy * toward[i] + wz * up[i];\n          mat[4 * i + 1] = sx * right[i] + sy * toward[i] + sz * up[i];\n          mat[4 * i + 2] = x;\n          mat[4 * i + 3] = 0.0;\n        }\n\n        var ax = mat[1];\n        var ay = mat[5];\n        var az = mat[9];\n        var bx = mat[2];\n        var by = mat[6];\n        var bz = mat[10];\n        var cx = ay * bz - az * by;\n        var cy = az * bx - ax * bz;\n        var cz = ax * by - ay * bx;\n        var cl = len3(cx, cy, cz);\n        cx /= cl;\n        cy /= cl;\n        cz /= cl;\n        mat[0] = cx;\n        mat[4] = cy;\n        mat[8] = cz;\n\n        for (var i = 0; i < 3; ++i) {\n          eye[i] = center[i] + mat[2 + 4 * i] * radius;\n        }\n\n        for (var i = 0; i < 3; ++i) {\n          var rr = 0.0;\n\n          for (var j = 0; j < 3; ++j) {\n            rr += mat[i + 4 * j] * eye[j];\n          }\n\n          mat[12 + i] = -rr;\n        }\n\n        mat[15] = 1.0;\n      };\n\n      proto.getMatrix = function (t, result) {\n        this.recalcMatrix(t);\n        var mat = this.computedMatrix;\n\n        if (result) {\n          for (var i = 0; i < 16; ++i) {\n            result[i] = mat[i];\n          }\n\n          return result;\n        }\n\n        return mat;\n      };\n\n      var zAxis = [0, 0, 0];\n\n      proto.rotate = function (t, dtheta, dphi, droll) {\n        this.angle.move(t, dtheta, dphi);\n\n        if (droll) {\n          this.recalcMatrix(t);\n          var mat = this.computedMatrix;\n          zAxis[0] = mat[2];\n          zAxis[1] = mat[6];\n          zAxis[2] = mat[10];\n          var up = this.computedUp;\n          var right = this.computedRight;\n          var toward = this.computedToward;\n\n          for (var i = 0; i < 3; ++i) {\n            mat[4 * i] = up[i];\n            mat[4 * i + 1] = right[i];\n            mat[4 * i + 2] = toward[i];\n          }\n\n          rotateM(mat, mat, droll, zAxis);\n\n          for (var i = 0; i < 3; ++i) {\n            up[i] = mat[4 * i];\n            right[i] = mat[4 * i + 1];\n          }\n\n          this.up.set(t, up[0], up[1], up[2]);\n          this.right.set(t, right[0], right[1], right[2]);\n        }\n      };\n\n      proto.pan = function (t, dx, dy, dz) {\n        dx = dx || 0.0;\n        dy = dy || 0.0;\n        dz = dz || 0.0;\n        this.recalcMatrix(t);\n        var mat = this.computedMatrix;\n        var dist = Math.exp(this.computedRadius[0]);\n        var ux = mat[1];\n        var uy = mat[5];\n        var uz = mat[9];\n        var ul = len3(ux, uy, uz);\n        ux /= ul;\n        uy /= ul;\n        uz /= ul;\n        var rx = mat[0];\n        var ry = mat[4];\n        var rz = mat[8];\n        var ru = rx * ux + ry * uy + rz * uz;\n        rx -= ux * ru;\n        ry -= uy * ru;\n        rz -= uz * ru;\n        var rl = len3(rx, ry, rz);\n        rx /= rl;\n        ry /= rl;\n        rz /= rl;\n        var vx = rx * dx + ux * dy;\n        var vy = ry * dx + uy * dy;\n        var vz = rz * dx + uz * dy;\n        this.center.move(t, vx, vy, vz); //Update z-component of radius\n\n        var radius = Math.exp(this.computedRadius[0]);\n        radius = Math.max(1e-4, radius + dz);\n        this.radius.set(t, Math.log(radius));\n      };\n\n      proto.translate = function (t, dx, dy, dz) {\n        this.center.move(t, dx || 0.0, dy || 0.0, dz || 0.0);\n      }; //Recenters the coordinate axes\n\n\n      proto.setMatrix = function (t, mat, axes, noSnap) {\n        //Get the axes for tare\n        var ushift = 1;\n\n        if (typeof axes === 'number') {\n          ushift = axes | 0;\n        }\n\n        if (ushift < 0 || ushift > 3) {\n          ushift = 1;\n        }\n\n        var vshift = (ushift + 2) % 3;\n        var fshift = (ushift + 1) % 3; //Recompute state for new t value\n\n        if (!mat) {\n          this.recalcMatrix(t);\n          mat = this.computedMatrix;\n        } //Get right and up vectors\n\n\n        var ux = mat[ushift];\n        var uy = mat[ushift + 4];\n        var uz = mat[ushift + 8];\n\n        if (!noSnap) {\n          var ul = len3(ux, uy, uz);\n          ux /= ul;\n          uy /= ul;\n          uz /= ul;\n        } else {\n          var ax = Math.abs(ux);\n          var ay = Math.abs(uy);\n          var az = Math.abs(uz);\n          var am = Math.max(ax, ay, az);\n\n          if (ax === am) {\n            ux = ux < 0 ? -1 : 1;\n            uy = uz = 0;\n          } else if (az === am) {\n            uz = uz < 0 ? -1 : 1;\n            ux = uy = 0;\n          } else {\n            uy = uy < 0 ? -1 : 1;\n            ux = uz = 0;\n          }\n        }\n\n        var rx = mat[vshift];\n        var ry = mat[vshift + 4];\n        var rz = mat[vshift + 8];\n        var ru = rx * ux + ry * uy + rz * uz;\n        rx -= ux * ru;\n        ry -= uy * ru;\n        rz -= uz * ru;\n        var rl = len3(rx, ry, rz);\n        rx /= rl;\n        ry /= rl;\n        rz /= rl;\n        var fx = uy * rz - uz * ry;\n        var fy = uz * rx - ux * rz;\n        var fz = ux * ry - uy * rx;\n        var fl = len3(fx, fy, fz);\n        fx /= fl;\n        fy /= fl;\n        fz /= fl;\n        this.center.jump(t, ex, ey, ez);\n        this.radius.idle(t);\n        this.up.jump(t, ux, uy, uz);\n        this.right.jump(t, rx, ry, rz);\n        var phi, theta;\n\n        if (ushift === 2) {\n          var cx = mat[1];\n          var cy = mat[5];\n          var cz = mat[9];\n          var cr = cx * rx + cy * ry + cz * rz;\n          var cf = cx * fx + cy * fy + cz * fz;\n\n          if (tu < 0) {\n            phi = -Math.PI / 2;\n          } else {\n            phi = Math.PI / 2;\n          }\n\n          theta = Math.atan2(cf, cr);\n        } else {\n          var tx = mat[2];\n          var ty = mat[6];\n          var tz = mat[10];\n          var tu = tx * ux + ty * uy + tz * uz;\n          var tr = tx * rx + ty * ry + tz * rz;\n          var tf = tx * fx + ty * fy + tz * fz;\n          phi = Math.asin(clamp1(tu));\n          theta = Math.atan2(tf, tr);\n        }\n\n        this.angle.jump(t, theta, phi);\n        this.recalcMatrix(t);\n        var dx = mat[2];\n        var dy = mat[6];\n        var dz = mat[10];\n        var imat = this.computedMatrix;\n        invert44(imat, mat);\n        var w = imat[15];\n        var ex = imat[12] / w;\n        var ey = imat[13] / w;\n        var ez = imat[14] / w;\n        var gs = Math.exp(this.computedRadius[0]);\n        this.center.jump(t, ex - dx * gs, ey - dy * gs, ez - dz * gs);\n      };\n\n      proto.lastT = function () {\n        return Math.max(this.center.lastT(), this.up.lastT(), this.right.lastT(), this.radius.lastT(), this.angle.lastT());\n      };\n\n      proto.idle = function (t) {\n        this.center.idle(t);\n        this.up.idle(t);\n        this.right.idle(t);\n        this.radius.idle(t);\n        this.angle.idle(t);\n      };\n\n      proto.flush = function (t) {\n        this.center.flush(t);\n        this.up.flush(t);\n        this.right.flush(t);\n        this.radius.flush(t);\n        this.angle.flush(t);\n      };\n\n      proto.setDistance = function (t, d) {\n        if (d > 0) {\n          this.radius.set(t, Math.log(d));\n        }\n      };\n\n      proto.lookAt = function (t, eye, center, up) {\n        this.recalcMatrix(t);\n        eye = eye || this.computedEye;\n        center = center || this.computedCenter;\n        up = up || this.computedUp;\n        var ux = up[0];\n        var uy = up[1];\n        var uz = up[2];\n        var ul = len3(ux, uy, uz);\n\n        if (ul < 1e-6) {\n          return;\n        }\n\n        ux /= ul;\n        uy /= ul;\n        uz /= ul;\n        var tx = eye[0] - center[0];\n        var ty = eye[1] - center[1];\n        var tz = eye[2] - center[2];\n        var tl = len3(tx, ty, tz);\n\n        if (tl < 1e-6) {\n          return;\n        }\n\n        tx /= tl;\n        ty /= tl;\n        tz /= tl;\n        var right = this.computedRight;\n        var rx = right[0];\n        var ry = right[1];\n        var rz = right[2];\n        var ru = ux * rx + uy * ry + uz * rz;\n        rx -= ru * ux;\n        ry -= ru * uy;\n        rz -= ru * uz;\n        var rl = len3(rx, ry, rz);\n\n        if (rl < 0.01) {\n          rx = uy * tz - uz * ty;\n          ry = uz * tx - ux * tz;\n          rz = ux * ty - uy * tx;\n          rl = len3(rx, ry, rz);\n\n          if (rl < 1e-6) {\n            return;\n          }\n        }\n\n        rx /= rl;\n        ry /= rl;\n        rz /= rl;\n        this.up.set(t, ux, uy, uz);\n        this.right.set(t, rx, ry, rz);\n        this.center.set(t, center[0], center[1], center[2]);\n        this.radius.set(t, Math.log(tl));\n        var fx = uy * rz - uz * ry;\n        var fy = uz * rx - ux * rz;\n        var fz = ux * ry - uy * rx;\n        var fl = len3(fx, fy, fz);\n        fx /= fl;\n        fy /= fl;\n        fz /= fl;\n        var tu = ux * tx + uy * ty + uz * tz;\n        var tr = rx * tx + ry * ty + rz * tz;\n        var tf = fx * tx + fy * ty + fz * tz;\n        var phi = Math.asin(clamp1(tu));\n        var theta = Math.atan2(tf, tr);\n        var angleState = this.angle._state;\n        var lastTheta = angleState[angleState.length - 1];\n        var lastPhi = angleState[angleState.length - 2];\n        lastTheta = lastTheta % (2.0 * Math.PI);\n        var dp = Math.abs(lastTheta + 2.0 * Math.PI - theta);\n        var d0 = Math.abs(lastTheta - theta);\n        var dn = Math.abs(lastTheta - 2.0 * Math.PI - theta);\n\n        if (dp < d0) {\n          lastTheta += 2.0 * Math.PI;\n        }\n\n        if (dn < d0) {\n          lastTheta -= 2.0 * Math.PI;\n        }\n\n        this.angle.jump(this.angle.lastT(), lastTheta, lastPhi);\n        this.angle.set(t, theta, phi);\n      };\n\n      function createTurntableController(options) {\n        options = options || {};\n        var center = options.center || [0, 0, 0];\n        var up = options.up || [0, 1, 0];\n        var right = options.right || findOrthoPair(up);\n        var radius = options.radius || 1.0;\n        var theta = options.theta || 0.0;\n        var phi = options.phi || 0.0;\n        center = [].slice.call(center, 0, 3);\n        up = [].slice.call(up, 0, 3);\n        normalize3(up, up);\n        right = [].slice.call(right, 0, 3);\n        normalize3(right, right);\n\n        if ('eye' in options) {\n          var eye = options.eye;\n          var toward = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];\n          cross(right, toward, up);\n\n          if (len3(right[0], right[1], right[2]) < 1e-6) {\n            right = findOrthoPair(up);\n          } else {\n            normalize3(right, right);\n          }\n\n          radius = len3(toward[0], toward[1], toward[2]);\n          var ut = dot3(up, toward) / radius;\n          var rt = dot3(right, toward) / radius;\n          phi = Math.acos(ut);\n          theta = Math.acos(rt);\n        } //Use logarithmic coordinates for radius\n\n\n        radius = Math.log(radius); //Return the controller\n\n        return new TurntableController(options.zoomMin, options.zoomMax, center, up, right, radius, theta, phi);\n      }\n    }, {\n      \"filtered-vector\": 68,\n      \"gl-mat4/invert\": 98,\n      \"gl-mat4/rotate\": 103,\n      \"gl-vec3/cross\": 157,\n      \"gl-vec3/dot\": 162,\n      \"gl-vec3/normalize\": 179\n    }],\n    306: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = twoProduct;\n      var SPLITTER = +(Math.pow(2, 27) + 1.0);\n\n      function twoProduct(a, b, result) {\n        var x = a * b;\n        var c = SPLITTER * a;\n        var abig = c - a;\n        var ahi = c - abig;\n        var alo = a - ahi;\n        var d = SPLITTER * b;\n        var bbig = d - b;\n        var bhi = d - bbig;\n        var blo = b - bhi;\n        var err1 = x - ahi * bhi;\n        var err2 = err1 - alo * bhi;\n        var err3 = err2 - ahi * blo;\n        var y = alo * blo - err3;\n\n        if (result) {\n          result[0] = y;\n          result[1] = x;\n          return result;\n        }\n\n        return [y, x];\n      }\n    }, {}],\n    307: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = fastTwoSum;\n\n      function fastTwoSum(a, b, result) {\n        var x = a + b;\n        var bv = x - a;\n        var av = x - bv;\n        var br = b - bv;\n        var ar = a - av;\n\n        if (result) {\n          result[0] = ar + br;\n          result[1] = x;\n          return result;\n        }\n\n        return [ar + br, x];\n      }\n    }, {}],\n    308: [function (_glvis_, module, exports) {\n      (function (global) {\n        (function () {\n          'use strict';\n\n          var bits = _glvis_('bit-twiddle');\n\n          var dup = _glvis_('dup');\n\n          var Buffer = _glvis_('buffer').Buffer; //Legacy pool support\n\n\n          if (!global.__TYPEDARRAY_POOL) {\n            global.__TYPEDARRAY_POOL = {\n              UINT8: dup([32, 0]),\n              UINT16: dup([32, 0]),\n              UINT32: dup([32, 0]),\n              BIGUINT64: dup([32, 0]),\n              INT8: dup([32, 0]),\n              INT16: dup([32, 0]),\n              INT32: dup([32, 0]),\n              BIGINT64: dup([32, 0]),\n              FLOAT: dup([32, 0]),\n              DOUBLE: dup([32, 0]),\n              DATA: dup([32, 0]),\n              UINT8C: dup([32, 0]),\n              BUFFER: dup([32, 0])\n            };\n          }\n\n          var hasUint8C = typeof Uint8ClampedArray !== 'undefined';\n          var hasBigUint64 = typeof BigUint64Array !== 'undefined';\n          var hasBigInt64 = typeof BigInt64Array !== 'undefined';\n          var POOL = global.__TYPEDARRAY_POOL; //Upgrade pool\n\n          if (!POOL.UINT8C) {\n            POOL.UINT8C = dup([32, 0]);\n          }\n\n          if (!POOL.BIGUINT64) {\n            POOL.BIGUINT64 = dup([32, 0]);\n          }\n\n          if (!POOL.BIGINT64) {\n            POOL.BIGINT64 = dup([32, 0]);\n          }\n\n          if (!POOL.BUFFER) {\n            POOL.BUFFER = dup([32, 0]);\n          } //New technique: Only allocate from ArrayBufferView and Buffer\n\n\n          var DATA = POOL.DATA,\n              BUFFER = POOL.BUFFER;\n\n          exports.free = function free(array) {\n            if (Buffer.isBuffer(array)) {\n              BUFFER[bits.log2(array.length)].push(array);\n            } else {\n              if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {\n                array = array.buffer;\n              }\n\n              if (!array) {\n                return;\n              }\n\n              var n = array.length || array.byteLength;\n              var log_n = bits.log2(n) | 0;\n              DATA[log_n].push(array);\n            }\n          };\n\n          function freeArrayBuffer(buffer) {\n            if (!buffer) {\n              return;\n            }\n\n            var n = buffer.length || buffer.byteLength;\n            var log_n = bits.log2(n);\n            DATA[log_n].push(buffer);\n          }\n\n          function freeTypedArray(array) {\n            freeArrayBuffer(array.buffer);\n          }\n\n          exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;\n          exports.freeArrayBuffer = freeArrayBuffer;\n\n          exports.freeBuffer = function freeBuffer(array) {\n            BUFFER[bits.log2(array.length)].push(array);\n          };\n\n          exports.malloc = function malloc(n, dtype) {\n            if (dtype === undefined || dtype === 'arraybuffer') {\n              return mallocArrayBuffer(n);\n            } else {\n              switch (dtype) {\n                case 'uint8':\n                  return mallocUint8(n);\n\n                case 'uint16':\n                  return mallocUint16(n);\n\n                case 'uint32':\n                  return mallocUint32(n);\n\n                case 'int8':\n                  return mallocInt8(n);\n\n                case 'int16':\n                  return mallocInt16(n);\n\n                case 'int32':\n                  return mallocInt32(n);\n\n                case 'float':\n                case 'float32':\n                  return mallocFloat(n);\n\n                case 'double':\n                case 'float64':\n                  return mallocDouble(n);\n\n                case 'uint8_clamped':\n                  return mallocUint8Clamped(n);\n\n                case 'bigint64':\n                  return mallocBigInt64(n);\n\n                case 'biguint64':\n                  return mallocBigUint64(n);\n\n                case 'buffer':\n                  return mallocBuffer(n);\n\n                case 'data':\n                case 'dataview':\n                  return mallocDataView(n);\n\n                default:\n                  return null;\n              }\n            }\n\n            return null;\n          };\n\n          function mallocArrayBuffer(n) {\n            var n = bits.nextPow2(n);\n            var log_n = bits.log2(n);\n            var d = DATA[log_n];\n\n            if (d.length > 0) {\n              return d.pop();\n            }\n\n            return new ArrayBuffer(n);\n          }\n\n          exports.mallocArrayBuffer = mallocArrayBuffer;\n\n          function mallocUint8(n) {\n            return new Uint8Array(mallocArrayBuffer(n), 0, n);\n          }\n\n          exports.mallocUint8 = mallocUint8;\n\n          function mallocUint16(n) {\n            return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);\n          }\n\n          exports.mallocUint16 = mallocUint16;\n\n          function mallocUint32(n) {\n            return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);\n          }\n\n          exports.mallocUint32 = mallocUint32;\n\n          function mallocInt8(n) {\n            return new Int8Array(mallocArrayBuffer(n), 0, n);\n          }\n\n          exports.mallocInt8 = mallocInt8;\n\n          function mallocInt16(n) {\n            return new Int16Array(mallocArrayBuffer(2 * n), 0, n);\n          }\n\n          exports.mallocInt16 = mallocInt16;\n\n          function mallocInt32(n) {\n            return new Int32Array(mallocArrayBuffer(4 * n), 0, n);\n          }\n\n          exports.mallocInt32 = mallocInt32;\n\n          function mallocFloat(n) {\n            return new Float32Array(mallocArrayBuffer(4 * n), 0, n);\n          }\n\n          exports.mallocFloat32 = exports.mallocFloat = mallocFloat;\n\n          function mallocDouble(n) {\n            return new Float64Array(mallocArrayBuffer(8 * n), 0, n);\n          }\n\n          exports.mallocFloat64 = exports.mallocDouble = mallocDouble;\n\n          function mallocUint8Clamped(n) {\n            if (hasUint8C) {\n              return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);\n            } else {\n              return mallocUint8(n);\n            }\n          }\n\n          exports.mallocUint8Clamped = mallocUint8Clamped;\n\n          function mallocBigUint64(n) {\n            if (hasBigUint64) {\n              return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);\n            } else {\n              return null;\n            }\n          }\n\n          exports.mallocBigUint64 = mallocBigUint64;\n\n          function mallocBigInt64(n) {\n            if (hasBigInt64) {\n              return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);\n            } else {\n              return null;\n            }\n          }\n\n          exports.mallocBigInt64 = mallocBigInt64;\n\n          function mallocDataView(n) {\n            return new DataView(mallocArrayBuffer(n), 0, n);\n          }\n\n          exports.mallocDataView = mallocDataView;\n\n          function mallocBuffer(n) {\n            n = bits.nextPow2(n);\n            var log_n = bits.log2(n);\n            var cache = BUFFER[log_n];\n\n            if (cache.length > 0) {\n              return cache.pop();\n            }\n\n            return new Buffer(n);\n          }\n\n          exports.mallocBuffer = mallocBuffer;\n\n          exports.clearCache = function clearCache() {\n            for (var i = 0; i < 32; ++i) {\n              POOL.UINT8[i].length = 0;\n              POOL.UINT16[i].length = 0;\n              POOL.UINT32[i].length = 0;\n              POOL.INT8[i].length = 0;\n              POOL.INT16[i].length = 0;\n              POOL.INT32[i].length = 0;\n              POOL.FLOAT[i].length = 0;\n              POOL.DOUBLE[i].length = 0;\n              POOL.BIGUINT64[i].length = 0;\n              POOL.BIGINT64[i].length = 0;\n              POOL.UINT8C[i].length = 0;\n              DATA[i].length = 0;\n              BUFFER[i].length = 0;\n            }\n          };\n        }).call(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"bit-twiddle\": 32,\n      \"buffer\": 3,\n      \"dup\": 65\n    }],\n    309: [function (_glvis_, module, exports) {\n      \"use strict\";\n      \"use restrict\";\n\n      module.exports = UnionFind;\n\n      function UnionFind(count) {\n        this.roots = new Array(count);\n        this.ranks = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          this.roots[i] = i;\n          this.ranks[i] = 0;\n        }\n      }\n\n      var proto = UnionFind.prototype;\n      Object.defineProperty(proto, \"length\", {\n        \"get\": function get() {\n          return this.roots.length;\n        }\n      });\n\n      proto.makeSet = function () {\n        var n = this.roots.length;\n        this.roots.push(n);\n        this.ranks.push(0);\n        return n;\n      };\n\n      proto.find = function (x) {\n        var x0 = x;\n        var roots = this.roots;\n\n        while (roots[x] !== x) {\n          x = roots[x];\n        }\n\n        while (roots[x0] !== x) {\n          var y = roots[x0];\n          roots[x0] = x;\n          x0 = y;\n        }\n\n        return x;\n      };\n\n      proto.link = function (x, y) {\n        var xr = this.find(x),\n            yr = this.find(y);\n\n        if (xr === yr) {\n          return;\n        }\n\n        var ranks = this.ranks,\n            roots = this.roots,\n            xd = ranks[xr],\n            yd = ranks[yr];\n\n        if (xd < yd) {\n          roots[xr] = yr;\n        } else if (yd < xd) {\n          roots[yr] = xr;\n        } else {\n          roots[yr] = xr;\n          ++ranks[xr];\n        }\n      };\n    }, {}],\n    310: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function unique_pred(list, compare) {\n        var ptr = 1,\n            len = list.length,\n            a = list[0],\n            b = list[0];\n\n        for (var i = 1; i < len; ++i) {\n          b = a;\n          a = list[i];\n\n          if (compare(a, b)) {\n            if (i === ptr) {\n              ptr++;\n              continue;\n            }\n\n            list[ptr++] = a;\n          }\n        }\n\n        list.length = ptr;\n        return list;\n      }\n\n      function unique_eq(list) {\n        var ptr = 1,\n            len = list.length,\n            a = list[0],\n            b = list[0];\n\n        for (var i = 1; i < len; ++i, b = a) {\n          b = a;\n          a = list[i];\n\n          if (a !== b) {\n            if (i === ptr) {\n              ptr++;\n              continue;\n            }\n\n            list[ptr++] = a;\n          }\n        }\n\n        list.length = ptr;\n        return list;\n      }\n\n      function unique(list, compare, sorted) {\n        if (list.length === 0) {\n          return list;\n        }\n\n        if (compare) {\n          if (!sorted) {\n            list.sort(compare);\n          }\n\n          return unique_pred(list, compare);\n        }\n\n        if (!sorted) {\n          list.sort();\n        }\n\n        return unique_eq(list);\n      }\n\n      module.exports = unique;\n    }, {}],\n    311: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = createText;\n\n      var vectorizeText = _glvis_(\"./lib/vtext\");\n\n      var defaultCanvas = null;\n      var defaultContext = null;\n\n      if (typeof document !== 'undefined') {\n        defaultCanvas = document.createElement('canvas');\n        defaultCanvas.width = 8192;\n        defaultCanvas.height = 1024;\n        defaultContext = defaultCanvas.getContext(\"2d\");\n      }\n\n      function createText(str, options) {\n        if (typeof options !== \"object\" || options === null) {\n          options = {};\n        }\n\n        return vectorizeText(str, options.canvas || defaultCanvas, options.context || defaultContext, options);\n      }\n    }, {\n      \"./lib/vtext\": 312\n    }],\n    312: [function (_glvis_, module, exports) {\n      module.exports = vectorizeText;\n      module.exports.processPixels = processPixels;\n\n      var surfaceNets = _glvis_('surface-nets');\n\n      var ndarray = _glvis_('ndarray');\n\n      var simplify = _glvis_('simplify-planar-graph');\n\n      var cleanPSLG = _glvis_('clean-pslg');\n\n      var cdt2d = _glvis_('cdt2d');\n\n      var toPolygonCrappy = _glvis_('planar-graph-to-polyline');\n\n      var TAG_bold = \"b\";\n      var CHR_bold = 'b|';\n      var TAG_italic = \"i\";\n      var CHR_italic = 'i|';\n      var TAG_super = \"sup\";\n      var CHR_super0 = '+';\n      var CHR_super = '+1';\n      var TAG_sub = \"sub\";\n      var CHR_sub0 = '-';\n      var CHR_sub = '-1';\n\n      function parseTag(tag, TAG_CHR, str, map) {\n        var opnTag = \"<\" + tag + \">\";\n        var clsTag = \"</\" + tag + \">\";\n        var nOPN = opnTag.length;\n        var nCLS = clsTag.length;\n        var isRecursive = TAG_CHR[0] === CHR_super0 || TAG_CHR[0] === CHR_sub0;\n        var a = 0;\n        var b = -nCLS;\n\n        while (a > -1) {\n          a = str.indexOf(opnTag, a);\n          if (a === -1) break;\n          b = str.indexOf(clsTag, a + nOPN);\n          if (b === -1) break;\n          if (b <= a) break;\n\n          for (var i = a; i < b + nCLS; ++i) {\n            if (i < a + nOPN || i >= b) {\n              map[i] = null;\n              str = str.substr(0, i) + \" \" + str.substr(i + 1);\n            } else {\n              if (map[i] !== null) {\n                var pos = map[i].indexOf(TAG_CHR[0]);\n\n                if (pos === -1) {\n                  map[i] += TAG_CHR;\n                } else {\n                  // i.e. to handle multiple sub/super-scripts\n                  if (isRecursive) {\n                    // i.e to increase the sub/sup number\n                    map[i] = map[i].substr(0, pos + 1) + (1 + parseInt(map[i][pos + 1])) + map[i].substr(pos + 2);\n                  }\n                }\n              }\n            }\n          }\n\n          var start = a + nOPN;\n          var remainingStr = str.substr(start, b - start);\n          var c = remainingStr.indexOf(opnTag);\n          if (c !== -1) a = c;else a = b + nCLS;\n        }\n\n        return map;\n      }\n\n      function transformPositions(positions, options, size) {\n        var align = options.textAlign || \"start\";\n        var baseline = options.textBaseline || \"alphabetic\";\n        var lo = [1 << 30, 1 << 30];\n        var hi = [0, 0];\n        var n = positions.length;\n\n        for (var i = 0; i < n; ++i) {\n          var p = positions[i];\n\n          for (var j = 0; j < 2; ++j) {\n            lo[j] = Math.min(lo[j], p[j]) | 0;\n            hi[j] = Math.max(hi[j], p[j]) | 0;\n          }\n        }\n\n        var xShift = 0;\n\n        switch (align) {\n          case \"center\":\n            xShift = -0.5 * (lo[0] + hi[0]);\n            break;\n\n          case \"right\":\n          case \"end\":\n            xShift = -hi[0];\n            break;\n\n          case \"left\":\n          case \"start\":\n            xShift = -lo[0];\n            break;\n\n          default:\n            throw new Error(\"vectorize-text: Unrecognized textAlign: '\" + align + \"'\");\n        }\n\n        var yShift = 0;\n\n        switch (baseline) {\n          case \"hanging\":\n          case \"top\":\n            yShift = -lo[1];\n            break;\n\n          case \"middle\":\n            yShift = -0.5 * (lo[1] + hi[1]);\n            break;\n\n          case \"alphabetic\":\n          case \"ideographic\":\n            yShift = -3 * size;\n            break;\n\n          case \"bottom\":\n            yShift = -hi[1];\n            break;\n\n          default:\n            throw new Error(\"vectorize-text: Unrecoginized textBaseline: '\" + baseline + \"'\");\n        }\n\n        var scale = 1.0 / size;\n\n        if (\"lineHeight\" in options) {\n          scale *= +options.lineHeight;\n        } else if (\"width\" in options) {\n          scale = options.width / (hi[0] - lo[0]);\n        } else if (\"height\" in options) {\n          scale = options.height / (hi[1] - lo[1]);\n        }\n\n        return positions.map(function (p) {\n          return [scale * (p[0] + xShift), scale * (p[1] + yShift)];\n        });\n      }\n\n      function getPixels(canvas, context, rawString, fontSize, lineSpacing, styletags) {\n        rawString = rawString.replace(/\\n/g, ''); // don't accept \\n in the input\n\n        if (styletags.breaklines === true) {\n          rawString = rawString.replace(/\\<br\\>/g, '\\n'); // replace <br> tags with \\n in the string\n        } else {\n          rawString = rawString.replace(/\\<br\\>/g, ' '); // don't accept <br> tags in the input and replace with space in this case\n        }\n\n        var activeStyle = \"\";\n        var map = [];\n\n        for (j = 0; j < rawString.length; ++j) {\n          map[j] = activeStyle;\n        }\n\n        if (styletags.bolds === true) map = parseTag(TAG_bold, CHR_bold, rawString, map);\n        if (styletags.italics === true) map = parseTag(TAG_italic, CHR_italic, rawString, map);\n        if (styletags.superscripts === true) map = parseTag(TAG_super, CHR_super, rawString, map);\n        if (styletags.subscripts === true) map = parseTag(TAG_sub, CHR_sub, rawString, map);\n        var allStyles = [];\n        var plainText = \"\";\n\n        for (j = 0; j < rawString.length; ++j) {\n          if (map[j] !== null) {\n            plainText += rawString[j];\n            allStyles.push(map[j]);\n          }\n        }\n\n        var allTexts = plainText.split('\\n');\n        var numberOfLines = allTexts.length;\n        var lineHeight = Math.round(lineSpacing * fontSize);\n        var offsetX = fontSize;\n        var offsetY = fontSize * 2;\n        var maxWidth = 0;\n        var minHeight = numberOfLines * lineHeight + offsetY;\n\n        if (canvas.height < minHeight) {\n          canvas.height = minHeight;\n        }\n\n        context.fillStyle = \"#000\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.fillStyle = \"#fff\";\n        var i, j, xPos, yPos, zPos;\n        var nDone = 0;\n        var buffer = \"\";\n\n        function writeBuffer() {\n          if (buffer !== \"\") {\n            var delta = context.measureText(buffer).width;\n            context.fillText(buffer, offsetX + xPos, offsetY + yPos);\n            xPos += delta;\n          }\n        }\n\n        function getTextFontSize() {\n          return \"\" + Math.round(zPos) + \"px \";\n        }\n\n        function changeStyle(oldStyle, newStyle) {\n          var ctxFont = \"\" + context.font;\n\n          if (styletags.subscripts === true) {\n            var oldIndex_Sub = oldStyle.indexOf(CHR_sub0);\n            var newIndex_Sub = newStyle.indexOf(CHR_sub0);\n            var oldSub = oldIndex_Sub > -1 ? parseInt(oldStyle[1 + oldIndex_Sub]) : 0;\n            var newSub = newIndex_Sub > -1 ? parseInt(newStyle[1 + newIndex_Sub]) : 0;\n\n            if (oldSub !== newSub) {\n              ctxFont = ctxFont.replace(getTextFontSize(), \"?px \");\n              zPos *= Math.pow(0.75, newSub - oldSub);\n              ctxFont = ctxFont.replace(\"?px \", getTextFontSize());\n            }\n\n            yPos += 0.25 * lineHeight * (newSub - oldSub);\n          }\n\n          if (styletags.superscripts === true) {\n            var oldIndex_Super = oldStyle.indexOf(CHR_super0);\n            var newIndex_Super = newStyle.indexOf(CHR_super0);\n            var oldSuper = oldIndex_Super > -1 ? parseInt(oldStyle[1 + oldIndex_Super]) : 0;\n            var newSuper = newIndex_Super > -1 ? parseInt(newStyle[1 + newIndex_Super]) : 0;\n\n            if (oldSuper !== newSuper) {\n              ctxFont = ctxFont.replace(getTextFontSize(), \"?px \");\n              zPos *= Math.pow(0.75, newSuper - oldSuper);\n              ctxFont = ctxFont.replace(\"?px \", getTextFontSize());\n            }\n\n            yPos -= 0.25 * lineHeight * (newSuper - oldSuper);\n          }\n\n          if (styletags.bolds === true) {\n            var wasBold = oldStyle.indexOf(CHR_bold) > -1;\n            var is_Bold = newStyle.indexOf(CHR_bold) > -1;\n\n            if (!wasBold && is_Bold) {\n              if (wasItalic) {\n                ctxFont = ctxFont.replace(\"italic \", \"italic bold \");\n              } else {\n                ctxFont = \"bold \" + ctxFont;\n              }\n            }\n\n            if (wasBold && !is_Bold) {\n              ctxFont = ctxFont.replace(\"bold \", '');\n            }\n          }\n\n          if (styletags.italics === true) {\n            var wasItalic = oldStyle.indexOf(CHR_italic) > -1;\n            var is_Italic = newStyle.indexOf(CHR_italic) > -1;\n\n            if (!wasItalic && is_Italic) {\n              ctxFont = \"italic \" + ctxFont;\n            }\n\n            if (wasItalic && !is_Italic) {\n              ctxFont = ctxFont.replace(\"italic \", '');\n            }\n          }\n\n          context.font = ctxFont;\n        }\n\n        for (i = 0; i < numberOfLines; ++i) {\n          var txt = allTexts[i] + '\\n';\n          xPos = 0;\n          yPos = i * lineHeight;\n          zPos = fontSize;\n          buffer = \"\";\n\n          for (j = 0; j < txt.length; ++j) {\n            var style = j + nDone < allStyles.length ? allStyles[j + nDone] : allStyles[allStyles.length - 1];\n\n            if (activeStyle === style) {\n              buffer += txt[j];\n            } else {\n              writeBuffer();\n              buffer = txt[j];\n\n              if (style !== undefined) {\n                changeStyle(activeStyle, style);\n                activeStyle = style;\n              }\n            }\n          }\n\n          writeBuffer();\n          nDone += txt.length;\n          var width = Math.round(xPos + 2 * offsetX) | 0;\n          if (maxWidth < width) maxWidth = width;\n        } //Cut pixels from image\n\n\n        var xCut = maxWidth;\n        var yCut = offsetY + lineHeight * numberOfLines;\n        var pixels = ndarray(context.getImageData(0, 0, xCut, yCut).data, [yCut, xCut, 4]);\n        return pixels.pick(-1, -1, 0).transpose(1, 0);\n      }\n\n      function getContour(pixels, doSimplify) {\n        var contour = surfaceNets(pixels, 128);\n\n        if (doSimplify) {\n          return simplify(contour.cells, contour.positions, 0.25);\n        }\n\n        return {\n          edges: contour.cells,\n          positions: contour.positions\n        };\n      }\n\n      function processPixelsImpl(pixels, options, size, simplify) {\n        //Extract contour\n        var contour = getContour(pixels, simplify); //Apply warp to positions\n\n        var positions = transformPositions(contour.positions, options, size);\n        var edges = contour.edges;\n        var flip = \"ccw\" === options.orientation; //Clean up the PSLG, resolve self intersections, etc.\n\n        cleanPSLG(positions, edges); //If triangulate flag passed, triangulate the result\n\n        if (options.polygons || options.polygon || options.polyline) {\n          var result = toPolygonCrappy(edges, positions);\n          var nresult = new Array(result.length);\n\n          for (var i = 0; i < result.length; ++i) {\n            var loops = result[i];\n            var nloops = new Array(loops.length);\n\n            for (var j = 0; j < loops.length; ++j) {\n              var loop = loops[j];\n              var nloop = new Array(loop.length);\n\n              for (var k = 0; k < loop.length; ++k) {\n                nloop[k] = positions[loop[k]].slice();\n              }\n\n              if (flip) {\n                nloop.reverse();\n              }\n\n              nloops[j] = nloop;\n            }\n\n            nresult[i] = nloops;\n          }\n\n          return nresult;\n        } else if (options.triangles || options.triangulate || options.triangle) {\n          return {\n            cells: cdt2d(positions, edges, {\n              delaunay: false,\n              exterior: false,\n              interior: true\n            }),\n            positions: positions\n          };\n        } else {\n          return {\n            edges: edges,\n            positions: positions\n          };\n        }\n      }\n\n      function processPixels(pixels, options, size) {\n        try {\n          return processPixelsImpl(pixels, options, size, true);\n        } catch (e) {}\n\n        try {\n          return processPixelsImpl(pixels, options, size, false);\n        } catch (e) {}\n\n        if (options.polygons || options.polyline || options.polygon) {\n          return [];\n        }\n\n        if (options.triangles || options.triangulate || options.triangle) {\n          return {\n            cells: [],\n            positions: []\n          };\n        }\n\n        return {\n          edges: [],\n          positions: []\n        };\n      }\n\n      function vectorizeText(str, canvas, context, options) {\n        var size = 64;\n        var lineSpacing = 1.25;\n        var styletags = {\n          breaklines: false,\n          bolds: false,\n          italics: false,\n          subscripts: false,\n          superscripts: false\n        };\n\n        if (options) {\n          if (options.size && options.size > 0) size = options.size;\n          if (options.lineSpacing && options.lineSpacing > 0) lineSpacing = options.lineSpacing;\n          if (options.styletags && options.styletags.breaklines) styletags.breaklines = options.styletags.breaklines ? true : false;\n          if (options.styletags && options.styletags.bolds) styletags.bolds = options.styletags.bolds ? true : false;\n          if (options.styletags && options.styletags.italics) styletags.italics = options.styletags.italics ? true : false;\n          if (options.styletags && options.styletags.subscripts) styletags.subscripts = options.styletags.subscripts ? true : false;\n          if (options.styletags && options.styletags.superscripts) styletags.superscripts = options.styletags.superscripts ? true : false;\n        }\n\n        context.font = [options.fontStyle, options.fontVariant, options.fontWeight, size + \"px\", options.font].filter(function (d) {\n          return d;\n        }).join(\" \");\n        context.textAlign = \"start\";\n        context.textBaseline = \"alphabetic\";\n        context.direction = \"ltr\";\n        var pixels = getPixels(canvas, context, str, size, lineSpacing, styletags);\n        return processPixels(pixels, options, size);\n      }\n    }, {\n      \"cdt2d\": 42,\n      \"clean-pslg\": 50,\n      \"ndarray\": 259,\n      \"planar-graph-to-polyline\": 268,\n      \"simplify-planar-graph\": 297,\n      \"surface-nets\": 302\n    }],\n    313: [function (_glvis_, module, exports) {\n      // Copyright (C) 2011 Google Inc.\n      //\n      // Licensed under the Apache License, Version 2.0 (the \"License\");\n      // you may not use this file except in compliance with the License.\n      // You may obtain a copy of the License at\n      //\n      // http://www.apache.org/licenses/LICENSE-2.0\n      //\n      // Unless required by applicable law or agreed to in writing, software\n      // distributed under the License is distributed on an \"AS IS\" BASIS,\n      // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      // See the License for the specific language governing permissions and\n      // limitations under the License.\n\n      /**\n       * @fileoverview Install a leaky WeakMap emulation on platforms that\n       * don't provide a built-in one.\n       *\n       * <p>Assumes that an ES5 platform where, if {@code WeakMap} is\n       * already present, then it conforms to the anticipated ES6\n       * specification. To run this file on an ES5 or almost ES5\n       * implementation where the {@code WeakMap} specification does not\n       * quite conform, run <code>repairES5.js</code> first.\n       *\n       * <p>Even though WeakMapModule is not global, the linter thinks it\n       * is, which is why it is in the overrides list below.\n       *\n       * <p>NOTE: Before using this WeakMap emulation in a non-SES\n       * environment, see the note below about hiddenRecord.\n       *\n       * @author Mark S. Miller\n       * @requires crypto, ArrayBuffer, Uint8Array, navigator, console\n       * @overrides WeakMap, ses, Proxy\n       * @overrides WeakMapModule\n       */\n\n      /**\n       * This {@code WeakMap} emulation is observably equivalent to the\n       * ES-Harmony WeakMap, but with leakier garbage collection properties.\n       *\n       * <p>As with true WeakMaps, in this emulation, a key does not\n       * retain maps indexed by that key and (crucially) a map does not\n       * retain the keys it indexes. A map by itself also does not retain\n       * the values associated with that map.\n       *\n       * <p>However, the values associated with a key in some map are\n       * retained so long as that key is retained and those associations are\n       * not overridden. For example, when used to support membranes, all\n       * values exported from a given membrane will live for the lifetime\n       * they would have had in the absence of an interposed membrane. Even\n       * when the membrane is revoked, all objects that would have been\n       * reachable in the absence of revocation will still be reachable, as\n       * far as the GC can tell, even though they will no longer be relevant\n       * to ongoing computation.\n       *\n       * <p>The API implemented here is approximately the API as implemented\n       * in FF6.0a1 and agreed to by MarkM, Andreas Gal, and Dave Herman,\n       * rather than the offially approved proposal page. TODO(erights):\n       * upgrade the ecmascript WeakMap proposal page to explain this API\n       * change and present to EcmaScript committee for their approval.\n       *\n       * <p>The first difference between the emulation here and that in\n       * FF6.0a1 is the presence of non enumerable {@code get___, has___,\n       * set___, and delete___} methods on WeakMap instances to represent\n       * what would be the hidden internal properties of a primitive\n       * implementation. Whereas the FF6.0a1 WeakMap.prototype methods\n       * require their {@code this} to be a genuine WeakMap instance (i.e.,\n       * an object of {@code [[Class]]} \"WeakMap}), since there is nothing\n       * unforgeable about the pseudo-internal method names used here,\n       * nothing prevents these emulated prototype methods from being\n       * applied to non-WeakMaps with pseudo-internal methods of the same\n       * names.\n       *\n       * <p>Another difference is that our emulated {@code\n       * WeakMap.prototype} is not itself a WeakMap. A problem with the\n       * current FF6.0a1 API is that WeakMap.prototype is itself a WeakMap\n       * providing ambient mutability and an ambient communications\n       * channel. Thus, if a WeakMap is already present and has this\n       * problem, repairES5.js wraps it in a safe wrappper in order to\n       * prevent access to this channel. (See\n       * PATCH_MUTABLE_FROZEN_WEAKMAP_PROTO in repairES5.js).\n       */\n\n      /**\n       * If this is a full <a href=\n       * \"http://code.google.com/p/es-lab/wiki/SecureableES5\"\n       * >secureable ES5</a> platform and the ES-Harmony {@code WeakMap} is\n       * absent, install an approximate emulation.\n       *\n       * <p>If WeakMap is present but cannot store some objects, use our approximate\n       * emulation as a wrapper.\n       *\n       * <p>If this is almost a secureable ES5 platform, then WeakMap.js\n       * should be run after repairES5.js.\n       *\n       * <p>See {@code WeakMap} for documentation of the garbage collection\n       * properties of this WeakMap emulation.\n       */\n      (function WeakMapModule() {\n        \"use strict\";\n\n        if (typeof ses !== 'undefined' && ses.ok && !ses.ok()) {\n          // already too broken, so give up\n          return;\n        }\n        /**\n         * In some cases (current Firefox), we must make a choice betweeen a\n         * WeakMap which is capable of using all varieties of host objects as\n         * keys and one which is capable of safely using proxies as keys. See\n         * comments below about HostWeakMap and DoubleWeakMap for details.\n         *\n         * This function (which is a global, not exposed to guests) marks a\n         * WeakMap as permitted to do what is necessary to index all host\n         * objects, at the cost of making it unsafe for proxies.\n         *\n         * Do not apply this function to anything which is not a genuine\n         * fresh WeakMap.\n         */\n\n\n        function weakMapPermitHostObjects(map) {\n          // identity of function used as a secret -- good enough and cheap\n          if (map.permitHostObjects___) {\n            map.permitHostObjects___(weakMapPermitHostObjects);\n          }\n        }\n\n        if (typeof ses !== 'undefined') {\n          ses.weakMapPermitHostObjects = weakMapPermitHostObjects;\n        } // IE 11 has no Proxy but has a broken WeakMap such that we need to patch\n        // it using DoubleWeakMap; this flag tells DoubleWeakMap so.\n\n\n        var doubleWeakMapCheckSilentFailure = false; // Check if there is already a good-enough WeakMap implementation, and if so\n        // exit without replacing it.\n\n        if (typeof WeakMap === 'function') {\n          var HostWeakMap = WeakMap; // There is a WeakMap -- is it good enough?\n\n          if (typeof navigator !== 'undefined' && /Firefox/.test(navigator.userAgent)) {// We're now *assuming not*, because as of this writing (2013-05-06)\n            // Firefox's WeakMaps have a miscellany of objects they won't accept, and\n            // we don't want to make an exhaustive list, and testing for just one\n            // will be a problem if that one is fixed alone (as they did for Event).\n            // If there is a platform that we *can* reliably test on, here's how to\n            // do it:\n            //  var problematic = ... ;\n            //  var testHostMap = new HostWeakMap();\n            //  try {\n            //    testHostMap.set(problematic, 1);  // Firefox 20 will throw here\n            //    if (testHostMap.get(problematic) === 1) {\n            //      return;\n            //    }\n            //  } catch (e) {}\n          } else {\n            // IE 11 bug: WeakMaps silently fail to store frozen objects.\n            var testMap = new HostWeakMap();\n            var testObject = Object.freeze({});\n            testMap.set(testObject, 1);\n\n            if (testMap.get(testObject) !== 1) {\n              doubleWeakMapCheckSilentFailure = true; // Fall through to installing our WeakMap.\n            } else {\n              module.exports = WeakMap;\n              return;\n            }\n          }\n        }\n\n        var hop = Object.prototype.hasOwnProperty;\n        var gopn = Object.getOwnPropertyNames;\n        var defProp = Object.defineProperty;\n        var isExtensible = Object.isExtensible;\n        /**\n         * Security depends on HIDDEN_NAME being both <i>unguessable</i> and\n         * <i>undiscoverable</i> by untrusted code.\n         *\n         * <p>Given the known weaknesses of Math.random() on existing\n         * browsers, it does not generate unguessability we can be confident\n         * of.\n         *\n         * <p>It is the monkey patching logic in this file that is intended\n         * to ensure undiscoverability. The basic idea is that there are\n         * three fundamental means of discovering properties of an object:\n         * The for/in loop, Object.keys(), and Object.getOwnPropertyNames(),\n         * as well as some proposed ES6 extensions that appear on our\n         * whitelist. The first two only discover enumerable properties, and\n         * we only use HIDDEN_NAME to name a non-enumerable property, so the\n         * only remaining threat should be getOwnPropertyNames and some\n         * proposed ES6 extensions that appear on our whitelist. We monkey\n         * patch them to remove HIDDEN_NAME from the list of properties they\n         * returns.\n         *\n         * <p>TODO(erights): On a platform with built-in Proxies, proxies\n         * could be used to trap and thereby discover the HIDDEN_NAME, so we\n         * need to monkey patch Proxy.create, Proxy.createFunction, etc, in\n         * order to wrap the provided handler with the real handler which\n         * filters out all traps using HIDDEN_NAME.\n         *\n         * <p>TODO(erights): Revisit Mike Stay's suggestion that we use an\n         * encapsulated function at a not-necessarily-secret name, which\n         * uses the Stiegler shared-state rights amplification pattern to\n         * reveal the associated value only to the WeakMap in which this key\n         * is associated with that value. Since only the key retains the\n         * function, the function can also remember the key without causing\n         * leakage of the key, so this doesn't violate our general gc\n         * goals. In addition, because the name need not be a guarded\n         * secret, we could efficiently handle cross-frame frozen keys.\n         */\n\n        var HIDDEN_NAME_PREFIX = 'weakmap:';\n        var HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'ident:' + Math.random() + '___';\n\n        if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function' && typeof ArrayBuffer === 'function' && typeof Uint8Array === 'function') {\n          var ab = new ArrayBuffer(25);\n          var u8s = new Uint8Array(ab);\n          crypto.getRandomValues(u8s);\n          HIDDEN_NAME = HIDDEN_NAME_PREFIX + 'rand:' + Array.prototype.map.call(u8s, function (u8) {\n            return (u8 % 36).toString(36);\n          }).join('') + '___';\n        }\n\n        function isNotHiddenName(name) {\n          return !(name.substr(0, HIDDEN_NAME_PREFIX.length) == HIDDEN_NAME_PREFIX && name.substr(name.length - 3) === '___');\n        }\n        /**\n         * Monkey patch getOwnPropertyNames to avoid revealing the\n         * HIDDEN_NAME.\n         *\n         * <p>The ES5.1 spec requires each name to appear only once, but as\n         * of this writing, this requirement is controversial for ES6, so we\n         * made this code robust against this case. If the resulting extra\n         * search turns out to be expensive, we can probably relax this once\n         * ES6 is adequately supported on all major browsers, iff no browser\n         * versions we support at that time have relaxed this constraint\n         * without providing built-in ES6 WeakMaps.\n         */\n\n\n        defProp(Object, 'getOwnPropertyNames', {\n          value: function fakeGetOwnPropertyNames(obj) {\n            return gopn(obj).filter(isNotHiddenName);\n          }\n        });\n        /**\n         * getPropertyNames is not in ES5 but it is proposed for ES6 and\n         * does appear in our whitelist, so we need to clean it too.\n         */\n\n        if ('getPropertyNames' in Object) {\n          var originalGetPropertyNames = Object.getPropertyNames;\n          defProp(Object, 'getPropertyNames', {\n            value: function fakeGetPropertyNames(obj) {\n              return originalGetPropertyNames(obj).filter(isNotHiddenName);\n            }\n          });\n        }\n        /**\n         * <p>To treat objects as identity-keys with reasonable efficiency\n         * on ES5 by itself (i.e., without any object-keyed collections), we\n         * need to add a hidden property to such key objects when we\n         * can. This raises several issues:\n         * <ul>\n         * <li>Arranging to add this property to objects before we lose the\n         *     chance, and\n         * <li>Hiding the existence of this new property from most\n         *     JavaScript code.\n         * <li>Preventing <i>certification theft</i>, where one object is\n         *     created falsely claiming to be the key of an association\n         *     actually keyed by another object.\n         * <li>Preventing <i>value theft</i>, where untrusted code with\n         *     access to a key object but not a weak map nevertheless\n         *     obtains access to the value associated with that key in that\n         *     weak map.\n         * </ul>\n         * We do so by\n         * <ul>\n         * <li>Making the name of the hidden property unguessable, so \"[]\"\n         *     indexing, which we cannot intercept, cannot be used to access\n         *     a property without knowing the name.\n         * <li>Making the hidden property non-enumerable, so we need not\n         *     worry about for-in loops or {@code Object.keys},\n         * <li>monkey patching those reflective methods that would\n         *     prevent extensions, to add this hidden property first,\n         * <li>monkey patching those methods that would reveal this\n         *     hidden property.\n         * </ul>\n         * Unfortunately, because of same-origin iframes, we cannot reliably\n         * add this hidden property before an object becomes\n         * non-extensible. Instead, if we encounter a non-extensible object\n         * without a hidden record that we can detect (whether or not it has\n         * a hidden record stored under a name secret to us), then we just\n         * use the key object itself to represent its identity in a brute\n         * force leaky map stored in the weak map, losing all the advantages\n         * of weakness for these.\n         */\n\n\n        function getHiddenRecord(key) {\n          if (key !== Object(key)) {\n            throw new TypeError('Not an object: ' + key);\n          }\n\n          var hiddenRecord = key[HIDDEN_NAME];\n\n          if (hiddenRecord && hiddenRecord.key === key) {\n            return hiddenRecord;\n          }\n\n          if (!isExtensible(key)) {\n            // Weak map must brute force, as explained in doc-comment above.\n            return void 0;\n          } // The hiddenRecord and the key point directly at each other, via\n          // the \"key\" and HIDDEN_NAME properties respectively. The key\n          // field is for quickly verifying that this hidden record is an\n          // own property, not a hidden record from up the prototype chain.\n          //\n          // NOTE: Because this WeakMap emulation is meant only for systems like\n          // SES where Object.prototype is frozen without any numeric\n          // properties, it is ok to use an object literal for the hiddenRecord.\n          // This has two advantages:\n          // * It is much faster in a performance critical place\n          // * It avoids relying on Object.create(null), which had been\n          //   problematic on Chrome 28.0.1480.0. See\n          //   https://code.google.com/p/google-caja/issues/detail?id=1687\n\n\n          hiddenRecord = {\n            key: key\n          }; // When using this WeakMap emulation on platforms where\n          // Object.prototype might not be frozen and Object.create(null) is\n          // reliable, use the following two commented out lines instead.\n          // hiddenRecord = Object.create(null);\n          // hiddenRecord.key = key;\n          // Please contact us if you need this to work on platforms where\n          // Object.prototype might not be frozen and\n          // Object.create(null) might not be reliable.\n\n          try {\n            defProp(key, HIDDEN_NAME, {\n              value: hiddenRecord,\n              writable: false,\n              enumerable: false,\n              configurable: false\n            });\n            return hiddenRecord;\n          } catch (error) {\n            // Under some circumstances, isExtensible seems to misreport whether\n            // the HIDDEN_NAME can be defined.\n            // The circumstances have not been isolated, but at least affect\n            // Node.js v0.10.26 on TravisCI / Linux, but not the same version of\n            // Node.js on OS X.\n            return void 0;\n          }\n        }\n        /**\n         * Monkey patch operations that would make their argument\n         * non-extensible.\n         *\n         * <p>The monkey patched versions throw a TypeError if their\n         * argument is not an object, so it should only be done to functions\n         * that should throw a TypeError anyway if their argument is not an\n         * object.\n         */\n\n\n        (function () {\n          var oldFreeze = Object.freeze;\n          defProp(Object, 'freeze', {\n            value: function identifyingFreeze(obj) {\n              getHiddenRecord(obj);\n              return oldFreeze(obj);\n            }\n          });\n          var oldSeal = Object.seal;\n          defProp(Object, 'seal', {\n            value: function identifyingSeal(obj) {\n              getHiddenRecord(obj);\n              return oldSeal(obj);\n            }\n          });\n          var oldPreventExtensions = Object.preventExtensions;\n          defProp(Object, 'preventExtensions', {\n            value: function identifyingPreventExtensions(obj) {\n              getHiddenRecord(obj);\n              return oldPreventExtensions(obj);\n            }\n          });\n        })();\n\n        function constFunc(func) {\n          func.prototype = null;\n          return Object.freeze(func);\n        }\n\n        var calledAsFunctionWarningDone = false;\n\n        function calledAsFunctionWarning() {\n          // Future ES6 WeakMap is currently (2013-09-10) expected to reject WeakMap()\n          // but we used to permit it and do it ourselves, so warn only.\n          if (!calledAsFunctionWarningDone && typeof console !== 'undefined') {\n            calledAsFunctionWarningDone = true;\n            console.warn('WeakMap should be invoked as new WeakMap(), not ' + 'WeakMap(). This will be an error in the future.');\n          }\n        }\n\n        var nextId = 0;\n\n        var OurWeakMap = function OurWeakMap() {\n          if (!(this instanceof OurWeakMap)) {\n            // approximate test for new ...()\n            calledAsFunctionWarning();\n          } // We are currently (12/25/2012) never encountering any prematurely\n          // non-extensible keys.\n\n\n          var keys = []; // brute force for prematurely non-extensible keys.\n\n          var values = []; // brute force for corresponding values.\n\n          var id = nextId++;\n\n          function get___(key, opt_default) {\n            var index;\n            var hiddenRecord = getHiddenRecord(key);\n\n            if (hiddenRecord) {\n              return id in hiddenRecord ? hiddenRecord[id] : opt_default;\n            } else {\n              index = keys.indexOf(key);\n              return index >= 0 ? values[index] : opt_default;\n            }\n          }\n\n          function has___(key) {\n            var hiddenRecord = getHiddenRecord(key);\n\n            if (hiddenRecord) {\n              return id in hiddenRecord;\n            } else {\n              return keys.indexOf(key) >= 0;\n            }\n          }\n\n          function set___(key, value) {\n            var index;\n            var hiddenRecord = getHiddenRecord(key);\n\n            if (hiddenRecord) {\n              hiddenRecord[id] = value;\n            } else {\n              index = keys.indexOf(key);\n\n              if (index >= 0) {\n                values[index] = value;\n              } else {\n                // Since some browsers preemptively terminate slow turns but\n                // then continue computing with presumably corrupted heap\n                // state, we here defensively get keys.length first and then\n                // use it to update both the values and keys arrays, keeping\n                // them in sync.\n                index = keys.length;\n                values[index] = value; // If we crash here, values will be one longer than keys.\n\n                keys[index] = key;\n              }\n            }\n\n            return this;\n          }\n\n          function delete___(key) {\n            var hiddenRecord = getHiddenRecord(key);\n            var index, lastIndex;\n\n            if (hiddenRecord) {\n              return id in hiddenRecord && delete hiddenRecord[id];\n            } else {\n              index = keys.indexOf(key);\n\n              if (index < 0) {\n                return false;\n              } // Since some browsers preemptively terminate slow turns but\n              // then continue computing with potentially corrupted heap\n              // state, we here defensively get keys.length first and then use\n              // it to update both the keys and the values array, keeping\n              // them in sync. We update the two with an order of assignments,\n              // such that any prefix of these assignments will preserve the\n              // key/value correspondence, either before or after the delete.\n              // Note that this needs to work correctly when index === lastIndex.\n\n\n              lastIndex = keys.length - 1;\n              keys[index] = void 0; // If we crash here, there's a void 0 in the keys array, but\n              // no operation will cause a \"keys.indexOf(void 0)\", since\n              // getHiddenRecord(void 0) will always throw an error first.\n\n              values[index] = values[lastIndex]; // If we crash here, values[index] cannot be found here,\n              // because keys[index] is void 0.\n\n              keys[index] = keys[lastIndex]; // If index === lastIndex and we crash here, then keys[index]\n              // is still void 0, since the aliasing killed the previous key.\n\n              keys.length = lastIndex; // If we crash here, keys will be one shorter than values.\n\n              values.length = lastIndex;\n              return true;\n            }\n          }\n\n          return Object.create(OurWeakMap.prototype, {\n            get___: {\n              value: constFunc(get___)\n            },\n            has___: {\n              value: constFunc(has___)\n            },\n            set___: {\n              value: constFunc(set___)\n            },\n            delete___: {\n              value: constFunc(delete___)\n            }\n          });\n        };\n\n        OurWeakMap.prototype = Object.create(Object.prototype, {\n          get: {\n            /**\n             * Return the value most recently associated with key, or\n             * opt_default if none.\n             */\n            value: function get(key, opt_default) {\n              return this.get___(key, opt_default);\n            },\n            writable: true,\n            configurable: true\n          },\n          has: {\n            /**\n             * Is there a value associated with key in this WeakMap?\n             */\n            value: function has(key) {\n              return this.has___(key);\n            },\n            writable: true,\n            configurable: true\n          },\n          set: {\n            /**\n             * Associate value with key in this WeakMap, overwriting any\n             * previous association if present.\n             */\n            value: function set(key, value) {\n              return this.set___(key, value);\n            },\n            writable: true,\n            configurable: true\n          },\n          'delete': {\n            /**\n             * Remove any association for key in this WeakMap, returning\n             * whether there was one.\n             *\n             * <p>Note that the boolean return here does not work like the\n             * {@code delete} operator. The {@code delete} operator returns\n             * whether the deletion succeeds at bringing about a state in\n             * which the deleted property is absent. The {@code delete}\n             * operator therefore returns true if the property was already\n             * absent, whereas this {@code delete} method returns false if\n             * the association was already absent.\n             */\n            value: function remove(key) {\n              return this.delete___(key);\n            },\n            writable: true,\n            configurable: true\n          }\n        });\n\n        if (typeof HostWeakMap === 'function') {\n          (function () {\n            // If we got here, then the platform has a WeakMap but we are concerned\n            // that it may refuse to store some key types. Therefore, make a map\n            // implementation which makes use of both as possible.\n            // In this mode we are always using double maps, so we are not proxy-safe.\n            // This combination does not occur in any known browser, but we had best\n            // be safe.\n            if (doubleWeakMapCheckSilentFailure && typeof Proxy !== 'undefined') {\n              Proxy = undefined;\n            }\n\n            function DoubleWeakMap() {\n              if (!(this instanceof OurWeakMap)) {\n                // approximate test for new ...()\n                calledAsFunctionWarning();\n              } // Preferable, truly weak map.\n\n\n              var hmap = new HostWeakMap(); // Our hidden-property-based pseudo-weak-map. Lazily initialized in the\n              // 'set' implementation; thus we can avoid performing extra lookups if\n              // we know all entries actually stored are entered in 'hmap'.\n\n              var omap = undefined; // Hidden-property maps are not compatible with proxies because proxies\n              // can observe the hidden name and either accidentally expose it or fail\n              // to allow the hidden property to be set. Therefore, we do not allow\n              // arbitrary WeakMaps to switch to using hidden properties, but only\n              // those which need the ability, and unprivileged code is not allowed\n              // to set the flag.\n              //\n              // (Except in doubleWeakMapCheckSilentFailure mode in which case we\n              // disable proxies.)\n\n              var enableSwitching = false;\n\n              function dget(key, opt_default) {\n                if (omap) {\n                  return hmap.has(key) ? hmap.get(key) : omap.get___(key, opt_default);\n                } else {\n                  return hmap.get(key, opt_default);\n                }\n              }\n\n              function dhas(key) {\n                return hmap.has(key) || (omap ? omap.has___(key) : false);\n              }\n\n              var dset;\n\n              if (doubleWeakMapCheckSilentFailure) {\n                dset = function dset(key, value) {\n                  hmap.set(key, value);\n\n                  if (!hmap.has(key)) {\n                    if (!omap) {\n                      omap = new OurWeakMap();\n                    }\n\n                    omap.set(key, value);\n                  }\n\n                  return this;\n                };\n              } else {\n                dset = function dset(key, value) {\n                  if (enableSwitching) {\n                    try {\n                      hmap.set(key, value);\n                    } catch (e) {\n                      if (!omap) {\n                        omap = new OurWeakMap();\n                      }\n\n                      omap.set___(key, value);\n                    }\n                  } else {\n                    hmap.set(key, value);\n                  }\n\n                  return this;\n                };\n              }\n\n              function ddelete(key) {\n                var result = !!hmap['delete'](key);\n\n                if (omap) {\n                  return omap.delete___(key) || result;\n                }\n\n                return result;\n              }\n\n              return Object.create(OurWeakMap.prototype, {\n                get___: {\n                  value: constFunc(dget)\n                },\n                has___: {\n                  value: constFunc(dhas)\n                },\n                set___: {\n                  value: constFunc(dset)\n                },\n                delete___: {\n                  value: constFunc(ddelete)\n                },\n                permitHostObjects___: {\n                  value: constFunc(function (token) {\n                    if (token === weakMapPermitHostObjects) {\n                      enableSwitching = true;\n                    } else {\n                      throw new Error('bogus call to permitHostObjects___');\n                    }\n                  })\n                }\n              });\n            }\n\n            DoubleWeakMap.prototype = OurWeakMap.prototype;\n            module.exports = DoubleWeakMap; // define .constructor to hide OurWeakMap ctor\n\n            Object.defineProperty(WeakMap.prototype, 'constructor', {\n              value: WeakMap,\n              enumerable: false,\n              // as default .constructor is\n              configurable: true,\n              writable: true\n            });\n          })();\n        } else {\n          // There is no host WeakMap, so we must use the emulation.\n          // Emulated WeakMaps are incompatible with native proxies (because proxies\n          // can observe the hidden name), so we must disable Proxy usage (in\n          // ArrayLike and Domado, currently).\n          if (typeof Proxy !== 'undefined') {\n            Proxy = undefined;\n          }\n\n          module.exports = OurWeakMap;\n        }\n      })();\n    }, {}],\n    314: [function (_glvis_, module, exports) {\n      var hiddenStore = _glvis_('./hidden-store.js');\n\n      module.exports = createStore;\n\n      function createStore() {\n        var key = {};\n        return function (obj) {\n          if ((typeof obj !== 'object' || obj === null) && typeof obj !== 'function') {\n            throw new Error('Weakmap-shim: Key must be object');\n          }\n\n          var store = obj.valueOf(key);\n          return store && store.identity === key ? store : hiddenStore(obj, key);\n        };\n      }\n    }, {\n      \"./hidden-store.js\": 315\n    }],\n    315: [function (_glvis_, module, exports) {\n      module.exports = hiddenStore;\n\n      function hiddenStore(obj, key) {\n        var store = {\n          identity: key\n        };\n        var valueOf = obj.valueOf;\n        Object.defineProperty(obj, \"valueOf\", {\n          value: function value(_value) {\n            return _value !== key ? valueOf.apply(this, arguments) : store;\n          },\n          writable: true\n        });\n        return store;\n      }\n    }, {}],\n    316: [function (_glvis_, module, exports) {\n      // Original - @Gozola.\n      // https://gist.github.com/Gozala/1269991\n      // This is a reimplemented version (with a few bug fixes).\n      var createStore = _glvis_('./create-store.js');\n\n      module.exports = weakMap;\n\n      function weakMap() {\n        var privates = createStore();\n        return {\n          'get': function get(key, fallback) {\n            var store = privates(key);\n            return store.hasOwnProperty('value') ? store.value : fallback;\n          },\n          'set': function set(key, value) {\n            privates(key).value = value;\n            return this;\n          },\n          'has': function has(key) {\n            return 'value' in privates(key);\n          },\n          'delete': function _delete(key) {\n            return delete privates(key).value;\n          }\n        };\n      }\n    }, {\n      \"./create-store.js\": 314\n    }],\n    317: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      function CWiseOp() {\n        return function (SS, a0, t0, p0, Y0, Y1) {\n          var s0 = SS[0],\n              t0p0 = t0[0],\n              index = [0],\n              q0 = t0p0;\n          p0 |= 0;\n          var i0 = 0,\n              d0s0 = t0p0;\n\n          for (i0 = 0; i0 < s0; ++i0) {\n            {\n              var da = a0[p0] - Y1;\n              var db = a0[p0 + q0] - Y1;\n\n              if (da >= 0 !== db >= 0) {\n                Y0.push(index[0] + 0.5 + 0.5 * (da + db) / (da - db));\n              }\n            }\n            p0 += d0s0;\n            ++index[0];\n          }\n        };\n      } //Generates a cwise operator\n\n\n      function generateCWiseOp() {\n        return CWiseOp();\n      }\n\n      var compile = generateCWiseOp;\n\n      function thunk(compile) {\n        var CACHED = {};\n        return function zeroCrossings_cwise_thunk(array0, scalar2, scalar3) {\n          var t0 = array0.dtype,\n              r0 = array0.order,\n              type = [t0, r0.join()].join(),\n              proc = CACHED[type];\n\n          if (!proc) {\n            CACHED[type] = proc = compile([t0, r0]);\n          }\n\n          return proc(array0.shape.slice(0), array0.data, array0.stride, array0.offset | 0, scalar2, scalar3);\n        };\n      }\n\n      function createThunk(proc) {\n        return thunk(compile.bind(undefined, proc));\n      }\n\n      function compileCwise(user_args) {\n        return createThunk({\n          funcName: user_args.funcName\n        });\n      }\n\n      module.exports = compileCwise({\n        funcName: 'zeroCrossings'\n      });\n    }, {}],\n    318: [function (_glvis_, module, exports) {\n      \"use strict\";\n\n      module.exports = findZeroCrossings;\n\n      var core = _glvis_(\"./lib/zc-core\");\n\n      function findZeroCrossings(array, level) {\n        var cross = [];\n        level = +level || 0.0;\n        core(array.hi(array.shape[0] - 1), cross, level);\n        return cross;\n      }\n    }, {\n      \"./lib/zc-core\": 317\n    }]\n  }, {}, [6])(6);\n});","map":null,"metadata":{},"sourceType":"script"}