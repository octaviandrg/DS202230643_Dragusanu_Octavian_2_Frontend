{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar extractOpts = require('../colorscale/helpers').extractOpts;\n\nvar subTypes = require('../../traces/scatter/subtypes');\n\nvar stylePie = require('../../traces/pie/style_one');\n\nvar pieCastOption = require('../../traces/pie/helpers').castOption;\n\nvar constants = require('./constants');\n\nvar CST_MARKER_SIZE = 12;\nvar CST_LINE_WIDTH = 5;\nvar CST_MARKER_LINE_WIDTH = 2;\nvar MAX_LINE_WIDTH = 10;\nvar MAX_MARKER_LINE_WIDTH = 5;\n\nmodule.exports = function style(s, gd, legend) {\n  var fullLayout = gd._fullLayout;\n  if (!legend) legend = fullLayout.legend;\n  var constantItemSizing = legend.itemsizing === 'constant';\n  var itemWidth = legend.itemwidth;\n  var centerPos = (itemWidth + constants.itemGap * 2) / 2;\n  var centerTransform = strTranslate(centerPos, 0);\n\n  var boundLineWidth = function boundLineWidth(mlw, cont, max, cst) {\n    var v;\n\n    if (mlw + 1) {\n      v = mlw;\n    } else if (cont && cont.width > 0) {\n      v = cont.width;\n    } else {\n      return 0;\n    }\n\n    return constantItemSizing ? cst : Math.min(v, max);\n  };\n\n  s.each(function (d) {\n    var traceGroup = d3.select(this);\n    var layers = Lib.ensureSingle(traceGroup, 'g', 'layers');\n    layers.style('opacity', d[0].trace.opacity);\n    var valign = legend.valign;\n    var lineHeight = d[0].lineHeight;\n    var height = d[0].height;\n\n    if (valign === 'middle' || !lineHeight || !height) {\n      layers.attr('transform', null);\n    } else {\n      var factor = {\n        top: 1,\n        bottom: -1\n      }[valign];\n      var markerOffsetY = factor * (0.5 * (lineHeight - height + 3));\n      layers.attr('transform', strTranslate(0, markerOffsetY));\n    }\n\n    var fill = layers.selectAll('g.legendfill').data([d]);\n    fill.enter().append('g').classed('legendfill', true);\n    var line = layers.selectAll('g.legendlines').data([d]);\n    line.enter().append('g').classed('legendlines', true);\n    var symbol = layers.selectAll('g.legendsymbols').data([d]);\n    symbol.enter().append('g').classed('legendsymbols', true);\n    symbol.selectAll('g.legendpoints').data([d]).enter().append('g').classed('legendpoints', true);\n  }).each(styleSpatial).each(styleWaterfalls).each(styleFunnels).each(styleBars).each(styleBoxes).each(styleFunnelareas).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);\n\n  function styleLines(d) {\n    var styleGuide = getStyleGuide(d);\n    var showFill = styleGuide.showFill;\n    var showLine = styleGuide.showLine;\n    var showGradientLine = styleGuide.showGradientLine;\n    var showGradientFill = styleGuide.showGradientFill;\n    var anyFill = styleGuide.anyFill;\n    var anyLine = styleGuide.anyLine;\n    var d0 = d[0];\n    var trace = d0.trace;\n    var dMod, tMod;\n    var cOpts = extractOpts(trace);\n    var colorscale = cOpts.colorscale;\n    var reversescale = cOpts.reversescale;\n\n    var fillStyle = function fillStyle(s) {\n      if (s.size()) {\n        if (showFill) {\n          Drawing.fillGroupStyle(s, gd);\n        } else {\n          var gradientID = 'legendfill-' + trace.uid;\n          Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale), colorscale, 'fill');\n        }\n      }\n    };\n\n    var lineGradient = function lineGradient(s) {\n      if (s.size()) {\n        var gradientID = 'legendline-' + trace.uid;\n        Drawing.lineGroupStyle(s);\n        Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale), colorscale, 'stroke');\n      }\n    }; // with fill and no markers or text, move the line and fill up a bit\n    // so it's more centered\n\n\n    var pathStart = subTypes.hasMarkers(trace) || !anyFill ? 'M5,0' : // with a line leave it slightly below center, to leave room for the\n    // line thickness and because the line is usually more prominent\n    anyLine ? 'M5,-2' : 'M5,-3';\n    var this3 = d3.select(this);\n    var fill = this3.select('.legendfill').selectAll('path').data(showFill || showGradientFill ? [d] : []);\n    fill.enter().append('path').classed('js-fill', true);\n    fill.exit().remove();\n    fill.attr('d', pathStart + 'h' + itemWidth + 'v6h-' + itemWidth + 'z').call(fillStyle);\n\n    if (showLine || showGradientLine) {\n      var lw = boundLineWidth(undefined, trace.line, MAX_LINE_WIDTH, CST_LINE_WIDTH);\n      tMod = Lib.minExtend(trace, {\n        line: {\n          width: lw\n        }\n      });\n      dMod = [Lib.minExtend(d0, {\n        trace: tMod\n      })];\n    }\n\n    var line = this3.select('.legendlines').selectAll('path').data(showLine || showGradientLine ? [dMod] : []);\n    line.enter().append('path').classed('js-line', true);\n    line.exit().remove(); // this is ugly... but you can't apply a gradient to a perfectly\n    // horizontal or vertical line. Presumably because then\n    // the system doesn't know how to scale vertical variation, even\n    // though there *is* no vertical variation in this case.\n    // so add an invisibly small angle to the line\n    // This issue (and workaround) exist across (Mac) Chrome, FF, and Safari\n\n    line.attr('d', pathStart + (showGradientLine ? 'l' + itemWidth + ',0.0001' : 'h' + itemWidth)).call(showLine ? Drawing.lineGroupStyle : lineGradient);\n  }\n\n  function stylePoints(d) {\n    var styleGuide = getStyleGuide(d);\n    var anyFill = styleGuide.anyFill;\n    var anyLine = styleGuide.anyLine;\n    var showLine = styleGuide.showLine;\n    var showMarker = styleGuide.showMarker;\n    var d0 = d[0];\n    var trace = d0.trace;\n    var showText = !showMarker && !anyLine && !anyFill && subTypes.hasText(trace);\n    var dMod, tMod; // 'scatter3d' don't use gd.calcdata,\n    // use d0.trace to infer arrayOk attributes\n\n    function boundVal(attrIn, arrayToValFn, bounds, cst) {\n      var valIn = Lib.nestedProperty(trace, attrIn).get();\n      var valToBound = Lib.isArrayOrTypedArray(valIn) && arrayToValFn ? arrayToValFn(valIn) : valIn;\n\n      if (constantItemSizing && valToBound && cst !== undefined) {\n        valToBound = cst;\n      }\n\n      if (bounds) {\n        if (valToBound < bounds[0]) return bounds[0];else if (valToBound > bounds[1]) return bounds[1];\n      }\n\n      return valToBound;\n    }\n\n    function pickFirst(array) {\n      if (d0._distinct && d0.index && array[d0.index]) return array[d0.index];\n      return array[0];\n    } // constrain text, markers, etc so they'll fit on the legend\n\n\n    if (showMarker || showText || showLine) {\n      var dEdit = {};\n      var tEdit = {};\n\n      if (showMarker) {\n        dEdit.mc = boundVal('marker.color', pickFirst);\n        dEdit.mx = boundVal('marker.symbol', pickFirst);\n        dEdit.mo = boundVal('marker.opacity', Lib.mean, [0.2, 1]);\n        dEdit.mlc = boundVal('marker.line.color', pickFirst);\n        dEdit.mlw = boundVal('marker.line.width', Lib.mean, [0, 5], CST_MARKER_LINE_WIDTH);\n        tEdit.marker = {\n          sizeref: 1,\n          sizemin: 1,\n          sizemode: 'diameter'\n        };\n        var ms = boundVal('marker.size', Lib.mean, [2, 16], CST_MARKER_SIZE);\n        dEdit.ms = ms;\n        tEdit.marker.size = ms;\n      }\n\n      if (showLine) {\n        tEdit.line = {\n          width: boundVal('line.width', pickFirst, [0, 10], CST_LINE_WIDTH)\n        };\n      }\n\n      if (showText) {\n        dEdit.tx = 'Aa';\n        dEdit.tp = boundVal('textposition', pickFirst);\n        dEdit.ts = 10;\n        dEdit.tc = boundVal('textfont.color', pickFirst);\n        dEdit.tf = boundVal('textfont.family', pickFirst);\n      }\n\n      dMod = [Lib.minExtend(d0, dEdit)];\n      tMod = Lib.minExtend(trace, tEdit); // always show legend items in base state\n\n      tMod.selectedpoints = null; // never show texttemplate\n\n      tMod.texttemplate = null;\n    }\n\n    var ptgroup = d3.select(this).select('g.legendpoints');\n    var pts = ptgroup.selectAll('path.scatterpts').data(showMarker ? dMod : []); // make sure marker is on the bottom, in case it enters after text\n\n    pts.enter().insert('path', ':first-child').classed('scatterpts', true).attr('transform', centerTransform);\n    pts.exit().remove();\n    pts.call(Drawing.pointStyle, tMod, gd); // 'mrc' is set in pointStyle and used in textPointStyle:\n    // constrain it here\n\n    if (showMarker) dMod[0].mrc = 3;\n    var txt = ptgroup.selectAll('g.pointtext').data(showText ? dMod : []);\n    txt.enter().append('g').classed('pointtext', true).append('text').attr('transform', centerTransform);\n    txt.exit().remove();\n    txt.selectAll('text').call(Drawing.textPointStyle, tMod, gd);\n  }\n\n  function styleWaterfalls(d) {\n    var trace = d[0].trace;\n    var isWaterfall = trace.type === 'waterfall';\n\n    if (d[0]._distinct && isWaterfall) {\n      var cont = d[0].trace[d[0].dir].marker;\n      d[0].mc = cont.color;\n      d[0].mlw = cont.line.width;\n      d[0].mlc = cont.line.color;\n      return styleBarLike(d, this, 'waterfall');\n    }\n\n    var ptsData = [];\n\n    if (trace.visible && isWaterfall) {\n      ptsData = d[0].hasTotals ? [['increasing', 'M-6,-6V6H0Z'], ['totals', 'M6,6H0L-6,-6H-0Z'], ['decreasing', 'M6,6V-6H0Z']] : [['increasing', 'M-6,-6V6H6Z'], ['decreasing', 'M6,6V-6H-6Z']];\n    }\n\n    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendwaterfall').data(ptsData);\n    pts.enter().append('path').classed('legendwaterfall', true).attr('transform', centerTransform).style('stroke-miterlimit', 1);\n    pts.exit().remove();\n    pts.each(function (dd) {\n      var pt = d3.select(this);\n      var cont = trace[dd[0]].marker;\n      var lw = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n      pt.attr('d', dd[1]).style('stroke-width', lw + 'px').call(Color.fill, cont.color);\n\n      if (lw) {\n        pt.call(Color.stroke, cont.line.color);\n      }\n    });\n  }\n\n  function styleBars(d) {\n    styleBarLike(d, this);\n  }\n\n  function styleFunnels(d) {\n    styleBarLike(d, this, 'funnel');\n  }\n\n  function styleBarLike(d, lThis, desiredType) {\n    var trace = d[0].trace;\n    var marker = trace.marker || {};\n    var markerLine = marker.line || {};\n    var isVisible = !desiredType ? Registry.traceIs(trace, 'bar') : trace.visible && trace.type === desiredType;\n    var barpath = d3.select(lThis).select('g.legendpoints').selectAll('path.legend' + desiredType).data(isVisible ? [d] : []);\n    barpath.enter().append('path').classed('legend' + desiredType, true).attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);\n    barpath.exit().remove();\n    barpath.each(function (d) {\n      var p = d3.select(this);\n      var d0 = d[0];\n      var w = boundLineWidth(d0.mlw, marker.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n      p.style('stroke-width', w + 'px');\n      var mcc = d0.mcc;\n\n      if (!legend._inHover && 'mc' in d0) {\n        // not in unified hover but\n        // for legend use the color in the middle of scale\n        var cOpts = extractOpts(marker);\n        var mid = cOpts.mid;\n        if (mid === undefined) mid = (cOpts.max + cOpts.min) / 2;\n        mcc = Drawing.tryColorscale(marker, '')(mid);\n      }\n\n      var fillColor = mcc || d0.mc || marker.color;\n      var markerPattern = marker.pattern;\n      var patternShape = markerPattern && Drawing.getPatternAttr(markerPattern.shape, 0, '');\n\n      if (patternShape) {\n        var patternBGColor = Drawing.getPatternAttr(markerPattern.bgcolor, 0, null);\n        var patternFGColor = Drawing.getPatternAttr(markerPattern.fgcolor, 0, null);\n        var patternFGOpacity = markerPattern.fgopacity;\n        var patternSize = dimAttr(markerPattern.size, 8, 10);\n        var patternSolidity = dimAttr(markerPattern.solidity, 0.5, 1);\n        var patternID = 'legend-' + trace.uid;\n        p.call(Drawing.pattern, 'legend', gd, patternID, patternShape, patternSize, patternSolidity, mcc, markerPattern.fillmode, patternBGColor, patternFGColor, patternFGOpacity);\n      } else {\n        p.call(Color.fill, fillColor);\n      }\n\n      if (w) Color.stroke(p, d0.mlc || markerLine.color);\n    });\n  }\n\n  function styleBoxes(d) {\n    var trace = d[0].trace;\n    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendbox').data(trace.visible && Registry.traceIs(trace, 'box-violin') ? [d] : []);\n    pts.enter().append('path').classed('legendbox', true) // if we want the median bar, prepend M6,0H-6\n    .attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);\n    pts.exit().remove();\n    pts.each(function () {\n      var p = d3.select(this);\n\n      if ((trace.boxpoints === 'all' || trace.points === 'all') && Color.opacity(trace.fillcolor) === 0 && Color.opacity((trace.line || {}).color) === 0) {\n        var tMod = Lib.minExtend(trace, {\n          marker: {\n            size: constantItemSizing ? CST_MARKER_SIZE : Lib.constrain(trace.marker.size, 2, 16),\n            sizeref: 1,\n            sizemin: 1,\n            sizemode: 'diameter'\n          }\n        });\n        pts.call(Drawing.pointStyle, tMod, gd);\n      } else {\n        var w = boundLineWidth(undefined, trace.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n        p.style('stroke-width', w + 'px').call(Color.fill, trace.fillcolor);\n        if (w) Color.stroke(p, trace.line.color);\n      }\n    });\n  }\n\n  function styleCandles(d) {\n    var trace = d[0].trace;\n    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendcandle').data(trace.visible && trace.type === 'candlestick' ? [d, d] : []);\n    pts.enter().append('path').classed('legendcandle', true).attr('d', function (_, i) {\n      if (i) return 'M-15,0H-8M-8,6V-6H8Z'; // increasing\n\n      return 'M15,0H8M8,-6V6H-8Z'; // decreasing\n    }).attr('transform', centerTransform).style('stroke-miterlimit', 1);\n    pts.exit().remove();\n    pts.each(function (_, i) {\n      var p = d3.select(this);\n      var cont = trace[i ? 'increasing' : 'decreasing'];\n      var w = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n      p.style('stroke-width', w + 'px').call(Color.fill, cont.fillcolor);\n      if (w) Color.stroke(p, cont.line.color);\n    });\n  }\n\n  function styleOHLC(d) {\n    var trace = d[0].trace;\n    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legendohlc').data(trace.visible && trace.type === 'ohlc' ? [d, d] : []);\n    pts.enter().append('path').classed('legendohlc', true).attr('d', function (_, i) {\n      if (i) return 'M-15,0H0M-8,-6V0'; // increasing\n\n      return 'M15,0H0M8,6V0'; // decreasing\n    }).attr('transform', centerTransform).style('stroke-miterlimit', 1);\n    pts.exit().remove();\n    pts.each(function (_, i) {\n      var p = d3.select(this);\n      var cont = trace[i ? 'increasing' : 'decreasing'];\n      var w = boundLineWidth(undefined, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n      p.style('fill', 'none').call(Drawing.dashLine, cont.line.dash, w);\n      if (w) Color.stroke(p, cont.line.color);\n    });\n  }\n\n  function stylePies(d) {\n    stylePieLike(d, this, 'pie');\n  }\n\n  function styleFunnelareas(d) {\n    stylePieLike(d, this, 'funnelarea');\n  }\n\n  function stylePieLike(d, lThis, desiredType) {\n    var d0 = d[0];\n    var trace = d0.trace;\n    var isVisible = !desiredType ? Registry.traceIs(trace, desiredType) : trace.visible && trace.type === desiredType;\n    var pts = d3.select(lThis).select('g.legendpoints').selectAll('path.legend' + desiredType).data(isVisible ? [d] : []);\n    pts.enter().append('path').classed('legend' + desiredType, true).attr('d', 'M6,6H-6V-6H6Z').attr('transform', centerTransform);\n    pts.exit().remove();\n\n    if (pts.size()) {\n      var cont = (trace.marker || {}).line;\n      var lw = boundLineWidth(pieCastOption(cont.width, d0.pts), cont, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);\n      var tMod = Lib.minExtend(trace, {\n        marker: {\n          line: {\n            width: lw\n          }\n        }\n      }); // since minExtend do not slice more than 3 items we need to patch line.color here\n\n      tMod.marker.line.color = cont.color;\n      var d0Mod = Lib.minExtend(d0, {\n        trace: tMod\n      });\n      stylePie(pts, d0Mod, tMod);\n    }\n  }\n\n  function styleSpatial(d) {\n    // i.e. maninly traces having z and colorscale\n    var trace = d[0].trace;\n    var useGradient;\n    var ptsData = [];\n\n    if (trace.visible) {\n      switch (trace.type) {\n        case 'histogram2d':\n        case 'heatmap':\n          ptsData = [['M-15,-2V4H15V-2Z'] // similar to contour\n          ];\n          useGradient = true;\n          break;\n\n        case 'choropleth':\n        case 'choroplethmapbox':\n          ptsData = [['M-6,-6V6H6V-6Z']];\n          useGradient = true;\n          break;\n\n        case 'densitymapbox':\n          ptsData = [['M-6,0 a6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0']];\n          useGradient = 'radial';\n          break;\n\n        case 'cone':\n          ptsData = [['M-6,2 A2,2 0 0,0 -6,6 V6L6,4Z'], ['M-6,-6 A2,2 0 0,0 -6,-2 L6,-4Z'], ['M-6,-2 A2,2 0 0,0 -6,2 L6,0Z']];\n          useGradient = false;\n          break;\n\n        case 'streamtube':\n          ptsData = [['M-6,2 A2,2 0 0,0 -6,6 H6 A2,2 0 0,1 6,2 Z'], ['M-6,-6 A2,2 0 0,0 -6,-2 H6 A2,2 0 0,1 6,-6 Z'], ['M-6,-2 A2,2 0 0,0 -6,2 H6 A2,2 0 0,1 6,-2 Z']];\n          useGradient = false;\n          break;\n\n        case 'surface':\n          ptsData = [['M-6,-6 A2,3 0 0,0 -6,0 H6 A2,3 0 0,1 6,-6 Z'], ['M-6,1 A2,3 0 0,1 -6,6 H6 A2,3 0 0,0 6,0 Z']];\n          useGradient = true;\n          break;\n\n        case 'mesh3d':\n          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6H6L0,6Z']];\n          useGradient = false;\n          break;\n\n        case 'volume':\n          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6H6L0,6Z']];\n          useGradient = true;\n          break;\n\n        case 'isosurface':\n          ptsData = [['M-6,6H0L-6,-6Z'], ['M6,6H0L6,-6Z'], ['M-6,-6 A12,24 0 0,0 6,-6 L0,6Z']];\n          useGradient = false;\n          break;\n      }\n    }\n\n    var pts = d3.select(this).select('g.legendpoints').selectAll('path.legend3dandfriends').data(ptsData);\n    pts.enter().append('path').classed('legend3dandfriends', true).attr('transform', centerTransform).style('stroke-miterlimit', 1);\n    pts.exit().remove();\n    pts.each(function (dd, i) {\n      var pt = d3.select(this);\n      var cOpts = extractOpts(trace);\n      var colorscale = cOpts.colorscale;\n      var reversescale = cOpts.reversescale;\n\n      var fillGradient = function fillGradient(s) {\n        if (s.size()) {\n          var gradientID = 'legendfill-' + trace.uid;\n          Drawing.gradient(s, gd, gradientID, getGradientDirection(reversescale, useGradient === 'radial'), colorscale, 'fill');\n        }\n      };\n\n      var fillColor;\n\n      if (!colorscale) {\n        var color = trace.vertexcolor || trace.facecolor || trace.color;\n        fillColor = Lib.isArrayOrTypedArray(color) ? color[i] || color[0] : color;\n      } else {\n        if (!useGradient) {\n          var len = colorscale.length;\n          fillColor = i === 0 ? colorscale[reversescale ? len - 1 : 0][1] : // minimum\n          i === 1 ? colorscale[reversescale ? 0 : len - 1][1] : // maximum\n          colorscale[Math.floor((len - 1) / 2)][1]; // middle\n        }\n      }\n\n      pt.attr('d', dd[0]);\n\n      if (fillColor) {\n        pt.call(Color.fill, fillColor);\n      } else {\n        pt.call(fillGradient);\n      }\n    });\n  }\n};\n\nfunction getGradientDirection(reversescale, isRadial) {\n  var str = isRadial ? 'radial' : 'horizontal';\n  return str + (reversescale ? '' : 'reversed');\n}\n\nfunction getStyleGuide(d) {\n  var trace = d[0].trace;\n  var contours = trace.contours;\n  var showLine = subTypes.hasLines(trace);\n  var showMarker = subTypes.hasMarkers(trace);\n  var showFill = trace.visible && trace.fill && trace.fill !== 'none';\n  var showGradientLine = false;\n  var showGradientFill = false;\n\n  if (contours) {\n    var coloring = contours.coloring;\n\n    if (coloring === 'lines') {\n      showGradientLine = true;\n    } else {\n      showLine = coloring === 'none' || coloring === 'heatmap' || contours.showlines;\n    }\n\n    if (contours.type === 'constraint') {\n      showFill = contours._operation !== '=';\n    } else if (coloring === 'fill' || coloring === 'heatmap') {\n      showGradientFill = true;\n    }\n  }\n\n  return {\n    showMarker: showMarker,\n    showLine: showLine,\n    showFill: showFill,\n    showGradientLine: showGradientLine,\n    showGradientFill: showGradientFill,\n    anyLine: showLine || showGradientLine,\n    anyFill: showFill || showGradientFill\n  };\n}\n\nfunction dimAttr(v, dflt, max) {\n  if (v && Lib.isArrayOrTypedArray(v)) return dflt;\n  if (v > max) return max;\n  return v;\n}","map":null,"metadata":{},"sourceType":"script"}