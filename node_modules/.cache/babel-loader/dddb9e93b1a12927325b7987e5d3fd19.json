{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\n\nvar Plots = require('../../plots/plots');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar Titles = require('../titles');\n\nvar Cartesian = require('../../plots/cartesian');\n\nvar axisIDs = require('../../plots/cartesian/axis_ids');\n\nvar dragElement = require('../dragelement');\n\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\n\nmodule.exports = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var rangeSliderData = fullLayout._rangeSliderData;\n\n  for (var i = 0; i < rangeSliderData.length; i++) {\n    var opts = rangeSliderData[i][constants.name]; // fullLayout._uid may not exist when we call makeData\n\n    opts._clipId = opts._id + '-' + fullLayout._uid;\n  }\n  /*\n   * <g container />\n   *  <rect bg />\n   *  < .... range plot />\n   *  <rect mask-min />\n   *  <rect mask-max />\n   *  <rect slidebox />\n   *  <g grabber-min />\n   *      <rect handle-min />\n   *      <rect grabare-min />\n   *  <g grabber-max />\n   *      <rect handle-max />\n   *      <rect grabare-max />\n   *\n   *  ...\n   */\n\n\n  function keyFunction(axisOpts) {\n    return axisOpts._name;\n  }\n\n  var rangeSliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(rangeSliderData, keyFunction); // remove exiting sliders and their corresponding clip paths\n\n\n  rangeSliders.exit().each(function (axisOpts) {\n    var opts = axisOpts[constants.name];\n\n    fullLayout._topdefs.select('#' + opts._clipId).remove();\n  }).remove(); // return early if no range slider is visible\n\n  if (rangeSliderData.length === 0) return;\n  rangeSliders.enter().append('g').classed(constants.containerClassName, true).attr('pointer-events', 'all'); // for all present range sliders\n\n  rangeSliders.each(function (axisOpts) {\n    var rangeSlider = d3.select(this);\n    var opts = axisOpts[constants.name];\n    var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];\n    var oppAxisRangeOpts = opts[axisIDs.id2name(axisOpts.anchor)]; // update range\n    // Expand slider range to the axis range\n\n    if (opts.range) {\n      var rng = Lib.simpleMap(opts.range, axisOpts.r2l);\n      var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);\n      var newRng;\n\n      if (axRng[0] < axRng[1]) {\n        newRng = [Math.min(rng[0], axRng[0]), Math.max(rng[1], axRng[1])];\n      } else {\n        newRng = [Math.max(rng[0], axRng[0]), Math.min(rng[1], axRng[1])];\n      }\n\n      opts.range = opts._input.range = Lib.simpleMap(newRng, axisOpts.l2r);\n    }\n\n    axisOpts.cleanRange('rangeslider.range'); // update range slider dimensions\n\n    var gs = fullLayout._size;\n    var domain = axisOpts.domain;\n    opts._width = gs.w * (domain[1] - domain[0]);\n    var x = Math.round(gs.l + gs.w * domain[0]);\n    var y = Math.round(gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === 'bottom' ? axisOpts._depth : 0) + opts._offsetShift + constants.extraPad);\n    rangeSlider.attr('transform', strTranslate(x, y)); // update data <--> pixel coordinate conversion methods\n\n    opts._rl = Lib.simpleMap(opts.range, axisOpts.r2l);\n    var rl0 = opts._rl[0];\n    var rl1 = opts._rl[1];\n    var drl = rl1 - rl0;\n\n    opts.p2d = function (v) {\n      return v / opts._width * drl + rl0;\n    };\n\n    opts.d2p = function (v) {\n      return (v - rl0) / drl * opts._width;\n    };\n\n    if (axisOpts.rangebreaks) {\n      var rsBreaks = axisOpts.locateBreaks(rl0, rl1);\n\n      if (rsBreaks.length) {\n        var j, brk;\n        var lBreaks = 0;\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          lBreaks += brk.max - brk.min;\n        } // TODO fix for reversed-range axes !!!\n        // compute slope and piecewise offsets\n\n\n        var m2 = opts._width / (rl1 - rl0 - lBreaks);\n        var _B = [-m2 * rl0];\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n\n          _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));\n        }\n\n        opts.d2p = function (v) {\n          var b = _B[0];\n\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.max) b = _B[j + 1];else if (v < brk.min) break;\n          }\n\n          return b + m2 * v;\n        }; // fill pixel (i.e. 'p') min/max here,\n        // to not have to loop through the _rangebreaks twice during `p2d`\n\n\n        for (j = 0; j < rsBreaks.length; j++) {\n          brk = rsBreaks[j];\n          brk.pmin = opts.d2p(brk.min);\n          brk.pmax = opts.d2p(brk.max);\n        }\n\n        opts.p2d = function (v) {\n          var b = _B[0];\n\n          for (var j = 0; j < rsBreaks.length; j++) {\n            var brk = rsBreaks[j];\n            if (v >= brk.pmax) b = _B[j + 1];else if (v < brk.pmin) break;\n          }\n\n          return (v - b) / m2;\n        };\n      }\n    }\n\n    if (oppAxisRangeOpts.rangemode !== 'match') {\n      var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);\n      var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);\n      var distOppAxis = range1OppAxis - range0OppAxis;\n\n      opts.d2pOppAxis = function (v) {\n        return (v - range0OppAxis) / distOppAxis * opts._height;\n      };\n    } // update inner nodes\n\n\n    rangeSlider.call(drawBg, gd, axisOpts, opts).call(addClipPath, gd, axisOpts, opts).call(drawRangePlot, gd, axisOpts, opts).call(drawMasks, gd, axisOpts, opts, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts).call(drawGrabbers, gd, axisOpts, opts); // setup drag element\n\n    setupDragElement(rangeSlider, gd, axisOpts, opts); // update current range\n\n    setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts); // title goes next to range slider instead of tick labels, so\n    // just take it over and draw it from here\n\n    if (axisOpts.side === 'bottom') {\n      Titles.draw(gd, axisOpts._id + 'title', {\n        propContainer: axisOpts,\n        propName: axisOpts._name + '.title',\n        placeholder: fullLayout._dfltTitle.x,\n        attributes: {\n          x: axisOpts._offset + axisOpts._length / 2,\n          y: y + opts._height + opts._offsetShift + 10 + 1.5 * axisOpts.title.font.size,\n          'text-anchor': 'middle'\n        }\n      });\n    }\n  });\n};\n\nfunction setupDragElement(rangeSlider, gd, axisOpts, opts) {\n  if (gd._context.staticPlot) return;\n  var slideBox = rangeSlider.select('rect.' + constants.slideBoxClassName).node();\n  var grabAreaMin = rangeSlider.select('rect.' + constants.grabAreaMinClassName).node();\n  var grabAreaMax = rangeSlider.select('rect.' + constants.grabAreaMaxClassName).node();\n\n  function mouseDownHandler() {\n    var event = d3.event;\n    var target = event.target;\n    var startX = event.clientX || event.touches[0].clientX;\n    var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;\n    var minVal = opts.d2p(axisOpts._rl[0]);\n    var maxVal = opts.d2p(axisOpts._rl[1]);\n    var dragCover = dragElement.coverSlip();\n    this.addEventListener('touchmove', mouseMove);\n    this.addEventListener('touchend', mouseUp);\n    dragCover.addEventListener('mousemove', mouseMove);\n    dragCover.addEventListener('mouseup', mouseUp);\n\n    function mouseMove(e) {\n      var clientX = e.clientX || e.touches[0].clientX;\n      var delta = +clientX - startX;\n      var pixelMin, pixelMax, cursor;\n\n      switch (target) {\n        case slideBox:\n          cursor = 'ew-resize';\n          pixelMin = minVal + delta;\n          pixelMax = maxVal + delta;\n          break;\n\n        case grabAreaMin:\n          cursor = 'col-resize';\n          pixelMin = minVal + delta;\n          pixelMax = maxVal;\n          break;\n\n        case grabAreaMax:\n          cursor = 'col-resize';\n          pixelMin = minVal;\n          pixelMax = maxVal + delta;\n          break;\n\n        default:\n          cursor = 'ew-resize';\n          pixelMin = offsetX;\n          pixelMax = offsetX + delta;\n          break;\n      }\n\n      if (pixelMax < pixelMin) {\n        var tmp = pixelMax;\n        pixelMax = pixelMin;\n        pixelMin = tmp;\n      }\n\n      opts._pixelMin = pixelMin;\n      opts._pixelMax = pixelMax;\n      setCursor(d3.select(dragCover), cursor);\n      setDataRange(rangeSlider, gd, axisOpts, opts);\n    }\n\n    function mouseUp() {\n      dragCover.removeEventListener('mousemove', mouseMove);\n      dragCover.removeEventListener('mouseup', mouseUp);\n      this.removeEventListener('touchmove', mouseMove);\n      this.removeEventListener('touchend', mouseUp);\n      Lib.removeElement(dragCover);\n    }\n  }\n\n  rangeSlider.on('mousedown', mouseDownHandler);\n  rangeSlider.on('touchstart', mouseDownHandler);\n}\n\nfunction setDataRange(rangeSlider, gd, axisOpts, opts) {\n  function clamp(v) {\n    return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));\n  }\n\n  var dataMin = clamp(opts.p2d(opts._pixelMin));\n  var dataMax = clamp(opts.p2d(opts._pixelMax));\n  window.requestAnimationFrame(function () {\n    Registry.call('_guiRelayout', gd, axisOpts._name + '.range', [dataMin, dataMax]);\n  });\n}\n\nfunction setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {\n  var hw2 = constants.handleWidth / 2;\n\n  function clamp(v) {\n    return Lib.constrain(v, 0, opts._width);\n  }\n\n  function clampOppAxis(v) {\n    return Lib.constrain(v, 0, opts._height);\n  }\n\n  function clampHandle(v) {\n    return Lib.constrain(v, -hw2, opts._width + hw2);\n  }\n\n  var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));\n  var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));\n  rangeSlider.select('rect.' + constants.slideBoxClassName).attr('x', pixelMin).attr('width', pixelMax - pixelMin);\n  rangeSlider.select('rect.' + constants.maskMinClassName).attr('width', pixelMin);\n  rangeSlider.select('rect.' + constants.maskMaxClassName).attr('x', pixelMax).attr('width', opts._width - pixelMax);\n\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));\n    var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));\n    rangeSlider.select('rect.' + constants.maskMinOppAxisClassName).attr('x', pixelMin).attr('height', pixelMinOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.maskMaxOppAxisClassName).attr('x', pixelMin).attr('y', pixelMaxOppAxis).attr('height', opts._height - pixelMaxOppAxis).attr('width', pixelMax - pixelMin);\n    rangeSlider.select('rect.' + constants.slideBoxClassName).attr('y', pixelMinOppAxis).attr('height', pixelMaxOppAxis - pixelMinOppAxis);\n  } // add offset for crispier corners\n  // https://github.com/plotly/plotly.js/pull/1409\n\n\n  var offset = 0.5;\n  var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;\n  var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;\n  rangeSlider.select('g.' + constants.grabberMinClassName).attr('transform', strTranslate(xMin, offset));\n  rangeSlider.select('g.' + constants.grabberMaxClassName).attr('transform', strTranslate(xMax, offset));\n}\n\nfunction drawBg(rangeSlider, gd, axisOpts, opts) {\n  var bg = Lib.ensureSingle(rangeSlider, 'rect', constants.bgClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;\n  var offsetShift = -opts._offsetShift;\n  var lw = Drawing.crispRound(gd, opts.borderwidth);\n  bg.attr({\n    width: opts._width + borderCorrect,\n    height: opts._height + borderCorrect,\n    transform: strTranslate(offsetShift, offsetShift),\n    'stroke-width': lw\n  }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);\n}\n\nfunction addClipPath(rangeSlider, gd, axisOpts, opts) {\n  var fullLayout = gd._fullLayout;\n  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', opts._clipId, function (s) {\n    s.append('rect').attr({\n      x: 0,\n      y: 0\n    });\n  });\n  clipPath.select('rect').attr({\n    width: opts._width,\n    height: opts._height\n  });\n}\n\nfunction drawRangePlot(rangeSlider, gd, axisOpts, opts) {\n  var calcData = gd.calcdata;\n  var rangePlots = rangeSlider.selectAll('g.' + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);\n  rangePlots.enter().append('g').attr('class', function (id) {\n    return constants.rangePlotClassName + ' ' + id;\n  }).call(Drawing.setClipUrl, opts._clipId, gd);\n  rangePlots.order();\n  rangePlots.exit().remove();\n  var mainplotinfo;\n  rangePlots.each(function (id, i) {\n    var plotgroup = d3.select(this);\n    var isMainPlot = i === 0;\n    var oppAxisOpts = axisIDs.getFromId(gd, id, 'y');\n    var oppAxisName = oppAxisOpts._name;\n    var oppAxisRangeOpts = opts[oppAxisName];\n    var mockFigure = {\n      data: [],\n      layout: {\n        xaxis: {\n          type: axisOpts.type,\n          domain: [0, 1],\n          range: opts.range.slice(),\n          calendar: axisOpts.calendar\n        },\n        width: opts._width,\n        height: opts._height,\n        margin: {\n          t: 0,\n          b: 0,\n          l: 0,\n          r: 0\n        }\n      },\n      _context: gd._context\n    };\n\n    if (axisOpts.rangebreaks) {\n      mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;\n    }\n\n    mockFigure.layout[oppAxisName] = {\n      type: oppAxisOpts.type,\n      domain: [0, 1],\n      range: oppAxisRangeOpts.rangemode !== 'match' ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),\n      calendar: oppAxisOpts.calendar\n    };\n\n    if (oppAxisOpts.rangebreaks) {\n      mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;\n    }\n\n    Plots.supplyDefaults(mockFigure);\n    var xa = mockFigure._fullLayout.xaxis;\n    var ya = mockFigure._fullLayout[oppAxisName];\n    xa.clearCalc();\n    xa.setScale();\n    ya.clearCalc();\n    ya.setScale();\n    var plotinfo = {\n      id: id,\n      plotgroup: plotgroup,\n      xaxis: xa,\n      yaxis: ya,\n      isRangePlot: true\n    };\n    if (isMainPlot) mainplotinfo = plotinfo;else {\n      plotinfo.mainplot = 'xy';\n      plotinfo.mainplotinfo = mainplotinfo;\n    }\n    Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));\n  });\n}\n\nfunction filterRangePlotCalcData(calcData, subplotId) {\n  var out = [];\n\n  for (var i = 0; i < calcData.length; i++) {\n    var calcTrace = calcData[i];\n    var trace = calcTrace[0].trace;\n\n    if (trace.xaxis + trace.yaxis === subplotId) {\n      out.push(calcTrace);\n    }\n  }\n\n  return out;\n}\n\nfunction drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {\n  var maskMin = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinClassName, function (s) {\n    s.attr({\n      x: 0,\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMin.attr('height', opts._height).call(Color.fill, constants.maskColor);\n  var maskMax = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxClassName, function (s) {\n    s.attr({\n      y: 0,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  maskMax.attr('height', opts._height).call(Color.fill, constants.maskColor); // masks used for oppAxis zoom\n\n  if (oppAxisRangeOpts.rangemode !== 'match') {\n    var maskMinOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMinOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMinOppAxis.attr('width', opts._width).call(Color.fill, constants.maskOppAxisColor);\n    var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, 'rect', constants.maskMaxOppAxisClassName, function (s) {\n      s.attr({\n        y: 0,\n        'shape-rendering': 'crispEdges'\n      });\n    });\n    maskMaxOppAxis.attr('width', opts._width).style('border-top', constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);\n  }\n}\n\nfunction drawSlideBox(rangeSlider, gd, axisOpts, opts) {\n  if (gd._context.staticPlot) return;\n  var slideBox = Lib.ensureSingle(rangeSlider, 'rect', constants.slideBoxClassName, function (s) {\n    s.attr({\n      y: 0,\n      cursor: constants.slideBoxCursor,\n      'shape-rendering': 'crispEdges'\n    });\n  });\n  slideBox.attr({\n    height: opts._height,\n    fill: constants.slideBoxFill\n  });\n}\n\nfunction drawGrabbers(rangeSlider, gd, axisOpts, opts) {\n  // <g grabber />\n  var grabberMin = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMinClassName);\n  var grabberMax = Lib.ensureSingle(rangeSlider, 'g', constants.grabberMaxClassName); // <g handle />\n\n  var handleFixAttrs = {\n    x: 0,\n    width: constants.handleWidth,\n    rx: constants.handleRadius,\n    fill: Color.background,\n    stroke: Color.defaultLine,\n    'stroke-width': constants.handleStrokeWidth,\n    'shape-rendering': 'crispEdges'\n  };\n  var handleDynamicAttrs = {\n    y: Math.round(opts._height / 4),\n    height: Math.round(opts._height / 2)\n  };\n  var handleMin = Lib.ensureSingle(grabberMin, 'rect', constants.handleMinClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMin.attr(handleDynamicAttrs);\n  var handleMax = Lib.ensureSingle(grabberMax, 'rect', constants.handleMaxClassName, function (s) {\n    s.attr(handleFixAttrs);\n  });\n  handleMax.attr(handleDynamicAttrs); // <g grabarea />\n\n  var grabAreaFixAttrs = {\n    width: constants.grabAreaWidth,\n    x: 0,\n    y: 0,\n    fill: constants.grabAreaFill,\n    cursor: !gd._context.staticPlot ? constants.grabAreaCursor : undefined\n  };\n  var grabAreaMin = Lib.ensureSingle(grabberMin, 'rect', constants.grabAreaMinClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMin.attr('height', opts._height);\n  var grabAreaMax = Lib.ensureSingle(grabberMax, 'rect', constants.grabAreaMaxClassName, function (s) {\n    s.attr(grabAreaFixAttrs);\n  });\n  grabAreaMax.attr('height', opts._height);\n}","map":null,"metadata":{},"sourceType":"script"}