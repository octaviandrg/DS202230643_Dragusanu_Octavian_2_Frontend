{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar handleArrayContainerDefaults = require('../../plots/array_container_defaults');\n\nvar attributes = require('./attributes');\n\nvar helpers = require('../shapes/helpers');\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {\n  handleArrayContainerDefaults(layoutIn, layoutOut, {\n    name: 'selections',\n    handleItemDefaults: handleSelectionDefaults\n  }); // Drop rect selections with undefined x0, y0, x1, x1 values.\n  // In future we may accept partially defined rects e.g.\n  // a case with only x0 and x1 may be used to define\n  // [-Infinity, +Infinity] range on the y axis, etc.\n\n  var selections = layoutOut.selections;\n\n  for (var i = 0; i < selections.length; i++) {\n    var selection = selections[i];\n    if (!selection) continue;\n\n    if (selection.path === undefined) {\n      if (selection.x0 === undefined || selection.x1 === undefined || selection.y0 === undefined || selection.y1 === undefined) {\n        layoutOut.selections[i] = null;\n      }\n    }\n  }\n};\n\nfunction handleSelectionDefaults(selectionIn, selectionOut, fullLayout) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(selectionIn, selectionOut, attributes, attr, dflt);\n  }\n\n  var path = coerce('path');\n  var dfltType = path ? 'path' : 'rect';\n  var selectionType = coerce('type', dfltType);\n  var noPath = selectionType !== 'path';\n  if (noPath) delete selectionOut.path;\n  coerce('opacity');\n  coerce('line.color');\n  coerce('line.width');\n  coerce('line.dash'); // positioning\n\n  var axLetters = ['x', 'y'];\n\n  for (var i = 0; i < 2; i++) {\n    var axLetter = axLetters[i];\n    var gdMock = {\n      _fullLayout: fullLayout\n    };\n    var ax;\n    var pos2r;\n    var r2pos; // xref, yref\n\n    var axRef = Axes.coerceRef(selectionIn, selectionOut, gdMock, axLetter); // axRefType is 'range' for selections\n\n    ax = Axes.getFromId(gdMock, axRef);\n\n    ax._selectionIndices.push(selectionOut._index);\n\n    r2pos = helpers.rangeToShapePosition(ax);\n    pos2r = helpers.shapePositionToRange(ax); // Coerce x0, x1, y0, y1\n\n    if (noPath) {\n      // hack until V3.0 when log has regular range behavior - make it look like other\n      // ranges to send to coerce, then put it back after\n      // this is all to give reasonable default position behavior on log axes, which is\n      // a pretty unimportant edge case so we could just ignore this.\n      var attr0 = axLetter + '0';\n      var attr1 = axLetter + '1';\n      var in0 = selectionIn[attr0];\n      var in1 = selectionIn[attr1];\n      selectionIn[attr0] = pos2r(selectionIn[attr0], true);\n      selectionIn[attr1] = pos2r(selectionIn[attr1], true);\n      Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr0);\n      Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr1);\n      var p0 = selectionOut[attr0];\n      var p1 = selectionOut[attr1];\n\n      if (p0 !== undefined && p1 !== undefined) {\n        // hack part 2\n        selectionOut[attr0] = r2pos(p0);\n        selectionOut[attr1] = r2pos(p1);\n        selectionIn[attr0] = in0;\n        selectionIn[attr1] = in1;\n      }\n    }\n  }\n\n  if (noPath) {\n    Lib.noneOrAll(selectionIn, selectionOut, ['x0', 'x1', 'y0', 'y1']);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}