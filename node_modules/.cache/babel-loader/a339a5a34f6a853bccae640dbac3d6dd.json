{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar Fx = require('../../components/fx');\n\nvar createPlot2D = require('../../../stackgl_modules').gl_plot2d;\n\nvar createSpikes = require('../../../stackgl_modules').gl_spikes2d;\n\nvar createSelectBox = require('../../../stackgl_modules').gl_select_box;\n\nvar getContext = require('webgl-context');\n\nvar createOptions = require('./convert');\n\nvar createCamera = require('./camera');\n\nvar showNoWebGlMsg = require('../../lib/show_no_webgl_msg');\n\nvar axisConstraints = require('../cartesian/constraints');\n\nvar enforceAxisConstraints = axisConstraints.enforce;\nvar cleanAxisConstraints = axisConstraints.clean;\n\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\n\nvar dragHelpers = require('../../components/dragelement/helpers');\n\nvar drawMode = dragHelpers.drawMode;\nvar selectMode = dragHelpers.selectMode;\nvar AXES = ['xaxis', 'yaxis'];\nvar STATIC_CANVAS, STATIC_CONTEXT;\n\nvar SUBPLOT_PATTERN = require('../cartesian/constants').SUBPLOT_PATTERN;\n\nfunction Scene2D(options, fullLayout) {\n  this.container = options.container;\n  this.graphDiv = options.graphDiv;\n  this.pixelRatio = options.plotGlPixelRatio || window.devicePixelRatio;\n  this.id = options.id;\n  this.staticPlot = !!options.staticPlot;\n  this.scrollZoom = this.graphDiv._context._scrollZoom.cartesian;\n  this.fullData = null;\n  this.updateRefs(fullLayout);\n  this.makeFramework();\n  if (this.stopped) return; // update options\n\n  this.glplotOptions = createOptions(this);\n  this.glplotOptions.merge(fullLayout); // create the plot\n\n  this.glplot = createPlot2D(this.glplotOptions); // create camera\n\n  this.camera = createCamera(this); // trace set\n\n  this.traces = {}; // create axes spikes\n\n  this.spikes = createSpikes(this.glplot);\n  this.selectBox = createSelectBox(this.glplot, {\n    innerFill: false,\n    outerFill: true\n  }); // last button state\n\n  this.lastButtonState = 0; // last pick result\n\n  this.pickResult = null; // is the mouse over the plot?\n  // it's OK if this says true when it's not, so long as\n  // when we get a mouseout we set it to false before handling\n\n  this.isMouseOver = true; // flag to stop render loop\n\n  this.stopped = false; // redraw the plot\n\n  this.redraw = this.draw.bind(this);\n  this.redraw();\n}\n\nmodule.exports = Scene2D;\nvar proto = Scene2D.prototype;\n\nproto.makeFramework = function () {\n  // create canvas and gl context\n  if (this.staticPlot) {\n    if (!STATIC_CONTEXT) {\n      STATIC_CANVAS = document.createElement('canvas');\n      STATIC_CONTEXT = getContext({\n        canvas: STATIC_CANVAS,\n        preserveDrawingBuffer: false,\n        premultipliedAlpha: true,\n        antialias: true\n      });\n\n      if (!STATIC_CONTEXT) {\n        throw new Error('Error creating static canvas/context for image server');\n      }\n    }\n\n    this.canvas = STATIC_CANVAS;\n    this.gl = STATIC_CONTEXT;\n  } else {\n    var liveCanvas = this.container.querySelector('.gl-canvas-focus');\n    var gl = getContext({\n      canvas: liveCanvas,\n      preserveDrawingBuffer: true,\n      premultipliedAlpha: true\n    });\n\n    if (!gl) {\n      showNoWebGlMsg(this);\n      this.stopped = true;\n      return;\n    }\n\n    this.canvas = liveCanvas;\n    this.gl = gl;\n  } // position the canvas\n\n\n  var canvas = this.canvas;\n  canvas.style.width = '100%';\n  canvas.style.height = '100%';\n  canvas.style.position = 'absolute';\n  canvas.style.top = '0px';\n  canvas.style.left = '0px';\n  canvas.style['pointer-events'] = 'none';\n  this.updateSize(canvas); // create SVG container for hover text\n\n  var svgContainer = this.svgContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n  svgContainer.style.position = 'absolute';\n  svgContainer.style.top = svgContainer.style.left = '0px';\n  svgContainer.style.width = svgContainer.style.height = '100%';\n  svgContainer.style['z-index'] = 20;\n  svgContainer.style['pointer-events'] = 'none'; // create div to catch the mouse event\n\n  var mouseContainer = this.mouseContainer = document.createElement('div');\n  mouseContainer.style.position = 'absolute';\n  mouseContainer.style['pointer-events'] = 'auto';\n  this.pickCanvas = this.container.querySelector('.gl-canvas-pick'); // append canvas, hover svg and mouse div to container\n\n  var container = this.container;\n  container.appendChild(svgContainer);\n  container.appendChild(mouseContainer);\n  var self = this;\n  mouseContainer.addEventListener('mouseout', function () {\n    self.isMouseOver = false;\n    self.unhover();\n  });\n  mouseContainer.addEventListener('mouseover', function () {\n    self.isMouseOver = true;\n  });\n};\n\nproto.toImage = function (format) {\n  if (!format) format = 'png';\n  this.stopped = true;\n  if (this.staticPlot) this.container.appendChild(STATIC_CANVAS); // update canvas size\n\n  this.updateSize(this.canvas); // grab context and yank out pixels\n\n  var gl = this.glplot.gl;\n  var w = gl.drawingBufferWidth;\n  var h = gl.drawingBufferHeight; // force redraw\n\n  gl.clearColor(1, 1, 1, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  this.glplot.setDirty();\n  this.glplot.draw();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  var pixels = new Uint8Array(w * h * 4);\n  gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels); // flip pixels\n\n  for (var j = 0, k = h - 1; j < k; ++j, --k) {\n    for (var i = 0; i < w; ++i) {\n      for (var l = 0; l < 4; ++l) {\n        var tmp = pixels[4 * (w * j + i) + l];\n        pixels[4 * (w * j + i) + l] = pixels[4 * (w * k + i) + l];\n        pixels[4 * (w * k + i) + l] = tmp;\n      }\n    }\n  }\n\n  var canvas = document.createElement('canvas');\n  canvas.width = w;\n  canvas.height = h;\n  var context = canvas.getContext('2d', {\n    willReadFrequently: true\n  });\n  var imageData = context.createImageData(w, h);\n  imageData.data.set(pixels);\n  context.putImageData(imageData, 0, 0);\n  var dataURL;\n\n  switch (format) {\n    case 'jpeg':\n      dataURL = canvas.toDataURL('image/jpeg');\n      break;\n\n    case 'webp':\n      dataURL = canvas.toDataURL('image/webp');\n      break;\n\n    default:\n      dataURL = canvas.toDataURL('image/png');\n  }\n\n  if (this.staticPlot) this.container.removeChild(STATIC_CANVAS);\n  return dataURL;\n};\n\nproto.updateSize = function (canvas) {\n  if (!canvas) canvas = this.canvas;\n  var pixelRatio = this.pixelRatio;\n  var fullLayout = this.fullLayout;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var pixelWidth = Math.ceil(pixelRatio * width) | 0;\n  var pixelHeight = Math.ceil(pixelRatio * height) | 0; // check for resize\n\n  if (canvas.width !== pixelWidth || canvas.height !== pixelHeight) {\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n  }\n\n  return canvas;\n};\n\nproto.computeTickMarks = function () {\n  this.xaxis.setScale();\n  this.yaxis.setScale();\n  var nextTicks = [Axes.calcTicks(this.xaxis), Axes.calcTicks(this.yaxis)];\n\n  for (var j = 0; j < 2; ++j) {\n    for (var i = 0; i < nextTicks[j].length; ++i) {\n      // coercing tick value (may not be a string) to a string\n      nextTicks[j][i].text = nextTicks[j][i].text + '';\n    }\n  }\n\n  return nextTicks;\n};\n\nfunction compareTicks(a, b) {\n  for (var i = 0; i < 2; ++i) {\n    var aticks = a[i];\n    var bticks = b[i];\n    if (aticks.length !== bticks.length) return true;\n\n    for (var j = 0; j < aticks.length; ++j) {\n      if (aticks[j].x !== bticks[j].x) return true;\n    }\n  }\n\n  return false;\n}\n\nproto.updateRefs = function (newFullLayout) {\n  this.fullLayout = newFullLayout;\n  var spmatch = this.id.match(SUBPLOT_PATTERN);\n  var xaxisName = 'xaxis' + spmatch[1];\n  var yaxisName = 'yaxis' + spmatch[2];\n  this.xaxis = this.fullLayout[xaxisName];\n  this.yaxis = this.fullLayout[yaxisName];\n};\n\nproto.relayoutCallback = function () {\n  var graphDiv = this.graphDiv;\n  var xaxis = this.xaxis;\n  var yaxis = this.yaxis;\n  var layout = graphDiv.layout; // make a meaningful value to be passed on to possible 'plotly_relayout' subscriber(s)\n\n  var update = {};\n  var xrange = update[xaxis._name + '.range'] = xaxis.range.slice();\n  var yrange = update[yaxis._name + '.range'] = yaxis.range.slice();\n  update[xaxis._name + '.autorange'] = xaxis.autorange;\n  update[yaxis._name + '.autorange'] = yaxis.autorange;\n  Registry.call('_storeDirectGUIEdit', graphDiv.layout, graphDiv._fullLayout._preGUI, update); // update the input layout\n\n  var xaIn = layout[xaxis._name];\n  xaIn.range = xrange;\n  xaIn.autorange = xaxis.autorange;\n  var yaIn = layout[yaxis._name];\n  yaIn.range = yrange;\n  yaIn.autorange = yaxis.autorange; // lastInputTime helps determine which one is the latest input (if async)\n\n  update.lastInputTime = this.camera.lastInputTime;\n  graphDiv.emit('plotly_relayout', update);\n};\n\nproto.cameraChanged = function () {\n  var camera = this.camera;\n  this.glplot.setDataBox(this.calcDataBox());\n  var nextTicks = this.computeTickMarks();\n  var curTicks = this.glplotOptions.ticks;\n\n  if (compareTicks(nextTicks, curTicks)) {\n    this.glplotOptions.ticks = nextTicks;\n    this.glplotOptions.dataBox = camera.dataBox;\n    this.glplot.update(this.glplotOptions);\n    this.handleAnnotations();\n  }\n};\n\nproto.handleAnnotations = function () {\n  var gd = this.graphDiv;\n  var annotations = this.fullLayout.annotations;\n\n  for (var i = 0; i < annotations.length; i++) {\n    var ann = annotations[i];\n\n    if (ann.xref === this.xaxis._id && ann.yref === this.yaxis._id) {\n      Registry.getComponentMethod('annotations', 'drawOne')(gd, i);\n    }\n  }\n};\n\nproto.destroy = function () {\n  if (!this.glplot) return;\n  var traces = this.traces;\n\n  if (traces) {\n    Object.keys(traces).map(function (key) {\n      traces[key].dispose();\n      delete traces[key];\n    });\n  }\n\n  this.glplot.dispose();\n  this.container.removeChild(this.svgContainer);\n  this.container.removeChild(this.mouseContainer);\n  this.fullData = null;\n  this.glplot = null;\n  this.stopped = true;\n  this.camera.mouseListener.enabled = false;\n  this.mouseContainer.removeEventListener('wheel', this.camera.wheelListener);\n  this.camera = null;\n};\n\nproto.plot = function (fullData, calcData, fullLayout) {\n  var glplot = this.glplot;\n  this.updateRefs(fullLayout);\n  this.xaxis.clearCalc();\n  this.yaxis.clearCalc();\n  this.updateTraces(fullData, calcData);\n  this.updateFx(fullLayout.dragmode);\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  this.updateSize(this.canvas);\n  var options = this.glplotOptions;\n  options.merge(fullLayout);\n  options.screenBox = [0, 0, width, height];\n  var mockGraphDiv = {\n    _fullLayout: {\n      _axisConstraintGroups: fullLayout._axisConstraintGroups,\n      xaxis: this.xaxis,\n      yaxis: this.yaxis,\n      _size: fullLayout._size\n    }\n  };\n  cleanAxisConstraints(mockGraphDiv, this.xaxis);\n  cleanAxisConstraints(mockGraphDiv, this.yaxis);\n  var size = fullLayout._size;\n  var domainX = this.xaxis.domain;\n  var domainY = this.yaxis.domain;\n  options.viewBox = [size.l + domainX[0] * size.w, size.b + domainY[0] * size.h, width - size.r - (1 - domainX[1]) * size.w, height - size.t - (1 - domainY[1]) * size.h];\n  this.mouseContainer.style.width = size.w * (domainX[1] - domainX[0]) + 'px';\n  this.mouseContainer.style.height = size.h * (domainY[1] - domainY[0]) + 'px';\n  this.mouseContainer.height = size.h * (domainY[1] - domainY[0]);\n  this.mouseContainer.style.left = size.l + domainX[0] * size.w + 'px';\n  this.mouseContainer.style.top = size.t + (1 - domainY[1]) * size.h + 'px';\n  var ax, i;\n\n  for (i = 0; i < 2; ++i) {\n    ax = this[AXES[i]];\n    ax._length = options.viewBox[i + 2] - options.viewBox[i];\n    doAutoRange(this.graphDiv, ax);\n    ax.setScale();\n  }\n\n  enforceAxisConstraints(mockGraphDiv);\n  options.ticks = this.computeTickMarks();\n  options.dataBox = this.calcDataBox();\n  options.merge(fullLayout);\n  glplot.update(options); // force redraw so that promise is returned when rendering is completed\n\n  this.glplot.draw();\n};\n\nproto.calcDataBox = function () {\n  var xaxis = this.xaxis;\n  var yaxis = this.yaxis;\n  var xrange = xaxis.range;\n  var yrange = yaxis.range;\n  var xr2l = xaxis.r2l;\n  var yr2l = yaxis.r2l;\n  return [xr2l(xrange[0]), yr2l(yrange[0]), xr2l(xrange[1]), yr2l(yrange[1])];\n};\n\nproto.setRanges = function (dataBox) {\n  var xaxis = this.xaxis;\n  var yaxis = this.yaxis;\n  var xl2r = xaxis.l2r;\n  var yl2r = yaxis.l2r;\n  xaxis.range = [xl2r(dataBox[0]), xl2r(dataBox[2])];\n  yaxis.range = [yl2r(dataBox[1]), yl2r(dataBox[3])];\n};\n\nproto.updateTraces = function (fullData, calcData) {\n  var traceIds = Object.keys(this.traces);\n  var i, j, fullTrace;\n  this.fullData = fullData; // remove empty traces\n\n  traceIdLoop: for (i = 0; i < traceIds.length; i++) {\n    var oldUid = traceIds[i];\n    var oldTrace = this.traces[oldUid];\n\n    for (j = 0; j < fullData.length; j++) {\n      fullTrace = fullData[j];\n\n      if (fullTrace.uid === oldUid && fullTrace.type === oldTrace.type) {\n        continue traceIdLoop;\n      }\n    }\n\n    oldTrace.dispose();\n    delete this.traces[oldUid];\n  } // update / create trace objects\n\n\n  for (i = 0; i < fullData.length; i++) {\n    fullTrace = fullData[i];\n    var calcTrace = calcData[i];\n    var traceObj = this.traces[fullTrace.uid];\n    if (traceObj) traceObj.update(fullTrace, calcTrace);else {\n      traceObj = fullTrace._module.plot(this, fullTrace, calcTrace);\n      this.traces[fullTrace.uid] = traceObj;\n    }\n  } // order object per traces\n\n\n  this.glplot.objects.sort(function (a, b) {\n    return a._trace.index - b._trace.index;\n  });\n};\n\nproto.updateFx = function (dragmode) {\n  // switch to svg interactions in lasso/select mode & shape drawing\n  if (selectMode(dragmode) || drawMode(dragmode)) {\n    this.pickCanvas.style['pointer-events'] = 'none';\n    this.mouseContainer.style['pointer-events'] = 'none';\n  } else {\n    this.pickCanvas.style['pointer-events'] = 'auto';\n    this.mouseContainer.style['pointer-events'] = 'auto';\n  } // set proper cursor\n\n\n  if (dragmode === 'pan') {\n    this.mouseContainer.style.cursor = 'move';\n  } else if (dragmode === 'zoom') {\n    this.mouseContainer.style.cursor = 'crosshair';\n  } else {\n    this.mouseContainer.style.cursor = null;\n  }\n};\n\nproto.emitPointAction = function (nextSelection, eventType) {\n  var uid = nextSelection.trace.uid;\n  var ptNumber = nextSelection.pointIndex;\n  var trace;\n\n  for (var i = 0; i < this.fullData.length; i++) {\n    if (this.fullData[i].uid === uid) {\n      trace = this.fullData[i];\n    }\n  }\n\n  var pointData = {\n    x: nextSelection.traceCoord[0],\n    y: nextSelection.traceCoord[1],\n    curveNumber: trace.index,\n    pointNumber: ptNumber,\n    data: trace._input,\n    fullData: this.fullData,\n    xaxis: this.xaxis,\n    yaxis: this.yaxis\n  };\n  Fx.appendArrayPointValue(pointData, trace, ptNumber);\n  this.graphDiv.emit(eventType, {\n    points: [pointData]\n  });\n};\n\nproto.draw = function () {\n  if (this.stopped) return;\n  requestAnimationFrame(this.redraw);\n  var glplot = this.glplot;\n  var camera = this.camera;\n  var mouseListener = camera.mouseListener;\n  var mouseUp = this.lastButtonState === 1 && mouseListener.buttons === 0;\n  var fullLayout = this.fullLayout;\n  this.lastButtonState = mouseListener.buttons;\n  this.cameraChanged();\n  var x = mouseListener.x * glplot.pixelRatio;\n  var y = this.canvas.height - glplot.pixelRatio * mouseListener.y;\n  var result;\n\n  if (camera.boxEnabled && fullLayout.dragmode === 'zoom') {\n    this.selectBox.enabled = true;\n    var selectBox = this.selectBox.selectBox = [Math.min(camera.boxStart[0], camera.boxEnd[0]), Math.min(camera.boxStart[1], camera.boxEnd[1]), Math.max(camera.boxStart[0], camera.boxEnd[0]), Math.max(camera.boxStart[1], camera.boxEnd[1])]; // 1D zoom\n\n    for (var i = 0; i < 2; i++) {\n      if (camera.boxStart[i] === camera.boxEnd[i]) {\n        selectBox[i] = glplot.dataBox[i];\n        selectBox[i + 2] = glplot.dataBox[i + 2];\n      }\n    }\n\n    glplot.setDirty();\n  } else if (!camera.panning && this.isMouseOver) {\n    this.selectBox.enabled = false;\n    var size = fullLayout._size;\n    var domainX = this.xaxis.domain;\n    var domainY = this.yaxis.domain;\n    result = glplot.pick(x / glplot.pixelRatio + size.l + domainX[0] * size.w, y / glplot.pixelRatio - (size.t + (1 - domainY[1]) * size.h));\n\n    var nextSelection = result && result.object._trace.handlePick(result);\n\n    if (nextSelection && mouseUp) {\n      this.emitPointAction(nextSelection, 'plotly_click');\n    }\n\n    if (result && result.object._trace.hoverinfo !== 'skip' && fullLayout.hovermode) {\n      if (nextSelection && (!this.lastPickResult || this.lastPickResult.traceUid !== nextSelection.trace.uid || this.lastPickResult.dataCoord[0] !== nextSelection.dataCoord[0] || this.lastPickResult.dataCoord[1] !== nextSelection.dataCoord[1])) {\n        var selection = nextSelection;\n        this.lastPickResult = {\n          traceUid: nextSelection.trace ? nextSelection.trace.uid : null,\n          dataCoord: nextSelection.dataCoord.slice()\n        };\n        this.spikes.update({\n          center: result.dataCoord\n        });\n        selection.screenCoord = [((glplot.viewBox[2] - glplot.viewBox[0]) * (result.dataCoord[0] - glplot.dataBox[0]) / (glplot.dataBox[2] - glplot.dataBox[0]) + glplot.viewBox[0]) / glplot.pixelRatio, (this.canvas.height - (glplot.viewBox[3] - glplot.viewBox[1]) * (result.dataCoord[1] - glplot.dataBox[1]) / (glplot.dataBox[3] - glplot.dataBox[1]) - glplot.viewBox[1]) / glplot.pixelRatio]; // this needs to happen before the next block that deletes traceCoord data\n        // also it's important to copy, otherwise data is lost by the time event data is read\n\n        this.emitPointAction(nextSelection, 'plotly_hover');\n        var trace = this.fullData[selection.trace.index] || {};\n        var ptNumber = selection.pointIndex;\n        var hoverinfo = Fx.castHoverinfo(trace, fullLayout, ptNumber);\n\n        if (hoverinfo && hoverinfo !== 'all') {\n          var parts = hoverinfo.split('+');\n          if (parts.indexOf('x') === -1) selection.traceCoord[0] = undefined;\n          if (parts.indexOf('y') === -1) selection.traceCoord[1] = undefined;\n          if (parts.indexOf('z') === -1) selection.traceCoord[2] = undefined;\n          if (parts.indexOf('text') === -1) selection.textLabel = undefined;\n          if (parts.indexOf('name') === -1) selection.name = undefined;\n        }\n\n        Fx.loneHover({\n          x: selection.screenCoord[0],\n          y: selection.screenCoord[1],\n          xLabel: this.hoverFormatter('xaxis', selection.traceCoord[0]),\n          yLabel: this.hoverFormatter('yaxis', selection.traceCoord[1]),\n          zLabel: selection.traceCoord[2],\n          text: selection.textLabel,\n          name: selection.name,\n          color: Fx.castHoverOption(trace, ptNumber, 'bgcolor') || selection.color,\n          borderColor: Fx.castHoverOption(trace, ptNumber, 'bordercolor'),\n          fontFamily: Fx.castHoverOption(trace, ptNumber, 'font.family'),\n          fontSize: Fx.castHoverOption(trace, ptNumber, 'font.size'),\n          fontColor: Fx.castHoverOption(trace, ptNumber, 'font.color'),\n          nameLength: Fx.castHoverOption(trace, ptNumber, 'namelength'),\n          textAlign: Fx.castHoverOption(trace, ptNumber, 'align')\n        }, {\n          container: this.svgContainer,\n          gd: this.graphDiv\n        });\n      }\n    }\n  } // Remove hover effects if we're not over a point OR\n  // if we're zooming or panning (in which case result is not set)\n\n\n  if (!result) {\n    this.unhover();\n  }\n\n  glplot.draw();\n};\n\nproto.unhover = function () {\n  if (this.lastPickResult) {\n    this.spikes.update({});\n    this.lastPickResult = null;\n    this.graphDiv.emit('plotly_unhover');\n    Fx.loneUnhover(this.svgContainer);\n  }\n};\n\nproto.hoverFormatter = function (axisName, val) {\n  if (val === undefined) return undefined;\n  var axis = this[axisName];\n  return Axes.tickText(axis, axis.c2l(val), 'hover').text;\n};","map":null,"metadata":{},"sourceType":"script"}