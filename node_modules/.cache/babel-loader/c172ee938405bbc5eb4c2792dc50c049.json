{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Events = require('../../lib/events');\n\nvar dragElement = require('../dragelement');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar handleClick = require('./handle_click');\n\nvar constants = require('./constants');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nvar getLegendData = require('./get_legend_data');\n\nvar style = require('./style');\n\nvar helpers = require('./helpers');\n\nvar MAIN_TITLE = 1;\n\nmodule.exports = function draw(gd, opts) {\n  if (!opts) opts = gd._fullLayout.legend || {};\n  return _draw(gd, opts);\n};\n\nfunction _draw(gd, legendObj) {\n  var fullLayout = gd._fullLayout;\n  var clipId = 'legend' + fullLayout._uid;\n  var layer;\n  var inHover = legendObj._inHover;\n\n  if (inHover) {\n    layer = legendObj.layer;\n    clipId += '-hover';\n  } else {\n    layer = fullLayout._infolayer;\n  }\n\n  if (!layer) return;\n  if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;\n  var legendData;\n\n  if (!inHover) {\n    if (!gd.calcdata) return;\n    legendData = fullLayout.showlegend && getLegendData(gd.calcdata, legendObj);\n  } else {\n    if (!legendObj.entries) return;\n    legendData = getLegendData(legendObj.entries, legendObj);\n  }\n\n  var hiddenSlices = fullLayout.hiddenlabels || [];\n\n  if (!inHover && (!fullLayout.showlegend || !legendData.length)) {\n    layer.selectAll('.legend').remove();\n\n    fullLayout._topdefs.select('#' + clipId).remove();\n\n    return Plots.autoMargin(gd, 'legend');\n  }\n\n  var legend = Lib.ensureSingle(layer, 'g', 'legend', function (s) {\n    if (!inHover) s.attr('pointer-events', 'all');\n  });\n  var clipPath = Lib.ensureSingleById(fullLayout._topdefs, 'clipPath', clipId, function (s) {\n    s.append('rect');\n  });\n  var bg = Lib.ensureSingle(legend, 'rect', 'bg', function (s) {\n    s.attr('shape-rendering', 'crispEdges');\n  });\n  bg.call(Color.stroke, legendObj.bordercolor).call(Color.fill, legendObj.bgcolor).style('stroke-width', legendObj.borderwidth + 'px');\n  var scrollBox = Lib.ensureSingle(legend, 'g', 'scrollbox');\n  var title = legendObj.title;\n  legendObj._titleWidth = 0;\n  legendObj._titleHeight = 0;\n\n  if (title.text) {\n    var titleEl = Lib.ensureSingle(scrollBox, 'text', 'legendtitletext');\n    titleEl.attr('text-anchor', 'start').call(Drawing.font, title.font).text(title.text);\n    textLayout(titleEl, scrollBox, gd, legendObj, MAIN_TITLE); // handle mathjax or multi-line text and compute title height\n  } else {\n    scrollBox.selectAll('.legendtitletext').remove();\n  }\n\n  var scrollBar = Lib.ensureSingle(legend, 'rect', 'scrollbar', function (s) {\n    s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);\n  });\n  var groups = scrollBox.selectAll('g.groups').data(legendData);\n  groups.enter().append('g').attr('class', 'groups');\n  groups.exit().remove();\n  var traces = groups.selectAll('g.traces').data(Lib.identity);\n  traces.enter().append('g').attr('class', 'traces');\n  traces.exit().remove();\n  traces.style('opacity', function (d) {\n    var trace = d[0].trace;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;\n    } else {\n      return trace.visible === 'legendonly' ? 0.5 : 1;\n    }\n  }).each(function () {\n    d3.select(this).call(drawTexts, gd, legendObj);\n  }).call(style, gd, legendObj).each(function () {\n    if (!inHover) d3.select(this).call(setupTraceToggle, gd);\n  });\n  Lib.syncOrAsync([Plots.previousPromises, function () {\n    return computeLegendDimensions(gd, groups, traces, legendObj);\n  }, function () {\n    var gs = fullLayout._size;\n    var bw = legendObj.borderwidth;\n\n    if (!inHover) {\n      var expMargin = expandMargin(gd); // IF expandMargin return a Promise (which is truthy),\n      // we're under a doAutoMargin redraw, so we don't have to\n      // draw the remaining pieces below\n\n      if (expMargin) return;\n\n      var lx = gs.l + gs.w * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;\n\n      var ly = gs.t + gs.h * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;\n\n      if (fullLayout.margin.autoexpand) {\n        var lx0 = lx;\n        var ly0 = ly;\n        lx = Lib.constrain(lx, 0, fullLayout.width - legendObj._width);\n        ly = Lib.constrain(ly, 0, fullLayout.height - legendObj._effHeight);\n\n        if (lx !== lx0) {\n          Lib.log('Constrain legend.x to make legend fit inside graph');\n        }\n\n        if (ly !== ly0) {\n          Lib.log('Constrain legend.y to make legend fit inside graph');\n        }\n      } // Set size and position of all the elements that make up a legend:\n      // legend, background and border, scroll box and scroll bar as well as title\n\n\n      Drawing.setTranslate(legend, lx, ly);\n    } // to be safe, remove previous listeners\n\n\n    scrollBar.on('.drag', null);\n    legend.on('wheel', null);\n\n    if (inHover || legendObj._height <= legendObj._maxHeight || gd._context.staticPlot) {\n      // if scrollbar should not be shown.\n      var height = legendObj._effHeight; // if unified hover, let it be its full size\n\n      if (inHover) height = legendObj._height;\n      bg.attr({\n        width: legendObj._width - bw,\n        height: height - bw,\n        x: bw / 2,\n        y: bw / 2\n      });\n      Drawing.setTranslate(scrollBox, 0, 0);\n      clipPath.select('rect').attr({\n        width: legendObj._width - 2 * bw,\n        height: height - 2 * bw,\n        x: bw,\n        y: bw\n      });\n      Drawing.setClipUrl(scrollBox, clipId, gd);\n      Drawing.setRect(scrollBar, 0, 0, 0, 0);\n      delete legendObj._scrollY;\n    } else {\n      var scrollBarHeight = Math.max(constants.scrollBarMinHeight, legendObj._effHeight * legendObj._effHeight / legendObj._height);\n      var scrollBarYMax = legendObj._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;\n      var scrollBoxYMax = legendObj._height - legendObj._effHeight;\n      var scrollRatio = scrollBarYMax / scrollBoxYMax;\n      var scrollBoxY = Math.min(legendObj._scrollY || 0, scrollBoxYMax); // increase the background and clip-path width\n      // by the scrollbar width and margin\n\n      bg.attr({\n        width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,\n        height: legendObj._effHeight - bw,\n        x: bw / 2,\n        y: bw / 2\n      });\n      clipPath.select('rect').attr({\n        width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,\n        height: legendObj._effHeight - 2 * bw,\n        x: bw,\n        y: bw + scrollBoxY\n      });\n      Drawing.setClipUrl(scrollBox, clipId, gd);\n      scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio); // scroll legend by mousewheel or touchpad swipe up/down\n\n      legend.on('wheel', function () {\n        scrollBoxY = Lib.constrain(legendObj._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax, 0, scrollBoxYMax);\n        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n\n        if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {\n          d3.event.preventDefault();\n        }\n      });\n      var eventY0, eventY1, scrollBoxY0;\n\n      var getScrollBarDragY = function getScrollBarDragY(scrollBoxY0, eventY0, eventY1) {\n        var y = (eventY1 - eventY0) / scrollRatio + scrollBoxY0;\n        return Lib.constrain(y, 0, scrollBoxYMax);\n      };\n\n      var getNaturalDragY = function getNaturalDragY(scrollBoxY0, eventY0, eventY1) {\n        var y = (eventY0 - eventY1) / scrollRatio + scrollBoxY0;\n        return Lib.constrain(y, 0, scrollBoxYMax);\n      }; // scroll legend by dragging scrollBAR\n\n\n      var scrollBarDrag = d3.behavior.drag().on('dragstart', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchstart') {\n          eventY0 = e.changedTouches[0].clientY;\n        } else {\n          eventY0 = e.clientY;\n        }\n\n        scrollBoxY0 = scrollBoxY;\n      }).on('drag', function () {\n        var e = d3.event.sourceEvent;\n        if (e.buttons === 2 || e.ctrlKey) return;\n\n        if (e.type === 'touchmove') {\n          eventY1 = e.changedTouches[0].clientY;\n        } else {\n          eventY1 = e.clientY;\n        }\n\n        scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);\n        scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n      });\n      scrollBar.call(scrollBarDrag); // scroll legend by touch-dragging scrollBOX\n\n      var scrollBoxTouchDrag = d3.behavior.drag().on('dragstart', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchstart') {\n          eventY0 = e.changedTouches[0].clientY;\n          scrollBoxY0 = scrollBoxY;\n        }\n      }).on('drag', function () {\n        var e = d3.event.sourceEvent;\n\n        if (e.type === 'touchmove') {\n          eventY1 = e.changedTouches[0].clientY;\n          scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);\n          scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);\n        }\n      });\n      scrollBox.call(scrollBoxTouchDrag);\n    }\n\n    function scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio) {\n      legendObj._scrollY = gd._fullLayout.legend._scrollY = scrollBoxY;\n      Drawing.setTranslate(scrollBox, 0, -scrollBoxY);\n      Drawing.setRect(scrollBar, legendObj._width, constants.scrollBarMargin + scrollBoxY * scrollRatio, constants.scrollBarWidth, scrollBarHeight);\n      clipPath.select('rect').attr('y', bw + scrollBoxY);\n    }\n\n    if (gd._context.edits.legendPosition) {\n      var xf, yf, x0, y0;\n      legend.classed('cursor-move', true);\n      dragElement.init({\n        element: legend.node(),\n        gd: gd,\n        prepFn: function prepFn() {\n          var transform = Drawing.getTranslate(legend);\n          x0 = transform.x;\n          y0 = transform.y;\n        },\n        moveFn: function moveFn(dx, dy) {\n          var newX = x0 + dx;\n          var newY = y0 + dy;\n          Drawing.setTranslate(legend, newX, newY);\n          xf = dragElement.align(newX, 0, gs.l, gs.l + gs.w, legendObj.xanchor);\n          yf = dragElement.align(newY, 0, gs.t + gs.h, gs.t, legendObj.yanchor);\n        },\n        doneFn: function doneFn() {\n          if (xf !== undefined && yf !== undefined) {\n            Registry.call('_guiRelayout', gd, {\n              'legend.x': xf,\n              'legend.y': yf\n            });\n          }\n        },\n        clickFn: function clickFn(numClicks, e) {\n          var clickedTrace = layer.selectAll('g.traces').filter(function () {\n            var bbox = this.getBoundingClientRect();\n            return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;\n          });\n\n          if (clickedTrace.size() > 0) {\n            clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);\n          }\n        }\n      });\n    }\n  }], gd);\n}\n\nfunction getTraceWidth(d, legendObj, textGap) {\n  var legendItem = d[0];\n  var legendWidth = legendItem.width;\n  var mode = legendObj.entrywidthmode;\n  var traceLegendWidth = legendItem.trace.legendwidth || legendObj.entrywidth;\n  if (mode === 'fraction') return legendObj._maxWidth * traceLegendWidth;\n  return textGap + (traceLegendWidth || legendWidth);\n}\n\nfunction clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {\n  var trace = legendItem.data()[0][0].trace;\n  var evtData = {\n    event: evt,\n    node: legendItem.node(),\n    curveNumber: trace.index,\n    expandedIndex: trace._expandedIndex,\n    data: gd.data,\n    layout: gd.layout,\n    frames: gd._transitionData._frames,\n    config: gd._context,\n    fullData: gd._fullData,\n    fullLayout: gd._fullLayout\n  };\n\n  if (trace._group) {\n    evtData.group = trace._group;\n  }\n\n  if (Registry.traceIs(trace, 'pie-like')) {\n    evtData.label = legendItem.datum()[0].label;\n  }\n\n  var clickVal = Events.triggerHandler(gd, 'plotly_legendclick', evtData);\n  if (clickVal === false) return;\n\n  if (numClicks === 1) {\n    legend._clickTimeout = setTimeout(function () {\n      if (!gd._fullLayout) return;\n      handleClick(legendItem, gd, numClicks);\n    }, gd._context.doubleClickDelay);\n  } else if (numClicks === 2) {\n    if (legend._clickTimeout) clearTimeout(legend._clickTimeout);\n    gd._legendMouseDownTime = 0;\n    var dblClickVal = Events.triggerHandler(gd, 'plotly_legenddoubleclick', evtData);\n    if (dblClickVal !== false) handleClick(legendItem, gd, numClicks);\n  }\n}\n\nfunction drawTexts(g, gd, legendObj) {\n  var legendItem = g.data()[0][0];\n  var trace = legendItem.trace;\n  var isPieLike = Registry.traceIs(trace, 'pie-like');\n  var isEditable = !legendObj._inHover && gd._context.edits.legendText && !isPieLike;\n  var maxNameLength = legendObj._maxNameLength;\n  var name, font;\n\n  if (legendItem.groupTitle) {\n    name = legendItem.groupTitle.text;\n    font = legendItem.groupTitle.font;\n  } else {\n    font = legendObj.font;\n\n    if (!legendObj.entries) {\n      name = isPieLike ? legendItem.label : trace.name;\n\n      if (trace._meta) {\n        name = Lib.templateString(name, trace._meta);\n      }\n    } else {\n      name = legendItem.text;\n    }\n  }\n\n  var textEl = Lib.ensureSingle(g, 'text', 'legendtext');\n  textEl.attr('text-anchor', 'start').call(Drawing.font, font).text(isEditable ? ensureLength(name, maxNameLength) : name);\n  var textGap = legendObj.itemwidth + constants.itemGap * 2;\n  svgTextUtils.positionText(textEl, textGap, 0);\n\n  if (isEditable) {\n    textEl.call(svgTextUtils.makeEditable, {\n      gd: gd,\n      text: name\n    }).call(textLayout, g, gd, legendObj).on('edit', function (newName) {\n      this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, legendObj);\n      var fullInput = legendItem.trace._fullInput || {};\n      var update = {};\n\n      if (Registry.hasTransform(fullInput, 'groupby')) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var index = groupbyIndices[groupbyIndices.length - 1];\n        var kcont = Lib.keyedContainer(fullInput, 'transforms[' + index + '].styles', 'target', 'value.name');\n        kcont.set(legendItem.trace._group, newName);\n        update = kcont.constructUpdate();\n      } else {\n        update.name = newName;\n      }\n\n      return Registry.call('_guiRestyle', gd, update, trace.index);\n    });\n  } else {\n    textLayout(textEl, g, gd, legendObj);\n  }\n}\n/*\n * Make sure we have a reasonably clickable region.\n * If this string is missing or very short, pad it with spaces out to at least\n * 4 characters, up to the max length of other labels, on the assumption that\n * most characters are wider than spaces so a string of spaces will usually be\n * no wider than the real labels.\n */\n\n\nfunction ensureLength(str, maxLength) {\n  var targetLength = Math.max(4, maxLength);\n  if (str && str.trim().length >= targetLength / 2) return str;\n  str = str || '';\n\n  for (var i = targetLength - str.length; i > 0; i--) {\n    str += ' ';\n  }\n\n  return str;\n}\n\nfunction setupTraceToggle(g, gd) {\n  var doubleClickDelay = gd._context.doubleClickDelay;\n  var newMouseDownTime;\n  var numClicks = 1;\n  var traceToggle = Lib.ensureSingle(g, 'rect', 'legendtoggle', function (s) {\n    if (!gd._context.staticPlot) {\n      s.style('cursor', 'pointer').attr('pointer-events', 'all');\n    }\n\n    s.call(Color.fill, 'rgba(0,0,0,0)');\n  });\n  if (gd._context.staticPlot) return;\n  traceToggle.on('mousedown', function () {\n    newMouseDownTime = new Date().getTime();\n\n    if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {\n      // in a click train\n      numClicks += 1;\n    } else {\n      // new click train\n      numClicks = 1;\n      gd._legendMouseDownTime = newMouseDownTime;\n    }\n  });\n  traceToggle.on('mouseup', function () {\n    if (gd._dragged || gd._editing) return;\n    var legend = gd._fullLayout.legend;\n\n    if (new Date().getTime() - gd._legendMouseDownTime > doubleClickDelay) {\n      numClicks = Math.max(numClicks - 1, 1);\n    }\n\n    clickOrDoubleClick(gd, legend, g, numClicks, d3.event);\n  });\n}\n\nfunction textLayout(s, g, gd, legendObj, aTitle) {\n  if (legendObj._inHover) s.attr('data-notex', true); // do not process MathJax for unified hover\n\n  svgTextUtils.convertToTspans(s, gd, function () {\n    computeTextDimensions(g, gd, legendObj, aTitle);\n  });\n}\n\nfunction computeTextDimensions(g, gd, legendObj, aTitle) {\n  var legendItem = g.data()[0][0];\n\n  if (!legendObj._inHover && legendItem && !legendItem.trace.showlegend) {\n    g.remove();\n    return;\n  }\n\n  var mathjaxGroup = g.select('g[class*=math-group]');\n  var mathjaxNode = mathjaxGroup.node();\n  if (!legendObj) legendObj = gd._fullLayout.legend;\n  var bw = legendObj.borderwidth;\n  var font;\n\n  if (aTitle === MAIN_TITLE) {\n    font = legendObj.title.font;\n  } else if (legendItem.groupTitle) {\n    font = legendItem.groupTitle.font;\n  } else {\n    font = legendObj.font;\n  }\n\n  var lineHeight = font.size * LINE_SPACING;\n  var height, width;\n\n  if (mathjaxNode) {\n    var mathjaxBB = Drawing.bBox(mathjaxNode);\n    height = mathjaxBB.height;\n    width = mathjaxBB.width;\n\n    if (aTitle === MAIN_TITLE) {\n      Drawing.setTranslate(mathjaxGroup, bw, bw + height * 0.75);\n    } else {\n      // legend item\n      Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);\n    }\n  } else {\n    var textEl = g.select(aTitle === MAIN_TITLE ? '.legendtitletext' : '.legendtext');\n    var textLines = svgTextUtils.lineCount(textEl);\n    var textNode = textEl.node();\n    height = lineHeight * textLines;\n    width = textNode ? Drawing.bBox(textNode).width : 0; // approximation to height offset to center the font\n    // to avoid getBoundingClientRect\n\n    if (aTitle === MAIN_TITLE) {\n      if (legendObj.title.side === 'left') {\n        // add extra space between legend title and itmes\n        width += constants.itemGap * 2;\n      }\n\n      svgTextUtils.positionText(textEl, bw + constants.titlePad, bw + lineHeight);\n    } else {\n      // legend item\n      var x = constants.itemGap * 2 + legendObj.itemwidth;\n\n      if (legendItem.groupTitle) {\n        x = constants.itemGap;\n        width -= legendObj.itemwidth;\n      }\n\n      svgTextUtils.positionText(textEl, x, -lineHeight * ((textLines - 1) / 2 - 0.3));\n    }\n  }\n\n  if (aTitle === MAIN_TITLE) {\n    legendObj._titleWidth = width;\n    legendObj._titleHeight = height;\n  } else {\n    // legend item\n    legendItem.lineHeight = lineHeight;\n    legendItem.height = Math.max(height, 16) + 3;\n    legendItem.width = width;\n  }\n}\n\nfunction getTitleSize(legendObj) {\n  var w = 0;\n  var h = 0;\n  var side = legendObj.title.side;\n\n  if (side) {\n    if (side.indexOf('left') !== -1) {\n      w = legendObj._titleWidth;\n    }\n\n    if (side.indexOf('top') !== -1) {\n      h = legendObj._titleHeight;\n    }\n  }\n\n  return [w, h];\n}\n/*\n * Computes in fullLayout.legend:\n *\n *  - _height: legend height including items past scrollbox height\n *  - _maxHeight: maximum legend height before scrollbox is required\n *  - _effHeight: legend height w/ or w/o scrollbox\n *\n *  - _width: legend width\n *  - _maxWidth (for orientation:h only): maximum width before starting new row\n */\n\n\nfunction computeLegendDimensions(gd, groups, traces, legendObj) {\n  var fullLayout = gd._fullLayout;\n  if (!legendObj) legendObj = fullLayout.legend;\n  var gs = fullLayout._size;\n  var isVertical = helpers.isVertical(legendObj);\n  var isGrouped = helpers.isGrouped(legendObj);\n  var isFraction = legendObj.entrywidthmode === 'fraction';\n  var bw = legendObj.borderwidth;\n  var bw2 = 2 * bw;\n  var itemGap = constants.itemGap;\n  var textGap = legendObj.itemwidth + itemGap * 2;\n  var endPad = 2 * (bw + itemGap);\n  var yanchor = getYanchor(legendObj);\n  var isBelowPlotArea = legendObj.y < 0 || legendObj.y === 0 && yanchor === 'top';\n  var isAbovePlotArea = legendObj.y > 1 || legendObj.y === 1 && yanchor === 'bottom';\n  var traceGroupGap = legendObj.tracegroupgap;\n  var legendGroupWidths = {}; // - if below/above plot area, give it the maximum potential margin-push value\n  // - otherwise, extend the height of the plot area\n\n  legendObj._maxHeight = Math.max(isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h, 30);\n  var toggleRectWidth = 0;\n  legendObj._width = 0;\n  legendObj._height = 0;\n  var titleSize = getTitleSize(legendObj);\n\n  if (isVertical) {\n    traces.each(function (d) {\n      var h = d[0].height;\n      Drawing.setTranslate(this, bw + titleSize[0], bw + titleSize[1] + legendObj._height + h / 2 + itemGap);\n      legendObj._height += h;\n      legendObj._width = Math.max(legendObj._width, d[0].width);\n    });\n    toggleRectWidth = textGap + legendObj._width;\n    legendObj._width += itemGap + textGap + bw2;\n    legendObj._height += endPad;\n\n    if (isGrouped) {\n      groups.each(function (d, i) {\n        Drawing.setTranslate(this, 0, i * legendObj.tracegroupgap);\n      });\n      legendObj._height += (legendObj._lgroupsLength - 1) * legendObj.tracegroupgap;\n    }\n  } else {\n    var xanchor = getXanchor(legendObj);\n    var isLeftOfPlotArea = legendObj.x < 0 || legendObj.x === 0 && xanchor === 'right';\n    var isRightOfPlotArea = legendObj.x > 1 || legendObj.x === 1 && xanchor === 'left';\n    var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;\n    var hw = fullLayout.width / 2; // - if placed within x-margins, extend the width of the plot area\n    // - else if below/above plot area and anchored in the margin, extend to opposite margin,\n    // - otherwise give it the maximum potential margin-push value\n\n    legendObj._maxWidth = Math.max(isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === 'left' ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === 'right' ? gs.r + gs.w : hw : gs.w, 2 * textGap);\n    var maxItemWidth = 0;\n    var combinedItemWidth = 0;\n    traces.each(function (d) {\n      var w = getTraceWidth(d, legendObj, textGap);\n      maxItemWidth = Math.max(maxItemWidth, w);\n      combinedItemWidth += w;\n    });\n    toggleRectWidth = null;\n    var maxRowWidth = 0;\n\n    if (isGrouped) {\n      var maxGroupHeightInRow = 0;\n      var groupOffsetX = 0;\n      var groupOffsetY = 0;\n      groups.each(function () {\n        var maxWidthInGroup = 0;\n        var offsetY = 0;\n        d3.select(this).selectAll('g.traces').each(function (d) {\n          var w = getTraceWidth(d, legendObj, textGap);\n          var h = d[0].height;\n          Drawing.setTranslate(this, titleSize[0], titleSize[1] + bw + itemGap + h / 2 + offsetY);\n          offsetY += h;\n          maxWidthInGroup = Math.max(maxWidthInGroup, w);\n          legendGroupWidths[d[0].trace.legendgroup] = maxWidthInGroup;\n        });\n        var next = maxWidthInGroup + itemGap; // horizontal_wrapping\n\n        if ( // not on the first column already\n        groupOffsetX > 0 && // goes beyound limit\n        next + bw + groupOffsetX > legendObj._maxWidth) {\n          maxRowWidth = Math.max(maxRowWidth, groupOffsetX);\n          groupOffsetX = 0;\n          groupOffsetY += maxGroupHeightInRow + traceGroupGap;\n          maxGroupHeightInRow = offsetY;\n        } else {\n          maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY);\n        }\n\n        Drawing.setTranslate(this, groupOffsetX, groupOffsetY);\n        groupOffsetX += next;\n      });\n      legendObj._width = Math.max(maxRowWidth, groupOffsetX) + bw;\n      legendObj._height = groupOffsetY + maxGroupHeightInRow + endPad;\n    } else {\n      var nTraces = traces.size();\n      var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < legendObj._maxWidth;\n      var maxItemHeightInRow = 0;\n      var offsetX = 0;\n      var offsetY = 0;\n      var rowWidth = 0;\n      traces.each(function (d) {\n        var h = d[0].height;\n        var w = getTraceWidth(d, legendObj, textGap, isGrouped);\n        var next = oneRowLegend ? w : maxItemWidth;\n\n        if (!isFraction) {\n          next += itemGap;\n        }\n\n        if (next + bw + offsetX - itemGap >= legendObj._maxWidth) {\n          maxRowWidth = Math.max(maxRowWidth, rowWidth);\n          offsetX = 0;\n          offsetY += maxItemHeightInRow;\n          legendObj._height += maxItemHeightInRow;\n          maxItemHeightInRow = 0;\n        }\n\n        Drawing.setTranslate(this, titleSize[0] + bw + offsetX, titleSize[1] + bw + offsetY + h / 2 + itemGap);\n        rowWidth = offsetX + w + itemGap;\n        offsetX += next;\n        maxItemHeightInRow = Math.max(maxItemHeightInRow, h);\n      });\n\n      if (oneRowLegend) {\n        legendObj._width = offsetX + bw2;\n        legendObj._height = maxItemHeightInRow + endPad;\n      } else {\n        legendObj._width = Math.max(maxRowWidth, rowWidth) + bw2;\n        legendObj._height += maxItemHeightInRow + endPad;\n      }\n    }\n  }\n\n  legendObj._width = Math.ceil(Math.max(legendObj._width + titleSize[0], legendObj._titleWidth + 2 * (bw + constants.titlePad)));\n  legendObj._height = Math.ceil(Math.max(legendObj._height + titleSize[1], legendObj._titleHeight + 2 * (bw + constants.itemGap)));\n  legendObj._effHeight = Math.min(legendObj._height, legendObj._maxHeight);\n  var edits = gd._context.edits;\n  var isEditable = edits.legendText || edits.legendPosition;\n  traces.each(function (d) {\n    var traceToggle = d3.select(this).select('.legendtoggle');\n    var h = d[0].height;\n    var legendgroup = d[0].trace.legendgroup;\n    var traceWidth = getTraceWidth(d, legendObj, textGap);\n\n    if (isGrouped && legendgroup !== '') {\n      traceWidth = legendGroupWidths[legendgroup];\n    }\n\n    var w = isEditable ? textGap : toggleRectWidth || traceWidth;\n\n    if (!isVertical && !isFraction) {\n      w += itemGap / 2;\n    }\n\n    Drawing.setRect(traceToggle, 0, -h / 2, w, h);\n  });\n}\n\nfunction expandMargin(gd) {\n  var fullLayout = gd._fullLayout;\n  var legendObj = fullLayout.legend;\n  var xanchor = getXanchor(legendObj);\n  var yanchor = getYanchor(legendObj);\n  return Plots.autoMargin(gd, 'legend', {\n    x: legendObj.x,\n    y: legendObj.y,\n    l: legendObj._width * FROM_TL[xanchor],\n    r: legendObj._width * FROM_BR[xanchor],\n    b: legendObj._effHeight * FROM_BR[yanchor],\n    t: legendObj._effHeight * FROM_TL[yanchor]\n  });\n}\n\nfunction getXanchor(legendObj) {\n  return Lib.isRightAnchor(legendObj) ? 'right' : Lib.isCenterAnchor(legendObj) ? 'center' : 'left';\n}\n\nfunction getYanchor(legendObj) {\n  return Lib.isBottomAnchor(legendObj) ? 'bottom' : Lib.isMiddleAnchor(legendObj) ? 'middle' : 'top';\n}","map":null,"metadata":{},"sourceType":"script"}