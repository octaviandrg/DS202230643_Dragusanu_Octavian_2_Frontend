{"ast":null,"code":"'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar isArray1D = require('../../lib').isArray1D;\n\nvar cheaterBasis = require('./cheater_basis');\n\nvar arrayMinmax = require('./array_minmax');\n\nvar calcGridlines = require('./calc_gridlines');\n\nvar calcLabels = require('./calc_labels');\n\nvar calcClipPath = require('./calc_clippath');\n\nvar clean2dArray = require('../heatmap/clean_2d_array');\n\nvar smoothFill2dArray = require('./smooth_fill_2d_array');\n\nvar convertColumnData = require('../heatmap/convert_column_xyz');\n\nvar setConvert = require('./set_convert');\n\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var aax = trace.aaxis;\n  var bax = trace.baxis;\n  var x = trace.x;\n  var y = trace.y;\n  var cols = [];\n  if (x && isArray1D(x)) cols.push('x');\n  if (y && isArray1D(y)) cols.push('y');\n\n  if (cols.length) {\n    convertColumnData(trace, aax, bax, 'a', 'b', cols);\n  }\n\n  var a = trace._a = trace._a || trace.a;\n  var b = trace._b = trace._b || trace.b;\n  x = trace._x || trace.x;\n  y = trace._y || trace.y;\n  var t = {};\n\n  if (trace._cheater) {\n    var avals = aax.cheatertype === 'index' ? a.length : a;\n    var bvals = bax.cheatertype === 'index' ? b.length : b;\n    x = cheaterBasis(avals, bvals, trace.cheaterslope);\n  }\n\n  trace._x = x = clean2dArray(x);\n  trace._y = y = clean2dArray(y); // Fill in any undefined values with elliptic smoothing. This doesn't take\n  // into account the spacing of the values. That is, the derivatives should\n  // be modified to use a and b values. It's not that hard, but this is already\n  // moderate overkill for just filling in missing values.\n\n  smoothFill2dArray(x, a, b);\n  smoothFill2dArray(y, a, b);\n  setConvert(trace); // create conversion functions that depend on the data\n\n  trace.setScale(); // This is a rather expensive scan. Nothing guarantees monotonicity,\n  // so we need to scan through all data to get proper ranges:\n\n  var xrange = arrayMinmax(x);\n  var yrange = arrayMinmax(y);\n  var dx = 0.5 * (xrange[1] - xrange[0]);\n  var xc = 0.5 * (xrange[1] + xrange[0]);\n  var dy = 0.5 * (yrange[1] - yrange[0]);\n  var yc = 0.5 * (yrange[1] + yrange[0]); // Expand the axes to fit the plot, except just grow it by a factor of 1.3\n  // because the labels should be taken into account except that's difficult\n  // hence 1.3.\n\n  var grow = 1.3;\n  xrange = [xc - dx * grow, xc + dx * grow];\n  yrange = [yc - dy * grow, yc + dy * grow];\n  trace._extremes[xa._id] = Axes.findExtremes(xa, xrange, {\n    padded: true\n  });\n  trace._extremes[ya._id] = Axes.findExtremes(ya, yrange, {\n    padded: true\n  }); // Enumerate the gridlines, both major and minor, and store them on the trace\n  // object:\n\n  calcGridlines(trace, 'a', 'b');\n  calcGridlines(trace, 'b', 'a'); // Calculate the text labels for each major gridline and store them on the\n  // trace object:\n\n  calcLabels(trace, aax);\n  calcLabels(trace, bax); // Tabulate points for the four segments that bound the axes so that we can\n  // map to pixel coordinates in the plot function and create a clip rect:\n\n  t.clipsegments = calcClipPath(trace._xctrl, trace._yctrl, aax, bax);\n  t.x = x;\n  t.y = y;\n  t.a = a;\n  t.b = b;\n  return [t];\n};","map":null,"metadata":{},"sourceType":"script"}