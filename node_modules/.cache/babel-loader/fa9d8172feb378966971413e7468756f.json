{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nvar constants = require('./constants');\n\nvar unsupportedBrowsers = Lib.isIOS() || Lib.isSafari() || Lib.isIE();\n\nmodule.exports = function plot(gd, plotinfo, cdimage, imageLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var supportsPixelatedImage = !(unsupportedBrowsers || gd._context._exportedPlot);\n  Lib.makeTraceGroups(imageLayer, cdimage, 'im').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var realImage = (trace.zsmooth === 'fast' || trace.zsmooth === false && supportsPixelatedImage) && !trace._hasZ && trace._hasSource && xa.type === 'linear' && ya.type === 'linear';\n    trace._realImage = realImage;\n    var z = cd0.z;\n    var x0 = cd0.x0;\n    var y0 = cd0.y0;\n    var w = cd0.w;\n    var h = cd0.h;\n    var dx = trace.dx;\n    var dy = trace.dy;\n    var left, right, temp, top, bottom, i; // in case of log of a negative\n\n    i = 0;\n\n    while (left === undefined && i < w) {\n      left = xa.c2p(x0 + i * dx);\n      i++;\n    }\n\n    i = w;\n\n    while (right === undefined && i > 0) {\n      right = xa.c2p(x0 + i * dx);\n      i--;\n    }\n\n    i = 0;\n\n    while (top === undefined && i < h) {\n      top = ya.c2p(y0 + i * dy);\n      i++;\n    }\n\n    i = h;\n\n    while (bottom === undefined && i > 0) {\n      bottom = ya.c2p(y0 + i * dy);\n      i--;\n    }\n\n    if (right < left) {\n      temp = right;\n      right = left;\n      left = temp;\n    }\n\n    if (bottom < top) {\n      temp = top;\n      top = bottom;\n      bottom = temp;\n    } // Reduce image size when zoomed in to save memory\n\n\n    if (!realImage) {\n      var extra = 0.5; // half the axis size\n\n      left = Math.max(-extra * xa._length, left);\n      right = Math.min((1 + extra) * xa._length, right);\n      top = Math.max(-extra * ya._length, top);\n      bottom = Math.min((1 + extra) * ya._length, bottom);\n    }\n\n    var imageWidth = Math.round(right - left);\n    var imageHeight = Math.round(bottom - top); // if image is entirely off-screen, don't even draw it\n\n    var isOffScreen = imageWidth <= 0 || imageHeight <= 0;\n\n    if (isOffScreen) {\n      var noImage = plotGroup.selectAll('image').data([]);\n      noImage.exit().remove();\n      return;\n    } // Create a new canvas and draw magnified pixels on it\n\n\n    function drawMagnifiedPixelsOnCanvas(readPixel) {\n      var canvas = document.createElement('canvas');\n      canvas.width = imageWidth;\n      canvas.height = imageHeight;\n      var context = canvas.getContext('2d', {\n        willReadFrequently: true\n      });\n\n      var ipx = function ipx(i) {\n        return Lib.constrain(Math.round(xa.c2p(x0 + i * dx) - left), 0, imageWidth);\n      };\n\n      var jpx = function jpx(j) {\n        return Lib.constrain(Math.round(ya.c2p(y0 + j * dy) - top), 0, imageHeight);\n      };\n\n      var cr = constants.colormodel[trace.colormodel];\n      var colormodel = cr.colormodel || trace.colormodel;\n      var fmt = cr.fmt;\n      var c;\n\n      for (i = 0; i < cd0.w; i++) {\n        var ipx0 = ipx(i);\n        var ipx1 = ipx(i + 1);\n        if (ipx1 === ipx0 || isNaN(ipx1) || isNaN(ipx0)) continue;\n\n        for (var j = 0; j < cd0.h; j++) {\n          var jpx0 = jpx(j);\n          var jpx1 = jpx(j + 1);\n          if (jpx1 === jpx0 || isNaN(jpx1) || isNaN(jpx0) || !readPixel(i, j)) continue;\n          c = trace._scaler(readPixel(i, j));\n\n          if (c) {\n            context.fillStyle = colormodel + '(' + fmt(c).join(',') + ')';\n          } else {\n            // Return a transparent pixel\n            context.fillStyle = 'rgba(0,0,0,0)';\n          }\n\n          context.fillRect(ipx0, jpx0, ipx1 - ipx0, jpx1 - jpx0);\n        }\n      }\n\n      return canvas;\n    }\n\n    var image3 = plotGroup.selectAll('image').data([cd]);\n    image3.enter().append('svg:image').attr({\n      xmlns: xmlnsNamespaces.svg,\n      preserveAspectRatio: 'none'\n    });\n    image3.exit().remove();\n    var style = trace.zsmooth === false ? constants.pixelatedStyle : '';\n\n    if (realImage) {\n      var xRange = Lib.simpleMap(xa.range, xa.r2l);\n      var yRange = Lib.simpleMap(ya.range, ya.r2l);\n      var flipX = xRange[1] < xRange[0];\n      var flipY = yRange[1] > yRange[0];\n\n      if (flipX || flipY) {\n        var tx = left + imageWidth / 2;\n        var ty = top + imageHeight / 2;\n        style += 'transform:' + strTranslate(tx + 'px', ty + 'px') + 'scale(' + (flipX ? -1 : 1) + ',' + (flipY ? -1 : 1) + ')' + strTranslate(-tx + 'px', -ty + 'px') + ';';\n      }\n    }\n\n    image3.attr('style', style);\n    var p = new Promise(function (resolve) {\n      if (trace._hasZ) {\n        resolve();\n      } else if (trace._hasSource) {\n        // Check if canvas already exists and has the right data\n        if (trace._canvas && trace._canvas.el.width === w && trace._canvas.el.height === h && trace._canvas.source === trace.source) {\n          resolve();\n        } else {\n          // Create a canvas and transfer image onto it to access pixel information\n          var canvas = document.createElement('canvas');\n          canvas.width = w;\n          canvas.height = h;\n          var context = canvas.getContext('2d', {\n            willReadFrequently: true\n          });\n          trace._image = trace._image || new Image();\n          var image = trace._image;\n\n          image.onload = function () {\n            context.drawImage(image, 0, 0);\n            trace._canvas = {\n              el: canvas,\n              source: trace.source\n            };\n            resolve();\n          };\n\n          image.setAttribute('src', trace.source);\n        }\n      }\n    }).then(function () {\n      var href, canvas;\n\n      if (trace._hasZ) {\n        canvas = drawMagnifiedPixelsOnCanvas(function (i, j) {\n          return z[j][i];\n        });\n        href = canvas.toDataURL('image/png');\n      } else if (trace._hasSource) {\n        if (realImage) {\n          href = trace.source;\n        } else {\n          var context = trace._canvas.el.getContext('2d', {\n            willReadFrequently: true\n          });\n\n          var data = context.getImageData(0, 0, w, h).data;\n          canvas = drawMagnifiedPixelsOnCanvas(function (i, j) {\n            var index = 4 * (j * w + i);\n            return [data[index], data[index + 1], data[index + 2], data[index + 3]];\n          });\n          href = canvas.toDataURL('image/png');\n        }\n      }\n\n      image3.attr({\n        'xlink:href': href,\n        height: imageHeight,\n        width: imageWidth,\n        x: left,\n        y: top\n      });\n    });\n\n    gd._promises.push(p);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}