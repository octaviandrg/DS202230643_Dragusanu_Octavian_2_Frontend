{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar Registry = require('../../registry');\n\nvar appendArrayPointValue = require('../../components/fx/helpers').appendArrayPointValue;\n\nvar Fx = require('../../components/fx');\n\nvar Lib = require('../../lib');\n\nvar Events = require('../../lib/events');\n\nvar helpers = require('./helpers');\n\nvar pieHelpers = require('../pie/helpers');\n\nvar formatValue = pieHelpers.formatPieValue;\n\nmodule.exports = function attachFxHandlers(sliceTop, entry, gd, cd, opts) {\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var hierarchy = cd0.hierarchy;\n  var isSunburst = trace.type === 'sunburst';\n  var isTreemapOrIcicle = trace.type === 'treemap' || trace.type === 'icicle'; // hover state vars\n  // have we drawn a hover label, so it should be cleared later\n\n  if (!('_hasHoverLabel' in trace)) trace._hasHoverLabel = false; // have we emitted a hover event, so later an unhover event should be emitted\n  // note that click events do not depend on this - you can still get them\n  // with hovermode: false or if you were earlier dragging, then clicked\n  // in the same slice that you moused up in\n\n  if (!('_hasHoverEvent' in trace)) trace._hasHoverEvent = false;\n\n  var onMouseOver = function onMouseOver(pt) {\n    var fullLayoutNow = gd._fullLayout;\n    if (gd._dragging || fullLayoutNow.hovermode === false) return;\n    var traceNow = gd._fullData[trace.index];\n    var cdi = pt.data.data;\n    var ptNumber = cdi.i;\n    var isRoot = helpers.isHierarchyRoot(pt);\n    var parent = helpers.getParent(hierarchy, pt);\n    var val = helpers.getValue(pt);\n\n    var _cast = function _cast(astr) {\n      return Lib.castOption(traceNow, ptNumber, astr);\n    };\n\n    var hovertemplate = _cast('hovertemplate');\n\n    var hoverinfo = Fx.castHoverinfo(traceNow, fullLayoutNow, ptNumber);\n    var separators = fullLayoutNow.separators;\n    var eventData;\n\n    if (hovertemplate || hoverinfo && hoverinfo !== 'none' && hoverinfo !== 'skip') {\n      var hoverCenterX;\n      var hoverCenterY;\n\n      if (isSunburst) {\n        hoverCenterX = cd0.cx + pt.pxmid[0] * (1 - pt.rInscribed);\n        hoverCenterY = cd0.cy + pt.pxmid[1] * (1 - pt.rInscribed);\n      }\n\n      if (isTreemapOrIcicle) {\n        hoverCenterX = pt._hoverX;\n        hoverCenterY = pt._hoverY;\n      }\n\n      var hoverPt = {};\n      var parts = [];\n      var thisText = [];\n\n      var hasFlag = function hasFlag(flag) {\n        return parts.indexOf(flag) !== -1;\n      };\n\n      if (hoverinfo) {\n        parts = hoverinfo === 'all' ? traceNow._module.attributes.hoverinfo.flags : hoverinfo.split('+');\n      }\n\n      hoverPt.label = cdi.label;\n      if (hasFlag('label') && hoverPt.label) thisText.push(hoverPt.label);\n\n      if (cdi.hasOwnProperty('v')) {\n        hoverPt.value = cdi.v;\n        hoverPt.valueLabel = formatValue(hoverPt.value, separators);\n        if (hasFlag('value')) thisText.push(hoverPt.valueLabel);\n      }\n\n      hoverPt.currentPath = pt.currentPath = helpers.getPath(pt.data);\n\n      if (hasFlag('current path') && !isRoot) {\n        thisText.push(hoverPt.currentPath);\n      }\n\n      var tx;\n      var allPercents = [];\n\n      var insertPercent = function insertPercent() {\n        if (allPercents.indexOf(tx) === -1) {\n          // no need to add redundant info\n          thisText.push(tx);\n          allPercents.push(tx);\n        }\n      };\n\n      hoverPt.percentParent = pt.percentParent = val / helpers.getValue(parent);\n      hoverPt.parent = pt.parentString = helpers.getPtLabel(parent);\n\n      if (hasFlag('percent parent')) {\n        tx = helpers.formatPercent(hoverPt.percentParent, separators) + ' of ' + hoverPt.parent;\n        insertPercent();\n      }\n\n      hoverPt.percentEntry = pt.percentEntry = val / helpers.getValue(entry);\n      hoverPt.entry = pt.entry = helpers.getPtLabel(entry);\n\n      if (hasFlag('percent entry') && !isRoot && !pt.onPathbar) {\n        tx = helpers.formatPercent(hoverPt.percentEntry, separators) + ' of ' + hoverPt.entry;\n        insertPercent();\n      }\n\n      hoverPt.percentRoot = pt.percentRoot = val / helpers.getValue(hierarchy);\n      hoverPt.root = pt.root = helpers.getPtLabel(hierarchy);\n\n      if (hasFlag('percent root') && !isRoot) {\n        tx = helpers.formatPercent(hoverPt.percentRoot, separators) + ' of ' + hoverPt.root;\n        insertPercent();\n      }\n\n      hoverPt.text = _cast('hovertext') || _cast('text');\n\n      if (hasFlag('text')) {\n        tx = hoverPt.text;\n        if (Lib.isValidTextValue(tx)) thisText.push(tx);\n      }\n\n      eventData = [makeEventData(pt, traceNow, opts.eventDataKeys)];\n      var hoverItems = {\n        trace: traceNow,\n        y: hoverCenterY,\n        _x0: pt._x0,\n        _x1: pt._x1,\n        _y0: pt._y0,\n        _y1: pt._y1,\n        text: thisText.join('<br>'),\n        name: hovertemplate || hasFlag('name') ? traceNow.name : undefined,\n        color: _cast('hoverlabel.bgcolor') || cdi.color,\n        borderColor: _cast('hoverlabel.bordercolor'),\n        fontFamily: _cast('hoverlabel.font.family'),\n        fontSize: _cast('hoverlabel.font.size'),\n        fontColor: _cast('hoverlabel.font.color'),\n        nameLength: _cast('hoverlabel.namelength'),\n        textAlign: _cast('hoverlabel.align'),\n        hovertemplate: hovertemplate,\n        hovertemplateLabels: hoverPt,\n        eventData: eventData\n      };\n\n      if (isSunburst) {\n        hoverItems.x0 = hoverCenterX - pt.rInscribed * pt.rpx1;\n        hoverItems.x1 = hoverCenterX + pt.rInscribed * pt.rpx1;\n        hoverItems.idealAlign = pt.pxmid[0] < 0 ? 'left' : 'right';\n      }\n\n      if (isTreemapOrIcicle) {\n        hoverItems.x = hoverCenterX;\n        hoverItems.idealAlign = hoverCenterX < 0 ? 'left' : 'right';\n      }\n\n      var bbox = [];\n      Fx.loneHover(hoverItems, {\n        container: fullLayoutNow._hoverlayer.node(),\n        outerContainer: fullLayoutNow._paper.node(),\n        gd: gd,\n        inOut_bbox: bbox\n      });\n      eventData[0].bbox = bbox[0];\n      trace._hasHoverLabel = true;\n    }\n\n    if (isTreemapOrIcicle) {\n      var slice = sliceTop.select('path.surface');\n      opts.styleOne(slice, pt, traceNow, {\n        hovered: true\n      });\n    }\n\n    trace._hasHoverEvent = true;\n    gd.emit('plotly_hover', {\n      points: eventData || [makeEventData(pt, traceNow, opts.eventDataKeys)],\n      event: d3.event\n    });\n  };\n\n  var onMouseOut = function onMouseOut(evt) {\n    var fullLayoutNow = gd._fullLayout;\n    var traceNow = gd._fullData[trace.index];\n    var pt = d3.select(this).datum();\n\n    if (trace._hasHoverEvent) {\n      evt.originalEvent = d3.event;\n      gd.emit('plotly_unhover', {\n        points: [makeEventData(pt, traceNow, opts.eventDataKeys)],\n        event: d3.event\n      });\n      trace._hasHoverEvent = false;\n    }\n\n    if (trace._hasHoverLabel) {\n      Fx.loneUnhover(fullLayoutNow._hoverlayer.node());\n      trace._hasHoverLabel = false;\n    }\n\n    if (isTreemapOrIcicle) {\n      var slice = sliceTop.select('path.surface');\n      opts.styleOne(slice, pt, traceNow, {\n        hovered: false\n      });\n    }\n  };\n\n  var onClick = function onClick(pt) {\n    // TODO: this does not support right-click. If we want to support it, we\n    // would likely need to change pie to use dragElement instead of straight\n    // mapbox event binding. Or perhaps better, make a simple wrapper with the\n    // right mousedown, mousemove, and mouseup handlers just for a left/right click\n    // mapbox would use this too.\n    var fullLayoutNow = gd._fullLayout;\n    var traceNow = gd._fullData[trace.index];\n    var noTransition = isSunburst && (helpers.isHierarchyRoot(pt) || helpers.isLeaf(pt));\n    var id = helpers.getPtId(pt);\n    var nextEntry = helpers.isEntry(pt) ? helpers.findEntryWithChild(hierarchy, id) : helpers.findEntryWithLevel(hierarchy, id);\n    var nextLevel = helpers.getPtId(nextEntry);\n    var typeClickEvtData = {\n      points: [makeEventData(pt, traceNow, opts.eventDataKeys)],\n      event: d3.event\n    };\n    if (!noTransition) typeClickEvtData.nextLevel = nextLevel;\n    var clickVal = Events.triggerHandler(gd, 'plotly_' + trace.type + 'click', typeClickEvtData);\n\n    if (clickVal !== false && fullLayoutNow.hovermode) {\n      gd._hoverdata = [makeEventData(pt, traceNow, opts.eventDataKeys)];\n      Fx.click(gd, d3.event);\n    } // if click does not trigger a transition, we're done!\n\n\n    if (noTransition) return; // if custom handler returns false, we're done!\n\n    if (clickVal === false) return; // skip if triggered from dragging a nearby cartesian subplot\n\n    if (gd._dragging) return; // skip during transitions, to avoid potential bugs\n    // we could remove this check later\n\n    if (gd._transitioning) return; // store 'old' level in guiEdit stash, so that subsequent Plotly.react\n    // calls with the same uirevision can start from the same entry\n\n    Registry.call('_storeDirectGUIEdit', traceNow, fullLayoutNow._tracePreGUI[traceNow.uid], {\n      level: traceNow.level\n    });\n    var frame = {\n      data: [{\n        level: nextLevel\n      }],\n      traces: [trace.index]\n    };\n    var animOpts = {\n      frame: {\n        redraw: false,\n        duration: opts.transitionTime\n      },\n      transition: {\n        duration: opts.transitionTime,\n        easing: opts.transitionEasing\n      },\n      mode: 'immediate',\n      fromcurrent: true\n    };\n    Fx.loneUnhover(fullLayoutNow._hoverlayer.node());\n    Registry.call('animate', gd, frame, animOpts);\n  };\n\n  sliceTop.on('mouseover', onMouseOver);\n  sliceTop.on('mouseout', onMouseOut);\n  sliceTop.on('click', onClick);\n};\n\nfunction makeEventData(pt, trace, keys) {\n  var cdi = pt.data.data;\n  var out = {\n    curveNumber: trace.index,\n    pointNumber: cdi.i,\n    data: trace._input,\n    fullData: trace // TODO more things like 'children', 'siblings', 'hierarchy?\n\n  };\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key in pt) out[key] = pt[key];\n  } // handle special case of parent\n\n\n  if ('parentString' in pt && !helpers.isHierarchyRoot(pt)) out.parent = pt.parentString;\n  appendArrayPointValue(out, trace, cdi.i);\n  return out;\n}","map":null,"metadata":{},"sourceType":"script"}