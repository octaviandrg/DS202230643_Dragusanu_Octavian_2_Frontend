{"ast":null,"code":"// Utils used to parse miaf-based files (avif/heic/heif)\n//\n// ISO media file spec:\n// https://web.archive.org/web/20180219054429/http://l.web.umkc.edu/lizhu/teaching/2016sp.video-communication/ref/mp4.pdf\n//\n// ISO image file format spec:\n// https://standards.iso.org/ittf/PubliclyAvailableStandards/c066067_ISO_IEC_23008-12_2017.zip\n//\n'use strict';\n/* eslint-disable consistent-return */\n\n/* eslint-disable no-bitwise */\n\nvar readUInt16BE = require('./common').readUInt16BE;\n\nvar readUInt32BE = require('./common').readUInt32BE;\n/*\n * interface Box {\n *   size:       uint32;   // if size == 0, box lasts until EOF\n *   boxtype:    char[4];\n *   largesize?: uint64;   // only if size == 1\n *   usertype?:  char[16]; // only if boxtype == 'uuid'\n * }\n */\n\n\nfunction unbox(data, offset) {\n  if (data.length < 4 + offset) return null;\n  var size = readUInt32BE(data, offset); // size includes first 4 bytes (length)\n\n  if (data.length < size + offset || size < 8) return null; // if size === 1, real size is following uint64 (only for big boxes, not needed)\n  // if size === 0, real size is until the end of the file (only for big boxes, not needed)\n\n  return {\n    boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),\n    data: data.slice(offset + 8, offset + size),\n    end: offset + size\n  };\n}\n\nmodule.exports.unbox = unbox; // parses `meta` -> `iprp` -> `ipco` box, returns:\n// {\n//   sizes: [ { width, height } ],\n//   transforms: [ { type, value } ]\n// }\n\nfunction scan_ipco(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    switch (box.boxtype) {\n      case 'ispe':\n        sandbox.sizes.push({\n          width: readUInt32BE(box.data, 4),\n          height: readUInt32BE(box.data, 8)\n        });\n        break;\n\n      case 'irot':\n        sandbox.transforms.push({\n          type: 'irot',\n          value: box.data[0] & 3\n        });\n        break;\n\n      case 'imir':\n        sandbox.transforms.push({\n          type: 'imir',\n          value: box.data[0] & 1\n        });\n        break;\n    }\n\n    offset = box.end;\n  }\n}\n\nfunction readUIntBE(data, offset, size) {\n  var result = 0;\n\n  for (var i = 0; i < size; i++) {\n    result = result * 256 + (data[offset + i] || 0);\n  }\n\n  return result;\n} // parses `meta` -> `iloc` box\n\n\nfunction scan_iloc(data, sandbox) {\n  var offset_size = data[4] >> 4 & 0xF;\n  var length_size = data[4] & 0xF;\n  var base_offset_size = data[5] >> 4 & 0xF;\n  var item_count = readUInt16BE(data, 6);\n  var offset = 8;\n\n  for (var i = 0; i < item_count; i++) {\n    var item_ID = readUInt16BE(data, offset);\n    offset += 2;\n    var data_reference_index = readUInt16BE(data, offset);\n    offset += 2;\n    var base_offset = readUIntBE(data, offset, base_offset_size);\n    offset += base_offset_size;\n    var extent_count = readUInt16BE(data, offset);\n    offset += 2;\n\n    if (data_reference_index === 0 && extent_count === 1) {\n      var first_extent_offset = readUIntBE(data, offset, offset_size);\n      var first_extent_length = readUIntBE(data, offset + offset_size, length_size);\n      sandbox.item_loc[item_ID] = {\n        length: first_extent_length,\n        offset: first_extent_offset + base_offset\n      };\n    }\n\n    offset += extent_count * (offset_size + length_size);\n  }\n} // parses `meta` -> `iinf` box\n\n\nfunction scan_iinf(data, sandbox) {\n  var item_count = readUInt16BE(data, 4);\n  var offset = 6;\n\n  for (var i = 0; i < item_count; i++) {\n    var box = unbox(data, offset);\n    if (!box) break;\n\n    if (box.boxtype === 'infe') {\n      var item_id = readUInt16BE(box.data, 4);\n      var item_name = '';\n\n      for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {\n        item_name += String.fromCharCode(box.data[pos]);\n      }\n\n      sandbox.item_inf[item_name] = item_id;\n    }\n\n    offset = box.end;\n  }\n} // parses `meta` -> `iprp` box\n\n\nfunction scan_iprp(data, sandbox) {\n  var offset = 0;\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'ipco') scan_ipco(box.data, sandbox);\n    offset = box.end;\n  }\n} // parses `meta` box\n\n\nfunction scan_meta(data, sandbox) {\n  var offset = 4; // version + flags\n\n  for (;;) {\n    var box = unbox(data, offset);\n    if (!box) break;\n    if (box.boxtype === 'iprp') scan_iprp(box.data, sandbox);\n    if (box.boxtype === 'iloc') scan_iloc(box.data, sandbox);\n    if (box.boxtype === 'iinf') scan_iinf(box.data, sandbox);\n    offset = box.end;\n  }\n} // get image with largest single dimension as base\n\n\nfunction getMaxSize(sizes) {\n  var maxWidthSize = sizes.reduce(function (a, b) {\n    return a.width > b.width || a.width === b.width && a.height > b.height ? a : b;\n  });\n  var maxHeightSize = sizes.reduce(function (a, b) {\n    return a.height > b.height || a.height === b.height && a.width > b.width ? a : b;\n  });\n  var maxSize;\n\n  if (maxWidthSize.width > maxHeightSize.height || maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width) {\n    maxSize = maxWidthSize;\n  } else {\n    maxSize = maxHeightSize;\n  }\n\n  return maxSize;\n}\n\nmodule.exports.readSizeFromMeta = function (data) {\n  var sandbox = {\n    sizes: [],\n    transforms: [],\n    item_inf: {},\n    item_loc: {}\n  };\n  scan_meta(data, sandbox);\n  if (!sandbox.sizes.length) return;\n  var maxSize = getMaxSize(sandbox.sizes);\n  var orientation = 1; // convert imir/irot to exif orientation\n\n  sandbox.transforms.forEach(function (transform) {\n    var rotate_ccw = {\n      1: 6,\n      2: 5,\n      3: 8,\n      4: 7,\n      5: 4,\n      6: 3,\n      7: 2,\n      8: 1\n    };\n    var mirror_vert = {\n      1: 4,\n      2: 3,\n      3: 2,\n      4: 1,\n      5: 6,\n      6: 5,\n      7: 8,\n      8: 7\n    };\n\n    if (transform.type === 'imir') {\n      if (transform.value === 0) {\n        // vertical flip\n        orientation = mirror_vert[orientation];\n      } else {\n        // horizontal flip = vertical flip + 180 deg rotation\n        orientation = mirror_vert[orientation];\n        orientation = rotate_ccw[orientation];\n        orientation = rotate_ccw[orientation];\n      }\n    }\n\n    if (transform.type === 'irot') {\n      // counter-clockwise rotation 90 deg 0-3 times\n      for (var i = 0; i < transform.value; i++) {\n        orientation = rotate_ccw[orientation];\n      }\n    }\n  });\n  var exif_location = null;\n\n  if (sandbox.item_inf.Exif) {\n    exif_location = sandbox.item_loc[sandbox.item_inf.Exif];\n  }\n\n  return {\n    width: maxSize.width,\n    height: maxSize.height,\n    orientation: sandbox.transforms.length ? orientation : null,\n    variants: sandbox.sizes,\n    exif_location: exif_location\n  };\n};\n\nmodule.exports.getMimeType = function (data) {\n  var brand = String.fromCharCode.apply(null, data.slice(0, 4));\n  var compat = {};\n  compat[brand] = true;\n\n  for (var i = 8; i < data.length; i += 4) {\n    compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;\n  } // heic and avif are superset of miaf, so they should all list mif1 as compatible\n\n\n  if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;\n\n  if (brand === 'avif' || brand === 'avis' || brand === 'avio') {\n    // `.avifs` and `image/avif-sequence` are removed from spec, all files have single type\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  } // https://nokiatech.github.io/heif/technical.html\n\n\n  if (brand === 'heic' || brand === 'heix') {\n    return {\n      type: 'heic',\n      mime: 'image/heic'\n    };\n  }\n\n  if (brand === 'hevc' || brand === 'hevx') {\n    return {\n      type: 'heic',\n      mime: 'image/heic-sequence'\n    };\n  }\n\n  if (compat.avif || compat.avis) {\n    return {\n      type: 'avif',\n      mime: 'image/avif'\n    };\n  }\n\n  if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {\n    if (compat.msf1) {\n      return {\n        type: 'heif',\n        mime: 'image/heif-sequence'\n      };\n    }\n\n    return {\n      type: 'heif',\n      mime: 'image/heif'\n    };\n  }\n\n  return {\n    type: 'avif',\n    mime: 'image/avif'\n  };\n};","map":null,"metadata":{},"sourceType":"script"}