{"ast":null,"code":"'use strict';\n\nvar getBounds = require('array-bounds');\n\nvar rgba = require('color-normalize');\n\nvar updateDiff = require('update-diff');\n\nvar pick = require('pick-by-alias');\n\nvar extend = require('object-assign');\n\nvar flatten = require('flatten-vertex-data');\n\nvar _require = require('to-float32'),\n    float32 = _require.float32,\n    fract32 = _require.fract32;\n\nmodule.exports = Error2D;\nvar WEIGHTS = [//direction, lineWidth shift, capSize shift\n// x-error bar\n[1, 0, 0, 1, 0, 0], [1, 0, 0, -1, 0, 0], [-1, 0, 0, -1, 0, 0], [-1, 0, 0, -1, 0, 0], [-1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0], // x-error right cap\n[1, 0, -1, 0, 0, 1], [1, 0, -1, 0, 0, -1], [1, 0, 1, 0, 0, -1], [1, 0, 1, 0, 0, -1], [1, 0, 1, 0, 0, 1], [1, 0, -1, 0, 0, 1], // x-error left cap\n[-1, 0, -1, 0, 0, 1], [-1, 0, -1, 0, 0, -1], [-1, 0, 1, 0, 0, -1], [-1, 0, 1, 0, 0, -1], [-1, 0, 1, 0, 0, 1], [-1, 0, -1, 0, 0, 1], // y-error bar\n[0, 1, 1, 0, 0, 0], [0, 1, -1, 0, 0, 0], [0, -1, -1, 0, 0, 0], [0, -1, -1, 0, 0, 0], [0, 1, 1, 0, 0, 0], [0, -1, 1, 0, 0, 0], // y-error top cap\n[0, 1, 0, -1, 1, 0], [0, 1, 0, -1, -1, 0], [0, 1, 0, 1, -1, 0], [0, 1, 0, 1, 1, 0], [0, 1, 0, -1, 1, 0], [0, 1, 0, 1, -1, 0], // y-error bottom cap\n[0, -1, 0, -1, 1, 0], [0, -1, 0, -1, -1, 0], [0, -1, 0, 1, -1, 0], [0, -1, 0, 1, 1, 0], [0, -1, 0, -1, 1, 0], [0, -1, 0, 1, -1, 0]];\n\nfunction Error2D(regl, options) {\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n\n  if (options.length) options.positions = options;\n  regl = options.regl;\n\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  } // persistent variables\n\n\n  var gl = regl._gl,\n      drawErrors,\n      positionBuffer,\n      positionFractBuffer,\n      colorBuffer,\n      errorBuffer,\n      meshBuffer,\n      defaults = {\n    color: 'black',\n    capSize: 5,\n    lineWidth: 1,\n    opacity: 1,\n    viewport: null,\n    range: null,\n    offset: 0,\n    count: 0,\n    bounds: null,\n    positions: [],\n    errors: []\n  },\n      groups = []; //color per-point\n\n  colorBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'uint8',\n    data: new Uint8Array(0)\n  }); //xy-position per-point\n\n  positionBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //xy-position float32-fraction\n\n  positionFractBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //4 errors per-point\n\n  errorBuffer = regl.buffer({\n    usage: 'dynamic',\n    type: 'float',\n    data: new Uint8Array(0)\n  }); //error bar mesh\n\n  meshBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: WEIGHTS\n  });\n  update(options); //drawing method\n\n  drawErrors = regl({\n    vert: \"\\n\\t\\tprecision highp float;\\n\\n\\t\\tattribute vec2 position, positionFract;\\n\\t\\tattribute vec4 error;\\n\\t\\tattribute vec4 color;\\n\\n\\t\\tattribute vec2 direction, lineOffset, capOffset;\\n\\n\\t\\tuniform vec4 viewport;\\n\\t\\tuniform float lineWidth, capSize;\\n\\t\\tuniform vec2 scale, scaleFract, translate, translateFract;\\n\\n\\t\\tvarying vec4 fragColor;\\n\\n\\t\\tvoid main() {\\n\\t\\t\\tfragColor = color / 255.;\\n\\n\\t\\t\\tvec2 pixelOffset = lineWidth * lineOffset + (capSize + lineWidth) * capOffset;\\n\\n\\t\\t\\tvec2 dxy = -step(.5, direction.xy) * error.xz + step(direction.xy, vec2(-.5)) * error.yw;\\n\\n\\t\\t\\tvec2 position = position + dxy;\\n\\n\\t\\t\\tvec2 pos = (position + translate) * scale\\n\\t\\t\\t\\t+ (positionFract + translateFract) * scale\\n\\t\\t\\t\\t+ (position + translate) * scaleFract\\n\\t\\t\\t\\t+ (positionFract + translateFract) * scaleFract;\\n\\n\\t\\t\\tpos += pixelOffset / viewport.zw;\\n\\n\\t\\t\\tgl_Position = vec4(pos * 2. - 1., 0, 1);\\n\\t\\t}\\n\\t\\t\",\n    frag: \"\\n\\t\\tprecision highp float;\\n\\n\\t\\tvarying vec4 fragColor;\\n\\n\\t\\tuniform float opacity;\\n\\n\\t\\tvoid main() {\\n\\t\\t\\tgl_FragColor = fragColor;\\n\\t\\t\\tgl_FragColor.a *= opacity;\\n\\t\\t}\\n\\t\\t\",\n    uniforms: {\n      range: regl.prop('range'),\n      lineWidth: regl.prop('lineWidth'),\n      capSize: regl.prop('capSize'),\n      opacity: regl.prop('opacity'),\n      scale: regl.prop('scale'),\n      translate: regl.prop('translate'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      viewport: function viewport(ctx, prop) {\n        return [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight];\n      }\n    },\n    attributes: {\n      //dynamic attributes\n      color: {\n        buffer: colorBuffer,\n        offset: function offset(ctx, prop) {\n          return prop.offset * 4;\n        },\n        divisor: 1\n      },\n      position: {\n        buffer: positionBuffer,\n        offset: function offset(ctx, prop) {\n          return prop.offset * 8;\n        },\n        divisor: 1\n      },\n      positionFract: {\n        buffer: positionFractBuffer,\n        offset: function offset(ctx, prop) {\n          return prop.offset * 8;\n        },\n        divisor: 1\n      },\n      error: {\n        buffer: errorBuffer,\n        offset: function offset(ctx, prop) {\n          return prop.offset * 16;\n        },\n        divisor: 1\n      },\n      //static attributes\n      direction: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 0\n      },\n      lineOffset: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 8\n      },\n      capOffset: {\n        buffer: meshBuffer,\n        stride: 24,\n        offset: 16\n      }\n    },\n    primitive: 'triangles',\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: false,\n    instances: regl.prop('count'),\n    count: WEIGHTS.length\n  }); //expose API\n\n  extend(error2d, {\n    update: update,\n    draw: draw,\n    destroy: destroy,\n    regl: regl,\n    gl: gl,\n    canvas: gl.canvas,\n    groups: groups\n  });\n  return error2d;\n\n  function error2d(opts) {\n    //update\n    if (opts) {\n      update(opts);\n    } //destroy\n    else if (opts === null) {\n        destroy();\n      }\n\n    draw();\n  } //main draw method\n\n\n  function draw(options) {\n    if (typeof options === 'number') return drawGroup(options); //make options a batch\n\n    if (options && !Array.isArray(options)) options = [options];\n\n    regl._refresh(); //render multiple polylines via regl batch\n\n\n    groups.forEach(function (s, i) {\n      if (!s) return;\n\n      if (options) {\n        if (!options[i]) s.draw = false;else s.draw = true;\n      } //ignore draw flag for one pass\n\n\n      if (!s.draw) {\n        s.draw = true;\n        return;\n      }\n\n      drawGroup(i);\n    });\n  } //draw single error group by id\n\n\n  function drawGroup(s) {\n    if (typeof s === 'number') s = groups[s];\n    if (s == null) return;\n    if (!(s && s.count && s.color && s.opacity && s.positions && s.positions.length > 1)) return;\n    s.scaleRatio = [s.scale[0] * s.viewport.width, s.scale[1] * s.viewport.height];\n    drawErrors(s);\n    if (s.after) s.after(s);\n  }\n\n  function update(options) {\n    if (!options) return; //direct points argument\n\n    if (options.length != null) {\n      if (typeof options[0] === 'number') options = [{\n        positions: options\n      }];\n    } //make options a batch\n    else if (!Array.isArray(options)) options = [options]; //global count of points\n\n\n    var pointCount = 0,\n        errorCount = 0;\n    error2d.groups = groups = options.map(function (options, i) {\n      var group = groups[i];\n      if (!options) return group;else if (typeof options === 'function') options = {\n        after: options\n      };else if (typeof options[0] === 'number') options = {\n        positions: options //copy options to avoid mutation & handle aliases\n\n      };\n      options = pick(options, {\n        color: 'color colors fill',\n        capSize: 'capSize cap capsize cap-size',\n        lineWidth: 'lineWidth line-width width line thickness',\n        opacity: 'opacity alpha',\n        range: 'range dataBox',\n        viewport: 'viewport viewBox',\n        errors: 'errors error',\n        positions: 'positions position data points'\n      });\n\n      if (!group) {\n        groups[i] = group = {\n          id: i,\n          scale: null,\n          translate: null,\n          scaleFract: null,\n          translateFract: null,\n          draw: true\n        };\n        options = extend({}, defaults, options);\n      }\n\n      updateDiff(group, options, [{\n        lineWidth: function lineWidth(v) {\n          return +v * .5;\n        },\n        capSize: function capSize(v) {\n          return +v * .5;\n        },\n        opacity: parseFloat,\n        errors: function errors(_errors) {\n          _errors = flatten(_errors);\n          errorCount += _errors.length;\n          return _errors;\n        },\n        positions: function positions(_positions, state) {\n          _positions = flatten(_positions, 'float64');\n          state.count = Math.floor(_positions.length / 2);\n          state.bounds = getBounds(_positions, 2);\n          state.offset = pointCount;\n          pointCount += state.count;\n          return _positions;\n        }\n      }, {\n        color: function color(colors, state) {\n          var count = state.count;\n          if (!colors) colors = 'transparent'; // 'black' or [0,0,0,0] case\n\n          if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n            var color = colors;\n            colors = Array(count);\n\n            for (var _i = 0; _i < count; _i++) {\n              colors[_i] = color;\n            }\n          }\n\n          if (colors.length < count) throw Error('Not enough colors');\n          var colorData = new Uint8Array(count * 4); //convert colors to float arrays\n\n          for (var _i2 = 0; _i2 < count; _i2++) {\n            var c = rgba(colors[_i2], 'uint8');\n            colorData.set(c, _i2 * 4);\n          }\n\n          return colorData;\n        },\n        range: function range(_range, state, options) {\n          var bounds = state.bounds;\n          if (!_range) _range = bounds;\n          state.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n          state.translate = [-_range[0], -_range[1]];\n          state.scaleFract = fract32(state.scale);\n          state.translateFract = fract32(state.translate);\n          return _range;\n        },\n        viewport: function viewport(vp) {\n          var viewport;\n\n          if (Array.isArray(vp)) {\n            viewport = {\n              x: vp[0],\n              y: vp[1],\n              width: vp[2] - vp[0],\n              height: vp[3] - vp[1]\n            };\n          } else if (vp) {\n            viewport = {\n              x: vp.x || vp.left || 0,\n              y: vp.y || vp.top || 0\n            };\n            if (vp.right) viewport.width = vp.right - viewport.x;else viewport.width = vp.w || vp.width || 0;\n            if (vp.bottom) viewport.height = vp.bottom - viewport.y;else viewport.height = vp.h || vp.height || 0;\n          } else {\n            viewport = {\n              x: 0,\n              y: 0,\n              width: gl.drawingBufferWidth,\n              height: gl.drawingBufferHeight\n            };\n          }\n\n          return viewport;\n        }\n      }]);\n      return group;\n    });\n\n    if (pointCount || errorCount) {\n      var len = groups.reduce(function (acc, group, i) {\n        return acc + (group ? group.count : 0);\n      }, 0);\n      var positionData = new Float64Array(len * 2);\n      var colorData = new Uint8Array(len * 4);\n      var errorData = new Float32Array(len * 4);\n      groups.forEach(function (group, i) {\n        if (!group) return;\n        var positions = group.positions,\n            count = group.count,\n            offset = group.offset,\n            color = group.color,\n            errors = group.errors;\n        if (!count) return;\n        colorData.set(color, offset * 4);\n        errorData.set(errors, offset * 4);\n        positionData.set(positions, offset * 2);\n      });\n      var float_data = float32(positionData);\n      positionBuffer(float_data);\n      var frac_data = fract32(positionData, float_data);\n      positionFractBuffer(frac_data);\n      colorBuffer(colorData);\n      errorBuffer(errorData);\n    }\n  }\n\n  function destroy() {\n    positionBuffer.destroy();\n    positionFractBuffer.destroy();\n    colorBuffer.destroy();\n    errorBuffer.destroy();\n    meshBuffer.destroy();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}