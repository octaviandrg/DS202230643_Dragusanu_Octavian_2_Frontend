{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar helpers = require('../sunburst/helpers');\n\nvar Lib = require('../../lib');\n\nvar TEXTPAD = require('../bar/constants').TEXTPAD;\n\nvar barPlot = require('../bar/plot');\n\nvar toMoveInsideBar = barPlot.toMoveInsideBar;\n\nvar uniformText = require('../bar/uniform_text');\n\nvar recordMinTextSize = uniformText.recordMinTextSize;\n\nvar constants = require('./constants');\n\nvar drawAncestors = require('./draw_ancestors');\n\nfunction getKey(pt) {\n  return helpers.isHierarchyRoot(pt) ? '' : // don't use the dummyId\n  helpers.getPtId(pt);\n}\n\nmodule.exports = function plotOne(gd, cd, element, transitionOpts, drawDescendants) {\n  var fullLayout = gd._fullLayout;\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var type = trace.type;\n  var isIcicle = type === 'icicle';\n  var hierarchy = cd0.hierarchy;\n  var entry = helpers.findEntryWithLevel(hierarchy, trace.level);\n  var gTrace = d3.select(element);\n  var selAncestors = gTrace.selectAll('g.pathbar');\n  var selDescendants = gTrace.selectAll('g.slice');\n\n  if (!entry) {\n    selAncestors.remove();\n    selDescendants.remove();\n    return;\n  }\n\n  var isRoot = helpers.isHierarchyRoot(entry);\n  var hasTransition = !fullLayout.uniformtext.mode && helpers.hasTransition(transitionOpts);\n  var maxDepth = helpers.getMaxDepth(trace);\n\n  var hasVisibleDepth = function hasVisibleDepth(pt) {\n    return pt.data.depth - entry.data.depth < maxDepth;\n  };\n\n  var gs = fullLayout._size;\n  var domain = trace.domain;\n  var vpw = gs.w * (domain.x[1] - domain.x[0]);\n  var vph = gs.h * (domain.y[1] - domain.y[0]);\n  var barW = vpw;\n  var barH = trace.pathbar.thickness;\n  var barPad = trace.marker.line.width + constants.gapWithPathbar;\n  var barDifY = !trace.pathbar.visible ? 0 : trace.pathbar.side.indexOf('bottom') > -1 ? vph + barPad : -(barH + barPad);\n  var pathbarOrigin = {\n    x0: barW,\n    // slide to the right\n    x1: barW,\n    y0: barDifY,\n    y1: barDifY + barH\n  };\n\n  var findClosestEdge = function findClosestEdge(pt, ref, size) {\n    var e = trace.tiling.pad;\n\n    var isLeftOfRect = function isLeftOfRect(x) {\n      return x - e <= ref.x0;\n    };\n\n    var isRightOfRect = function isRightOfRect(x) {\n      return x + e >= ref.x1;\n    };\n\n    var isBottomOfRect = function isBottomOfRect(y) {\n      return y - e <= ref.y0;\n    };\n\n    var isTopOfRect = function isTopOfRect(y) {\n      return y + e >= ref.y1;\n    };\n\n    if (pt.x0 === ref.x0 && pt.x1 === ref.x1 && pt.y0 === ref.y0 && pt.y1 === ref.y1) {\n      return {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n    }\n\n    return {\n      x0: isLeftOfRect(pt.x0 - e) ? 0 : isRightOfRect(pt.x0 - e) ? size[0] : pt.x0,\n      x1: isLeftOfRect(pt.x1 + e) ? 0 : isRightOfRect(pt.x1 + e) ? size[0] : pt.x1,\n      y0: isBottomOfRect(pt.y0 - e) ? 0 : isTopOfRect(pt.y0 - e) ? size[1] : pt.y0,\n      y1: isBottomOfRect(pt.y1 + e) ? 0 : isTopOfRect(pt.y1 + e) ? size[1] : pt.y1\n    };\n  }; // stash of 'previous' position data used by tweening functions\n\n\n  var prevEntry = null;\n  var prevLookupPathbar = {};\n  var prevLookupSlices = {};\n  var nextOfPrevEntry = null;\n\n  var getPrev = function getPrev(pt, onPathbar) {\n    return onPathbar ? prevLookupPathbar[getKey(pt)] : prevLookupSlices[getKey(pt)];\n  };\n\n  var getOrigin = function getOrigin(pt, onPathbar, refRect, size) {\n    if (onPathbar) {\n      return prevLookupPathbar[getKey(hierarchy)] || pathbarOrigin;\n    } else {\n      var ref = prevLookupSlices[trace.level] || refRect;\n\n      if (hasVisibleDepth(pt)) {\n        // case of an empty object - happens when maxdepth is set\n        return findClosestEdge(pt, ref, size);\n      }\n    }\n\n    return {};\n  }; // N.B. handle multiple-root special case\n\n\n  if (cd0.hasMultipleRoots && isRoot) {\n    maxDepth++;\n  }\n\n  trace._maxDepth = maxDepth;\n  trace._backgroundColor = fullLayout.paper_bgcolor;\n  trace._entryDepth = entry.data.depth;\n  trace._atRootLevel = isRoot;\n  var cenX = -vpw / 2 + gs.l + gs.w * (domain.x[1] + domain.x[0]) / 2;\n  var cenY = -vph / 2 + gs.t + gs.h * (1 - (domain.y[1] + domain.y[0]) / 2);\n\n  var viewMapX = function viewMapX(x) {\n    return cenX + x;\n  };\n\n  var viewMapY = function viewMapY(y) {\n    return cenY + y;\n  };\n\n  var barY0 = viewMapY(0);\n  var barX0 = viewMapX(0);\n\n  var viewBarX = function viewBarX(x) {\n    return barX0 + x;\n  };\n\n  var viewBarY = function viewBarY(y) {\n    return barY0 + y;\n  };\n\n  function pos(x, y) {\n    return x + ',' + y;\n  }\n\n  var xStart = viewBarX(0);\n\n  var limitX0 = function limitX0(p) {\n    p.x = Math.max(xStart, p.x);\n  };\n\n  var edgeshape = trace.pathbar.edgeshape; // pathbar(directory) path generation fn\n\n  var pathAncestor = function pathAncestor(d) {\n    var _x0 = viewBarX(Math.max(Math.min(d.x0, d.x0), 0));\n\n    var _x1 = viewBarX(Math.min(Math.max(d.x1, d.x1), barW));\n\n    var _y0 = viewBarY(d.y0);\n\n    var _y1 = viewBarY(d.y1);\n\n    var halfH = barH / 2;\n    var pL = {};\n    var pR = {};\n    pL.x = _x0;\n    pR.x = _x1;\n    pL.y = pR.y = (_y0 + _y1) / 2;\n    var pA = {\n      x: _x0,\n      y: _y0\n    };\n    var pB = {\n      x: _x1,\n      y: _y0\n    };\n    var pC = {\n      x: _x1,\n      y: _y1\n    };\n    var pD = {\n      x: _x0,\n      y: _y1\n    };\n\n    if (edgeshape === '>') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pC.x -= halfH;\n      pD.x -= halfH;\n    } else if (edgeshape === '/') {\n      pC.x -= halfH;\n      pD.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '\\\\') {\n      pA.x -= halfH;\n      pB.x -= halfH;\n      pL.x -= halfH / 2;\n      pR.x -= halfH / 2;\n    } else if (edgeshape === '<') {\n      pL.x -= halfH;\n      pR.x -= halfH;\n    }\n\n    limitX0(pA);\n    limitX0(pD);\n    limitX0(pL);\n    limitX0(pB);\n    limitX0(pC);\n    limitX0(pR);\n    return 'M' + pos(pA.x, pA.y) + 'L' + pos(pB.x, pB.y) + 'L' + pos(pR.x, pR.y) + 'L' + pos(pC.x, pC.y) + 'L' + pos(pD.x, pD.y) + 'L' + pos(pL.x, pL.y) + 'Z';\n  }; // slice path generation fn\n\n\n  var pathDescendant = function pathDescendant(d) {\n    var _x0 = viewMapX(d.x0);\n\n    var _x1 = viewMapX(d.x1);\n\n    var _y0 = viewMapY(d.y0);\n\n    var _y1 = viewMapY(d.y1);\n\n    var dx = _x1 - _x0;\n    var dy = _y1 - _y0;\n    if (!dx || !dy) return '';\n    var FILLET = 0; // TODO: may expose this constant\n\n    var r = dx > 2 * FILLET && dy > 2 * FILLET ? FILLET : 0;\n\n    var arc = function arc(rx, ry) {\n      return r ? 'a' + pos(r, r) + ' 0 0 1 ' + pos(rx, ry) : '';\n    };\n\n    return 'M' + pos(_x0, _y0 + r) + arc(r, -r) + 'L' + pos(_x1 - r, _y0) + arc(r, r) + 'L' + pos(_x1, _y1 - r) + arc(-r, r) + 'L' + pos(_x0 + r, _y1) + arc(-r, -r) + 'Z';\n  };\n\n  var toMoveInsideSlice = function toMoveInsideSlice(pt, opts) {\n    var x0 = pt.x0;\n    var x1 = pt.x1;\n    var y0 = pt.y0;\n    var y1 = pt.y1;\n    var textBB = pt.textBB;\n\n    var hasFlag = function hasFlag(f) {\n      return trace.textposition.indexOf(f) !== -1;\n    };\n\n    var hasBottom = hasFlag('bottom');\n    var hasTop = hasFlag('top') || opts.isHeader && !hasBottom;\n    var anchor = hasTop ? 'start' : hasBottom ? 'end' : 'middle';\n    var hasRight = hasFlag('right');\n    var hasLeft = hasFlag('left') || opts.onPathbar;\n    var leftToRight = hasLeft ? -1 : hasRight ? 1 : 0; // Note that `pad` is just an integer for `icicle`` traces where\n    // `pad` is a hashmap for treemap: pad.t, pad.b, pad.l, and pad.r\n\n    var pad = trace[isIcicle ? 'tiling' : 'marker'].pad;\n\n    if (opts.isHeader) {\n      x0 += (isIcicle ? pad : pad.l) - TEXTPAD;\n      x1 -= (isIcicle ? pad : pad.r) - TEXTPAD;\n\n      if (x0 >= x1) {\n        var mid = (x0 + x1) / 2;\n        x0 = mid;\n        x1 = mid;\n      } // limit the drawing area for headers\n\n\n      var limY;\n\n      if (hasBottom) {\n        limY = y1 - (isIcicle ? pad : pad.b);\n        if (y0 < limY && limY < y1) y0 = limY;\n      } else {\n        limY = y0 + (isIcicle ? pad : pad.t);\n        if (y0 < limY && limY < y1) y1 = limY;\n      }\n    } // position the text relative to the slice\n\n\n    var transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {\n      isHorizontal: false,\n      constrained: true,\n      angle: 0,\n      anchor: anchor,\n      leftToRight: leftToRight\n    });\n    transform.fontSize = opts.fontSize;\n    transform.targetX = viewMapX(transform.targetX);\n    transform.targetY = viewMapY(transform.targetY);\n\n    if (isNaN(transform.targetX) || isNaN(transform.targetY)) {\n      return {};\n    }\n\n    if (x0 !== x1 && y0 !== y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return {\n      scale: transform.scale,\n      rotate: transform.rotate,\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY\n    };\n  };\n\n  var interpFromParent = function interpFromParent(pt, onPathbar) {\n    var parentPrev;\n    var i = 0;\n    var Q = pt;\n\n    while (!parentPrev && i < maxDepth) {\n      // loop to find a parent/grandParent on the previous graph\n      i++;\n      Q = Q.parent;\n\n      if (Q) {\n        parentPrev = getPrev(Q, onPathbar);\n      } else i = maxDepth;\n    }\n\n    return parentPrev || {};\n  };\n\n  var makeExitSliceInterpolator = function makeExitSliceInterpolator(pt, onPathbar, refRect, size) {\n    var prev = getPrev(pt, onPathbar);\n    var next;\n\n    if (onPathbar) {\n      next = pathbarOrigin;\n    } else {\n      var entryPrev = getPrev(entry, onPathbar);\n\n      if (entryPrev) {\n        // 'entryPrev' is here has the previous coordinates of the entry\n        // node, which corresponds to the last \"clicked\" node when zooming in\n        next = findClosestEdge(pt, entryPrev, size);\n      } else {\n        // this happens when maxdepth is set, when leaves must\n        // be removed and the entry is new (i.e. does not have a 'prev' object)\n        next = {};\n      }\n    }\n\n    return interpolate(prev, next);\n  };\n\n  var makeUpdateSliceInterpolator = function makeUpdateSliceInterpolator(pt, onPathbar, refRect, size, opts) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev;\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (onPathbar) {\n        prev = pathbarOrigin;\n      } else {\n        if (prevEntry) {\n          // if trace was visible before\n          if (pt.parent) {\n            var ref = nextOfPrevEntry || refRect;\n\n            if (ref && !onPathbar) {\n              prev = findClosestEdge(pt, ref, size);\n            } else {\n              // if new leaf (when maxdepth is set),\n              // grow it from its parent node\n              prev = {};\n              Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n            }\n          } else {\n            prev = Lib.extendFlat({}, pt);\n\n            if (isIcicle) {\n              if (opts.orientation === 'h') {\n                if (opts.flipX) prev.x0 = pt.x1;else prev.x1 = 0;\n              } else {\n                if (opts.flipY) prev.y0 = pt.y1;else prev.y1 = 0;\n              }\n            }\n          }\n        } else {\n          prev = {};\n        }\n      }\n    }\n\n    return interpolate(prev, {\n      x0: pt.x0,\n      x1: pt.x1,\n      y0: pt.y0,\n      y1: pt.y1\n    });\n  };\n\n  var makeUpdateTextInterpolator = function makeUpdateTextInterpolator(pt, onPathbar, refRect, size) {\n    var prev0 = getPrev(pt, onPathbar);\n    var prev = {};\n    var origin = getOrigin(pt, onPathbar, refRect, size);\n    Lib.extendFlat(prev, {\n      transform: toMoveInsideSlice({\n        x0: origin.x0,\n        x1: origin.x1,\n        y0: origin.y0,\n        y1: origin.y1,\n        textBB: pt.textBB,\n        _text: pt._text\n      }, {\n        isHeader: helpers.isHeader(pt, trace)\n      })\n    });\n\n    if (prev0) {\n      // if pt already on graph, this is easy\n      prev = prev0;\n    } else {\n      // for new pts:\n      if (pt.parent) {\n        Lib.extendFlat(prev, interpFromParent(pt, onPathbar));\n      }\n    }\n\n    var transform = pt.transform;\n\n    if (pt.x0 !== pt.x1 && pt.y0 !== pt.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return interpolate(prev, {\n      transform: {\n        scale: transform.scale,\n        rotate: transform.rotate,\n        textX: transform.textX,\n        textY: transform.textY,\n        anchorX: transform.anchorX,\n        anchorY: transform.anchorY,\n        targetX: transform.targetX,\n        targetY: transform.targetY\n      }\n    });\n  };\n\n  var handleSlicesExit = function handleSlicesExit(slices, onPathbar, refRect, size, pathSlice) {\n    var width = size[0];\n    var height = size[1];\n\n    if (hasTransition) {\n      slices.exit().transition().each(function () {\n        var sliceTop = d3.select(this);\n        var slicePath = sliceTop.select('path.surface');\n        slicePath.transition().attrTween('d', function (pt2) {\n          var interp = makeExitSliceInterpolator(pt2, onPathbar, refRect, [width, height]);\n          return function (t) {\n            return pathSlice(interp(t));\n          };\n        });\n        var sliceTextGroup = sliceTop.select('g.slicetext');\n        sliceTextGroup.attr('opacity', 0);\n      }).remove();\n    } else {\n      slices.exit().remove();\n    }\n  };\n\n  var strTransform = function strTransform(d) {\n    var transform = d.transform;\n\n    if (d.x0 !== d.x1 && d.y0 !== d.y1) {\n      recordMinTextSize(trace.type, transform, fullLayout);\n    }\n\n    return Lib.getTextTransform({\n      textX: transform.textX,\n      textY: transform.textY,\n      anchorX: transform.anchorX,\n      anchorY: transform.anchorY,\n      targetX: transform.targetX,\n      targetY: transform.targetY,\n      scale: transform.scale,\n      rotate: transform.rotate\n    });\n  };\n\n  if (hasTransition) {\n    // Important: do this before binding new sliceData!\n    selAncestors.each(function (pt) {\n      prevLookupPathbar[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupPathbar[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n    });\n    selDescendants.each(function (pt) {\n      prevLookupSlices[getKey(pt)] = {\n        x0: pt.x0,\n        x1: pt.x1,\n        y0: pt.y0,\n        y1: pt.y1\n      };\n\n      if (pt.transform) {\n        prevLookupSlices[getKey(pt)].transform = {\n          textX: pt.transform.textX,\n          textY: pt.transform.textY,\n          anchorX: pt.transform.anchorX,\n          anchorY: pt.transform.anchorY,\n          targetX: pt.transform.targetX,\n          targetY: pt.transform.targetY,\n          scale: pt.transform.scale,\n          rotate: pt.transform.rotate\n        };\n      }\n\n      if (!prevEntry && helpers.isEntry(pt)) {\n        prevEntry = pt;\n      }\n    });\n  }\n\n  nextOfPrevEntry = drawDescendants(gd, cd, entry, selDescendants, {\n    width: vpw,\n    height: vph,\n    viewX: viewMapX,\n    viewY: viewMapY,\n    pathSlice: pathDescendant,\n    toMoveInsideSlice: toMoveInsideSlice,\n    prevEntry: prevEntry,\n    makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n    makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n    handleSlicesExit: handleSlicesExit,\n    hasTransition: hasTransition,\n    strTransform: strTransform\n  });\n\n  if (trace.pathbar.visible) {\n    drawAncestors(gd, cd, entry, selAncestors, {\n      barDifY: barDifY,\n      width: barW,\n      height: barH,\n      viewX: viewBarX,\n      viewY: viewBarY,\n      pathSlice: pathAncestor,\n      toMoveInsideSlice: toMoveInsideSlice,\n      makeUpdateSliceInterpolator: makeUpdateSliceInterpolator,\n      makeUpdateTextInterpolator: makeUpdateTextInterpolator,\n      handleSlicesExit: handleSlicesExit,\n      hasTransition: hasTransition,\n      strTransform: strTransform\n    });\n  } else {\n    selAncestors.remove();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}