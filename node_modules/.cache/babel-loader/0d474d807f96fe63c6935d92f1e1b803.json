{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar rgba = require('color-normalize');\n\nvar getBounds = require('array-bounds');\n\nvar colorId = require('color-id');\n\nvar cluster = require('@plotly/point-cluster');\n\nvar extend = require('object-assign');\n\nvar glslify = require('glslify');\n\nvar pick = require('pick-by-alias');\n\nvar updateDiff = require('update-diff');\n\nvar flatten = require('flatten-vertex-data');\n\nvar ie = require('is-iexplorer');\n\nvar f32 = require('to-float32');\n\nvar parseRect = require('parse-rect');\n\nvar scatter = Scatter;\n\nfunction Scatter(regl, options) {\n  var _this = this;\n\n  if (!(this instanceof Scatter)) return new Scatter(regl, options);\n\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n    regl = null;\n  }\n\n  if (options && options.length) options.positions = options;\n  regl = options.regl; // persistent variables\n\n  var gl = regl._gl,\n      paletteTexture,\n      palette = [],\n      paletteIds = {},\n      // state\n  groups = [],\n      // textures for marker keys\n  markerTextures = [null],\n      markerCache = [null];\n  var maxColors = 255,\n      maxSize = 100; // direct color buffer mode\n  // IE does not support palette anyways\n\n  this.tooManyColors = ie; // texture with color palette\n\n  paletteTexture = regl.texture({\n    data: new Uint8Array(maxColors * 4),\n    width: maxColors,\n    height: 1,\n    type: 'uint8',\n    format: 'rgba',\n    wrapS: 'clamp',\n    wrapT: 'clamp',\n    mag: 'nearest',\n    min: 'nearest'\n  });\n  extend(this, {\n    regl: regl,\n    gl: gl,\n    groups: groups,\n    markerCache: markerCache,\n    markerTextures: markerTextures,\n    palette: palette,\n    paletteIds: paletteIds,\n    paletteTexture: paletteTexture,\n    maxColors: maxColors,\n    maxSize: maxSize,\n    canvas: gl.canvas\n  });\n  this.update(options); // common shader options\n\n  var shaderOptions = {\n    uniforms: {\n      constPointSize: !!options.constPointSize,\n      opacity: regl.prop('opacity'),\n      paletteSize: function paletteSize(ctx, prop) {\n        return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];\n      },\n      pixelRatio: regl.context('pixelRatio'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translate: regl.prop('translate'),\n      translateFract: regl.prop('translateFract'),\n      markerTexture: regl.prop('markerTexture'),\n      paletteTexture: paletteTexture\n    },\n    attributes: {\n      // FIXME: optimize these parts\n      x: function x(ctx, prop) {\n        return prop.xAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      y: function y(ctx, prop) {\n        return prop.yAttr || {\n          buffer: prop.positionBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      xFract: function xFract(ctx, prop) {\n        return prop.xAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 0\n        };\n      },\n      yFract: function yFract(ctx, prop) {\n        return prop.yAttr ? {\n          constant: [0, 0]\n        } : {\n          buffer: prop.positionFractBuffer,\n          stride: 8,\n          offset: 4\n        };\n      },\n      size: function size(ctx, prop) {\n        return prop.size.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 0\n        } : {\n          constant: [Math.round(prop.size * 255 / _this.maxSize)]\n        };\n      },\n      borderSize: function borderSize(ctx, prop) {\n        return prop.borderSize.length ? {\n          buffer: prop.sizeBuffer,\n          stride: 2,\n          offset: 1\n        } : {\n          constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]\n        };\n      },\n      colorId: function colorId(ctx, prop) {\n        return prop.color.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: 0\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]\n        };\n      },\n      borderColorId: function borderColorId(ctx, prop) {\n        return prop.borderColor.length ? {\n          buffer: prop.colorBuffer,\n          stride: _this.tooManyColors ? 8 : 4,\n          offset: _this.tooManyColors ? 4 : 2\n        } : {\n          constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]\n        };\n      },\n      isActive: function isActive(ctx, prop) {\n        return prop.activation === true ? {\n          constant: [1]\n        } : prop.activation ? prop.activation : {\n          constant: [0]\n        };\n      }\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      // photoshop blending\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport'),\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    elements: regl.prop('elements'),\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    primitive: 'points'\n  }; // draw sdf-marker\n\n  var markerOptions = extend({}, shaderOptions);\n  markerOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform float opacity;\\nuniform sampler2D markerTexture;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat smoothStep(float x, float y) {\\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\\n}\\n\\nvoid main() {\\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\\n\\n  // max-distance alpha\\n  if (dist < 0.003) discard;\\n\\n  // null-border case\\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\\n  }\\n  else {\\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\\n\\n    vec4 color = fragBorderColor;\\n    color.a *= borderColorAmt;\\n    color = mix(color, fragColor, colorAmt);\\n    color.a *= opacity;\\n\\n    gl_FragColor = color;\\n  }\\n\\n}\\n\"]);\n  markerOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\nconst float borderLevel = .5;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = 2. * size * pointSizeScale;\\n  fragPointSize = size * pixelRatio;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragColor = color;\\n  fragBorderColor = borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n\\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\\n}\"]);\n  this.drawMarker = regl(markerOptions); // draw circle\n\n  var circleOptions = extend({}, shaderOptions);\n  circleOptions.frag = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nuniform float opacity;\\n\\nfloat smoothStep(float edge0, float edge1, float x) {\\n\\tfloat t;\\n\\tt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\\n\\treturn t * t * (3.0 - 2.0 * t);\\n}\\n\\nvoid main() {\\n\\tfloat radius, alpha = 1.0, delta = fragWidth;\\n\\n\\tradius = length(2.0 * gl_PointCoord.xy - 1.0);\\n\\n\\tif (radius > 1.0 + delta) {\\n\\t\\tdiscard;\\n\\t}\\n\\n\\talpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\\n\\n\\tfloat borderRadius = fragBorderRadius;\\n\\tfloat ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\\n\\tvec4 color = mix(fragColor, fragBorderColor, ratio);\\n\\tcolor.a *= alpha * opacity;\\n\\tgl_FragColor = color;\\n}\\n\"]);\n  circleOptions.vert = glslify([\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute float x, y, xFract, yFract;\\nattribute float size, borderSize;\\nattribute vec4 colorId, borderColorId;\\nattribute float isActive;\\n\\nuniform bool constPointSize;\\nuniform float pixelRatio;\\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\\nuniform sampler2D paletteTexture;\\n\\nconst float maxSize = 100.;\\n\\nvarying vec4 fragColor, fragBorderColor;\\nvarying float fragBorderRadius, fragWidth;\\n\\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\\n\\nbool isDirect = (paletteSize.x < 1.);\\n\\nvec4 getColor(vec4 id) {\\n  return isDirect ? id / 255. : texture2D(paletteTexture,\\n    vec2(\\n      (id.x + .5) / paletteSize.x,\\n      (id.y + .5) / paletteSize.y\\n    )\\n  );\\n}\\n\\nvoid main() {\\n  // ignore inactive points\\n  if (isActive == 0.) return;\\n\\n  vec2 position = vec2(x, y);\\n  vec2 positionFract = vec2(xFract, yFract);\\n\\n  vec4 color = getColor(colorId);\\n  vec4 borderColor = getColor(borderColorId);\\n\\n  float size = size * maxSize / 255.;\\n  float borderSize = borderSize * maxSize / 255.;\\n\\n  gl_PointSize = (size + borderSize) * pointSizeScale;\\n\\n  vec2 pos = (position + translate) * scale\\n      + (positionFract + translateFract) * scale\\n      + (position + translate) * scaleFract\\n      + (positionFract + translateFract) * scaleFract;\\n\\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\\n\\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\\n  fragColor = color;\\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\\n  fragWidth = 1. / gl_PointSize;\\n}\\n\"]); // polyfill IE\n\n  if (ie) {\n    circleOptions.frag = circleOptions.frag.replace('smoothstep', 'smoothStep');\n    markerOptions.frag = markerOptions.frag.replace('smoothstep', 'smoothStep');\n  }\n\n  this.drawCircle = regl(circleOptions);\n} // single pass defaults\n\n\nScatter.defaults = {\n  color: 'black',\n  borderColor: 'transparent',\n  borderSize: 0,\n  size: 12,\n  opacity: 1,\n  marker: undefined,\n  viewport: null,\n  range: null,\n  pixelSize: null,\n  count: 0,\n  offset: 0,\n  bounds: null,\n  positions: [],\n  snap: 1e4\n}; // update & redraw\n\nScatter.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  this.draw();\n  return this;\n}; // draw all groups or only indicated ones\n\n\nScatter.prototype.draw = function () {\n  var _this2 = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var groups = this.groups; // if directly array passed - treat as passes\n\n  if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {\n    args = args[0];\n  } // FIXME: remove once https://github.com/regl-project/regl/issues/474 resolved\n\n\n  this.regl._refresh();\n\n  if (args.length) {\n    for (var i = 0; i < args.length; i++) {\n      this.drawItem(i, args[i]);\n    }\n  } // draw all passes\n  else {\n      groups.forEach(function (group, i) {\n        _this2.drawItem(i);\n      });\n    }\n\n  return this;\n}; // draw specific scatter group\n\n\nScatter.prototype.drawItem = function (id, els) {\n  var groups = this.groups;\n  var group = groups[id]; // debug viewport\n  // let { viewport } = group\n  // gl.enable(gl.SCISSOR_TEST);\n  // gl.scissor(viewport.x, viewport.y, viewport.width, viewport.height);\n  // gl.clearColor(0, 0, 0, .5);\n  // gl.clear(gl.COLOR_BUFFER_BIT);\n\n  if (typeof els === 'number') {\n    id = els;\n    group = groups[els];\n    els = null;\n  }\n\n  if (!(group && group.count && group.opacity)) return; // draw circles\n\n  if (group.activation[0]) {\n    // TODO: optimize this performance by making groups and regl.this props\n    this.drawCircle(this.getMarkerDrawOptions(0, group, els));\n  } // draw all other available markers\n\n\n  var batch = [];\n\n  for (var i = 1; i < group.activation.length; i++) {\n    if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;\n    batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));\n  }\n\n  if (batch.length) {\n    this.drawMarker(batch);\n  }\n}; // get options for the marker ids\n\n\nScatter.prototype.getMarkerDrawOptions = function (markerId, group, elements) {\n  var range = group.range,\n      tree = group.tree,\n      viewport = group.viewport,\n      activation = group.activation,\n      selectionBuffer = group.selectionBuffer,\n      count = group.count;\n  var regl = this.regl; // direct points\n\n  if (!tree) {\n    // if elements array - draw unclustered points\n    if (elements) {\n      return [extend({}, group, {\n        markerTexture: this.markerTextures[markerId],\n        activation: activation[markerId],\n        count: elements.length,\n        elements: elements,\n        offset: 0\n      })];\n    }\n\n    return [extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: activation[markerId],\n      offset: 0\n    })];\n  } // clustered points\n\n\n  var batch = [];\n  var lod = tree.range(range, {\n    lod: true,\n    px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]\n  }); // enable elements by using selection buffer\n\n  if (elements) {\n    var markerActivation = activation[markerId];\n    var mask = markerActivation.data;\n    var data = new Uint8Array(count);\n\n    for (var i = 0; i < elements.length; i++) {\n      var id = elements[i];\n      data[id] = mask ? mask[id] : 1;\n    }\n\n    selectionBuffer.subdata(data);\n  }\n\n  for (var l = lod.length; l--;) {\n    var _lod$l = _slicedToArray(lod[l], 2),\n        from = _lod$l[0],\n        to = _lod$l[1];\n\n    batch.push(extend({}, group, {\n      markerTexture: this.markerTextures[markerId],\n      activation: elements ? selectionBuffer : activation[markerId],\n      offset: from,\n      count: to - from\n    }));\n  }\n\n  return batch;\n}; // update groups options\n\n\nScatter.prototype.update = function () {\n  var _this3 = this;\n\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (!args.length) return; // passes are as single array\n\n  if (args.length === 1 && Array.isArray(args[0])) args = args[0];\n  var groups = this.groups,\n      gl = this.gl,\n      regl = this.regl,\n      maxSize = this.maxSize,\n      maxColors = this.maxColors,\n      palette = this.palette;\n  this.groups = groups = args.map(function (options, i) {\n    var group = groups[i];\n    if (options === undefined) return group;\n    if (options === null) options = {\n      positions: null\n    };else if (typeof options === 'function') options = {\n      ondraw: options\n    };else if (typeof options[0] === 'number') options = {\n      positions: options\n    }; // copy options to avoid mutation & handle aliases\n\n    options = pick(options, {\n      positions: 'positions data points',\n      snap: 'snap cluster lod tree',\n      size: 'sizes size radius',\n      borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n      color: 'colors color fill fill-color fillColor',\n      borderColor: 'borderColors borderColor stroke stroke-color strokeColor',\n      marker: 'markers marker shape',\n      range: 'range dataBox databox',\n      viewport: 'viewport viewPort viewBox viewbox',\n      opacity: 'opacity alpha transparency',\n      bounds: 'bound bounds boundaries limits',\n      tooManyColors: 'tooManyColors palette paletteMode optimizePalette enablePalette'\n    });\n    if (options.positions === null) options.positions = [];\n    if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;\n\n    if (!group) {\n      groups[i] = group = {\n        id: i,\n        scale: null,\n        translate: null,\n        scaleFract: null,\n        translateFract: null,\n        // buffers for active markers\n        activation: [],\n        // buffer for filtered markers\n        selectionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'stream',\n          type: 'uint8'\n        }),\n        // buffers with data: it is faster to switch them per-pass\n        // than provide one congregate buffer\n        sizeBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        colorBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'uint8'\n        }),\n        positionBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        }),\n        positionFractBuffer: regl.buffer({\n          data: new Uint8Array(0),\n          usage: 'dynamic',\n          type: 'float'\n        })\n      };\n      options = extend({}, Scatter.defaults, options);\n    } // force update triggers\n\n\n    if (options.positions && !('marker' in options)) {\n      options.marker = group.marker;\n      delete group.marker;\n    } // updating markers cause recalculating snapping\n\n\n    if (options.marker && !('positions' in options)) {\n      options.positions = group.positions;\n      delete group.positions;\n    } // global count of points\n\n\n    var hasSize = 0,\n        hasColor = 0;\n    updateDiff(group, options, [{\n      snap: true,\n      size: function size(s, group) {\n        if (s == null) s = Scatter.defaults.size;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      borderSize: function borderSize(s, group) {\n        if (s == null) s = Scatter.defaults.borderSize;\n        hasSize += s && s.length ? 1 : 0;\n        return s;\n      },\n      opacity: parseFloat,\n      // add colors to palette, save references\n      color: function color(c, group) {\n        if (c == null) c = Scatter.defaults.color;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      borderColor: function borderColor(c, group) {\n        if (c == null) c = Scatter.defaults.borderColor;\n        c = _this3.updateColor(c);\n        hasColor++;\n        return c;\n      },\n      bounds: function bounds(_bounds, group, options) {\n        if (!('range' in options)) options.range = null;\n        return _bounds;\n      },\n      positions: function positions(_positions, group, options) {\n        var snap = group.snap;\n        var positionBuffer = group.positionBuffer,\n            positionFractBuffer = group.positionFractBuffer,\n            selectionBuffer = group.selectionBuffer; // separate buffers for x/y coordinates\n\n        if (_positions.x || _positions.y) {\n          if (_positions.x.length) {\n            group.xAttr = {\n              buffer: regl.buffer(_positions.x),\n              offset: 0,\n              stride: 4,\n              count: _positions.x.length\n            };\n          } else {\n            group.xAttr = {\n              buffer: _positions.x.buffer,\n              offset: _positions.x.offset * 4 || 0,\n              stride: (_positions.x.stride || 1) * 4,\n              count: _positions.x.count\n            };\n          }\n\n          if (_positions.y.length) {\n            group.yAttr = {\n              buffer: regl.buffer(_positions.y),\n              offset: 0,\n              stride: 4,\n              count: _positions.y.length\n            };\n          } else {\n            group.yAttr = {\n              buffer: _positions.y.buffer,\n              offset: _positions.y.offset * 4 || 0,\n              stride: (_positions.y.stride || 1) * 4,\n              count: _positions.y.count\n            };\n          }\n\n          group.count = Math.max(group.xAttr.count, group.yAttr.count);\n          return _positions;\n        }\n\n        _positions = flatten(_positions, 'float64');\n        var count = group.count = Math.floor(_positions.length / 2);\n        var bounds = group.bounds = count ? getBounds(_positions, 2) : null; // if range is not provided updated - recalc it\n\n        if (!options.range && !group.range) {\n          delete group.range;\n          options.range = bounds;\n        } // reset marker\n\n\n        if (!options.marker && !group.marker) {\n          delete group.marker;\n          options.marker = null;\n        } // build cluster tree if required\n\n\n        if (snap && (snap === true || count > snap)) {\n          group.tree = cluster(_positions, {\n            bounds: bounds\n          });\n        } // existing tree instance\n        else if (snap && snap.length) {\n            group.tree = snap;\n          }\n\n        if (group.tree) {\n          var opts = {\n            primitive: 'points',\n            usage: 'static',\n            data: group.tree,\n            type: 'uint32'\n          };\n          if (group.elements) group.elements(opts);else group.elements = regl.elements(opts);\n        } // update position buffers\n\n\n        var float_data = f32.float32(_positions);\n        positionBuffer({\n          data: float_data,\n          usage: 'dynamic'\n        });\n        var frac_data = f32.fract32(_positions, float_data);\n        positionFractBuffer({\n          data: frac_data,\n          usage: 'dynamic'\n        }); // expand selectionBuffer\n\n        selectionBuffer({\n          data: new Uint8Array(count),\n          type: 'uint8',\n          usage: 'stream'\n        });\n        return _positions;\n      }\n    }, {\n      // create marker ids corresponding to known marker textures\n      marker: function marker(markers, group, options) {\n        var activation = group.activation; // reset marker elements\n\n        activation.forEach(function (buffer) {\n          return buffer && buffer.destroy && buffer.destroy();\n        });\n        activation.length = 0; // single sdf marker\n\n        if (!markers || typeof markers[0] === 'number') {\n          var id = _this3.addMarker(markers);\n\n          activation[id] = true;\n        } // per-point markers use mask buffers to enable markers in vert shader\n        else {\n            var markerMasks = [];\n\n            for (var _i = 0, l = Math.min(markers.length, group.count); _i < l; _i++) {\n              var _id = _this3.addMarker(markers[_i]);\n\n              if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group.count); // enable marker by default\n\n              markerMasks[_id][_i] = 1;\n            }\n\n            for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {\n              if (!markerMasks[_id2]) continue;\n              var opts = {\n                data: markerMasks[_id2],\n                type: 'uint8',\n                usage: 'static'\n              };\n\n              if (!activation[_id2]) {\n                activation[_id2] = regl.buffer(opts);\n              } else {\n                activation[_id2](opts);\n              }\n\n              activation[_id2].data = markerMasks[_id2];\n            }\n          }\n\n        return markers;\n      },\n      range: function range(_range, group, options) {\n        var bounds = group.bounds; // FIXME: why do we need this?\n\n        if (!bounds) return;\n        if (!_range) _range = bounds;\n        group.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];\n        group.translate = [-_range[0], -_range[1]];\n        group.scaleFract = f32.fract(group.scale);\n        group.translateFract = f32.fract(group.translate);\n        return _range;\n      },\n      viewport: function viewport(vp) {\n        var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]); // normalize viewport to the canvas coordinates\n        // rect.y = gl.drawingBufferHeight - rect.height - rect.y\n\n        return rect;\n      }\n    }]); // update size buffer, if needed\n\n    if (hasSize) {\n      var _group = group,\n          count = _group.count,\n          size = _group.size,\n          borderSize = _group.borderSize,\n          sizeBuffer = _group.sizeBuffer;\n      var sizes = new Uint8Array(count * 2);\n\n      if (size.length || borderSize.length) {\n        for (var _i2 = 0; _i2 < count; _i2++) {\n          // we downscale size to allow for fractions\n          sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);\n          sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);\n        }\n      }\n\n      sizeBuffer({\n        data: sizes,\n        usage: 'dynamic'\n      });\n    } // update color buffer if needed\n\n\n    if (hasColor) {\n      var _group2 = group,\n          _count = _group2.count,\n          color = _group2.color,\n          borderColor = _group2.borderColor,\n          colorBuffer = _group2.colorBuffer;\n      var colors; // if too many colors - put colors to buffer directly\n\n      if (_this3.tooManyColors) {\n        if (color.length || borderColor.length) {\n          colors = new Uint8Array(_count * 8);\n\n          for (var _i3 = 0; _i3 < _count; _i3++) {\n            var _colorId = color[_i3];\n            colors[_i3 * 8] = palette[_colorId * 4];\n            colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];\n            colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];\n            colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];\n            var borderColorId = borderColor[_i3];\n            colors[_i3 * 8 + 4] = palette[borderColorId * 4];\n            colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];\n            colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];\n            colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];\n          }\n        }\n      } // if limited amount of colors - keep palette color picking\n      // that saves significant memory\n      else {\n          if (color.length || borderColor.length) {\n            // we need slight data increase by 2 due to vec4 borderId in shader\n            colors = new Uint8Array(_count * 4 + 2);\n\n            for (var _i4 = 0; _i4 < _count; _i4++) {\n              // put color coords in palette texture\n              if (color[_i4] != null) {\n                colors[_i4 * 4] = color[_i4] % maxColors;\n                colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);\n              }\n\n              if (borderColor[_i4] != null) {\n                colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;\n                colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);\n              }\n            }\n          }\n        }\n\n      colorBuffer({\n        data: colors || new Uint8Array(0),\n        type: 'uint8',\n        usage: 'dynamic'\n      });\n    }\n\n    return group;\n  });\n}; // get (and create) marker texture id\n\n\nScatter.prototype.addMarker = function (sdf) {\n  var markerTextures = this.markerTextures,\n      regl = this.regl,\n      markerCache = this.markerCache;\n  var pos = sdf == null ? 0 : markerCache.indexOf(sdf);\n  if (pos >= 0) return pos; // convert sdf to 0..255 range\n\n  var distArr;\n\n  if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {\n    distArr = sdf;\n  } else {\n    distArr = new Uint8Array(sdf.length);\n\n    for (var i = 0, l = sdf.length; i < l; i++) {\n      distArr[i] = sdf[i] * 255;\n    }\n  }\n\n  var radius = Math.floor(Math.sqrt(distArr.length));\n  pos = markerTextures.length;\n  markerCache.push(sdf);\n  markerTextures.push(regl.texture({\n    channels: 1,\n    data: distArr,\n    radius: radius,\n    mag: 'linear',\n    min: 'linear'\n  }));\n  return pos;\n}; // register color to palette, return it's index or list of indexes\n\n\nScatter.prototype.updateColor = function (colors) {\n  var paletteIds = this.paletteIds,\n      palette = this.palette,\n      maxColors = this.maxColors;\n\n  if (!Array.isArray(colors)) {\n    colors = [colors];\n  }\n\n  var idx = []; // if color groups - flatten them\n\n  if (typeof colors[0] === 'number') {\n    var grouped = [];\n\n    if (Array.isArray(colors)) {\n      for (var i = 0; i < colors.length; i += 4) {\n        grouped.push(colors.slice(i, i + 4));\n      }\n    } else {\n      for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {\n        grouped.push(colors.subarray(_i5, _i5 + 4));\n      }\n    }\n\n    colors = grouped;\n  }\n\n  for (var _i6 = 0; _i6 < colors.length; _i6++) {\n    var color = colors[_i6];\n    color = rgba(color, 'uint8');\n    var id = colorId(color, false); // if new color - save it\n\n    if (paletteIds[id] == null) {\n      var pos = palette.length;\n      paletteIds[id] = Math.floor(pos / 4);\n      palette[pos] = color[0];\n      palette[pos + 1] = color[1];\n      palette[pos + 2] = color[2];\n      palette[pos + 3] = color[3];\n    }\n\n    idx[_i6] = paletteIds[id];\n  } // detect if too many colors in palette\n\n\n  if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true; // limit max color\n\n  this.updatePalette(palette); // keep static index for single-color property\n\n  return idx.length === 1 ? idx[0] : idx;\n};\n\nScatter.prototype.updatePalette = function (palette) {\n  if (this.tooManyColors) return;\n  var maxColors = this.maxColors,\n      paletteTexture = this.paletteTexture;\n  var requiredHeight = Math.ceil(palette.length * .25 / maxColors); // pad data\n\n  if (requiredHeight > 1) {\n    palette = palette.slice();\n\n    for (var i = palette.length * .25 % maxColors; i < requiredHeight * maxColors; i++) {\n      palette.push(0, 0, 0, 0);\n    }\n  } // ensure height\n\n\n  if (paletteTexture.height < requiredHeight) {\n    paletteTexture.resize(maxColors, requiredHeight);\n  } // update full data\n\n\n  paletteTexture.subimage({\n    width: Math.min(palette.length * .25, maxColors),\n    height: requiredHeight,\n    data: palette\n  }, 0, 0);\n}; // remove unused stuff\n\n\nScatter.prototype.destroy = function () {\n  this.groups.forEach(function (group) {\n    group.sizeBuffer.destroy();\n    group.positionBuffer.destroy();\n    group.positionFractBuffer.destroy();\n    group.colorBuffer.destroy();\n    group.activation.forEach(function (b) {\n      return b && b.destroy && b.destroy();\n    });\n    group.selectionBuffer.destroy();\n    if (group.elements) group.elements.destroy();\n  });\n  this.groups.length = 0;\n  this.paletteTexture.destroy();\n  this.markerTextures.forEach(function (txt) {\n    return txt && txt.destroy && txt.destroy();\n  });\n  return this;\n};\n\nvar extend$1 = require('object-assign');\n\nvar reglScatter2d = function reglScatter2d(regl, options) {\n  var scatter$1 = new scatter(regl, options);\n  var render = scatter$1.render.bind(scatter$1); // expose API\n\n  extend$1(render, {\n    render: render,\n    update: scatter$1.update.bind(scatter$1),\n    draw: scatter$1.draw.bind(scatter$1),\n    destroy: scatter$1.destroy.bind(scatter$1),\n    regl: scatter$1.regl,\n    gl: scatter$1.gl,\n    canvas: scatter$1.gl.canvas,\n    groups: scatter$1.groups,\n    markers: scatter$1.markerCache,\n    palette: scatter$1.palette\n  });\n  return render;\n};\n\nmodule.exports = reglScatter2d;","map":null,"metadata":{},"sourceType":"script"}