{"ast":null,"code":"'use strict';\n\nvar createMesh = require('../../../stackgl_modules').gl_mesh3d;\n\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\n\nvar str2RgbaArray = require('../../lib/str2rgbarray');\n\nvar extractOpts = require('../../components/colorscale').extractOpts;\n\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar findNearestOnAxis = function findNearestOnAxis(w, arr) {\n  for (var q = arr.length - 1; q > 0; q--) {\n    var min = Math.min(arr[q], arr[q - 1]);\n    var max = Math.max(arr[q], arr[q - 1]);\n\n    if (max > min && min < w && w <= max) {\n      return {\n        id: q,\n        distRatio: (max - w) / (max - min)\n      };\n    }\n  }\n\n  return {\n    id: 0,\n    distRatio: 0\n  };\n};\n\nfunction IsosurfaceTrace(scene, mesh, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = mesh;\n  this.name = '';\n  this.data = null;\n  this.showContour = false;\n}\n\nvar proto = IsosurfaceTrace.prototype;\n\nproto.handlePick = function (selection) {\n  if (selection.object === this.mesh) {\n    var rawId = selection.data.index;\n    var x = this.data._meshX[rawId];\n    var y = this.data._meshY[rawId];\n    var z = this.data._meshZ[rawId];\n    var height = this.data._Ys.length;\n    var depth = this.data._Zs.length;\n    var i = findNearestOnAxis(x, this.data._Xs).id;\n    var j = findNearestOnAxis(y, this.data._Ys).id;\n    var k = findNearestOnAxis(z, this.data._Zs).id;\n    var selectIndex = selection.index = k + depth * j + depth * height * i;\n    selection.traceCoordinate = [this.data._meshX[selectIndex], this.data._meshY[selectIndex], this.data._meshZ[selectIndex], this.data._value[selectIndex]];\n    var text = this.data.hovertext || this.data.text;\n\n    if (Array.isArray(text) && text[selectIndex] !== undefined) {\n      selection.textLabel = text[selectIndex];\n    } else if (text) {\n      selection.textLabel = text;\n    }\n\n    return true;\n  }\n};\n\nproto.update = function (data) {\n  var scene = this.scene;\n  var layout = scene.fullSceneLayout;\n  this.data = generateIsoMeshes(data); // Unpack position data\n\n  function toDataCoords(axis, coord, scale, calendar) {\n    return coord.map(function (x) {\n      return axis.d2l(x, 0, calendar) * scale;\n    });\n  }\n\n  var positions = zip3(toDataCoords(layout.xaxis, data._meshX, scene.dataScale[0], data.xcalendar), toDataCoords(layout.yaxis, data._meshY, scene.dataScale[1], data.ycalendar), toDataCoords(layout.zaxis, data._meshZ, scene.dataScale[2], data.zcalendar));\n  var cells = zip3(data._meshI, data._meshJ, data._meshK);\n  var config = {\n    positions: positions,\n    cells: cells,\n    lightPosition: [data.lightposition.x, data.lightposition.y, data.lightposition.z],\n    ambient: data.lighting.ambient,\n    diffuse: data.lighting.diffuse,\n    specular: data.lighting.specular,\n    roughness: data.lighting.roughness,\n    fresnel: data.lighting.fresnel,\n    vertexNormalsEpsilon: data.lighting.vertexnormalsepsilon,\n    faceNormalsEpsilon: data.lighting.facenormalsepsilon,\n    opacity: data.opacity,\n    contourEnable: data.contour.show,\n    contourColor: str2RgbaArray(data.contour.color).slice(0, 3),\n    contourWidth: data.contour.width,\n    useFacetNormals: data.flatshading\n  };\n  var cOpts = extractOpts(data);\n  config.vertexIntensity = data._meshIntensity;\n  config.vertexIntensityBounds = [cOpts.min, cOpts.max];\n  config.colormap = parseColorScale(data); // Update mesh\n\n  this.mesh.update(config);\n};\n\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\n\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\nfunction generateIsoMeshes(data) {\n  data._meshI = [];\n  data._meshJ = [];\n  data._meshK = [];\n  var showSurface = data.surface.show;\n  var showSpaceframe = data.spaceframe.show;\n  var surfaceFill = data.surface.fill;\n  var spaceframeFill = data.spaceframe.fill;\n  var drawingSurface = false;\n  var drawingSpaceframe = false;\n  var numFaces = 0;\n  var numVertices;\n  var beginVertextLength;\n  var Xs = data._Xs;\n  var Ys = data._Ys;\n  var Zs = data._Zs;\n  var width = Xs.length;\n  var height = Ys.length;\n  var depth = Zs.length;\n  var filled = GRID_TYPES.indexOf(data._gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n  var getIndex = function getIndex(i, j, k) {\n    switch (filled) {\n      case 5:\n        // 'zyx'\n        return k + depth * j + depth * height * i;\n\n      case 4:\n        // 'zxy'\n        return k + depth * i + depth * width * j;\n\n      case 3:\n        // 'yzx'\n        return j + height * k + height * depth * i;\n\n      case 2:\n        // 'yxz'\n        return j + height * i + height * width * k;\n\n      case 1:\n        // 'xzy'\n        return i + width * k + width * depth * j;\n\n      default:\n        // case 0: // 'xyz'\n        return i + width * j + width * height * k;\n    }\n  };\n\n  var minValues = data._minValues;\n  var maxValues = data._maxValues;\n  var vMin = data._vMin;\n  var vMax = data._vMax;\n  var allXs;\n  var allYs;\n  var allZs;\n  var allVs;\n\n  function findVertexId(x, y, z) {\n    // could be used to find the vertex id of previously generated vertex within the group\n    var len = allVs.length;\n\n    for (var f = beginVertextLength; f < len; f++) {\n      if (x === allXs[f] && y === allYs[f] && z === allZs[f]) {\n        return f;\n      }\n    }\n\n    return -1;\n  }\n\n  function beginGroup() {\n    beginVertextLength = numVertices;\n  }\n\n  function emptyVertices() {\n    allXs = [];\n    allYs = [];\n    allZs = [];\n    allVs = [];\n    numVertices = 0;\n    beginGroup();\n  }\n\n  function addVertex(x, y, z, v) {\n    allXs.push(x);\n    allYs.push(y);\n    allZs.push(z);\n    allVs.push(v);\n    numVertices++;\n    return numVertices - 1;\n  }\n\n  function addFace(a, b, c) {\n    data._meshI.push(a);\n\n    data._meshJ.push(b);\n\n    data._meshK.push(c);\n\n    numFaces++;\n    return numFaces - 1;\n  }\n\n  function getCenter(A, B, C) {\n    var M = [];\n\n    for (var i = 0; i < A.length; i++) {\n      M[i] = (A[i] + B[i] + C[i]) / 3.0;\n    }\n\n    return M;\n  }\n\n  function getBetween(A, B, r) {\n    var M = [];\n\n    for (var i = 0; i < A.length; i++) {\n      M[i] = A[i] * (1 - r) + r * B[i];\n    }\n\n    return M;\n  }\n\n  var activeFill;\n\n  function setFill(fill) {\n    activeFill = fill;\n  }\n\n  function createOpenTri(xyzv, abc) {\n    var A = xyzv[0];\n    var B = xyzv[1];\n    var C = xyzv[2];\n    var G = getCenter(A, B, C);\n    var r = Math.sqrt(1 - activeFill);\n    var p1 = getBetween(G, A, r);\n    var p2 = getBetween(G, B, r);\n    var p3 = getBetween(G, C, r);\n    var a = abc[0];\n    var b = abc[1];\n    var c = abc[2];\n    return {\n      xyzv: [[A, B, p2], [p2, p1, A], [B, C, p3], [p3, p2, B], [C, A, p1], [p1, p3, C]],\n      abc: [[a, b, -1], [-1, -1, a], [b, c, -1], [-1, -1, b], [c, a, -1], [-1, -1, c]]\n    };\n  }\n\n  function styleIncludes(style, char) {\n    if (style === 'all' || style === null) return true;\n    return style.indexOf(char) > -1;\n  }\n\n  function mapValue(style, value) {\n    if (style === null) return value;\n    return style;\n  }\n\n  function drawTri(style, xyzv, abc) {\n    beginGroup();\n    var allXYZVs = [xyzv];\n    var allABCs = [abc];\n\n    if (activeFill >= 1) {\n      allXYZVs = [xyzv];\n      allABCs = [abc];\n    } else if (activeFill > 0) {\n      var openTri = createOpenTri(xyzv, abc);\n      allXYZVs = openTri.xyzv;\n      allABCs = openTri.abc;\n    }\n\n    for (var f = 0; f < allXYZVs.length; f++) {\n      xyzv = allXYZVs[f];\n      abc = allABCs[f];\n      var pnts = [];\n\n      for (var i = 0; i < 3; i++) {\n        var x = xyzv[i][0];\n        var y = xyzv[i][1];\n        var z = xyzv[i][2];\n        var v = xyzv[i][3];\n        var id = abc[i] > -1 ? abc[i] : findVertexId(x, y, z);\n\n        if (id > -1) {\n          pnts[i] = id;\n        } else {\n          pnts[i] = addVertex(x, y, z, mapValue(style, v));\n        }\n      }\n\n      addFace(pnts[0], pnts[1], pnts[2]);\n    }\n  }\n\n  function drawQuad(style, xyzv, abcd) {\n    var makeTri = function makeTri(i, j, k) {\n      drawTri(style, [xyzv[i], xyzv[j], xyzv[k]], [abcd[i], abcd[j], abcd[k]]);\n    };\n\n    makeTri(0, 1, 2);\n    makeTri(2, 3, 0);\n  }\n\n  function drawTetra(style, xyzv, abcd) {\n    var makeTri = function makeTri(i, j, k) {\n      drawTri(style, [xyzv[i], xyzv[j], xyzv[k]], [abcd[i], abcd[j], abcd[k]]);\n    };\n\n    makeTri(0, 1, 2);\n    makeTri(3, 0, 1);\n    makeTri(2, 3, 0);\n    makeTri(1, 2, 3);\n  }\n\n  function calcIntersection(pointOut, pointIn, min, max) {\n    var value = pointOut[3];\n    if (value < min) value = min;\n    if (value > max) value = max;\n    var ratio = (pointOut[3] - value) / (pointOut[3] - pointIn[3] + 0.000000001); // we had to add this error to force solve the tiny caps\n\n    var result = [];\n\n    for (var s = 0; s < 4; s++) {\n      result[s] = (1 - ratio) * pointOut[s] + ratio * pointIn[s];\n    }\n\n    return result;\n  }\n\n  function inRange(value, min, max) {\n    return value >= min && value <= max;\n  }\n\n  function almostInFinalRange(value) {\n    var vErr = 0.001 * (vMax - vMin);\n    return value >= vMin - vErr && value <= vMax + vErr;\n  }\n\n  function getXYZV(indecies) {\n    var xyzv = [];\n\n    for (var q = 0; q < 4; q++) {\n      var index = indecies[q];\n      xyzv.push([data._x[index], data._y[index], data._z[index], data._value[index]]);\n    }\n\n    return xyzv;\n  }\n\n  var MAX_PASS = 3;\n\n  function tryCreateTri(style, xyzv, abc, min, max, nPass) {\n    if (!nPass) nPass = 1;\n    abc = [-1, -1, -1]; // Note: for the moment we override indices\n    // to run faster! But it is possible to comment this line\n    // to reduce the number of vertices.\n\n    var result = false;\n    var ok = [inRange(xyzv[0][3], min, max), inRange(xyzv[1][3], min, max), inRange(xyzv[2][3], min, max)];\n\n    if (!ok[0] && !ok[1] && !ok[2]) {\n      return false;\n    }\n\n    var tryDrawTri = function tryDrawTri(style, xyzv, abc) {\n      if ( // we check here if the points are in `real` iso-min/max range\n      almostInFinalRange(xyzv[0][3]) && almostInFinalRange(xyzv[1][3]) && almostInFinalRange(xyzv[2][3])) {\n        drawTri(style, xyzv, abc);\n        return true;\n      } else if (nPass < MAX_PASS) {\n        return tryCreateTri(style, xyzv, abc, vMin, vMax, ++nPass); // i.e. second pass using actual vMin vMax bounds\n      }\n\n      return false;\n    };\n\n    if (ok[0] && ok[1] && ok[2]) {\n      return tryDrawTri(style, xyzv, abc) || result;\n    }\n\n    var interpolated = false;\n    [[0, 1, 2], [2, 0, 1], [1, 2, 0]].forEach(function (e) {\n      if (ok[e[0]] && ok[e[1]] && !ok[e[2]]) {\n        var A = xyzv[e[0]];\n        var B = xyzv[e[1]];\n        var C = xyzv[e[2]];\n        var p1 = calcIntersection(C, A, min, max);\n        var p2 = calcIntersection(C, B, min, max);\n        result = tryDrawTri(style, [p2, p1, A], [-1, -1, abc[e[0]]]) || result;\n        result = tryDrawTri(style, [A, B, p2], [abc[e[0]], abc[e[1]], -1]) || result;\n        interpolated = true;\n      }\n    });\n    if (interpolated) return result;\n    [[0, 1, 2], [1, 2, 0], [2, 0, 1]].forEach(function (e) {\n      if (ok[e[0]] && !ok[e[1]] && !ok[e[2]]) {\n        var A = xyzv[e[0]];\n        var B = xyzv[e[1]];\n        var C = xyzv[e[2]];\n        var p1 = calcIntersection(B, A, min, max);\n        var p2 = calcIntersection(C, A, min, max);\n        result = tryDrawTri(style, [p2, p1, A], [-1, -1, abc[e[0]]]) || result;\n        interpolated = true;\n      }\n    });\n    return result;\n  }\n\n  function tryCreateTetra(style, abcd, min, max) {\n    var result = false;\n    var xyzv = getXYZV(abcd);\n    var ok = [inRange(xyzv[0][3], min, max), inRange(xyzv[1][3], min, max), inRange(xyzv[2][3], min, max), inRange(xyzv[3][3], min, max)];\n\n    if (!ok[0] && !ok[1] && !ok[2] && !ok[3]) {\n      return result;\n    }\n\n    if (ok[0] && ok[1] && ok[2] && ok[3]) {\n      if (drawingSpaceframe) {\n        result = drawTetra(style, xyzv, abcd) || result;\n      }\n\n      return result;\n    }\n\n    var interpolated = false;\n    [[0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0]].forEach(function (e) {\n      if (ok[e[0]] && ok[e[1]] && ok[e[2]] && !ok[e[3]]) {\n        var A = xyzv[e[0]];\n        var B = xyzv[e[1]];\n        var C = xyzv[e[2]];\n        var D = xyzv[e[3]];\n\n        if (drawingSpaceframe) {\n          result = drawTri(style, [A, B, C], [abcd[e[0]], abcd[e[1]], abcd[e[2]]]) || result;\n        } else {\n          var p1 = calcIntersection(D, A, min, max);\n          var p2 = calcIntersection(D, B, min, max);\n          var p3 = calcIntersection(D, C, min, max);\n          result = drawTri(null, [p1, p2, p3], [-1, -1, -1]) || result;\n        }\n\n        interpolated = true;\n      }\n    });\n    if (interpolated) return result;\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2], [0, 2, 3, 1], [1, 3, 2, 0]].forEach(function (e) {\n      if (ok[e[0]] && ok[e[1]] && !ok[e[2]] && !ok[e[3]]) {\n        var A = xyzv[e[0]];\n        var B = xyzv[e[1]];\n        var C = xyzv[e[2]];\n        var D = xyzv[e[3]];\n        var p1 = calcIntersection(C, A, min, max);\n        var p2 = calcIntersection(C, B, min, max);\n        var p3 = calcIntersection(D, B, min, max);\n        var p4 = calcIntersection(D, A, min, max);\n\n        if (drawingSpaceframe) {\n          result = drawTri(style, [A, p4, p1], [abcd[e[0]], -1, -1]) || result;\n          result = drawTri(style, [B, p2, p3], [abcd[e[1]], -1, -1]) || result;\n        } else {\n          result = drawQuad(null, [p1, p2, p3, p4], [-1, -1, -1, -1]) || result;\n        }\n\n        interpolated = true;\n      }\n    });\n    if (interpolated) return result;\n    [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2]].forEach(function (e) {\n      if (ok[e[0]] && !ok[e[1]] && !ok[e[2]] && !ok[e[3]]) {\n        var A = xyzv[e[0]];\n        var B = xyzv[e[1]];\n        var C = xyzv[e[2]];\n        var D = xyzv[e[3]];\n        var p1 = calcIntersection(B, A, min, max);\n        var p2 = calcIntersection(C, A, min, max);\n        var p3 = calcIntersection(D, A, min, max);\n\n        if (drawingSpaceframe) {\n          result = drawTri(style, [A, p1, p2], [abcd[e[0]], -1, -1]) || result;\n          result = drawTri(style, [A, p2, p3], [abcd[e[0]], -1, -1]) || result;\n          result = drawTri(style, [A, p3, p1], [abcd[e[0]], -1, -1]) || result;\n        } else {\n          result = drawTri(null, [p1, p2, p3], [-1, -1, -1]) || result;\n        }\n\n        interpolated = true;\n      }\n    });\n    return result;\n  }\n\n  function addCube(style, p000, p001, p010, p011, p100, p101, p110, p111, min, max) {\n    var result = false;\n\n    if (drawingSurface) {\n      if (styleIncludes(style, 'A')) {\n        result = tryCreateTetra(null, [p000, p001, p010, p100], min, max) || result;\n      }\n\n      if (styleIncludes(style, 'B')) {\n        result = tryCreateTetra(null, [p001, p010, p011, p111], min, max) || result;\n      }\n\n      if (styleIncludes(style, 'C')) {\n        result = tryCreateTetra(null, [p001, p100, p101, p111], min, max) || result;\n      }\n\n      if (styleIncludes(style, 'D')) {\n        result = tryCreateTetra(null, [p010, p100, p110, p111], min, max) || result;\n      }\n\n      if (styleIncludes(style, 'E')) {\n        result = tryCreateTetra(null, [p001, p010, p100, p111], min, max) || result;\n      }\n    }\n\n    if (drawingSpaceframe) {\n      result = tryCreateTetra(style, [p001, p010, p100, p111], min, max) || result;\n    }\n\n    return result;\n  }\n\n  function addRect(style, a, b, c, d, min, max, previousResult) {\n    return [previousResult[0] === true ? true : tryCreateTri(style, getXYZV([a, b, c]), [a, b, c], min, max), previousResult[1] === true ? true : tryCreateTri(style, getXYZV([c, d, a]), [c, d, a], min, max)];\n  }\n\n  function begin2dCell(style, p00, p01, p10, p11, min, max, isEven, previousResult) {\n    // used to create caps and/or slices on exact axis points\n    if (isEven) {\n      return addRect(style, p00, p01, p11, p10, min, max, previousResult);\n    } else {\n      return addRect(style, p01, p11, p10, p00, min, max, previousResult);\n    }\n  }\n\n  function beginSection(style, i, j, k, min, max, distRatios) {\n    // used to create slices between axis points\n    var result = false;\n    var A, B, C, D;\n\n    var makeSection = function makeSection() {\n      result = tryCreateTri(style, [A, B, C], [-1, -1, -1], min, max) || result;\n      result = tryCreateTri(style, [C, D, A], [-1, -1, -1], min, max) || result;\n    };\n\n    var rX = distRatios[0];\n    var rY = distRatios[1];\n    var rZ = distRatios[2];\n\n    if (rX) {\n      A = getBetween(getXYZV([getIndex(i, j - 0, k - 0)])[0], getXYZV([getIndex(i - 1, j - 0, k - 0)])[0], rX);\n      B = getBetween(getXYZV([getIndex(i, j - 0, k - 1)])[0], getXYZV([getIndex(i - 1, j - 0, k - 1)])[0], rX);\n      C = getBetween(getXYZV([getIndex(i, j - 1, k - 1)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rX);\n      D = getBetween(getXYZV([getIndex(i, j - 1, k - 0)])[0], getXYZV([getIndex(i - 1, j - 1, k - 0)])[0], rX);\n      makeSection();\n    }\n\n    if (rY) {\n      A = getBetween(getXYZV([getIndex(i - 0, j, k - 0)])[0], getXYZV([getIndex(i - 0, j - 1, k - 0)])[0], rY);\n      B = getBetween(getXYZV([getIndex(i - 0, j, k - 1)])[0], getXYZV([getIndex(i - 0, j - 1, k - 1)])[0], rY);\n      C = getBetween(getXYZV([getIndex(i - 1, j, k - 1)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rY);\n      D = getBetween(getXYZV([getIndex(i - 1, j, k - 0)])[0], getXYZV([getIndex(i - 1, j - 1, k - 0)])[0], rY);\n      makeSection();\n    }\n\n    if (rZ) {\n      A = getBetween(getXYZV([getIndex(i - 0, j - 0, k)])[0], getXYZV([getIndex(i - 0, j - 0, k - 1)])[0], rZ);\n      B = getBetween(getXYZV([getIndex(i - 0, j - 1, k)])[0], getXYZV([getIndex(i - 0, j - 1, k - 1)])[0], rZ);\n      C = getBetween(getXYZV([getIndex(i - 1, j - 1, k)])[0], getXYZV([getIndex(i - 1, j - 1, k - 1)])[0], rZ);\n      D = getBetween(getXYZV([getIndex(i - 1, j - 0, k)])[0], getXYZV([getIndex(i - 1, j - 0, k - 1)])[0], rZ);\n      makeSection();\n    }\n\n    return result;\n  }\n\n  function begin3dCell(style, p000, p001, p010, p011, p100, p101, p110, p111, min, max, isEven) {\n    // used to create spaceframe and/or iso-surfaces\n    var cellStyle = style;\n\n    if (isEven) {\n      if (drawingSurface && style === 'even') cellStyle = null;\n      return addCube(cellStyle, p000, p001, p010, p011, p100, p101, p110, p111, min, max);\n    } else {\n      if (drawingSurface && style === 'odd') cellStyle = null;\n      return addCube(cellStyle, p111, p110, p101, p100, p011, p010, p001, p000, min, max);\n    }\n  }\n\n  function draw2dX(style, items, min, max, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var i = items[q];\n\n      for (var k = 1; k < depth; k++) {\n        for (var j = 1; j < height; j++) {\n          result.push(begin2dCell(style, getIndex(i, j - 1, k - 1), getIndex(i, j - 1, k), getIndex(i, j, k - 1), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function draw2dY(style, items, min, max, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var j = items[q];\n\n      for (var i = 1; i < width; i++) {\n        for (var k = 1; k < depth; k++) {\n          result.push(begin2dCell(style, getIndex(i - 1, j, k - 1), getIndex(i, j, k - 1), getIndex(i - 1, j, k), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function draw2dZ(style, items, min, max, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var k = items[q];\n\n      for (var j = 1; j < height; j++) {\n        for (var i = 1; i < width; i++) {\n          result.push(begin2dCell(style, getIndex(i - 1, j - 1, k), getIndex(i - 1, j, k), getIndex(i, j - 1, k), getIndex(i, j, k), min, max, (i + j + k) % 2, previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function draw3d(style, min, max) {\n    for (var k = 1; k < depth; k++) {\n      for (var j = 1; j < height; j++) {\n        for (var i = 1; i < width; i++) {\n          begin3dCell(style, getIndex(i - 1, j - 1, k - 1), getIndex(i - 1, j - 1, k), getIndex(i - 1, j, k - 1), getIndex(i - 1, j, k), getIndex(i, j - 1, k - 1), getIndex(i, j - 1, k), getIndex(i, j, k - 1), getIndex(i, j, k), min, max, (i + j + k) % 2);\n        }\n      }\n    }\n  }\n\n  function drawSpaceframe(style, min, max) {\n    drawingSpaceframe = true;\n    draw3d(style, min, max);\n    drawingSpaceframe = false;\n  }\n\n  function drawSurface(style, min, max) {\n    drawingSurface = true;\n    draw3d(style, min, max);\n    drawingSurface = false;\n  }\n\n  function drawSectionX(style, items, min, max, distRatios, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var i = items[q];\n\n      for (var k = 1; k < depth; k++) {\n        for (var j = 1; j < height; j++) {\n          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function drawSectionY(style, items, min, max, distRatios, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var j = items[q];\n\n      for (var i = 1; i < width; i++) {\n        for (var k = 1; k < depth; k++) {\n          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function drawSectionZ(style, items, min, max, distRatios, previousResult) {\n    var result = [];\n    var n = 0;\n\n    for (var q = 0; q < items.length; q++) {\n      var k = items[q];\n\n      for (var j = 1; j < height; j++) {\n        for (var i = 1; i < width; i++) {\n          result.push(beginSection(style, i, j, k, min, max, distRatios[q], previousResult && previousResult[n] ? previousResult[n] : []));\n          n++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function createRange(a, b) {\n    var range = [];\n\n    for (var q = a; q < b; q++) {\n      range.push(q);\n    }\n\n    return range;\n  }\n\n  function insertGridPoints() {\n    for (var i = 0; i < width; i++) {\n      for (var j = 0; j < height; j++) {\n        for (var k = 0; k < depth; k++) {\n          var index = getIndex(i, j, k);\n          addVertex(data._x[index], data._y[index], data._z[index], data._value[index]);\n        }\n      }\n    }\n  }\n\n  function drawAll() {\n    emptyVertices(); // insert grid points\n\n    insertGridPoints();\n    var activeStyle = null; // draw spaceframes\n\n    if (showSpaceframe && spaceframeFill) {\n      setFill(spaceframeFill);\n      drawSpaceframe(activeStyle, vMin, vMax);\n    } // draw iso-surfaces\n\n\n    if (showSurface && surfaceFill) {\n      setFill(surfaceFill);\n      var surfacePattern = data.surface.pattern;\n      var surfaceCount = data.surface.count;\n\n      for (var q = 0; q < surfaceCount; q++) {\n        var ratio = surfaceCount === 1 ? 0.5 : q / (surfaceCount - 1);\n        var level = (1 - ratio) * vMin + ratio * vMax;\n        var d1 = Math.abs(level - minValues);\n        var d2 = Math.abs(level - maxValues);\n        var ranges = d1 > d2 ? [minValues, level] : [level, maxValues];\n        drawSurface(surfacePattern, ranges[0], ranges[1]);\n      }\n    }\n\n    var setupMinMax = [[Math.min(vMin, maxValues), Math.max(vMin, maxValues)], [Math.min(minValues, vMax), Math.max(minValues, vMax)]];\n    ['x', 'y', 'z'].forEach(function (e) {\n      var preRes = [];\n\n      for (var s = 0; s < setupMinMax.length; s++) {\n        var count = 0;\n        var activeMin = setupMinMax[s][0];\n        var activeMax = setupMinMax[s][1]; // draw slices\n\n        var slice = data.slices[e];\n\n        if (slice.show && slice.fill) {\n          setFill(slice.fill);\n          var exactIndices = [];\n          var ceilIndices = [];\n          var distRatios = [];\n\n          if (slice.locations.length) {\n            for (var q = 0; q < slice.locations.length; q++) {\n              var near = findNearestOnAxis(slice.locations[q], e === 'x' ? Xs : e === 'y' ? Ys : Zs);\n\n              if (near.distRatio === 0) {\n                exactIndices.push(near.id);\n              } else if (near.id > 0) {\n                ceilIndices.push(near.id);\n\n                if (e === 'x') {\n                  distRatios.push([near.distRatio, 0, 0]);\n                } else if (e === 'y') {\n                  distRatios.push([0, near.distRatio, 0]);\n                } else {\n                  distRatios.push([0, 0, near.distRatio]);\n                }\n              }\n            }\n          } else {\n            if (e === 'x') {\n              exactIndices = createRange(1, width - 1);\n            } else if (e === 'y') {\n              exactIndices = createRange(1, height - 1);\n            } else {\n              exactIndices = createRange(1, depth - 1);\n            }\n          }\n\n          if (ceilIndices.length > 0) {\n            if (e === 'x') {\n              preRes[count] = drawSectionX(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);\n            } else if (e === 'y') {\n              preRes[count] = drawSectionY(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);\n            } else {\n              preRes[count] = drawSectionZ(activeStyle, ceilIndices, activeMin, activeMax, distRatios, preRes[count]);\n            }\n\n            count++;\n          }\n\n          if (exactIndices.length > 0) {\n            if (e === 'x') {\n              preRes[count] = draw2dX(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);\n            } else if (e === 'y') {\n              preRes[count] = draw2dY(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);\n            } else {\n              preRes[count] = draw2dZ(activeStyle, exactIndices, activeMin, activeMax, preRes[count]);\n            }\n\n            count++;\n          }\n        } // draw caps\n\n\n        var cap = data.caps[e];\n\n        if (cap.show && cap.fill) {\n          setFill(cap.fill);\n\n          if (e === 'x') {\n            preRes[count] = draw2dX(activeStyle, [0, width - 1], activeMin, activeMax, preRes[count]);\n          } else if (e === 'y') {\n            preRes[count] = draw2dY(activeStyle, [0, height - 1], activeMin, activeMax, preRes[count]);\n          } else {\n            preRes[count] = draw2dZ(activeStyle, [0, depth - 1], activeMin, activeMax, preRes[count]);\n          }\n\n          count++;\n        }\n      }\n    }); // remove vertices arrays (i.e. grid points) in case no face was created.\n\n    if (numFaces === 0) {\n      emptyVertices();\n    }\n\n    data._meshX = allXs;\n    data._meshY = allYs;\n    data._meshZ = allZs;\n    data._meshIntensity = allVs;\n    data._Xs = Xs;\n    data._Ys = Ys;\n    data._Zs = Zs;\n  }\n\n  drawAll();\n  return data;\n}\n\nfunction createIsosurfaceTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var mesh = createMesh({\n    gl: gl\n  });\n  var result = new IsosurfaceTrace(scene, mesh, data.uid);\n  mesh._trace = result;\n  result.update(data);\n  scene.glplot.add(mesh);\n  return result;\n}\n\nmodule.exports = {\n  findNearestOnAxis: findNearestOnAxis,\n  generateIsoMeshes: generateIsoMeshes,\n  createIsosurfaceTrace: createIsosurfaceTrace\n};","map":null,"metadata":{},"sourceType":"script"}