{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar tinycolor = require('tinycolor2');\n\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar dragElement = require('../dragelement');\n\nvar Lib = require('../../lib');\n\nvar strTranslate = Lib.strTranslate;\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar setCursor = require('../../lib/setcursor');\n\nvar Drawing = require('../drawing');\n\nvar Color = require('../color');\n\nvar Titles = require('../titles');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar flipScale = require('../colorscale/helpers').flipScale;\n\nvar handleAxisDefaults = require('../../plots/cartesian/axis_defaults');\n\nvar handleAxisPositionDefaults = require('../../plots/cartesian/position_defaults');\n\nvar axisLayoutAttrs = require('../../plots/cartesian/layout_attributes');\n\nvar alignmentConstants = require('../../constants/alignment');\n\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nvar cn = require('./constants').cn;\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  var colorBars = fullLayout._infolayer.selectAll('g.' + cn.colorbar).data(makeColorBarData(gd), function (opts) {\n    return opts._id;\n  });\n\n  colorBars.enter().append('g').attr('class', function (opts) {\n    return opts._id;\n  }).classed(cn.colorbar, true);\n  colorBars.each(function (opts) {\n    var g = d3.select(this);\n    Lib.ensureSingle(g, 'rect', cn.cbbg);\n    Lib.ensureSingle(g, 'g', cn.cbfills);\n    Lib.ensureSingle(g, 'g', cn.cblines);\n    Lib.ensureSingle(g, 'g', cn.cbaxis, function (s) {\n      s.classed(cn.crisp, true);\n    });\n    Lib.ensureSingle(g, 'g', cn.cbtitleunshift, function (s) {\n      s.append('g').classed(cn.cbtitle, true);\n    });\n    Lib.ensureSingle(g, 'rect', cn.cboutline);\n    var done = drawColorBar(g, opts, gd);\n    if (done && done.then) (gd._promises || []).push(done);\n\n    if (gd._context.edits.colorbarPosition) {\n      makeEditable(g, opts, gd);\n    }\n  });\n  colorBars.exit().each(function (opts) {\n    Plots.autoMargin(gd, opts._id);\n  }).remove();\n  colorBars.order();\n}\n\nfunction makeColorBarData(gd) {\n  var fullLayout = gd._fullLayout;\n  var calcdata = gd.calcdata;\n  var out = []; // single out item\n\n  var opts; // colorbar attr parent container\n\n  var cont; // trace attr container\n\n  var trace; // colorbar options\n\n  var cbOpt;\n\n  function initOpts(opts) {\n    return extendFlat(opts, {\n      // fillcolor can be a d3 scale, domain is z values, range is colors\n      // or leave it out for no fill,\n      // or set to a string constant for single-color fill\n      _fillcolor: null,\n      // line.color has the same options as fillcolor\n      _line: {\n        color: null,\n        width: null,\n        dash: null\n      },\n      // levels of lines to draw.\n      // note that this DOES NOT determine the extent of the bar\n      // that's given by the domain of fillcolor\n      // (or line.color if no fillcolor domain)\n      _levels: {\n        start: null,\n        end: null,\n        size: null\n      },\n      // separate fill levels (for example, heatmap coloring of a\n      // contour map) if this is omitted, fillcolors will be\n      // evaluated halfway between levels\n      _filllevels: null,\n      // for continuous colorscales: fill with a gradient instead of explicit levels\n      // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]\n      _fillgradient: null,\n      // when using a gradient, we need the data range specified separately\n      _zrange: null\n    });\n  }\n\n  function calcOpts() {\n    if (typeof cbOpt.calc === 'function') {\n      cbOpt.calc(gd, trace, opts);\n    } else {\n      opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;\n      opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];\n    }\n  }\n\n  for (var i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    trace = cd[0].trace;\n    var moduleOpts = trace._module.colorbar;\n\n    if (trace.visible === true && moduleOpts) {\n      var allowsMultiplotCbs = Array.isArray(moduleOpts);\n      var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];\n\n      for (var j = 0; j < cbOpts.length; j++) {\n        cbOpt = cbOpts[j];\n        var contName = cbOpt.container;\n        cont = contName ? trace[contName] : trace;\n\n        if (cont && cont.showscale) {\n          opts = initOpts(cont.colorbar);\n          opts._id = 'cb' + trace.uid + (allowsMultiplotCbs && contName ? '-' + contName : '');\n          opts._traceIndex = trace.index;\n          opts._propPrefix = (contName ? contName + '.' : '') + 'colorbar.';\n          opts._meta = trace._meta;\n          calcOpts();\n          out.push(opts);\n        }\n      }\n    }\n  }\n\n  for (var k in fullLayout._colorAxes) {\n    cont = fullLayout[k];\n\n    if (cont.showscale) {\n      var colorAxOpts = fullLayout._colorAxes[k];\n      opts = initOpts(cont.colorbar);\n      opts._id = 'cb' + k;\n      opts._propPrefix = k + '.colorbar.';\n      opts._meta = fullLayout._meta;\n      cbOpt = {\n        min: 'cmin',\n        max: 'cmax'\n      };\n\n      if (colorAxOpts[0] !== 'heatmap') {\n        trace = colorAxOpts[1];\n        cbOpt.calc = trace._module.colorbar.calc;\n      }\n\n      calcOpts();\n      out.push(opts);\n    }\n  }\n\n  return out;\n}\n\nfunction drawColorBar(g, opts, gd) {\n  var isVertical = opts.orientation === 'v';\n  var len = opts.len;\n  var lenmode = opts.lenmode;\n  var thickness = opts.thickness;\n  var thicknessmode = opts.thicknessmode;\n  var outlinewidth = opts.outlinewidth;\n  var borderwidth = opts.borderwidth;\n  var bgcolor = opts.bgcolor;\n  var xanchor = opts.xanchor;\n  var yanchor = opts.yanchor;\n  var xpad = opts.xpad;\n  var ypad = opts.ypad;\n  var optsX = opts.x;\n  var optsY = isVertical ? opts.y : 1 - opts.y;\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var fillColor = opts._fillcolor;\n  var line = opts._line;\n  var title = opts.title;\n  var titleSide = title.side;\n  var zrange = opts._zrange || d3.extent((typeof fillColor === 'function' ? fillColor : line.color).domain());\n  var lineColormap = typeof line.color === 'function' ? line.color : function () {\n    return line.color;\n  };\n  var fillColormap = typeof fillColor === 'function' ? fillColor : function () {\n    return fillColor;\n  };\n  var levelsIn = opts._levels;\n  var levelsOut = calcLevels(gd, opts, zrange);\n  var fillLevels = levelsOut.fill;\n  var lineLevels = levelsOut.line; // we calculate pixel sizes based on the specified graph size,\n  // not the actual (in case something pushed the margins around)\n  // which is a little odd but avoids an odd iterative effect\n  // when the colorbar itself is pushing the margins.\n  // but then the fractional size is calculated based on the\n  // actual graph size, so that the axes will size correctly.\n\n  var thickPx = Math.round(thickness * (thicknessmode === 'fraction' ? isVertical ? gs.w : gs.h : 1));\n  var thickFrac = thickPx / (isVertical ? gs.w : gs.h);\n  var lenPx = Math.round(len * (lenmode === 'fraction' ? isVertical ? gs.h : gs.w : 1));\n  var lenFrac = lenPx / (isVertical ? gs.h : gs.w); // x positioning: do it initially just for left anchor,\n  // then fix at the end (since we don't know the width yet)\n\n  var uPx = Math.round(isVertical ? optsX * gs.w + xpad : optsY * gs.h + ypad);\n  var xRatio = {\n    center: 0.5,\n    right: 1\n  }[xanchor] || 0;\n  var yRatio = {\n    top: 1,\n    middle: 0.5\n  }[yanchor] || 0; // for dragging... this is getting a little muddled...\n\n  var uFrac = isVertical ? optsX - xRatio * thickFrac : optsY - yRatio * thickFrac; // y/x positioning (for v/h) we can do correctly from the start\n\n  var vFrac = isVertical ? optsY - yRatio * lenFrac : optsX - xRatio * lenFrac;\n  var vPx = Math.round(isVertical ? gs.h * (1 - vFrac) : gs.w * vFrac); // stash a few things for makeEditable\n\n  opts._lenFrac = lenFrac;\n  opts._thickFrac = thickFrac;\n  opts._uFrac = uFrac;\n  opts._vFrac = vFrac; // stash mocked axis for contour label formatting\n\n  var ax = opts._axis = mockColorBarAxis(gd, opts, zrange); // position can't go in through supplyDefaults\n  // because that restricts it to [0,1]\n\n  ax.position = thickFrac + (isVertical ? optsX + xpad / gs.w : optsY + ypad / gs.h);\n  var topOrBottom = ['top', 'bottom'].indexOf(titleSide) !== -1;\n\n  if (isVertical && topOrBottom) {\n    ax.title.side = titleSide;\n    ax.titlex = optsX + xpad / gs.w;\n    ax.titley = vFrac + (title.side === 'top' ? lenFrac - ypad / gs.h : ypad / gs.h);\n  }\n\n  if (!isVertical && !topOrBottom) {\n    ax.title.side = titleSide;\n    ax.titley = optsY + ypad / gs.h;\n    ax.titlex = vFrac + xpad / gs.w; // right side\n  }\n\n  if (line.color && opts.tickmode === 'auto') {\n    ax.tickmode = 'linear';\n    ax.tick0 = levelsIn.start;\n    var dtick = levelsIn.size; // expand if too many contours, so we don't get too many ticks\n\n    var autoNtick = Lib.constrain(lenPx / 50, 4, 15) + 1;\n    var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);\n\n    if (dtFactor > 1) {\n      var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));\n      dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]); // if the contours are at round multiples, reset tick0\n      // so they're still at round multiples. Otherwise,\n      // keep the first label on the first contour level\n\n      if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {\n        ax.tick0 = 0;\n      }\n    }\n\n    ax.dtick = dtick;\n  } // set domain after init, because we may want to\n  // allow it outside [0,1]\n\n\n  ax.domain = isVertical ? [vFrac + ypad / gs.h, vFrac + lenFrac - ypad / gs.h] : [vFrac + xpad / gs.w, vFrac + lenFrac - xpad / gs.w];\n  ax.setScale();\n  g.attr('transform', strTranslate(Math.round(gs.l), Math.round(gs.t)));\n  var titleCont = g.select('.' + cn.cbtitleunshift).attr('transform', strTranslate(-Math.round(gs.l), -Math.round(gs.t)));\n  var ticklabelposition = ax.ticklabelposition;\n  var titleFontSize = ax.title.font.size;\n  var axLayer = g.select('.' + cn.cbaxis);\n  var titleEl;\n  var titleHeight = 0;\n  var titleWidth = 0;\n\n  function drawTitle(titleClass, titleOpts) {\n    var dfltTitleOpts = {\n      propContainer: ax,\n      propName: opts._propPrefix + 'title',\n      traceIndex: opts._traceIndex,\n      _meta: opts._meta,\n      placeholder: fullLayout._dfltTitle.colorbar,\n      containerGroup: g.select('.' + cn.cbtitle)\n    }; // this class-to-rotate thing with convertToTspans is\n    // getting hackier and hackier... delete groups with the\n    // wrong class (in case earlier the colorbar was drawn on\n    // a different side, I think?)\n\n    var otherClass = titleClass.charAt(0) === 'h' ? titleClass.substr(1) : 'h' + titleClass;\n    g.selectAll('.' + otherClass + ',.' + otherClass + '-math-group').remove();\n    Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));\n  }\n\n  function drawDummyTitle() {\n    // draw the title so we know how much room it needs\n    // when we squish the axis.\n    // On vertical colorbars this only applies to top or bottom titles, not right side.\n    // On horizontal colorbars this only applies to right, etc.\n    if (isVertical && topOrBottom || !isVertical && !topOrBottom) {\n      var x, y;\n\n      if (titleSide === 'top') {\n        x = xpad + gs.l + gs.w * optsX;\n        y = ypad + gs.t + gs.h * (1 - vFrac - lenFrac) + 3 + titleFontSize * 0.75;\n      }\n\n      if (titleSide === 'bottom') {\n        x = xpad + gs.l + gs.w * optsX;\n        y = ypad + gs.t + gs.h * (1 - vFrac) - 3 - titleFontSize * 0.25;\n      }\n\n      if (titleSide === 'right') {\n        y = ypad + gs.t + gs.h * optsY + 3 + titleFontSize * 0.75;\n        x = xpad + gs.l + gs.w * vFrac;\n      }\n\n      drawTitle(ax._id + 'title', {\n        attributes: {\n          x: x,\n          y: y,\n          'text-anchor': isVertical ? 'start' : 'middle'\n        }\n      });\n    }\n  }\n\n  function drawCbTitle() {\n    if (isVertical && !topOrBottom || !isVertical && topOrBottom) {\n      var pos = ax.position || 0;\n      var mid = ax._offset + ax._length / 2;\n      var x, y;\n\n      if (titleSide === 'right') {\n        y = mid;\n        x = gs.l + gs.w * pos + 10 + titleFontSize * (ax.showticklabels ? 1 : 0.5);\n      } else {\n        x = mid;\n\n        if (titleSide === 'bottom') {\n          y = gs.t + gs.h * pos + 10 + (ticklabelposition.indexOf('inside') === -1 ? ax.tickfont.size : 0) + (ax.ticks !== 'intside' ? opts.ticklen || 0 : 0);\n        }\n\n        if (titleSide === 'top') {\n          var nlines = title.text.split('<br>').length;\n          y = gs.t + gs.h * pos + 10 - thickPx - LINE_SPACING * titleFontSize * nlines;\n        }\n      }\n\n      drawTitle((isVertical ? // the 'h' + is a hack to get around the fact that\n      // convertToTspans rotates any 'y...' class by 90 degrees.\n      // TODO: find a better way to control this.\n      'h' : 'v') + ax._id + 'title', {\n        avoid: {\n          selection: d3.select(gd).selectAll('g.' + ax._id + 'tick'),\n          side: titleSide,\n          offsetTop: isVertical ? 0 : gs.t,\n          offsetLeft: isVertical ? gs.l : 0,\n          maxShift: isVertical ? fullLayout.width : fullLayout.height\n        },\n        attributes: {\n          x: x,\n          y: y,\n          'text-anchor': 'middle'\n        },\n        transform: {\n          rotate: isVertical ? -90 : 0,\n          offset: 0\n        }\n      });\n    }\n  }\n\n  function drawAxis() {\n    if (!isVertical && !topOrBottom || isVertical && topOrBottom) {\n      // squish the axis top to make room for the title\n      var titleGroup = g.select('.' + cn.cbtitle);\n      var titleText = titleGroup.select('text');\n      var titleTrans = [-outlinewidth / 2, outlinewidth / 2];\n      var mathJaxNode = titleGroup.select('.h' + ax._id + 'title-math-group').node();\n      var lineSize = 15.6;\n\n      if (titleText.node()) {\n        lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;\n      }\n\n      var bb;\n\n      if (mathJaxNode) {\n        bb = Drawing.bBox(mathJaxNode);\n        titleWidth = bb.width;\n        titleHeight = bb.height;\n\n        if (titleHeight > lineSize) {\n          // not entirely sure how mathjax is doing\n          // vertical alignment, but this seems to work.\n          titleTrans[1] -= (titleHeight - lineSize) / 2;\n        }\n      } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {\n        bb = Drawing.bBox(titleText.node());\n        titleWidth = bb.width;\n        titleHeight = bb.height;\n      }\n\n      if (isVertical) {\n        if (titleHeight) {\n          // buffer btwn colorbar and title\n          // TODO: configurable\n          titleHeight += 5;\n\n          if (titleSide === 'top') {\n            ax.domain[1] -= titleHeight / gs.h;\n            titleTrans[1] *= -1;\n          } else {\n            ax.domain[0] += titleHeight / gs.h;\n            var nlines = svgTextUtils.lineCount(titleText);\n            titleTrans[1] += (1 - nlines) * lineSize;\n          }\n\n          titleGroup.attr('transform', strTranslate(titleTrans[0], titleTrans[1]));\n          ax.setScale();\n        }\n      } else {\n        // horizontal colorbars\n        if (titleWidth) {\n          if (titleSide === 'right') {\n            ax.domain[0] += (titleWidth + titleFontSize / 2) / gs.w;\n          }\n\n          titleGroup.attr('transform', strTranslate(titleTrans[0], titleTrans[1]));\n          ax.setScale();\n        }\n      }\n    }\n\n    g.selectAll('.' + cn.cbfills + ',.' + cn.cblines).attr('transform', isVertical ? strTranslate(0, Math.round(gs.h * (1 - ax.domain[1]))) : strTranslate(Math.round(gs.w * ax.domain[0]), 0));\n    axLayer.attr('transform', isVertical ? strTranslate(0, Math.round(-gs.t)) : strTranslate(Math.round(-gs.l), 0));\n    var fills = g.select('.' + cn.cbfills).selectAll('rect.' + cn.cbfill).attr('style', '').data(fillLevels);\n    fills.enter().append('rect').classed(cn.cbfill, true).style('stroke', 'none');\n    fills.exit().remove();\n    var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function (a, b) {\n      return a - b;\n    });\n    fills.each(function (d, i) {\n      var z = [i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2, i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2].map(ax.c2p).map(Math.round); // offset the side adjoining the next rectangle so they\n      // overlap, to prevent antialiasing gaps\n\n      if (isVertical) {\n        z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);\n      }\n      /* else {\n        // TODO: horizontal case\n      } */\n      // Colorbar cannot currently support opacities so we\n      // use an opaque fill even when alpha channels present\n\n\n      var fillEl = d3.select(this).attr(isVertical ? 'x' : 'y', uPx).attr(isVertical ? 'y' : 'x', d3.min(z)).attr(isVertical ? 'width' : 'height', Math.max(thickPx, 2)).attr(isVertical ? 'height' : 'width', Math.max(d3.max(z) - d3.min(z), 2));\n\n      if (opts._fillgradient) {\n        Drawing.gradient(fillEl, gd, opts._id, isVertical ? 'vertical' : 'horizontalreversed', opts._fillgradient, 'fill');\n      } else {\n        // tinycolor can't handle exponents and\n        // at this scale, removing it makes no difference.\n        var colorString = fillColormap(d).replace('e-', '');\n        fillEl.attr('fill', tinycolor(colorString).toHexString());\n      }\n    });\n    var lines = g.select('.' + cn.cblines).selectAll('path.' + cn.cbline).data(line.color && line.width ? lineLevels : []);\n    lines.enter().append('path').classed(cn.cbline, true);\n    lines.exit().remove();\n    lines.each(function (d) {\n      var a = uPx;\n      var b = Math.round(ax.c2p(d)) + line.width / 2 % 1;\n      d3.select(this).attr('d', 'M' + (isVertical ? a + ',' + b : b + ',' + a) + (isVertical ? 'h' : 'v') + thickPx).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);\n    }); // force full redraw of labels and ticks\n\n    axLayer.selectAll('g.' + ax._id + 'tick,path').remove();\n    var shift = uPx + thickPx + (outlinewidth || 0) / 2 - (opts.ticks === 'outside' ? 1 : 0);\n    var vals = Axes.calcTicks(ax);\n    var tickSign = Axes.getTickSigns(ax)[2];\n    Axes.drawTicks(gd, ax, {\n      vals: ax.ticks === 'inside' ? Axes.clipEnds(ax, vals) : vals,\n      layer: axLayer,\n      path: Axes.makeTickPath(ax, shift, tickSign),\n      transFn: Axes.makeTransTickFn(ax)\n    });\n    return Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: axLayer,\n      transFn: Axes.makeTransTickLabelFn(ax),\n      labelFns: Axes.makeLabelFns(ax, shift)\n    });\n  } // wait for the axis & title to finish rendering before\n  // continuing positioning\n  // TODO: why are we redrawing multiple times now with this?\n  // I guess autoMargin doesn't like being post-promise?\n\n\n  function positionCB() {\n    var bb;\n    var innerThickness = thickPx + outlinewidth / 2;\n\n    if (ticklabelposition.indexOf('inside') === -1) {\n      bb = Drawing.bBox(axLayer.node());\n      innerThickness += isVertical ? bb.width : bb.height;\n    }\n\n    titleEl = titleCont.select('text');\n    var titleWidth = 0;\n    var topSideVertical = isVertical && titleSide === 'top';\n    var rightSideHorizontal = !isVertical && titleSide === 'right';\n    var moveY = 0;\n\n    if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {\n      var _titleHeight;\n\n      var mathJaxNode = titleCont.select('.h' + ax._id + 'title-math-group').node();\n\n      if (mathJaxNode && (isVertical && topOrBottom || !isVertical && !topOrBottom)) {\n        bb = Drawing.bBox(mathJaxNode);\n        titleWidth = bb.width;\n        _titleHeight = bb.height;\n      } else {\n        // note: the formula below works for all title sides,\n        // (except for top/bottom mathjax, above)\n        // but the weird gs.l is because the titleunshift\n        // transform gets removed by Drawing.bBox\n        bb = Drawing.bBox(titleCont.node());\n        titleWidth = bb.right - gs.l - (isVertical ? uPx : vPx);\n        _titleHeight = bb.bottom - gs.t - (isVertical ? vPx : uPx);\n\n        if (!isVertical && titleSide === 'top') {\n          innerThickness += bb.height;\n          moveY = bb.height;\n        }\n      }\n\n      if (rightSideHorizontal) {\n        titleEl.attr('transform', strTranslate(titleWidth / 2 + titleFontSize / 2, 0));\n        titleWidth *= 2;\n      }\n\n      innerThickness = Math.max(innerThickness, isVertical ? titleWidth : _titleHeight);\n    }\n\n    var outerThickness = (isVertical ? xpad : ypad) * 2 + innerThickness + borderwidth + outlinewidth / 2;\n    var hColorbarMoveTitle = 0;\n\n    if (!isVertical && title.text && yanchor === 'bottom' && optsY <= 0) {\n      hColorbarMoveTitle = outerThickness / 2;\n      outerThickness += hColorbarMoveTitle;\n      moveY += hColorbarMoveTitle;\n    }\n\n    fullLayout._hColorbarMoveTitle = hColorbarMoveTitle;\n    fullLayout._hColorbarMoveCBTitle = moveY;\n    var extraW = borderwidth + outlinewidth;\n    g.select('.' + cn.cbbg).attr('x', (isVertical ? uPx : vPx) - extraW / 2 - (isVertical ? xpad : 0)).attr('y', (isVertical ? vPx : uPx) - (isVertical ? lenPx : ypad + moveY - hColorbarMoveTitle)).attr(isVertical ? 'width' : 'height', Math.max(outerThickness - hColorbarMoveTitle, 2)).attr(isVertical ? 'height' : 'width', Math.max(lenPx + extraW, 2)).call(Color.fill, bgcolor).call(Color.stroke, opts.bordercolor).style('stroke-width', borderwidth);\n    var moveX = rightSideHorizontal ? Math.max(titleWidth - 10, 0) : 0;\n    g.selectAll('.' + cn.cboutline).attr('x', (isVertical ? uPx : vPx + xpad) + moveX).attr('y', (isVertical ? vPx + ypad - lenPx : uPx) + (topSideVertical ? titleHeight : 0)).attr(isVertical ? 'width' : 'height', Math.max(thickPx, 2)).attr(isVertical ? 'height' : 'width', Math.max(lenPx - (isVertical ? 2 * ypad + titleHeight : 2 * xpad + moveX), 2)).call(Color.stroke, opts.outlinecolor).style({\n      fill: 'none',\n      'stroke-width': outlinewidth\n    });\n    g.attr('transform', strTranslate(gs.l - (isVertical ? xRatio * outerThickness : 0), gs.t - (isVertical ? 0 : (1 - yRatio) * outerThickness - moveY)));\n\n    if (!isVertical && (borderwidth || tinycolor(bgcolor).getAlpha() && !tinycolor.equals(fullLayout.paper_bgcolor, bgcolor))) {\n      // for horizontal colorbars when there is a border line or having different background color\n      // hide/adjust x positioning for the first/last tick labels if they go outside the border\n      var tickLabels = axLayer.selectAll('text');\n      var numTicks = tickLabels[0].length;\n      var border = g.select('.' + cn.cbbg).node();\n      var oBb = Drawing.bBox(border);\n      var oTr = Drawing.getTranslate(g);\n      var TEXTPAD = 2;\n      tickLabels.each(function (d, i) {\n        var first = 0;\n        var last = numTicks - 1;\n\n        if (i === first || i === last) {\n          var iBb = Drawing.bBox(this);\n          var iTr = Drawing.getTranslate(this);\n          var deltaX;\n\n          if (i === last) {\n            var iRight = iBb.right + iTr.x;\n            var oRight = oBb.right + oTr.x + vPx - borderwidth - TEXTPAD + optsX;\n            deltaX = oRight - iRight;\n            if (deltaX > 0) deltaX = 0;\n          } else if (i === first) {\n            var iLeft = iBb.left + iTr.x;\n            var oLeft = oBb.left + oTr.x + vPx + borderwidth + TEXTPAD;\n            deltaX = oLeft - iLeft;\n            if (deltaX < 0) deltaX = 0;\n          }\n\n          if (deltaX) {\n            if (numTicks < 3) {\n              // adjust position\n              this.setAttribute('transform', 'translate(' + deltaX + ',0) ' + this.getAttribute('transform'));\n            } else {\n              // hide\n              this.setAttribute('visibility', 'hidden');\n            }\n          }\n        }\n      });\n    } // auto margin adjustment\n\n\n    var marginOpts = {};\n    var lFrac = FROM_TL[xanchor];\n    var rFrac = FROM_BR[xanchor];\n    var tFrac = FROM_TL[yanchor];\n    var bFrac = FROM_BR[yanchor];\n    var extraThickness = outerThickness - thickPx;\n\n    if (isVertical) {\n      if (lenmode === 'pixels') {\n        marginOpts.y = optsY;\n        marginOpts.t = lenPx * tFrac;\n        marginOpts.b = lenPx * bFrac;\n      } else {\n        marginOpts.t = marginOpts.b = 0;\n        marginOpts.yt = optsY + len * tFrac;\n        marginOpts.yb = optsY - len * bFrac;\n      }\n\n      if (thicknessmode === 'pixels') {\n        marginOpts.x = optsX;\n        marginOpts.l = outerThickness * lFrac;\n        marginOpts.r = outerThickness * rFrac;\n      } else {\n        marginOpts.l = extraThickness * lFrac;\n        marginOpts.r = extraThickness * rFrac;\n        marginOpts.xl = optsX - thickness * lFrac;\n        marginOpts.xr = optsX + thickness * rFrac;\n      }\n    } else {\n      // horizontal colorbars\n      if (lenmode === 'pixels') {\n        marginOpts.x = optsX;\n        marginOpts.l = lenPx * lFrac;\n        marginOpts.r = lenPx * rFrac;\n      } else {\n        marginOpts.l = marginOpts.r = 0;\n        marginOpts.xl = optsX + len * lFrac;\n        marginOpts.xr = optsX - len * rFrac;\n      }\n\n      if (thicknessmode === 'pixels') {\n        marginOpts.y = 1 - optsY;\n        marginOpts.t = outerThickness * tFrac;\n        marginOpts.b = outerThickness * bFrac;\n      } else {\n        marginOpts.t = extraThickness * tFrac;\n        marginOpts.b = extraThickness * bFrac;\n        marginOpts.yt = optsY - thickness * tFrac;\n        marginOpts.yb = optsY + thickness * bFrac;\n      }\n    }\n\n    Plots.autoMargin(gd, opts._id, marginOpts);\n  }\n\n  return Lib.syncOrAsync([Plots.previousPromises, drawDummyTitle, drawAxis, drawCbTitle, Plots.previousPromises, positionCB], gd);\n}\n\nfunction makeEditable(g, opts, gd) {\n  var isVertical = opts.orientation === 'v';\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var t0, xf, yf;\n  dragElement.init({\n    element: g.node(),\n    gd: gd,\n    prepFn: function prepFn() {\n      t0 = g.attr('transform');\n      setCursor(g);\n    },\n    moveFn: function moveFn(dx, dy) {\n      g.attr('transform', t0 + strTranslate(dx, dy));\n      xf = dragElement.align((isVertical ? opts._uFrac : opts._vFrac) + dx / gs.w, isVertical ? opts._thickFrac : opts._lenFrac, 0, 1, opts.xanchor);\n      yf = dragElement.align((isVertical ? opts._vFrac : 1 - opts._uFrac) - dy / gs.h, isVertical ? opts._lenFrac : opts._thickFrac, 0, 1, opts.yanchor);\n      var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);\n      setCursor(g, csr);\n    },\n    doneFn: function doneFn() {\n      setCursor(g);\n\n      if (xf !== undefined && yf !== undefined) {\n        var update = {};\n        update[opts._propPrefix + 'x'] = xf;\n        update[opts._propPrefix + 'y'] = yf;\n\n        if (opts._traceIndex !== undefined) {\n          Registry.call('_guiRestyle', gd, update, opts._traceIndex);\n        } else {\n          Registry.call('_guiRelayout', gd, update);\n        }\n      }\n    }\n  });\n}\n\nfunction calcLevels(gd, opts, zrange) {\n  var levelsIn = opts._levels;\n  var lineLevels = [];\n  var fillLevels = [];\n  var l;\n  var i;\n  var l0 = levelsIn.end + levelsIn.size / 100;\n  var ls = levelsIn.size;\n  var zr0 = 1.001 * zrange[0] - 0.001 * zrange[1];\n  var zr1 = 1.001 * zrange[1] - 0.001 * zrange[0];\n\n  for (i = 0; i < 1e5; i++) {\n    l = levelsIn.start + i * ls;\n    if (ls > 0 ? l >= l0 : l <= l0) break;\n    if (l > zr0 && l < zr1) lineLevels.push(l);\n  }\n\n  if (opts._fillgradient) {\n    fillLevels = [0];\n  } else if (typeof opts._fillcolor === 'function') {\n    var fillLevelsIn = opts._filllevels;\n\n    if (fillLevelsIn) {\n      l0 = fillLevelsIn.end + fillLevelsIn.size / 100;\n      ls = fillLevelsIn.size;\n\n      for (i = 0; i < 1e5; i++) {\n        l = fillLevelsIn.start + i * ls;\n        if (ls > 0 ? l >= l0 : l <= l0) break;\n        if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);\n      }\n    } else {\n      fillLevels = lineLevels.map(function (v) {\n        return v - levelsIn.size / 2;\n      });\n      fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);\n    }\n  } else if (opts._fillcolor && typeof opts._fillcolor === 'string') {\n    // doesn't matter what this value is, with a single value\n    // we'll make a single fill rect covering the whole bar\n    fillLevels = [0];\n  }\n\n  if (levelsIn.size < 0) {\n    lineLevels.reverse();\n    fillLevels.reverse();\n  }\n\n  return {\n    line: lineLevels,\n    fill: fillLevels\n  };\n}\n\nfunction mockColorBarAxis(gd, opts, zrange) {\n  var fullLayout = gd._fullLayout;\n  var isVertical = opts.orientation === 'v';\n  var cbAxisIn = {\n    type: 'linear',\n    range: zrange,\n    tickmode: opts.tickmode,\n    nticks: opts.nticks,\n    tick0: opts.tick0,\n    dtick: opts.dtick,\n    tickvals: opts.tickvals,\n    ticktext: opts.ticktext,\n    ticks: opts.ticks,\n    ticklen: opts.ticklen,\n    tickwidth: opts.tickwidth,\n    tickcolor: opts.tickcolor,\n    showticklabels: opts.showticklabels,\n    ticklabelposition: opts.ticklabelposition,\n    ticklabeloverflow: opts.ticklabeloverflow,\n    ticklabelstep: opts.ticklabelstep,\n    tickfont: opts.tickfont,\n    tickangle: opts.tickangle,\n    tickformat: opts.tickformat,\n    exponentformat: opts.exponentformat,\n    minexponent: opts.minexponent,\n    separatethousands: opts.separatethousands,\n    showexponent: opts.showexponent,\n    showtickprefix: opts.showtickprefix,\n    tickprefix: opts.tickprefix,\n    showticksuffix: opts.showticksuffix,\n    ticksuffix: opts.ticksuffix,\n    title: opts.title,\n    showline: true,\n    anchor: 'free',\n    side: isVertical ? 'right' : 'bottom',\n    position: 1\n  };\n  var letter = isVertical ? 'y' : 'x';\n  var cbAxisOut = {\n    type: 'linear',\n    _id: letter + opts._id\n  };\n  var axisOptions = {\n    letter: letter,\n    font: fullLayout.font,\n    noHover: true,\n    noTickson: true,\n    noTicklabelmode: true,\n    calendar: fullLayout.calendar // not really necessary (yet?)\n\n  };\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);\n  }\n\n  handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);\n  handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);\n  return cbAxisOut;\n}\n\nmodule.exports = {\n  draw: draw\n};","map":null,"metadata":{},"sourceType":"script"}