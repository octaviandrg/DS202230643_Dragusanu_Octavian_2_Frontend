{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Registry = require('../../registry');\n\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\n\nvar getLineWidth = require('./helpers').getLineWidth;\n\nvar hoverLabelText = require('../../plots/cartesian/axes').hoverLabelText;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval, hovermode, opts) {\n  var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);\n\n  if (barPointData) {\n    var cd = barPointData.cd;\n    var trace = cd[0].trace;\n    var di = cd[barPointData.index];\n    barPointData.color = getTraceColor(trace, di);\n    Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, barPointData);\n    return [barPointData];\n  }\n}\n\nfunction hoverOnBars(pointData, xval, yval, hovermode, opts) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isClosest = hovermode === 'closest';\n  var isWaterfall = trace.type === 'waterfall';\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var maxSpikeDistance = pointData.maxSpikeDistance;\n  var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n\n  if (trace.orientation === 'h') {\n    posVal = yval;\n    sizeVal = xval;\n    posLetter = 'y';\n    sizeLetter = 'x';\n    dx = sizeFn;\n    dy = positionFn;\n  } else {\n    posVal = xval;\n    sizeVal = yval;\n    posLetter = 'x';\n    sizeLetter = 'y';\n    dy = sizeFn;\n    dx = positionFn;\n  }\n\n  var period = trace[posLetter + 'period'];\n  var isClosestOrPeriod = isClosest || period;\n\n  function thisBarMinPos(di) {\n    return thisBarExtPos(di, -1);\n  }\n\n  function thisBarMaxPos(di) {\n    return thisBarExtPos(di, 1);\n  }\n\n  function thisBarExtPos(di, sgn) {\n    var w = di.w;\n    return di[posLetter] + sgn * w / 2;\n  }\n\n  function periodLength(di) {\n    return di[posLetter + 'End'] - di[posLetter + 'Start'];\n  }\n\n  var minPos = isClosest ? thisBarMinPos : period ? function (di) {\n    return di.p - periodLength(di) / 2;\n  } : function (di) {\n    /*\n     * In compare mode, accept a bar if you're on it *or* its group.\n     * Nearly always it's the group that matters, but in case the bar\n     * was explicitly set wider than its group we'd better accept the\n     * whole bar.\n     *\n     * use `bardelta` instead of `bargroupwidth` so we accept hover\n     * in the gap. That way hover doesn't flash on and off as you\n     * mouse over the plot in compare modes.\n     * In 'closest' mode though the flashing seems inevitable,\n     * without far more complex logic\n     */\n    return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n  };\n  var maxPos = isClosest ? thisBarMaxPos : period ? function (di) {\n    return di.p + periodLength(di) / 2;\n  } : function (di) {\n    return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n  };\n\n  function inbox(_minPos, _maxPos, maxDistance) {\n    if (opts.finiteRange) maxDistance = 0; // add a little to the pseudo-distance for wider bars, so that like scatter,\n    // if you are over two overlapping bars, the narrower one wins.\n\n    return Fx.inbox(_minPos - posVal, _maxPos - posVal, maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n  }\n\n  function positionFn(di) {\n    return inbox(minPos(di), maxPos(di), maxHoverDistance);\n  }\n\n  function thisBarPositionFn(di) {\n    return inbox(thisBarMinPos(di), thisBarMaxPos(di), maxSpikeDistance);\n  }\n\n  function getSize(di) {\n    var s = di[sizeLetter];\n\n    if (isWaterfall) {\n      var rawS = Math.abs(di.rawS) || 0;\n\n      if (sizeVal > 0) {\n        s += rawS;\n      } else if (sizeVal < 0) {\n        s -= rawS;\n      }\n    }\n\n    return s;\n  }\n\n  function sizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di); // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n\n    return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);\n  }\n\n  function thisBarSizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di); // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n\n    return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);\n  }\n\n  var pa = pointData[posLetter + 'a'];\n  var sa = pointData[sizeLetter + 'a'];\n  pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n  if (pointData.index === false) return; // skip points inside axis rangebreaks\n\n  if (cd[pointData.index].p === BADNUM) return; // if we get here and we're not in 'closest' mode, push min/max pos back\n  // onto the group - even though that means occasionally the mouse will be\n  // over the hover label.\n\n  if (!isClosestOrPeriod) {\n    minPos = function minPos(di) {\n      return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n    };\n\n    maxPos = function maxPos(di) {\n      return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n    };\n  } // the closest data point\n\n\n  var index = pointData.index;\n  var di = cd[index];\n  var size = trace.base ? di.b + di.s : di.s;\n  pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n  pointData[sizeLetter + 'LabelVal'] = size;\n  var extent = t.extents[t.extents.round(di.p)];\n  pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n  pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n  var hasPeriod = di.orig_p !== undefined;\n  pointData[posLetter + 'LabelVal'] = hasPeriod ? di.orig_p : di.p;\n  pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + 'LabelVal'], trace[posLetter + 'hoverformat']);\n  pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + 'LabelVal'], trace[sizeLetter + 'hoverformat']);\n  pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + 'hoverformat']); // spikelines always want \"closest\" distance regardless of hovermode\n\n  pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2; // they also want to point to the data value, regardless of where the label goes\n  // in case of bars shifted within groups\n\n  pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n  fillText(di, trace, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  return pointData;\n}\n\nfunction getTraceColor(trace, di) {\n  var mc = di.mcc || trace.marker.color;\n  var mlc = di.mlcc || trace.marker.line.color;\n  var mlw = getLineWidth(trace, di);\n  if (Color.opacity(mc)) return mc;else if (Color.opacity(mlc) && mlw) return mlc;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBars: hoverOnBars,\n  getTraceColor: getTraceColor\n};","map":null,"metadata":{},"sourceType":"script"}