{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib'); // Maybe add kernels more down the road,\n// but note that the default `spanmode: 'soft'` bounds might have\n// to become kernel-dependent\n\n\nvar kernels = {\n  gaussian: function gaussian(v) {\n    return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * v * v);\n  }\n};\n\nexports.makeKDE = function (calcItem, trace, vals) {\n  var len = vals.length;\n  var kernel = kernels.gaussian;\n  var bandwidth = calcItem.bandwidth;\n  var factor = 1 / (len * bandwidth); // don't use Lib.aggNums to skip isNumeric checks\n\n  return function (x) {\n    var sum = 0;\n\n    for (var i = 0; i < len; i++) {\n      sum += kernel((x - vals[i]) / bandwidth);\n    }\n\n    return factor * sum;\n  };\n};\n\nexports.getPositionOnKdePath = function (calcItem, trace, valuePx) {\n  var posLetter, valLetter;\n\n  if (trace.orientation === 'h') {\n    posLetter = 'y';\n    valLetter = 'x';\n  } else {\n    posLetter = 'x';\n    valLetter = 'y';\n  }\n\n  var pointOnPath = Lib.findPointOnPath(calcItem.path, valuePx, valLetter, {\n    pathLength: calcItem.pathLength\n  });\n  var posCenterPx = calcItem.posCenterPx;\n  var posOnPath0 = pointOnPath[posLetter];\n  var posOnPath1 = trace.side === 'both' ? 2 * posCenterPx - posOnPath0 : posCenterPx;\n  return [posOnPath0, posOnPath1];\n};\n\nexports.getKdeValue = function (calcItem, trace, valueDist) {\n  var vals = calcItem.pts.map(exports.extractVal);\n  var kde = exports.makeKDE(calcItem, trace, vals);\n  return kde(valueDist) / calcItem.posDensityScale;\n};\n\nexports.extractVal = function (o) {\n  return o.v;\n};","map":null,"metadata":{},"sourceType":"script"}