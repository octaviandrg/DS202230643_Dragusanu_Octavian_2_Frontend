{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar interpolate = require('d3-interpolate').interpolate;\n\nvar interpolateNumber = require('d3-interpolate').interpolateNumber;\n\nvar Lib = require('../../lib');\n\nvar strScale = Lib.strScale;\nvar strTranslate = Lib.strTranslate;\nvar rad2deg = Lib.rad2deg;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\n\nvar Drawing = require('../../components/drawing');\n\nvar cn = require('./constants');\n\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar handleAxisDefaults = require('../../plots/cartesian/axis_defaults');\n\nvar handleAxisPositionDefaults = require('../../plots/cartesian/position_defaults');\n\nvar axisLayoutAttrs = require('../../plots/cartesian/layout_attributes');\n\nvar Color = require('../../components/color');\n\nvar anchor = {\n  'left': 'start',\n  'center': 'middle',\n  'right': 'end'\n};\nvar position = {\n  'left': 0,\n  'center': 0.5,\n  'right': 1\n};\nvar SI_PREFIX = /[yzafpnÂµmkMGTPEZY]/;\n\nfunction hasTransition(transitionOpts) {\n  // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n  return transitionOpts && transitionOpts.duration > 0;\n}\n\nmodule.exports = function plot(gd, cdModule, transitionOpts, makeOnCompleteCallback) {\n  var fullLayout = gd._fullLayout;\n  var onComplete;\n\n  if (hasTransition(transitionOpts)) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n  }\n\n  Lib.makeTraceGroups(fullLayout._indicatorlayer, cdModule, 'trace').each(function (cd) {\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var plotGroup = d3.select(this); // Elements in trace\n\n    var hasGauge = trace._hasGauge;\n    var isAngular = trace._isAngular;\n    var isBullet = trace._isBullet; // Domain size\n\n    var domain = trace.domain;\n    var size = {\n      w: fullLayout._size.w * (domain.x[1] - domain.x[0]),\n      h: fullLayout._size.h * (domain.y[1] - domain.y[0]),\n      l: fullLayout._size.l + fullLayout._size.w * domain.x[0],\n      r: fullLayout._size.r + fullLayout._size.w * (1 - domain.x[1]),\n      t: fullLayout._size.t + fullLayout._size.h * (1 - domain.y[1]),\n      b: fullLayout._size.b + fullLayout._size.h * domain.y[0]\n    };\n    var centerX = size.l + size.w / 2;\n    var centerY = size.t + size.h / 2; // Angular gauge size\n\n    var radius = Math.min(size.w / 2, size.h); // fill domain\n\n    var innerRadius = cn.innerRadius * radius; // Position numbers based on mode and set the scaling logic\n\n    var numbersX, numbersY, numbersScaler;\n    var numbersAlign = trace.align || 'center';\n    numbersY = centerY;\n\n    if (!hasGauge) {\n      numbersX = size.l + position[numbersAlign] * size.w;\n\n      numbersScaler = function numbersScaler(el) {\n        return fitTextInsideBox(el, size.w, size.h);\n      };\n    } else {\n      if (isAngular) {\n        numbersX = centerX;\n        numbersY = centerY + radius / 2;\n\n        numbersScaler = function numbersScaler(el) {\n          return fitTextInsideCircle(el, 0.9 * innerRadius);\n        };\n      }\n\n      if (isBullet) {\n        var padding = cn.bulletPadding;\n        var p = 1 - cn.bulletNumberDomainSize + padding;\n        numbersX = size.l + (p + (1 - p) * position[numbersAlign]) * size.w;\n\n        numbersScaler = function numbersScaler(el) {\n          return fitTextInsideBox(el, (cn.bulletNumberDomainSize - padding) * size.w, size.h);\n        };\n      }\n    } // Draw numbers\n\n\n    drawNumbers(gd, plotGroup, cd, {\n      numbersX: numbersX,\n      numbersY: numbersY,\n      numbersScaler: numbersScaler,\n      transitionOpts: transitionOpts,\n      onComplete: onComplete\n    }); // Reexpress our gauge background attributes for drawing\n\n    var gaugeBg, gaugeOutline;\n\n    if (hasGauge) {\n      gaugeBg = {\n        range: trace.gauge.axis.range,\n        color: trace.gauge.bgcolor,\n        line: {\n          color: trace.gauge.bordercolor,\n          width: 0\n        },\n        thickness: 1\n      };\n      gaugeOutline = {\n        range: trace.gauge.axis.range,\n        color: 'rgba(0, 0, 0, 0)',\n        line: {\n          color: trace.gauge.bordercolor,\n          width: trace.gauge.borderwidth\n        },\n        thickness: 1\n      };\n    } // Prepare angular gauge layers\n\n\n    var angularGauge = plotGroup.selectAll('g.angular').data(isAngular ? cd : []);\n    angularGauge.exit().remove();\n    var angularaxisLayer = plotGroup.selectAll('g.angularaxis').data(isAngular ? cd : []);\n    angularaxisLayer.exit().remove();\n\n    if (isAngular) {\n      drawAngularGauge(gd, plotGroup, cd, {\n        radius: radius,\n        innerRadius: innerRadius,\n        gauge: angularGauge,\n        layer: angularaxisLayer,\n        size: size,\n        gaugeBg: gaugeBg,\n        gaugeOutline: gaugeOutline,\n        transitionOpts: transitionOpts,\n        onComplete: onComplete\n      });\n    } // Prepare bullet layers\n\n\n    var bulletGauge = plotGroup.selectAll('g.bullet').data(isBullet ? cd : []);\n    bulletGauge.exit().remove();\n    var bulletaxisLayer = plotGroup.selectAll('g.bulletaxis').data(isBullet ? cd : []);\n    bulletaxisLayer.exit().remove();\n\n    if (isBullet) {\n      drawBulletGauge(gd, plotGroup, cd, {\n        gauge: bulletGauge,\n        layer: bulletaxisLayer,\n        size: size,\n        gaugeBg: gaugeBg,\n        gaugeOutline: gaugeOutline,\n        transitionOpts: transitionOpts,\n        onComplete: onComplete\n      });\n    } // title\n\n\n    var title = plotGroup.selectAll('text.title').data(cd);\n    title.exit().remove();\n    title.enter().append('text').classed('title', true);\n    title.attr('text-anchor', function () {\n      return isBullet ? anchor.right : anchor[trace.title.align];\n    }).text(trace.title.text).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd); // Position title\n\n    title.attr('transform', function () {\n      var titleX = size.l + size.w * position[trace.title.align];\n      var titleY;\n      var titlePadding = cn.titlePadding;\n      var titlebBox = Drawing.bBox(title.node());\n\n      if (hasGauge) {\n        if (isAngular) {\n          // position above axis ticks/labels\n          if (trace.gauge.axis.visible) {\n            var bBox = Drawing.bBox(angularaxisLayer.node());\n            titleY = bBox.top - titlePadding - titlebBox.bottom;\n          } else {\n            titleY = size.t + size.h / 2 - radius / 2 - titlebBox.bottom - titlePadding;\n          }\n        }\n\n        if (isBullet) {\n          // position outside domain\n          titleY = numbersY - (titlebBox.top + titlebBox.bottom) / 2;\n          titleX = size.l - cn.bulletPadding * size.w; // Outside domain, on the left\n        }\n      } else {\n        // position above numbers\n        titleY = trace._numbersTop - titlePadding - titlebBox.bottom;\n      }\n\n      return strTranslate(titleX, titleY);\n    });\n  });\n};\n\nfunction drawBulletGauge(gd, plotGroup, cd, opts) {\n  var trace = cd[0].trace;\n  var bullet = opts.gauge;\n  var axisLayer = opts.layer;\n  var gaugeBg = opts.gaugeBg;\n  var gaugeOutline = opts.gaugeOutline;\n  var size = opts.size;\n  var domain = trace.domain;\n  var transitionOpts = opts.transitionOpts;\n  var onComplete = opts.onComplete; // preparing axis\n\n  var ax, vals, transFn, tickSign, shift; // Enter bullet, axis\n\n  bullet.enter().append('g').classed('bullet', true);\n  bullet.attr('transform', strTranslate(size.l, size.t));\n  axisLayer.enter().append('g').classed('bulletaxis', true).classed('crisp', true);\n  axisLayer.selectAll('g.' + 'xbulletaxis' + 'tick,path,text').remove(); // Draw bullet\n\n  var bulletHeight = size.h; // use all vertical domain\n\n  var innerBulletHeight = trace.gauge.bar.thickness * bulletHeight;\n  var bulletLeft = domain.x[0];\n  var bulletRight = domain.x[0] + (domain.x[1] - domain.x[0]) * (trace._hasNumber || trace._hasDelta ? 1 - cn.bulletNumberDomainSize : 1);\n  ax = mockAxis(gd, trace.gauge.axis);\n  ax._id = 'xbulletaxis';\n  ax.domain = [bulletLeft, bulletRight];\n  ax.setScale();\n  vals = Axes.calcTicks(ax);\n  transFn = Axes.makeTransTickFn(ax);\n  tickSign = Axes.getTickSigns(ax)[2];\n  shift = size.t + size.h;\n\n  if (ax.visible) {\n    Axes.drawTicks(gd, ax, {\n      vals: ax.ticks === 'inside' ? Axes.clipEnds(ax, vals) : vals,\n      layer: axisLayer,\n      path: Axes.makeTickPath(ax, shift, tickSign),\n      transFn: transFn\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: axisLayer,\n      transFn: transFn,\n      labelFns: Axes.makeLabelFns(ax, shift)\n    });\n  }\n\n  function drawRect(s) {\n    s.attr('width', function (d) {\n      return Math.max(0, ax.c2p(d.range[1]) - ax.c2p(d.range[0]));\n    }).attr('x', function (d) {\n      return ax.c2p(d.range[0]);\n    }).attr('y', function (d) {\n      return 0.5 * (1 - d.thickness) * bulletHeight;\n    }).attr('height', function (d) {\n      return d.thickness * bulletHeight;\n    });\n  } // Draw bullet background, steps\n\n\n  var boxes = [gaugeBg].concat(trace.gauge.steps);\n  var bgBullet = bullet.selectAll('g.bg-bullet').data(boxes);\n  bgBullet.enter().append('g').classed('bg-bullet', true).append('rect');\n  bgBullet.select('rect').call(drawRect).call(styleShape);\n  bgBullet.exit().remove(); // Draw value bar with transitions\n\n  var fgBullet = bullet.selectAll('g.value-bullet').data([trace.gauge.bar]);\n  fgBullet.enter().append('g').classed('value-bullet', true).append('rect');\n  fgBullet.select('rect').attr('height', innerBulletHeight).attr('y', (bulletHeight - innerBulletHeight) / 2).call(styleShape);\n\n  if (hasTransition(transitionOpts)) {\n    fgBullet.select('rect').transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    }).attr('width', Math.max(0, ax.c2p(Math.min(trace.gauge.axis.range[1], cd[0].y))));\n  } else {\n    fgBullet.select('rect').attr('width', typeof cd[0].y === 'number' ? Math.max(0, ax.c2p(Math.min(trace.gauge.axis.range[1], cd[0].y))) : 0);\n  }\n\n  fgBullet.exit().remove();\n  var data = cd.filter(function () {\n    return trace.gauge.threshold.value || trace.gauge.threshold.value === 0;\n  });\n  var threshold = bullet.selectAll('g.threshold-bullet').data(data);\n  threshold.enter().append('g').classed('threshold-bullet', true).append('line');\n  threshold.select('line').attr('x1', ax.c2p(trace.gauge.threshold.value)).attr('x2', ax.c2p(trace.gauge.threshold.value)).attr('y1', (1 - trace.gauge.threshold.thickness) / 2 * bulletHeight).attr('y2', (1 - (1 - trace.gauge.threshold.thickness) / 2) * bulletHeight).call(Color.stroke, trace.gauge.threshold.line.color).style('stroke-width', trace.gauge.threshold.line.width);\n  threshold.exit().remove();\n  var bulletOutline = bullet.selectAll('g.gauge-outline').data([gaugeOutline]);\n  bulletOutline.enter().append('g').classed('gauge-outline', true).append('rect');\n  bulletOutline.select('rect').call(drawRect).call(styleShape);\n  bulletOutline.exit().remove();\n}\n\nfunction drawAngularGauge(gd, plotGroup, cd, opts) {\n  var trace = cd[0].trace;\n  var size = opts.size;\n  var radius = opts.radius;\n  var innerRadius = opts.innerRadius;\n  var gaugeBg = opts.gaugeBg;\n  var gaugeOutline = opts.gaugeOutline;\n  var gaugePosition = [size.l + size.w / 2, size.t + size.h / 2 + radius / 2];\n  var gauge = opts.gauge;\n  var axisLayer = opts.layer;\n  var transitionOpts = opts.transitionOpts;\n  var onComplete = opts.onComplete; // circular gauge\n\n  var theta = Math.PI / 2;\n\n  function valueToAngle(v) {\n    var min = trace.gauge.axis.range[0];\n    var max = trace.gauge.axis.range[1];\n    var angle = (v - min) / (max - min) * Math.PI - theta;\n    if (angle < -theta) return -theta;\n    if (angle > theta) return theta;\n    return angle;\n  }\n\n  function arcPathGenerator(size) {\n    return d3.svg.arc().innerRadius((innerRadius + radius) / 2 - size / 2 * (radius - innerRadius)).outerRadius((innerRadius + radius) / 2 + size / 2 * (radius - innerRadius)).startAngle(-theta);\n  }\n\n  function drawArc(p) {\n    p.attr('d', function (d) {\n      return arcPathGenerator(d.thickness).startAngle(valueToAngle(d.range[0])).endAngle(valueToAngle(d.range[1]))();\n    });\n  } // preparing axis\n\n\n  var ax, vals, transFn, tickSign; // Enter gauge and axis\n\n  gauge.enter().append('g').classed('angular', true);\n  gauge.attr('transform', strTranslate(gaugePosition[0], gaugePosition[1]));\n  axisLayer.enter().append('g').classed('angularaxis', true).classed('crisp', true);\n  axisLayer.selectAll('g.' + 'xangularaxis' + 'tick,path,text').remove();\n  ax = mockAxis(gd, trace.gauge.axis);\n  ax.type = 'linear';\n  ax.range = trace.gauge.axis.range;\n  ax._id = 'xangularaxis'; // or 'y', but I don't think this makes a difference here\n\n  ax.ticklabeloverflow = 'allow';\n  ax.setScale(); // 't'ick to 'g'eometric radians is used all over the place here\n\n  var t2g = function t2g(d) {\n    return (ax.range[0] - d.x) / (ax.range[1] - ax.range[0]) * Math.PI + Math.PI;\n  };\n\n  var labelFns = {};\n  var out = Axes.makeLabelFns(ax, 0);\n  var labelStandoff = out.labelStandoff;\n\n  labelFns.xFn = function (d) {\n    var rad = t2g(d);\n    return Math.cos(rad) * labelStandoff;\n  };\n\n  labelFns.yFn = function (d) {\n    var rad = t2g(d);\n    var ff = Math.sin(rad) > 0 ? 0.2 : 1;\n    return -Math.sin(rad) * (labelStandoff + d.fontSize * ff) + Math.abs(Math.cos(rad)) * (d.fontSize * MID_SHIFT);\n  };\n\n  labelFns.anchorFn = function (d) {\n    var rad = t2g(d);\n    var cos = Math.cos(rad);\n    return Math.abs(cos) < 0.1 ? 'middle' : cos > 0 ? 'start' : 'end';\n  };\n\n  labelFns.heightFn = function (d, a, h) {\n    var rad = t2g(d);\n    return -0.5 * (1 + Math.sin(rad)) * h;\n  };\n\n  var _transFn = function _transFn(rad) {\n    return strTranslate(gaugePosition[0] + radius * Math.cos(rad), gaugePosition[1] - radius * Math.sin(rad));\n  };\n\n  transFn = function transFn(d) {\n    return _transFn(t2g(d));\n  };\n\n  var transFn2 = function transFn2(d) {\n    var rad = t2g(d);\n    return _transFn(rad) + 'rotate(' + -rad2deg(rad) + ')';\n  };\n\n  vals = Axes.calcTicks(ax);\n  tickSign = Axes.getTickSigns(ax)[2];\n\n  if (ax.visible) {\n    tickSign = ax.ticks === 'inside' ? -1 : 1;\n    var pad = (ax.linewidth || 1) / 2;\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: axisLayer,\n      path: 'M' + tickSign * pad + ',0h' + tickSign * ax.ticklen,\n      transFn: transFn2\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: axisLayer,\n      transFn: transFn,\n      labelFns: labelFns\n    });\n  } // Draw background + steps\n\n\n  var arcs = [gaugeBg].concat(trace.gauge.steps);\n  var bgArc = gauge.selectAll('g.bg-arc').data(arcs);\n  bgArc.enter().append('g').classed('bg-arc', true).append('path');\n  bgArc.select('path').call(drawArc).call(styleShape);\n  bgArc.exit().remove(); // Draw foreground with transition\n\n  var valueArcPathGenerator = arcPathGenerator(trace.gauge.bar.thickness);\n  var valueArc = gauge.selectAll('g.value-arc').data([trace.gauge.bar]);\n  valueArc.enter().append('g').classed('value-arc', true).append('path');\n  var valueArcPath = valueArc.select('path');\n\n  if (hasTransition(transitionOpts)) {\n    valueArcPath.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    }).attrTween('d', arcTween(valueArcPathGenerator, valueToAngle(cd[0].lastY), valueToAngle(cd[0].y)));\n    trace._lastValue = cd[0].y;\n  } else {\n    valueArcPath.attr('d', typeof cd[0].y === 'number' ? valueArcPathGenerator.endAngle(valueToAngle(cd[0].y)) : 'M0,0Z');\n  }\n\n  valueArcPath.call(styleShape);\n  valueArc.exit().remove(); // Draw threshold\n\n  arcs = [];\n  var v = trace.gauge.threshold.value;\n\n  if (v || v === 0) {\n    arcs.push({\n      range: [v, v],\n      color: trace.gauge.threshold.color,\n      line: {\n        color: trace.gauge.threshold.line.color,\n        width: trace.gauge.threshold.line.width\n      },\n      thickness: trace.gauge.threshold.thickness\n    });\n  }\n\n  var thresholdArc = gauge.selectAll('g.threshold-arc').data(arcs);\n  thresholdArc.enter().append('g').classed('threshold-arc', true).append('path');\n  thresholdArc.select('path').call(drawArc).call(styleShape);\n  thresholdArc.exit().remove(); // Draw border last\n\n  var gaugeBorder = gauge.selectAll('g.gauge-outline').data([gaugeOutline]);\n  gaugeBorder.enter().append('g').classed('gauge-outline', true).append('path');\n  gaugeBorder.select('path').call(drawArc).call(styleShape);\n  gaugeBorder.exit().remove();\n}\n\nfunction drawNumbers(gd, plotGroup, cd, opts) {\n  var trace = cd[0].trace;\n  var numbersX = opts.numbersX;\n  var numbersY = opts.numbersY;\n  var numbersAlign = trace.align || 'center';\n  var numbersAnchor = anchor[numbersAlign];\n  var transitionOpts = opts.transitionOpts;\n  var onComplete = opts.onComplete;\n  var numbers = Lib.ensureSingle(plotGroup, 'g', 'numbers');\n  var bignumberbBox, deltabBox;\n  var numbersbBox;\n  var data = [];\n  if (trace._hasNumber) data.push('number');\n\n  if (trace._hasDelta) {\n    data.push('delta');\n    if (trace.delta.position === 'left') data.reverse();\n  }\n\n  var sel = numbers.selectAll('text').data(data);\n  sel.enter().append('text');\n  sel.attr('text-anchor', function () {\n    return numbersAnchor;\n  }).attr('class', function (d) {\n    return d;\n  }).attr('x', null).attr('y', null).attr('dx', null).attr('dy', null);\n  sel.exit().remove(); // Function to override the number formatting used during transitions\n\n  function transitionFormat(valueformat, fmt, from, to) {\n    // For now, do not display SI prefix if start and end value do not have any\n    if (valueformat.match('s') && // If using SI prefix\n    from >= 0 !== to >= 0 && // If sign change\n    !fmt(from).slice(-1).match(SI_PREFIX) && !fmt(to).slice(-1).match(SI_PREFIX) // Has no SI prefix\n    ) {\n        var transitionValueFormat = valueformat.slice().replace('s', 'f').replace(/\\d+/, function (m) {\n          return parseInt(m) - 1;\n        });\n        var transitionAx = mockAxis(gd, {\n          tickformat: transitionValueFormat\n        });\n        return function (v) {\n          // Switch to fixed precision if number is smaller than one\n          if (Math.abs(v) < 1) return Axes.tickText(transitionAx, v).text;\n          return fmt(v);\n        };\n      } else {\n      return fmt;\n    }\n  }\n\n  function drawBignumber() {\n    var bignumberAx = mockAxis(gd, {\n      tickformat: trace.number.valueformat\n    }, trace._range);\n    bignumberAx.setScale();\n    Axes.prepTicks(bignumberAx);\n\n    var bignumberFmt = function bignumberFmt(v) {\n      return Axes.tickText(bignumberAx, v).text;\n    };\n\n    var bignumberSuffix = trace.number.suffix;\n    var bignumberPrefix = trace.number.prefix;\n    var number = numbers.select('text.number');\n\n    function writeNumber() {\n      var txt = typeof cd[0].y === 'number' ? bignumberPrefix + bignumberFmt(cd[0].y) + bignumberSuffix : '-';\n      number.text(txt).call(Drawing.font, trace.number.font).call(svgTextUtils.convertToTspans, gd);\n    }\n\n    if (hasTransition(transitionOpts)) {\n      number.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n        writeNumber();\n        onComplete && onComplete();\n      }).each('interrupt', function () {\n        writeNumber();\n        onComplete && onComplete();\n      }).attrTween('text', function () {\n        var that = d3.select(this);\n        var interpolator = interpolateNumber(cd[0].lastY, cd[0].y);\n        trace._lastValue = cd[0].y;\n        var transitionFmt = transitionFormat(trace.number.valueformat, bignumberFmt, cd[0].lastY, cd[0].y);\n        return function (t) {\n          that.text(bignumberPrefix + transitionFmt(interpolator(t)) + bignumberSuffix);\n        };\n      });\n    } else {\n      writeNumber();\n    }\n\n    bignumberbBox = measureText(bignumberPrefix + bignumberFmt(cd[0].y) + bignumberSuffix, trace.number.font, numbersAnchor, gd);\n    return number;\n  }\n\n  function drawDelta() {\n    var deltaAx = mockAxis(gd, {\n      tickformat: trace.delta.valueformat\n    }, trace._range);\n    deltaAx.setScale();\n    Axes.prepTicks(deltaAx);\n\n    var deltaFmt = function deltaFmt(v) {\n      return Axes.tickText(deltaAx, v).text;\n    };\n\n    var deltaSuffix = trace.delta.suffix;\n    var deltaPrefix = trace.delta.prefix;\n\n    var deltaValue = function deltaValue(d) {\n      var value = trace.delta.relative ? d.relativeDelta : d.delta;\n      return value;\n    };\n\n    var deltaFormatText = function deltaFormatText(value, numberFmt) {\n      if (value === 0 || typeof value !== 'number' || isNaN(value)) return '-';\n      return (value > 0 ? trace.delta.increasing.symbol : trace.delta.decreasing.symbol) + deltaPrefix + numberFmt(value) + deltaSuffix;\n    };\n\n    var deltaFill = function deltaFill(d) {\n      return d.delta >= 0 ? trace.delta.increasing.color : trace.delta.decreasing.color;\n    };\n\n    if (trace._deltaLastValue === undefined) {\n      trace._deltaLastValue = deltaValue(cd[0]);\n    }\n\n    var delta = numbers.select('text.delta');\n    delta.call(Drawing.font, trace.delta.font).call(Color.fill, deltaFill({\n      delta: trace._deltaLastValue\n    }));\n\n    function writeDelta() {\n      delta.text(deltaFormatText(deltaValue(cd[0]), deltaFmt)).call(Color.fill, deltaFill(cd[0])).call(svgTextUtils.convertToTspans, gd);\n    }\n\n    if (hasTransition(transitionOpts)) {\n      delta.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).tween('text', function () {\n        var that = d3.select(this);\n        var to = deltaValue(cd[0]);\n        var from = trace._deltaLastValue;\n        var transitionFmt = transitionFormat(trace.delta.valueformat, deltaFmt, from, to);\n        var interpolator = interpolateNumber(from, to);\n        trace._deltaLastValue = to;\n        return function (t) {\n          that.text(deltaFormatText(interpolator(t), transitionFmt));\n          that.call(Color.fill, deltaFill({\n            delta: interpolator(t)\n          }));\n        };\n      }).each('end', function () {\n        writeDelta();\n        onComplete && onComplete();\n      }).each('interrupt', function () {\n        writeDelta();\n        onComplete && onComplete();\n      });\n    } else {\n      writeDelta();\n    }\n\n    deltabBox = measureText(deltaFormatText(deltaValue(cd[0]), deltaFmt), trace.delta.font, numbersAnchor, gd);\n    return delta;\n  }\n\n  var key = trace.mode + trace.align;\n  var delta;\n\n  if (trace._hasDelta) {\n    delta = drawDelta();\n    key += trace.delta.position + trace.delta.font.size + trace.delta.font.family + trace.delta.valueformat;\n    key += trace.delta.increasing.symbol + trace.delta.decreasing.symbol;\n    numbersbBox = deltabBox;\n  }\n\n  if (trace._hasNumber) {\n    drawBignumber();\n    key += trace.number.font.size + trace.number.font.family + trace.number.valueformat + trace.number.suffix + trace.number.prefix;\n    numbersbBox = bignumberbBox;\n  } // Position delta relative to bignumber\n\n\n  if (trace._hasDelta && trace._hasNumber) {\n    var bignumberCenter = [(bignumberbBox.left + bignumberbBox.right) / 2, (bignumberbBox.top + bignumberbBox.bottom) / 2];\n    var deltaCenter = [(deltabBox.left + deltabBox.right) / 2, (deltabBox.top + deltabBox.bottom) / 2];\n    var dx, dy;\n    var padding = 0.75 * trace.delta.font.size;\n\n    if (trace.delta.position === 'left') {\n      dx = cache(trace, 'deltaPos', 0, -1 * (bignumberbBox.width * position[trace.align] + deltabBox.width * (1 - position[trace.align]) + padding), key, Math.min);\n      dy = bignumberCenter[1] - deltaCenter[1];\n      numbersbBox = {\n        width: bignumberbBox.width + deltabBox.width + padding,\n        height: Math.max(bignumberbBox.height, deltabBox.height),\n        left: deltabBox.left + dx,\n        right: bignumberbBox.right,\n        top: Math.min(bignumberbBox.top, deltabBox.top + dy),\n        bottom: Math.max(bignumberbBox.bottom, deltabBox.bottom + dy)\n      };\n    }\n\n    if (trace.delta.position === 'right') {\n      dx = cache(trace, 'deltaPos', 0, bignumberbBox.width * (1 - position[trace.align]) + deltabBox.width * position[trace.align] + padding, key, Math.max);\n      dy = bignumberCenter[1] - deltaCenter[1];\n      numbersbBox = {\n        width: bignumberbBox.width + deltabBox.width + padding,\n        height: Math.max(bignumberbBox.height, deltabBox.height),\n        left: bignumberbBox.left,\n        right: deltabBox.right + dx,\n        top: Math.min(bignumberbBox.top, deltabBox.top + dy),\n        bottom: Math.max(bignumberbBox.bottom, deltabBox.bottom + dy)\n      };\n    }\n\n    if (trace.delta.position === 'bottom') {\n      dx = null;\n      dy = deltabBox.height;\n      numbersbBox = {\n        width: Math.max(bignumberbBox.width, deltabBox.width),\n        height: bignumberbBox.height + deltabBox.height,\n        left: Math.min(bignumberbBox.left, deltabBox.left),\n        right: Math.max(bignumberbBox.right, deltabBox.right),\n        top: bignumberbBox.bottom - bignumberbBox.height,\n        bottom: bignumberbBox.bottom + deltabBox.height\n      };\n    }\n\n    if (trace.delta.position === 'top') {\n      dx = null;\n      dy = bignumberbBox.top;\n      numbersbBox = {\n        width: Math.max(bignumberbBox.width, deltabBox.width),\n        height: bignumberbBox.height + deltabBox.height,\n        left: Math.min(bignumberbBox.left, deltabBox.left),\n        right: Math.max(bignumberbBox.right, deltabBox.right),\n        top: bignumberbBox.bottom - bignumberbBox.height - deltabBox.height,\n        bottom: bignumberbBox.bottom\n      };\n    }\n\n    delta.attr({\n      dx: dx,\n      dy: dy\n    });\n  } // Resize numbers to fit within space and position\n\n\n  if (trace._hasNumber || trace._hasDelta) {\n    numbers.attr('transform', function () {\n      var m = opts.numbersScaler(numbersbBox);\n      key += m[2];\n      var scaleRatio = cache(trace, 'numbersScale', 1, m[0], key, Math.min);\n      var translateY;\n      if (!trace._scaleNumbers) scaleRatio = 1;\n\n      if (trace._isAngular) {\n        // align vertically to bottom\n        translateY = numbersY - scaleRatio * numbersbBox.bottom;\n      } else {\n        // align vertically to center\n        translateY = numbersY - scaleRatio * (numbersbBox.top + numbersbBox.bottom) / 2;\n      } // Stash the top position of numbersbBox for title positioning\n\n\n      trace._numbersTop = scaleRatio * numbersbBox.top + translateY;\n      var ref = numbersbBox[numbersAlign];\n      if (numbersAlign === 'center') ref = (numbersbBox.left + numbersbBox.right) / 2;\n      var translateX = numbersX - scaleRatio * ref; // Stash translateX\n\n      translateX = cache(trace, 'numbersTranslate', 0, translateX, key, Math.max);\n      return strTranslate(translateX, translateY) + strScale(scaleRatio);\n    });\n  }\n} // Apply fill, stroke, stroke-width to SVG shape\n\n\nfunction styleShape(p) {\n  p.each(function (d) {\n    Color.stroke(d3.select(this), d.line.color);\n  }).each(function (d) {\n    Color.fill(d3.select(this), d.color);\n  }).style('stroke-width', function (d) {\n    return d.line.width;\n  });\n} // Returns a tween for a transitionâs \"d\" attribute, transitioning any selected\n// arcs from their current angle to the specified new angle.\n\n\nfunction arcTween(arc, endAngle, newAngle) {\n  return function () {\n    var interp = interpolate(endAngle, newAngle);\n    return function (t) {\n      return arc.endAngle(interp(t))();\n    };\n  };\n} // mocks our axis\n\n\nfunction mockAxis(gd, opts, zrange) {\n  var fullLayout = gd._fullLayout;\n  var axisIn = Lib.extendFlat({\n    type: 'linear',\n    ticks: 'outside',\n    range: zrange,\n    showline: true\n  }, opts);\n  var axisOut = {\n    type: 'linear',\n    _id: 'x' + opts._id\n  };\n  var axisOptions = {\n    letter: 'x',\n    font: fullLayout.font,\n    noHover: true,\n    noTickson: true\n  };\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axisIn, axisOut, axisLayoutAttrs, attr, dflt);\n  }\n\n  handleAxisDefaults(axisIn, axisOut, coerce, axisOptions, fullLayout);\n  handleAxisPositionDefaults(axisIn, axisOut, coerce, axisOptions);\n  return axisOut;\n}\n\nfunction fitTextInsideBox(textBB, width, height) {\n  // compute scaling ratio to have text fit within specified width and height\n  var ratio = Math.min(width / textBB.width, height / textBB.height);\n  return [ratio, textBB, width + 'x' + height];\n}\n\nfunction fitTextInsideCircle(textBB, radius) {\n  // compute scaling ratio to have text fit within specified radius\n  var elRadius = Math.sqrt(textBB.width / 2 * (textBB.width / 2) + textBB.height * textBB.height);\n  var ratio = radius / elRadius;\n  return [ratio, textBB, radius];\n}\n\nfunction measureText(txt, font, textAnchor, gd) {\n  var element = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n  var sel = d3.select(element);\n  sel.text(txt).attr('x', 0).attr('y', 0).attr('text-anchor', textAnchor).attr('data-unformatted', txt).call(svgTextUtils.convertToTspans, gd).call(Drawing.font, font);\n  return Drawing.bBox(sel.node());\n}\n\nfunction cache(trace, name, initialValue, value, key, fn) {\n  var objName = '_cache' + name;\n\n  if (!(trace[objName] && trace[objName].key === key)) {\n    trace[objName] = {\n      key: key,\n      value: initialValue\n    };\n  }\n\n  var v = Lib.aggNums(fn, null, [trace[objName].value, value], 2);\n  trace[objName].value = v;\n  return v;\n}","map":null,"metadata":{},"sourceType":"script"}