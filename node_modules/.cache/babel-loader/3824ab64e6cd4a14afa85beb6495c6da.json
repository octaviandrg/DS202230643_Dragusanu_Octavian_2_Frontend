{"ast":null,"code":"'use strict';\n\nvar mat4X4 = require('gl-mat4');\n\nexports.init2dArray = function (rowLength, colLength) {\n  var array = new Array(rowLength);\n\n  for (var i = 0; i < rowLength; i++) {\n    array[i] = new Array(colLength);\n  }\n\n  return array;\n};\n/**\n * transpose a (possibly ragged) 2d array z. inspired by\n * http://stackoverflow.com/questions/17428587/\n * transposing-a-2d-array-in-javascript\n */\n\n\nexports.transposeRagged = function (z) {\n  var maxlen = 0;\n  var zlen = z.length;\n  var i, j; // Maximum row length:\n\n  for (i = 0; i < zlen; i++) {\n    maxlen = Math.max(maxlen, z[i].length);\n  }\n\n  var t = new Array(maxlen);\n\n  for (i = 0; i < maxlen; i++) {\n    t[i] = new Array(zlen);\n\n    for (j = 0; j < zlen; j++) {\n      t[i][j] = z[j][i];\n    }\n  }\n\n  return t;\n}; // our own dot function so that we don't need to include numeric\n\n\nexports.dot = function (x, y) {\n  if (!(x.length && y.length) || x.length !== y.length) return null;\n  var len = x.length;\n  var out;\n  var i;\n\n  if (x[0].length) {\n    // mat-vec or mat-mat\n    out = new Array(len);\n\n    for (i = 0; i < len; i++) {\n      out[i] = exports.dot(x[i], y);\n    }\n  } else if (y[0].length) {\n    // vec-mat\n    var yTranspose = exports.transposeRagged(y);\n    out = new Array(yTranspose.length);\n\n    for (i = 0; i < yTranspose.length; i++) {\n      out[i] = exports.dot(x, yTranspose[i]);\n    }\n  } else {\n    // vec-vec\n    out = 0;\n\n    for (i = 0; i < len; i++) {\n      out += x[i] * y[i];\n    }\n  }\n\n  return out;\n}; // translate by (x,y)\n\n\nexports.translationMatrix = function (x, y) {\n  return [[1, 0, x], [0, 1, y], [0, 0, 1]];\n}; // rotate by alpha around (0,0)\n\n\nexports.rotationMatrix = function (alpha) {\n  var a = alpha * Math.PI / 180;\n  return [[Math.cos(a), -Math.sin(a), 0], [Math.sin(a), Math.cos(a), 0], [0, 0, 1]];\n}; // rotate by alpha around (x,y)\n\n\nexports.rotationXYMatrix = function (a, x, y) {\n  return exports.dot(exports.dot(exports.translationMatrix(x, y), exports.rotationMatrix(a)), exports.translationMatrix(-x, -y));\n}; // applies a 3D transformation matrix to either x, y and z params\n// Note: z is optional\n\n\nexports.apply3DTransform = function (transform) {\n  return function () {\n    var args = arguments;\n    var xyz = arguments.length === 1 ? args[0] : [args[0], args[1], args[2] || 0];\n    return exports.dot(transform, [xyz[0], xyz[1], xyz[2], 1]).slice(0, 3);\n  };\n}; // applies a 2D transformation matrix to either x and y params or an [x,y] array\n\n\nexports.apply2DTransform = function (transform) {\n  return function () {\n    var args = arguments;\n\n    if (args.length === 3) {\n      args = args[0];\n    } // from map\n\n\n    var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];\n    return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);\n  };\n}; // applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)\n\n\nexports.apply2DTransform2 = function (transform) {\n  var at = exports.apply2DTransform(transform);\n  return function (xys) {\n    return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));\n  };\n};\n\nexports.convertCssMatrix = function (m) {\n  if (m) {\n    var len = m.length;\n    if (len === 16) return m;\n\n    if (len === 6) {\n      // converts a 2x3 css transform matrix to a 4x4 matrix see https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n      return [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];\n    }\n  }\n\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}; // find the inverse for a 4x4 affine transform matrix\n\n\nexports.inverseTransformMatrix = function (m) {\n  var out = [];\n  mat4X4.invert(out, m);\n  return [[out[0], out[1], out[2], out[3]], [out[4], out[5], out[6], out[7]], [out[8], out[9], out[10], out[11]], [out[12], out[13], out[14], out[15]]];\n};","map":null,"metadata":{},"sourceType":"script"}