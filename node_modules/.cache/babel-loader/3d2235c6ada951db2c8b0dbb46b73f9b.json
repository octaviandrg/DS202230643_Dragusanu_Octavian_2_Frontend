{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../../registry');\n\nvar Lib = require('../../lib');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar handleArrayContainerDefaults = require('../array_container_defaults');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTickValueDefaults = require('./tick_value_defaults');\n\nvar handleTickMarkDefaults = require('./tick_mark_defaults');\n\nvar handleTickLabelDefaults = require('./tick_label_defaults');\n\nvar handlePrefixSuffixDefaults = require('./prefix_suffix_defaults');\n\nvar handleCategoryOrderDefaults = require('./category_order_defaults');\n\nvar handleLineGridDefaults = require('./line_grid_defaults');\n\nvar setConvert = require('./set_convert');\n\nvar DAY_OF_WEEK = require('./constants').WEEKDAY_PATTERN;\n\nvar HOUR = require('./constants').HOUR_PATTERN;\n/**\n * options: object containing:\n *\n *  letter: 'x' or 'y'\n *  title: name of the axis (ie 'Colorbar') to go in default title\n *  font: the default font to inherit\n *  outerTicks: boolean, should ticks default to outside?\n *  showGrid: boolean, should gridlines be shown by default?\n *  noHover: boolean, this axis doesn't support hover effects?\n *  noTickson: boolean, this axis doesn't support 'tickson'\n *  data: the plot data, used to manage categories\n *  bgColor: the plot background color, to calculate default gridline colors\n *  calendar:\n *  splomStash:\n *  visibleDflt: boolean\n *  reverseDflt: boolean\n *  automargin: boolean\n */\n\n\nmodule.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {\n  var letter = options.letter;\n  var font = options.font || {};\n  var splomStash = options.splomStash || {};\n  var visible = coerce('visible', !options.visibleDflt);\n  var axTemplate = containerOut._template || {};\n  var axType = containerOut.type || axTemplate.type || '-';\n  var ticklabelmode;\n\n  if (axType === 'date') {\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(containerIn, containerOut, 'calendar', options.calendar);\n\n    if (!options.noTicklabelmode) {\n      ticklabelmode = coerce('ticklabelmode');\n    }\n  }\n\n  var ticklabelposition = '';\n\n  if (!options.noTicklabelposition || axType === 'multicategory') {\n    ticklabelposition = Lib.coerce(containerIn, containerOut, {\n      ticklabelposition: {\n        valType: 'enumerated',\n        dflt: 'outside',\n        values: ticklabelmode === 'period' ? ['outside', 'inside'] : letter === 'x' ? ['outside', 'inside', 'outside left', 'inside left', 'outside right', 'inside right'] : ['outside', 'inside', 'outside top', 'inside top', 'outside bottom', 'inside bottom']\n      }\n    }, 'ticklabelposition');\n  }\n\n  if (!options.noTicklabeloverflow) {\n    coerce('ticklabeloverflow', ticklabelposition.indexOf('inside') !== -1 ? 'hide past domain' : axType === 'category' || axType === 'multicategory' ? 'allow' : 'hide past div');\n  }\n\n  setConvert(containerOut, layoutOut);\n  var autorangeDflt = !containerOut.isValidRange(containerIn.range);\n  if (autorangeDflt && options.reverseDflt) autorangeDflt = 'reversed';\n  var autoRange = coerce('autorange', autorangeDflt);\n  if (autoRange && (axType === 'linear' || axType === '-')) coerce('rangemode');\n  coerce('range');\n  containerOut.cleanRange();\n  handleCategoryOrderDefaults(containerIn, containerOut, coerce, options);\n  if (axType !== 'category' && !options.noHover) coerce('hoverformat');\n  var dfltColor = coerce('color'); // if axis.color was provided, use it for fonts too; otherwise,\n  // inherit from global font color in case that was provided.\n  // Compare to dflt rather than to containerIn, so we can provide color via\n  // template too.\n\n  var dfltFontColor = dfltColor !== layoutAttributes.color.dflt ? dfltColor : font.color; // try to get default title from splom trace, fallback to graph-wide value\n\n  var dfltTitle = splomStash.label || layoutOut._dfltTitle[letter];\n  handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options);\n  if (!visible) return containerOut;\n  coerce('title.text', dfltTitle);\n  Lib.coerceFont(coerce, 'title.font', {\n    family: font.family,\n    size: Lib.bigFont(font.size),\n    color: dfltFontColor\n  }); // major ticks\n\n  handleTickValueDefaults(containerIn, containerOut, coerce, axType);\n  var hasMinor = options.hasMinor;\n\n  if (hasMinor) {\n    // minor ticks\n    Template.newContainer(containerOut, 'minor');\n    handleTickValueDefaults(containerIn, containerOut, coerce, axType, {\n      isMinor: true\n    });\n  }\n\n  handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options); // major and minor ticks\n\n  handleTickMarkDefaults(containerIn, containerOut, coerce, options);\n\n  if (hasMinor) {\n    var keepIsMinor = options.isMinor;\n    options.isMinor = true;\n    handleTickMarkDefaults(containerIn, containerOut, coerce, options);\n    options.isMinor = keepIsMinor;\n  }\n\n  handleLineGridDefaults(containerIn, containerOut, coerce, {\n    dfltColor: dfltColor,\n    bgColor: options.bgColor,\n    showGrid: options.showGrid,\n    hasMinor: hasMinor,\n    attributes: layoutAttributes\n  }); // delete minor when no minor ticks or gridlines\n\n  if (hasMinor && !containerOut.minor.ticks && !containerOut.minor.showgrid) {\n    delete containerOut.minor;\n  } // mirror\n\n\n  if (containerOut.showline || containerOut.ticks) coerce('mirror');\n  if (options.automargin) coerce('automargin');\n  var isMultiCategory = axType === 'multicategory';\n\n  if (!options.noTickson && (axType === 'category' || isMultiCategory) && (containerOut.ticks || containerOut.showgrid)) {\n    var ticksonDflt;\n    if (isMultiCategory) ticksonDflt = 'boundaries';\n    var tickson = coerce('tickson', ticksonDflt);\n\n    if (tickson === 'boundaries') {\n      delete containerOut.ticklabelposition;\n    }\n  }\n\n  if (isMultiCategory) {\n    var showDividers = coerce('showdividers');\n\n    if (showDividers) {\n      coerce('dividercolor');\n      coerce('dividerwidth');\n    }\n  }\n\n  if (axType === 'date') {\n    handleArrayContainerDefaults(containerIn, containerOut, {\n      name: 'rangebreaks',\n      inclusionAttr: 'enabled',\n      handleItemDefaults: rangebreaksDefaults\n    });\n\n    if (!containerOut.rangebreaks.length) {\n      delete containerOut.rangebreaks;\n    } else {\n      for (var k = 0; k < containerOut.rangebreaks.length; k++) {\n        if (containerOut.rangebreaks[k].pattern === DAY_OF_WEEK) {\n          containerOut._hasDayOfWeekBreaks = true;\n          break;\n        }\n      }\n\n      setConvert(containerOut, layoutOut);\n\n      if (layoutOut._has('scattergl') || layoutOut._has('splom')) {\n        for (var i = 0; i < options.data.length; i++) {\n          var trace = options.data[i];\n\n          if (trace.type === 'scattergl' || trace.type === 'splom') {\n            trace.visible = false;\n            Lib.warn(trace.type + ' traces do not work on axes with rangebreaks.' + ' Setting trace ' + trace.index + ' to `visible: false`.');\n          }\n        }\n      }\n    }\n  }\n\n  return containerOut;\n};\n\nfunction rangebreaksDefaults(itemIn, itemOut, containerOut) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(itemIn, itemOut, layoutAttributes.rangebreaks, attr, dflt);\n  }\n\n  var enabled = coerce('enabled');\n\n  if (enabled) {\n    var bnds = coerce('bounds');\n\n    if (bnds && bnds.length >= 2) {\n      var dfltPattern = '';\n      var i, q;\n\n      if (bnds.length === 2) {\n        for (i = 0; i < 2; i++) {\n          q = indexOfDay(bnds[i]);\n\n          if (q) {\n            dfltPattern = DAY_OF_WEEK;\n            break;\n          }\n        }\n      }\n\n      var pattern = coerce('pattern', dfltPattern);\n\n      if (pattern === DAY_OF_WEEK) {\n        for (i = 0; i < 2; i++) {\n          q = indexOfDay(bnds[i]);\n\n          if (q) {\n            // convert to integers i.e 'Sunday' --> 0\n            itemOut.bounds[i] = bnds[i] = q - 1;\n          }\n        }\n      }\n\n      if (pattern) {\n        // ensure types and ranges\n        for (i = 0; i < 2; i++) {\n          q = bnds[i];\n\n          switch (pattern) {\n            case DAY_OF_WEEK:\n              if (!isNumeric(q)) {\n                itemOut.enabled = false;\n                return;\n              }\n\n              q = +q;\n\n              if (q !== Math.floor(q) || // don't accept fractional days for mow\n              q < 0 || q >= 7) {\n                itemOut.enabled = false;\n                return;\n              } // use number\n\n\n              itemOut.bounds[i] = bnds[i] = q;\n              break;\n\n            case HOUR:\n              if (!isNumeric(q)) {\n                itemOut.enabled = false;\n                return;\n              }\n\n              q = +q;\n\n              if (q < 0 || q > 24) {\n                // accept 24\n                itemOut.enabled = false;\n                return;\n              } // use number\n\n\n              itemOut.bounds[i] = bnds[i] = q;\n              break;\n          }\n        }\n      }\n\n      if (containerOut.autorange === false) {\n        var rng = containerOut.range; // if bounds are bigger than the (set) range, disable break\n\n        if (rng[0] < rng[1]) {\n          if (bnds[0] < rng[0] && bnds[1] > rng[1]) {\n            itemOut.enabled = false;\n            return;\n          }\n        } else if (bnds[0] > rng[0] && bnds[1] < rng[1]) {\n          itemOut.enabled = false;\n          return;\n        }\n      }\n    } else {\n      var values = coerce('values');\n\n      if (values && values.length) {\n        coerce('dvalue');\n      } else {\n        itemOut.enabled = false;\n        return;\n      }\n    }\n  }\n} // these numbers are one more than what bounds would be mapped to\n\n\nvar dayStrToNum = {\n  sun: 1,\n  mon: 2,\n  tue: 3,\n  wed: 4,\n  thu: 5,\n  fri: 6,\n  sat: 7\n};\n\nfunction indexOfDay(v) {\n  if (typeof v !== 'string') return;\n  return dayStrToNum[v.substr(0, 3).toLowerCase()];\n}","map":null,"metadata":{},"sourceType":"script"}