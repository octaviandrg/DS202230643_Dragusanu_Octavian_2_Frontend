{"ast":null,"code":"'use strict';\n\nvar readPaths = require('../shapes/draw_newshape/helpers').readPaths;\n\nvar displayOutlines = require('../shapes/display_outlines');\n\nvar clearOutlineControllers = require('../shapes/handle_outline').clearOutlineControllers;\n\nvar Color = require('../color');\n\nvar Drawing = require('../drawing');\n\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar helpers = require('../shapes/helpers');\n\nvar getPathString = helpers.getPathString; // Selections are stored in gd.layout.selections, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  activateLastSelection: activateLastSelection\n};\n\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n  clearOutlineControllers(gd); // Remove previous selections before drawing new selections in fullLayout.selections\n\n  fullLayout._selectionLayer.selectAll('path').remove();\n\n  for (var k in fullLayout._plots) {\n    var selectionLayer = fullLayout._plots[k].selectionLayer;\n    if (selectionLayer) selectionLayer.selectAll('path').remove();\n  }\n\n  for (var i = 0; i < fullLayout.selections.length; i++) {\n    drawOne(gd, i);\n  }\n}\n\nfunction couldHaveActiveSelection(gd) {\n  return gd._context.editSelection;\n}\n\nfunction drawOne(gd, index) {\n  // remove the existing selection if there is one.\n  // because indices can change, we need to look in all selection layers\n  gd._fullLayout._paperdiv.selectAll('.selectionlayer [data-index=\"' + index + '\"]').remove();\n\n  var o = helpers.makeSelectionsOptionsAndPlotinfo(gd, index);\n  var options = o.options;\n  var plotinfo = o.plotinfo; // this selection is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n\n  if (!options._input) return;\n  drawSelection(gd._fullLayout._selectionLayer);\n\n  function drawSelection(selectionLayer) {\n    var d = getPathString(gd, options);\n    var attrs = {\n      'data-index': index,\n      'fill-rule': 'evenodd',\n      d: d\n    };\n    var opacity = options.opacity;\n    var fillColor = 'rgba(0,0,0,0)';\n    var lineColor = options.line.color || Color.contrast(gd._fullLayout.plot_bgcolor);\n    var lineWidth = options.line.width;\n    var lineDash = options.line.dash;\n\n    if (!lineWidth) {\n      // ensure invisible border to activate the selection\n      lineWidth = 5;\n      lineDash = 'solid';\n    }\n\n    var isActiveSelection = couldHaveActiveSelection(gd) && gd._fullLayout._activeSelectionIndex === index;\n\n    if (isActiveSelection) {\n      fillColor = gd._fullLayout.activeselection.fillcolor;\n      opacity = gd._fullLayout.activeselection.opacity;\n    }\n\n    var allPaths = [];\n\n    for (var sensory = 1; sensory >= 0; sensory--) {\n      var path = selectionLayer.append('path').attr(attrs).style('opacity', sensory ? 0.1 : opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor) // make it easier to select senory background path\n      .call(Drawing.dashLine, sensory ? 'solid' : lineDash, sensory ? 4 + lineWidth : lineWidth);\n      setClipPath(path, gd, options);\n\n      if (isActiveSelection) {\n        var editHelpers = arrayEditor(gd.layout, 'selections', options);\n        path.style({\n          'cursor': 'move'\n        });\n        var dragOptions = {\n          element: path.node(),\n          plotinfo: plotinfo,\n          gd: gd,\n          editHelpers: editHelpers,\n          isActiveSelection: true // i.e. to enable controllers\n\n        };\n        var polygons = readPaths(d, gd); // display polygons on the screen\n\n        displayOutlines(polygons, path, dragOptions);\n      } else {\n        path.style('pointer-events', sensory ? 'all' : 'none');\n      }\n\n      allPaths[sensory] = path;\n    }\n\n    var forePath = allPaths[0];\n    var backPath = allPaths[1];\n    backPath.node().addEventListener('click', function () {\n      return activateSelection(gd, forePath);\n    });\n  }\n}\n\nfunction setClipPath(selectionPath, gd, selectionOptions) {\n  var clipAxes = selectionOptions.xref + selectionOptions.yref;\n  Drawing.setClipUrl(selectionPath, 'clip' + gd._fullLayout._uid + clipAxes, gd);\n}\n\nfunction activateSelection(gd, path) {\n  if (!couldHaveActiveSelection(gd)) return;\n  var element = path.node();\n  var id = +element.getAttribute('data-index');\n\n  if (id >= 0) {\n    // deactivate if already active\n    if (id === gd._fullLayout._activeSelectionIndex) {\n      deactivateSelection(gd);\n      return;\n    }\n\n    gd._fullLayout._activeSelectionIndex = id;\n    gd._fullLayout._deactivateSelection = deactivateSelection;\n    draw(gd);\n  }\n}\n\nfunction activateLastSelection(gd) {\n  if (!couldHaveActiveSelection(gd)) return;\n  var id = gd._fullLayout.selections.length - 1;\n  gd._fullLayout._activeSelectionIndex = id;\n  gd._fullLayout._deactivateSelection = deactivateSelection;\n  draw(gd);\n}\n\nfunction deactivateSelection(gd) {\n  if (!couldHaveActiveSelection(gd)) return;\n  var id = gd._fullLayout._activeSelectionIndex;\n\n  if (id >= 0) {\n    clearOutlineControllers(gd);\n    delete gd._fullLayout._activeSelectionIndex;\n    draw(gd);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}