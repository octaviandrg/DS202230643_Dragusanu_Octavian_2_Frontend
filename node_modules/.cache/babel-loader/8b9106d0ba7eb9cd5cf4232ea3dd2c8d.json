{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar sanitizeHTML = require('../../lib/svg_text_utils').sanitizeHTML;\n\nvar convertTextOpts = require('./convert_text_opts');\n\nvar constants = require('./constants');\n\nfunction MapboxLayer(subplot, index) {\n  this.subplot = subplot;\n  this.uid = subplot.uid + '-' + index;\n  this.index = index;\n  this.idSource = 'source-' + this.uid;\n  this.idLayer = constants.layoutLayerPrefix + this.uid; // some state variable to check if a remove/add step is needed\n\n  this.sourceType = null;\n  this.source = null;\n  this.layerType = null;\n  this.below = null; // is layer currently visible\n\n  this.visible = false;\n}\n\nvar proto = MapboxLayer.prototype;\n\nproto.update = function update(opts) {\n  if (!this.visible) {\n    // IMPORTANT: must create source before layer to not cause errors\n    this.updateSource(opts);\n    this.updateLayer(opts);\n  } else if (this.needsNewImage(opts)) {\n    this.updateImage(opts);\n  } else if (this.needsNewSource(opts)) {\n    // IMPORTANT: must delete layer before source to not cause errors\n    this.removeLayer();\n    this.updateSource(opts);\n    this.updateLayer(opts);\n  } else if (this.needsNewLayer(opts)) {\n    this.updateLayer(opts);\n  } else {\n    this.updateStyle(opts);\n  }\n\n  this.visible = isVisible(opts);\n};\n\nproto.needsNewImage = function (opts) {\n  var map = this.subplot.map;\n  return map.getSource(this.idSource) && this.sourceType === 'image' && opts.sourcetype === 'image' && (this.source !== opts.source || JSON.stringify(this.coordinates) !== JSON.stringify(opts.coordinates));\n};\n\nproto.needsNewSource = function (opts) {\n  // for some reason changing layer to 'fill' or 'symbol'\n  // w/o changing the source throws an exception in mapbox-gl 0.18 ;\n  // stay safe and make new source on type changes\n  return this.sourceType !== opts.sourcetype || JSON.stringify(this.source) !== JSON.stringify(opts.source) || this.layerType !== opts.type;\n};\n\nproto.needsNewLayer = function (opts) {\n  return this.layerType !== opts.type || this.below !== this.subplot.belowLookup['layout-' + this.index];\n};\n\nproto.lookupBelow = function () {\n  return this.subplot.belowLookup['layout-' + this.index];\n};\n\nproto.updateImage = function (opts) {\n  var map = this.subplot.map;\n  map.getSource(this.idSource).updateImage({\n    url: opts.source,\n    coordinates: opts.coordinates\n  }); // Since the `updateImage` control flow doesn't call updateLayer,\n  // We need to take care of moving the image layer to match the location\n  // where updateLayer would have placed it.\n\n  var _below = this.findFollowingMapboxLayerId(this.lookupBelow());\n\n  if (_below !== null) {\n    this.subplot.map.moveLayer(this.idLayer, _below);\n  }\n};\n\nproto.updateSource = function (opts) {\n  var map = this.subplot.map;\n  if (map.getSource(this.idSource)) map.removeSource(this.idSource);\n  this.sourceType = opts.sourcetype;\n  this.source = opts.source;\n  if (!isVisible(opts)) return;\n  var sourceOpts = convertSourceOpts(opts);\n  map.addSource(this.idSource, sourceOpts);\n};\n\nproto.findFollowingMapboxLayerId = function (below) {\n  if (below === 'traces') {\n    var mapLayers = this.subplot.getMapLayers(); // find id of first plotly trace layer\n\n    for (var i = 0; i < mapLayers.length; i++) {\n      var layerId = mapLayers[i].id;\n\n      if (typeof layerId === 'string' && layerId.indexOf(constants.traceLayerPrefix) === 0) {\n        below = layerId;\n        break;\n      }\n    }\n  }\n\n  return below;\n};\n\nproto.updateLayer = function (opts) {\n  var subplot = this.subplot;\n  var convertedOpts = convertOpts(opts);\n  var below = this.lookupBelow();\n\n  var _below = this.findFollowingMapboxLayerId(below);\n\n  this.removeLayer();\n\n  if (isVisible(opts)) {\n    subplot.addLayer({\n      id: this.idLayer,\n      source: this.idSource,\n      'source-layer': opts.sourcelayer || '',\n      type: opts.type,\n      minzoom: opts.minzoom,\n      maxzoom: opts.maxzoom,\n      layout: convertedOpts.layout,\n      paint: convertedOpts.paint\n    }, _below);\n  }\n\n  this.layerType = opts.type;\n  this.below = below;\n};\n\nproto.updateStyle = function (opts) {\n  if (isVisible(opts)) {\n    var convertedOpts = convertOpts(opts);\n    this.subplot.setOptions(this.idLayer, 'setLayoutProperty', convertedOpts.layout);\n    this.subplot.setOptions(this.idLayer, 'setPaintProperty', convertedOpts.paint);\n  }\n};\n\nproto.removeLayer = function () {\n  var map = this.subplot.map;\n\n  if (map.getLayer(this.idLayer)) {\n    map.removeLayer(this.idLayer);\n  }\n};\n\nproto.dispose = function () {\n  var map = this.subplot.map;\n  if (map.getLayer(this.idLayer)) map.removeLayer(this.idLayer);\n  if (map.getSource(this.idSource)) map.removeSource(this.idSource);\n};\n\nfunction isVisible(opts) {\n  if (!opts.visible) return false;\n  var source = opts.source;\n\n  if (Array.isArray(source) && source.length > 0) {\n    for (var i = 0; i < source.length; i++) {\n      if (typeof source[i] !== 'string' || source[i].length === 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return Lib.isPlainObject(source) || typeof source === 'string' && source.length > 0;\n}\n\nfunction convertOpts(opts) {\n  var layout = {};\n  var paint = {};\n\n  switch (opts.type) {\n    case 'circle':\n      Lib.extendFlat(paint, {\n        'circle-radius': opts.circle.radius,\n        'circle-color': opts.color,\n        'circle-opacity': opts.opacity\n      });\n      break;\n\n    case 'line':\n      Lib.extendFlat(paint, {\n        'line-width': opts.line.width,\n        'line-color': opts.color,\n        'line-opacity': opts.opacity,\n        'line-dasharray': opts.line.dash\n      });\n      break;\n\n    case 'fill':\n      Lib.extendFlat(paint, {\n        'fill-color': opts.color,\n        'fill-outline-color': opts.fill.outlinecolor,\n        'fill-opacity': opts.opacity // no way to pass specify outline width at the moment\n\n      });\n      break;\n\n    case 'symbol':\n      var symbol = opts.symbol;\n      var textOpts = convertTextOpts(symbol.textposition, symbol.iconsize);\n      Lib.extendFlat(layout, {\n        'icon-image': symbol.icon + '-15',\n        'icon-size': symbol.iconsize / 10,\n        'text-field': symbol.text,\n        'text-size': symbol.textfont.size,\n        'text-anchor': textOpts.anchor,\n        'text-offset': textOpts.offset,\n        'symbol-placement': symbol.placement // TODO font family\n        // 'text-font': symbol.textfont.family.split(', '),\n\n      });\n      Lib.extendFlat(paint, {\n        'icon-color': opts.color,\n        'text-color': symbol.textfont.color,\n        'text-opacity': opts.opacity\n      });\n      break;\n\n    case 'raster':\n      Lib.extendFlat(paint, {\n        'raster-fade-duration': 0,\n        'raster-opacity': opts.opacity\n      });\n      break;\n  }\n\n  return {\n    layout: layout,\n    paint: paint\n  };\n}\n\nfunction convertSourceOpts(opts) {\n  var sourceType = opts.sourcetype;\n  var source = opts.source;\n  var sourceOpts = {\n    type: sourceType\n  };\n  var field;\n\n  if (sourceType === 'geojson') {\n    field = 'data';\n  } else if (sourceType === 'vector') {\n    field = typeof source === 'string' ? 'url' : 'tiles';\n  } else if (sourceType === 'raster') {\n    field = 'tiles';\n    sourceOpts.tileSize = 256;\n  } else if (sourceType === 'image') {\n    field = 'url';\n    sourceOpts.coordinates = opts.coordinates;\n  }\n\n  sourceOpts[field] = source;\n\n  if (opts.sourceattribution) {\n    sourceOpts.attribution = sanitizeHTML(opts.sourceattribution);\n  }\n\n  return sourceOpts;\n}\n\nmodule.exports = function createMapboxLayer(subplot, index, opts) {\n  var mapboxLayer = new MapboxLayer(subplot, index);\n  mapboxLayer.update(opts);\n  return mapboxLayer;\n};","map":null,"metadata":{},"sourceType":"script"}