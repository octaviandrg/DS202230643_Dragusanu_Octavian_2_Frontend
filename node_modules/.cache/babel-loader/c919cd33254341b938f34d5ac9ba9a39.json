{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Axes = require('../../plots/cartesian/axes');\n\nvar boxCalc = require('../box/calc');\n\nvar helpers = require('./helpers');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function calc(gd, trace) {\n  var cd = boxCalc(gd, trace);\n  if (cd[0].t.empty) return cd;\n  var fullLayout = gd._fullLayout;\n  var valAxis = Axes.getFromId(gd, trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']);\n  var spanMin = Infinity;\n  var spanMax = -Infinity;\n  var maxKDE = 0;\n  var maxCount = 0;\n\n  for (var i = 0; i < cd.length; i++) {\n    var cdi = cd[i];\n    var vals = cdi.pts.map(helpers.extractVal);\n    var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n    var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n    if (cdi.min === cdi.max && bandwidth === 0) {\n      // if span is zero and bandwidth is zero, we want a violin with zero width\n      span = cdi.span = [cdi.min, cdi.max];\n      cdi.density = [{\n        v: 1,\n        t: span[0]\n      }];\n      cdi.bandwidth = bandwidth;\n      maxKDE = Math.max(maxKDE, 1);\n    } else {\n      // step that well covers the bandwidth and is multiple of span distance\n      var dist = span[1] - span[0];\n      var n = Math.ceil(dist / (bandwidth / 3));\n      var step = dist / n;\n\n      if (!isFinite(step) || !isFinite(n)) {\n        Lib.error('Something went wrong with computing the violin span');\n        cd[0].t.empty = true;\n        return cd;\n      }\n\n      var kde = helpers.makeKDE(cdi, trace, vals);\n      cdi.density = new Array(n);\n\n      for (var k = 0, t = span[0]; t < span[1] + step / 2; k++, t += step) {\n        var v = kde(t);\n        cdi.density[k] = {\n          v: v,\n          t: t\n        };\n        maxKDE = Math.max(maxKDE, v);\n      }\n    }\n\n    maxCount = Math.max(maxCount, vals.length);\n    spanMin = Math.min(spanMin, span[0]);\n    spanMax = Math.max(spanMax, span[1]);\n  }\n\n  var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {\n    padded: true\n  });\n  trace._extremes[valAxis._id] = extremes;\n\n  if (trace.width) {\n    cd[0].t.maxKDE = maxKDE;\n  } else {\n    var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n    var scaleGroup = trace.scalegroup;\n    var groupStats = violinScaleGroupStats[scaleGroup];\n\n    if (groupStats) {\n      groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n      groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n    } else {\n      violinScaleGroupStats[scaleGroup] = {\n        maxKDE: maxKDE,\n        maxCount: maxCount\n      };\n    }\n  }\n\n  cd[0].t.labels.kde = Lib._(gd, 'kde:');\n  return cd;\n}; // Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\n\n\nfunction silvermanRule(len, ssd, iqr) {\n  var a = Math.min(ssd, iqr / 1.349);\n  return 1.059 * a * Math.pow(len, -0.2);\n}\n\nfunction calcBandwidth(trace, cdi, vals) {\n  var span = cdi.max - cdi.min; // If span is zero\n\n  if (!span) {\n    if (trace.bandwidth) {\n      return trace.bandwidth;\n    } else {\n      // if span is zero and no bandwidth is specified\n      // it returns zero bandwidth which is a special case\n      return 0;\n    }\n  } // Limit how small the bandwidth can be.\n  //\n  // Silverman's rule of thumb can be \"very\" small\n  // when IQR does a poor job at describing the spread\n  // of the distribution.\n  // We also want to limit custom bandwidths\n  // to not blow up kde computations.\n\n\n  if (trace.bandwidth) {\n    return Math.max(trace.bandwidth, span / 1e4);\n  } else {\n    var len = vals.length;\n    var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n    return Math.max(silvermanRule(len, ssd, cdi.q3 - cdi.q1), span / 100);\n  }\n}\n\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n  var spanmode = trace.spanmode;\n  var spanIn = trace.span || [];\n  var spanTight = [cdi.min, cdi.max];\n  var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n  var spanOut;\n\n  function calcSpanItem(index) {\n    var s = spanIn[index];\n    var sc = valAxis.type === 'multicategory' ? valAxis.r2c(s) : valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n    return sc === BADNUM ? spanLoose[index] : sc;\n  }\n\n  if (spanmode === 'soft') {\n    spanOut = spanLoose;\n  } else if (spanmode === 'hard') {\n    spanOut = spanTight;\n  } else {\n    spanOut = [calcSpanItem(0), calcSpanItem(1)];\n  } // to reuse the equal-range-item block\n\n\n  var dummyAx = {\n    type: 'linear',\n    range: spanOut\n  };\n  Axes.setConvert(dummyAx);\n  dummyAx.cleanRange();\n  return spanOut;\n}","map":null,"metadata":{},"sourceType":"script"}