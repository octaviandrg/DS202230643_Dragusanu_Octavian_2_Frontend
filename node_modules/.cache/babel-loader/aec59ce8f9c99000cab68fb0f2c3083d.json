{"ast":null,"code":"'use strict';\n/* eslint-disable consistent-return */\n\nfunction isWhiteSpace(chr) {\n  return chr === 0x20 || chr === 0x09 || chr === 0x0D || chr === 0x0A;\n} // Filter NaN, Infinity, < 0\n\n\nfunction isFinitePositive(val) {\n  return typeof val === 'number' && isFinite(val) && val > 0;\n}\n\nfunction canBeSvg(buf) {\n  var i = 0,\n      max = buf.length; // byte order mark, https://github.com/nodeca/probe-image-size/issues/57\n\n  if (buf[0] === 0xEF && buf[1] === 0xBB && buf[2] === 0xBF) i = 3;\n\n  while (i < max && isWhiteSpace(buf[i])) {\n    i++;\n  }\n\n  if (i === max) return false;\n  return buf[i] === 0x3c;\n  /* < */\n} // skip `<?` (comments), `<!` (directives, cdata, doctype),\n// looking for `<svg>` or `<NAMESPACE:svg>`\n\n\nvar SVG_HEADER_RE = /<[-_.:a-zA-Z0-9][^>]*>/; // test if the top level element is svg + optional namespace,\n// used to skip svg embedded in html\n\nvar SVG_TAG_RE = /^<([-_.:a-zA-Z0-9]+:)?svg\\s/;\nvar SVG_WIDTH_RE = /[^-]\\bwidth=\"([^%]+?)\"|[^-]\\bwidth='([^%]+?)'/;\nvar SVG_HEIGHT_RE = /\\bheight=\"([^%]+?)\"|\\bheight='([^%]+?)'/;\nvar SVG_VIEWBOX_RE = /\\bview[bB]ox=\"(.+?)\"|\\bview[bB]ox='(.+?)'/;\nvar SVG_UNITS_RE = /in$|mm$|cm$|pt$|pc$|px$|em$|ex$/;\n\nfunction svgAttrs(str) {\n  var width = str.match(SVG_WIDTH_RE);\n  var height = str.match(SVG_HEIGHT_RE);\n  var viewbox = str.match(SVG_VIEWBOX_RE);\n  return {\n    width: width && (width[1] || width[2]),\n    height: height && (height[1] || height[2]),\n    viewbox: viewbox && (viewbox[1] || viewbox[2])\n  };\n}\n\nfunction units(str) {\n  if (!SVG_UNITS_RE.test(str)) return 'px';\n  return str.match(SVG_UNITS_RE)[0];\n}\n\nmodule.exports = function (data) {\n  if (!canBeSvg(data)) return;\n  var str = '';\n\n  for (var i = 0; i < data.length; i++) {\n    // 1. We can't rely on buffer features\n    // 2. Don't care about UTF16 because ascii is enougth for our goals\n    str += String.fromCharCode(data[i]);\n  } // get top level element\n\n\n  var svgTag = (str.match(SVG_HEADER_RE) || [''])[0]; // test if top level element is <svg>\n\n  if (!SVG_TAG_RE.test(svgTag)) return;\n  var attrs = svgAttrs(svgTag);\n  var width = parseFloat(attrs.width);\n  var height = parseFloat(attrs.height); // Extract from direct values\n\n  if (attrs.width && attrs.height) {\n    if (!isFinitePositive(width) || !isFinitePositive(height)) return;\n    return {\n      width: width,\n      height: height,\n      type: 'svg',\n      mime: 'image/svg+xml',\n      wUnits: units(attrs.width),\n      hUnits: units(attrs.height)\n    };\n  } // Extract from viewbox\n\n\n  var parts = (attrs.viewbox || '').split(' ');\n  var viewbox = {\n    width: parts[2],\n    height: parts[3]\n  };\n  var vbWidth = parseFloat(viewbox.width);\n  var vbHeight = parseFloat(viewbox.height);\n  if (!isFinitePositive(vbWidth) || !isFinitePositive(vbHeight)) return;\n  if (units(viewbox.width) !== units(viewbox.height)) return;\n  var ratio = vbWidth / vbHeight;\n\n  if (attrs.width) {\n    if (!isFinitePositive(width)) return;\n    return {\n      width: width,\n      height: width / ratio,\n      type: 'svg',\n      mime: 'image/svg+xml',\n      wUnits: units(attrs.width),\n      hUnits: units(attrs.width)\n    };\n  }\n\n  if (attrs.height) {\n    if (!isFinitePositive(height)) return;\n    return {\n      width: height * ratio,\n      height: height,\n      type: 'svg',\n      mime: 'image/svg+xml',\n      wUnits: units(attrs.height),\n      hUnits: units(attrs.height)\n    };\n  }\n\n  return {\n    width: vbWidth,\n    height: vbHeight,\n    type: 'svg',\n    mime: 'image/svg+xml',\n    wUnits: units(viewbox.width),\n    hUnits: units(viewbox.height)\n  };\n};","map":null,"metadata":{},"sourceType":"script"}