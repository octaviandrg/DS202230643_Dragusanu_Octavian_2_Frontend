{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Color = require('../../components/color');\n\nvar isUnifiedHover = require('../../components/fx/helpers').isUnifiedHover;\n\nvar handleHoverModeDefaults = require('../../components/fx/hovermode_defaults');\n\nvar Template = require('../../plot_api/plot_template');\n\nvar basePlotLayoutAttributes = require('../layout_attributes');\n\nvar layoutAttributes = require('./layout_attributes');\n\nvar handleTypeDefaults = require('./type_defaults');\n\nvar handleAxisDefaults = require('./axis_defaults');\n\nvar constraints = require('./constraints');\n\nvar handlePositionDefaults = require('./position_defaults');\n\nvar axisIds = require('./axis_ids');\n\nvar id2name = axisIds.id2name;\nvar name2id = axisIds.name2id;\n\nvar AX_ID_PATTERN = require('./constants').AX_ID_PATTERN;\n\nvar Registry = require('../../registry');\n\nvar traceIs = Registry.traceIs;\nvar getComponentMethod = Registry.getComponentMethod;\n\nfunction appendList(cont, k, item) {\n  if (Array.isArray(cont[k])) cont[k].push(item);else cont[k] = [item];\n}\n\nmodule.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {\n  var autotypenumbersDflt = layoutOut.autotypenumbers;\n  var ax2traces = {};\n  var xaMayHide = {};\n  var yaMayHide = {};\n  var xaMustDisplay = {};\n  var yaMustDisplay = {};\n  var yaMustNotReverse = {};\n  var yaMayReverse = {};\n  var axHasImage = {};\n  var outerTicks = {};\n  var noGrids = {};\n  var i, j; // look for axes in the data\n\n  for (i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (!traceIs(trace, 'cartesian') && !traceIs(trace, 'gl2d')) continue;\n    var xaName;\n\n    if (trace.xaxis) {\n      xaName = id2name(trace.xaxis);\n      appendList(ax2traces, xaName, trace);\n    } else if (trace.xaxes) {\n      for (j = 0; j < trace.xaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.xaxes[j]), trace);\n      }\n    }\n\n    var yaName;\n\n    if (trace.yaxis) {\n      yaName = id2name(trace.yaxis);\n      appendList(ax2traces, yaName, trace);\n    } else if (trace.yaxes) {\n      for (j = 0; j < trace.yaxes.length; j++) {\n        appendList(ax2traces, id2name(trace.yaxes[j]), trace);\n      }\n    } // logic for funnels\n\n\n    if (trace.type === 'funnel') {\n      if (trace.orientation === 'h') {\n        if (xaName) xaMayHide[xaName] = true;\n        if (yaName) yaMayReverse[yaName] = true;\n      } else {\n        if (yaName) yaMayHide[yaName] = true;\n      }\n    } else if (trace.type === 'image') {\n      if (yaName) axHasImage[yaName] = true;\n      if (xaName) axHasImage[xaName] = true;\n    } else {\n      if (yaName) {\n        yaMustDisplay[yaName] = true;\n        yaMustNotReverse[yaName] = true;\n      }\n\n      if (!traceIs(trace, 'carpet') || trace.type === 'carpet' && !trace._cheater) {\n        if (xaName) xaMustDisplay[xaName] = true;\n      }\n    } // Two things trigger axis visibility:\n    // 1. is not carpet\n    // 2. carpet that's not cheater\n    // The above check for definitely-not-cheater is not adequate. This\n    // second list tracks which axes *could* be a cheater so that the\n    // full condition triggering hiding is:\n    //   *could* be a cheater and *is not definitely visible*\n\n\n    if (trace.type === 'carpet' && trace._cheater) {\n      if (xaName) xaMayHide[xaName] = true;\n    } // check for default formatting tweaks\n\n\n    if (traceIs(trace, '2dMap')) {\n      outerTicks[xaName] = true;\n      outerTicks[yaName] = true;\n    }\n\n    if (traceIs(trace, 'oriented')) {\n      var positionAxis = trace.orientation === 'h' ? yaName : xaName;\n      noGrids[positionAxis] = true;\n    }\n  }\n\n  var subplots = layoutOut._subplots;\n  var xIds = subplots.xaxis;\n  var yIds = subplots.yaxis;\n  var xNames = Lib.simpleMap(xIds, id2name);\n  var yNames = Lib.simpleMap(yIds, id2name);\n  var axNames = xNames.concat(yNames); // plot_bgcolor only makes sense if there's a (2D) plot!\n  // TODO: bgcolor for each subplot, to inherit from the main one\n\n  var plotBgColor = Color.background;\n\n  if (xIds.length && yIds.length) {\n    plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');\n  }\n\n  var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor); // name of single axis (e.g. 'xaxis', 'yaxis2')\n\n  var axName; // id of single axis (e.g. 'y', 'x5')\n\n  var axId; // 'x' or 'y'\n\n  var axLetter; // input layout axis container\n\n  var axLayoutIn; // full layout axis container\n\n  var axLayoutOut;\n\n  function newAxLayoutOut() {\n    var traces = ax2traces[axName] || [];\n    axLayoutOut._traceIndices = traces.map(function (t) {\n      return t._expandedIndex;\n    });\n    axLayoutOut._annIndices = [];\n    axLayoutOut._shapeIndices = [];\n    axLayoutOut._selectionIndices = [];\n    axLayoutOut._imgIndices = [];\n    axLayoutOut._subplotsWith = [];\n    axLayoutOut._counterAxes = [];\n    axLayoutOut._name = axLayoutOut._attr = axName;\n    axLayoutOut._id = axId;\n  }\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function coerce2(attr, dflt) {\n    return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);\n  }\n\n  function getCounterAxes(axLetter) {\n    return axLetter === 'x' ? yIds : xIds;\n  }\n\n  function getOverlayableAxes(axLetter, axName) {\n    var list = axLetter === 'x' ? xNames : yNames;\n    var out = [];\n\n    for (var j = 0; j < list.length; j++) {\n      var axName2 = list[j];\n\n      if (axName2 !== axName && !(layoutIn[axName2] || {}).overlaying) {\n        out.push(name2id(axName2));\n      }\n    }\n\n    return out;\n  } // list of available counter axis names\n\n\n  var counterAxes = {\n    x: getCounterAxes('x'),\n    y: getCounterAxes('y')\n  }; // list of all x AND y axis ids\n\n  var allAxisIds = counterAxes.x.concat(counterAxes.y); // lookup and list of axis ids that axes in axNames have a reference to,\n  // even though they are missing from allAxisIds\n\n  var missingMatchedAxisIdsLookup = {};\n  var missingMatchedAxisIds = []; // fill in 'missing' axis lookup when an axis is set to match an axis\n  // not part of the allAxisIds list, save axis type so that we can propagate\n  // it to the missing axes\n\n  function addMissingMatchedAxis() {\n    var matchesIn = axLayoutIn.matches;\n\n    if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {\n      missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;\n      missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);\n    }\n  }\n\n  var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);\n  var unifiedHover = isUnifiedHover(hovermode); // first pass creates the containers, determines types, and handles most of the settings\n\n  for (i = 0; i < axNames.length; i++) {\n    axName = axNames[i];\n    axId = name2id(axName);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var visibleDflt = axLetter === 'x' && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === 'y' && !yaMustDisplay[axName] && yaMayHide[axName];\n    var reverseDflt = axLetter === 'y' && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);\n    var defaultOptions = {\n      hasMinor: true,\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: ax2traces[axName] || [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: visibleDflt,\n      reverseDflt: reverseDflt,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);\n    var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);\n    var spikecolor = coerce2('spikecolor', unifiedHover ? axLayoutOut.color : undefined);\n    var spikethickness = coerce2('spikethickness', unifiedHover ? 1.5 : undefined);\n    var spikedash = coerce2('spikedash', unifiedHover ? 'dot' : undefined);\n    var spikemode = coerce2('spikemode', unifiedHover ? 'across' : undefined);\n    var spikesnap = coerce2('spikesnap');\n    var showSpikes = coerce('showspikes', !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);\n\n    if (!showSpikes) {\n      delete axLayoutOut.spikecolor;\n      delete axLayoutOut.spikethickness;\n      delete axLayoutOut.spikedash;\n      delete axLayoutOut.spikemode;\n      delete axLayoutOut.spikesnap;\n    }\n\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('title.standoff');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // coerce the 'missing' axes\n\n\n  i = 0;\n\n  while (i < missingMatchedAxisIds.length) {\n    axId = missingMatchedAxisIds[i++];\n    axName = id2name(axId);\n    axLetter = axName.charAt(0);\n\n    if (!Lib.isPlainObject(layoutIn[axName])) {\n      layoutIn[axName] = {};\n    }\n\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + 'axis');\n    newAxLayoutOut();\n    var defaultOptions2 = {\n      letter: axLetter,\n      font: layoutOut.font,\n      outerTicks: outerTicks[axName],\n      showGrid: !noGrids[axName],\n      data: [],\n      bgColor: bgColor,\n      calendar: layoutOut.calendar,\n      automargin: true,\n      visibleDflt: false,\n      reverseDflt: false,\n      autotypenumbersDflt: autotypenumbersDflt,\n      splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]\n    };\n    coerce('uirevision', layoutOut.uirevision);\n    axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || 'linear';\n    handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);\n    handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {\n      letter: axLetter,\n      counterAxes: counterAxes[axLetter],\n      overlayableAxes: getOverlayableAxes(axLetter, axName),\n      grid: layoutOut.grid\n    });\n    coerce('fixedrange');\n    addMissingMatchedAxis();\n    axLayoutOut._input = axLayoutIn;\n  } // quick second pass for range slider and selector defaults\n\n\n  var rangeSliderDefaults = getComponentMethod('rangeslider', 'handleDefaults');\n  var rangeSelectorDefaults = getComponentMethod('rangeselector', 'handleDefaults');\n\n  for (i = 0; i < xNames.length; i++) {\n    axName = xNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    rangeSliderDefaults(layoutIn, layoutOut, axName);\n\n    if (axLayoutOut.type === 'date') {\n      rangeSelectorDefaults(axLayoutIn, axLayoutOut, layoutOut, yNames, axLayoutOut.calendar);\n    }\n\n    coerce('fixedrange');\n  }\n\n  for (i = 0; i < yNames.length; i++) {\n    axName = yNames[i];\n    axLayoutIn = layoutIn[axName];\n    axLayoutOut = layoutOut[axName];\n    var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];\n    var fixedRangeDflt = getComponentMethod('rangeslider', 'isVisible')(anchoredAxis);\n    coerce('fixedrange', fixedRangeDflt);\n  } // Finally, handle scale constraints and matching axes.\n  //\n  // We need to do this after all axes have coerced both `type`\n  // (so we link only axes of the same type) and\n  // `fixedrange` (so we can avoid linking from OR TO a fixed axis).\n\n\n  constraints.handleDefaults(layoutIn, layoutOut, {\n    axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),\n    axHasImage: axHasImage\n  });\n};","map":null,"metadata":{},"sourceType":"script"}