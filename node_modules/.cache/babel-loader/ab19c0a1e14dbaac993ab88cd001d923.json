{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/danaliulica/Documents/PROIECT/DS202230643_Dragusanu_Octavian_1_Frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar rgba = require('color-normalize');\n\nvar getBounds = require('array-bounds');\n\nvar extend = require('object-assign');\n\nvar glslify = require('glslify');\n\nvar pick = require('pick-by-alias');\n\nvar flatten = require('flatten-vertex-data');\n\nvar triangulate = require('earcut');\n\nvar normalize = require('array-normalize');\n\nvar _require = require('to-float32'),\n    float32 = _require.float32,\n    fract32 = _require.fract32;\n\nvar WeakMap = require('es6-weak-map');\n\nvar parseRect = require('parse-rect');\n\nvar findIndex = require('array-find-index');\n\nmodule.exports = Line2D;\n/** @constructor */\n\nfunction Line2D(regl, options) {\n  if (!(this instanceof Line2D)) return new Line2D(regl, options);\n\n  if (typeof regl === 'function') {\n    if (!options) options = {};\n    options.regl = regl;\n  } else {\n    options = regl;\n  }\n\n  if (options.length) options.positions = options;\n  regl = options.regl;\n\n  if (!regl.hasExtension('ANGLE_instanced_arrays')) {\n    throw Error('regl-error2d: `ANGLE_instanced_arrays` extension should be enabled');\n  } // persistent variables\n\n\n  this.gl = regl._gl;\n  this.regl = regl; // list of options for lines\n\n  this.passes = []; // cached shaders instance\n\n  this.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl); // init defaults\n\n  this.update(options);\n}\n\nLine2D.dashMult = 2;\nLine2D.maxPatternLength = 256;\nLine2D.precisionThreshold = 3e6;\nLine2D.maxPoints = 1e4;\nLine2D.maxLines = 2048; // cache of created draw calls per-regl instance\n\nLine2D.shaders = new WeakMap(); // create static shaders once\n\nLine2D.createShaders = function (regl) {\n  var offsetBuffer = regl.buffer({\n    usage: 'static',\n    type: 'float',\n    data: [0, 1, 0, 0, 1, 1, 1, 0]\n  });\n  var shaderOptions = {\n    primitive: 'triangle strip',\n    instances: regl.prop('count'),\n    count: 4,\n    offset: 0,\n    uniforms: {\n      miterMode: function miterMode(ctx, prop) {\n        return prop.join === 'round' ? 2 : 1;\n      },\n      miterLimit: regl.prop('miterLimit'),\n      scale: regl.prop('scale'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      thickness: regl.prop('thickness'),\n      dashTexture: regl.prop('dashTexture'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      dashLength: regl.prop('dashLength'),\n      viewport: function viewport(c, p) {\n        return [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight];\n      },\n      depth: regl.prop('depth')\n    },\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 0],\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    depth: {\n      enable: function enable(c, p) {\n        return !p.overlay;\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    scissor: {\n      enable: true,\n      box: regl.prop('viewport')\n    },\n    viewport: regl.prop('viewport') // simplified rectangular line shader\n\n  };\n  var drawRectLine = regl(extend({\n    vert: glslify('./rect-vert.glsl'),\n    frag: glslify('./rect-frag.glsl'),\n    attributes: {\n      // if point is at the end of segment\n      lineEnd: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 0\n      },\n      // if point is at the top of segment\n      lineTop: {\n        buffer: offsetBuffer,\n        divisor: 0,\n        stride: 8,\n        offset: 4\n      },\n      // beginning of line coordinate\n      aCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      // end of line coordinate\n      bCoord: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      aCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8,\n        divisor: 1\n      },\n      bCoordFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 16,\n        divisor: 1\n      },\n      color: {\n        buffer: regl.prop('colorBuffer'),\n        stride: 4,\n        offset: 0,\n        divisor: 1\n      }\n    }\n  }, shaderOptions)); // create regl draw\n\n  var drawMiterLine;\n\n  try {\n    drawMiterLine = regl(extend({\n      // culling removes polygon creasing\n      cull: {\n        enable: true,\n        face: 'back'\n      },\n      vert: glslify('./miter-vert.glsl'),\n      frag: glslify('./miter-frag.glsl'),\n      attributes: {\n        // is line end\n        lineEnd: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 0\n        },\n        // is line top\n        lineTop: {\n          buffer: offsetBuffer,\n          divisor: 0,\n          stride: 8,\n          offset: 4\n        },\n        // left color\n        aColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 0,\n          divisor: 1\n        },\n        // right color\n        bColor: {\n          buffer: regl.prop('colorBuffer'),\n          stride: 4,\n          offset: 4,\n          divisor: 1\n        },\n        prevCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 0,\n          divisor: 1\n        },\n        aCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 8,\n          divisor: 1\n        },\n        bCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 16,\n          divisor: 1\n        },\n        nextCoord: {\n          buffer: regl.prop('positionBuffer'),\n          stride: 8,\n          offset: 24,\n          divisor: 1\n        }\n      }\n    }, shaderOptions));\n  } catch (e) {\n    // IE/bad Webkit fallback\n    drawMiterLine = drawRectLine;\n  } // fill shader\n\n\n  var drawFill = regl({\n    primitive: 'triangle',\n    elements: function elements(ctx, prop) {\n      return prop.triangles;\n    },\n    offset: 0,\n    vert: glslify('./fill-vert.glsl'),\n    frag: glslify('./fill-frag.glsl'),\n    uniforms: {\n      scale: regl.prop('scale'),\n      color: regl.prop('fill'),\n      scaleFract: regl.prop('scaleFract'),\n      translateFract: regl.prop('translateFract'),\n      translate: regl.prop('translate'),\n      opacity: regl.prop('opacity'),\n      pixelRatio: regl.context('pixelRatio'),\n      id: regl.prop('id'),\n      viewport: function viewport(ctx, prop) {\n        return [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight];\n      }\n    },\n    attributes: {\n      position: {\n        buffer: regl.prop('positionBuffer'),\n        stride: 8,\n        offset: 8\n      },\n      positionFract: {\n        buffer: regl.prop('positionFractBuffer'),\n        stride: 8,\n        offset: 8\n      }\n    },\n    blend: shaderOptions.blend,\n    depth: {\n      enable: false\n    },\n    scissor: shaderOptions.scissor,\n    stencil: shaderOptions.stencil,\n    viewport: shaderOptions.viewport\n  });\n  return {\n    fill: drawFill,\n    rect: drawRectLine,\n    miter: drawMiterLine\n  };\n}; // used to for new lines instances\n\n\nLine2D.defaults = {\n  dashes: null,\n  join: 'miter',\n  miterLimit: 1,\n  thickness: 10,\n  cap: 'square',\n  color: 'black',\n  opacity: 1,\n  overlay: false,\n  viewport: null,\n  range: null,\n  close: false,\n  fill: null\n};\n\nLine2D.prototype.render = function () {\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n\n  this.draw();\n};\n\nLine2D.prototype.draw = function () {\n  var _this = this;\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  // render multiple polylines via regl batch\n  (args.length ? args : this.passes).forEach(function (s, i) {\n    // render array pass as a list of passes\n    if (s && Array.isArray(s)) return _this.draw.apply(_this, _toConsumableArray(s));\n    if (typeof s === 'number') s = _this.passes[s];\n    if (!(s && s.count > 1 && s.opacity)) return;\n\n    _this.regl._refresh();\n\n    if (s.fill && s.triangles && s.triangles.length > 2) {\n      _this.shaders.fill(s);\n    }\n\n    if (!s.thickness) return; // high scale is only available for rect mode with precision\n\n    if (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {\n      _this.shaders.rect(s);\n    } // thin this.passes or too many points are rendered as simplified rect shader\n    else if (s.join === 'rect' || !s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints)) {\n        _this.shaders.rect(s);\n      } else {\n        _this.shaders.miter(s);\n      }\n  });\n  return this;\n};\n\nLine2D.prototype.update = function (options) {\n  var _this2 = this;\n\n  if (!options) return;\n\n  if (options.length != null) {\n    if (typeof options[0] === 'number') options = [{\n      positions: options\n    }];\n  } // make options a batch\n  else if (!Array.isArray(options)) options = [options];\n\n  var regl = this.regl,\n      gl = this.gl; // process per-line settings\n\n  options.forEach(function (o, i) {\n    var state = _this2.passes[i];\n    if (o === undefined) return; // null-argument removes pass\n\n    if (o === null) {\n      _this2.passes[i] = null;\n      return;\n    }\n\n    if (typeof o[0] === 'number') o = {\n      positions: o // handle aliases\n\n    };\n    o = pick(o, {\n      positions: 'positions points data coords',\n      thickness: 'thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth',\n      join: 'lineJoin linejoin join type mode',\n      miterLimit: 'miterlimit miterLimit',\n      dashes: 'dash dashes dasharray dash-array dashArray',\n      color: 'color colour stroke colors colours stroke-color strokeColor',\n      fill: 'fill fill-color fillColor',\n      opacity: 'alpha opacity',\n      overlay: 'overlay crease overlap intersect',\n      close: 'closed close closed-path closePath',\n      range: 'range dataBox',\n      viewport: 'viewport viewBox',\n      hole: 'holes hole hollow',\n      splitNull: 'splitNull'\n    }); // init state\n\n    if (!state) {\n      _this2.passes[i] = state = {\n        id: i,\n        scale: null,\n        scaleFract: null,\n        translate: null,\n        translateFract: null,\n        count: 0,\n        hole: [],\n        depth: 0,\n        dashLength: 1,\n        dashTexture: regl.texture({\n          channels: 1,\n          data: new Uint8Array([255]),\n          width: 1,\n          height: 1,\n          mag: 'linear',\n          min: 'linear'\n        }),\n        colorBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'uint8',\n          data: new Uint8Array()\n        }),\n        positionBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        }),\n        positionFractBuffer: regl.buffer({\n          usage: 'dynamic',\n          type: 'float',\n          data: new Uint8Array()\n        })\n      };\n      o = extend({}, Line2D.defaults, o);\n    }\n\n    if (o.thickness != null) state.thickness = parseFloat(o.thickness);\n    if (o.opacity != null) state.opacity = parseFloat(o.opacity);\n    if (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit);\n\n    if (o.overlay != null) {\n      state.overlay = !!o.overlay;\n\n      if (i < Line2D.maxLines) {\n        state.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1.;\n      }\n    }\n\n    if (o.join != null) state.join = o.join;\n    if (o.hole != null) state.hole = o.hole;\n    if (o.fill != null) state.fill = !o.fill ? null : rgba(o.fill, 'uint8');\n    if (o.viewport != null) state.viewport = parseRect(o.viewport);\n\n    if (!state.viewport) {\n      state.viewport = parseRect([gl.drawingBufferWidth, gl.drawingBufferHeight]);\n    }\n\n    if (o.close != null) state.close = o.close; // reset positions\n\n    if (o.positions === null) o.positions = [];\n\n    if (o.positions) {\n      var positions, count; // if positions are an object with x/y\n\n      if (o.positions.x && o.positions.y) {\n        var xPos = o.positions.x;\n        var yPos = o.positions.y;\n        count = state.count = Math.max(xPos.length, yPos.length);\n        positions = new Float64Array(count * 2);\n\n        for (var _i = 0; _i < count; _i++) {\n          positions[_i * 2] = xPos[_i];\n          positions[_i * 2 + 1] = yPos[_i];\n        }\n      } else {\n        positions = flatten(o.positions, 'float64');\n        count = state.count = Math.floor(positions.length / 2);\n      }\n\n      var bounds = state.bounds = getBounds(positions, 2); // create fill positions\n      // FIXME: fill positions can be set only along with positions\n\n      if (state.fill) {\n        var pos = []; // filter bad vertices and remap triangles to ensure shape\n\n        var ids = {};\n        var lastId = 0;\n\n        for (var _i2 = 0, ptr = 0, l = state.count; _i2 < l; _i2++) {\n          var x = positions[_i2 * 2];\n          var y = positions[_i2 * 2 + 1];\n\n          if (isNaN(x) || isNaN(y) || x == null || y == null) {\n            x = positions[lastId * 2];\n            y = positions[lastId * 2 + 1];\n            ids[_i2] = lastId;\n          } else {\n            lastId = _i2;\n          }\n\n          pos[ptr++] = x;\n          pos[ptr++] = y;\n        } // split the input into multiple polygon at Null/NaN\n\n\n        if (o.splitNull) {\n          (function () {\n            // use \"ids\" to track the boundary of segment\n            // the keys in \"ids\" is the end boundary of a segment, or split point\n            // make sure there is at least one segment\n            if (!(state.count - 1 in ids)) ids[state.count] = state.count - 1;\n            var splits = Object.keys(ids).map(Number).sort(function (a, b) {\n              return a - b;\n            });\n            var split_triangles = [];\n            var base = 0; // do not split holes\n\n            var hole_base = state.hole != null ? state.hole[0] : null;\n\n            if (hole_base != null) {\n              var last_id = findIndex(splits, function (e) {\n                return e >= hole_base;\n              });\n              splits = splits.slice(0, last_id);\n              splits.push(hole_base);\n            }\n\n            var _loop = function _loop(_i3) {\n              // create temporary pos array with only one segment and all the holes\n              var seg_pos = pos.slice(base * 2, splits[_i3] * 2).concat(hole_base ? pos.slice(hole_base * 2) : []);\n              var hole = (state.hole || []).map(function (e) {\n                return e - hole_base + (splits[_i3] - base);\n              });\n              var triangles = triangulate(seg_pos, hole); // map triangle index back to the original pos buffer\n\n              triangles = triangles.map(function (e) {\n                return e + base + (e + base < splits[_i3] ? 0 : hole_base - splits[_i3]);\n              });\n              split_triangles.push.apply(split_triangles, _toConsumableArray(triangles)); // skip split point\n\n              base = splits[_i3] + 1;\n            };\n\n            for (var _i3 = 0; _i3 < splits.length; _i3++) {\n              _loop(_i3);\n            }\n\n            for (var _i4 = 0, _l = split_triangles.length; _i4 < _l; _i4++) {\n              if (ids[split_triangles[_i4]] != null) split_triangles[_i4] = ids[split_triangles[_i4]];\n            }\n\n            state.triangles = split_triangles;\n          })();\n        } else {\n          // treat the wholw input as a single polygon\n          var triangles = triangulate(pos, state.hole || []);\n\n          for (var _i5 = 0, _l2 = triangles.length; _i5 < _l2; _i5++) {\n            if (ids[triangles[_i5]] != null) triangles[_i5] = ids[triangles[_i5]];\n          }\n\n          state.triangles = triangles;\n        }\n      } // update position buffers\n\n\n      var npos = new Float64Array(positions);\n      normalize(npos, 2, bounds);\n      var positionData = new Float64Array(count * 2 + 6); // rotate first segment join\n\n      if (state.close) {\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[0] = npos[count * 2 - 4];\n          positionData[1] = npos[count * 2 - 3];\n        } else {\n          positionData[0] = npos[count * 2 - 2];\n          positionData[1] = npos[count * 2 - 1];\n        }\n      } else {\n        positionData[0] = npos[0];\n        positionData[1] = npos[1];\n      }\n\n      positionData.set(npos, 2); // add last segment\n\n      if (state.close) {\n        // ignore coinciding start/end\n        if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {\n          positionData[count * 2 + 2] = npos[2];\n          positionData[count * 2 + 3] = npos[3];\n          state.count -= 1;\n        } else {\n          positionData[count * 2 + 2] = npos[0];\n          positionData[count * 2 + 3] = npos[1];\n          positionData[count * 2 + 4] = npos[2];\n          positionData[count * 2 + 5] = npos[3];\n        }\n      } // add stub\n      else {\n          positionData[count * 2 + 2] = npos[count * 2 - 2];\n          positionData[count * 2 + 3] = npos[count * 2 - 1];\n          positionData[count * 2 + 4] = npos[count * 2 - 2];\n          positionData[count * 2 + 5] = npos[count * 2 - 1];\n        }\n\n      var float_data = float32(positionData);\n      state.positionBuffer(float_data);\n      var frac_data = fract32(positionData, float_data);\n      state.positionFractBuffer(frac_data);\n    }\n\n    if (o.range) {\n      state.range = o.range;\n    } else if (!state.range) {\n      state.range = state.bounds;\n    }\n\n    if ((o.range || o.positions) && state.count) {\n      var _bounds = state.bounds;\n      var boundsW = _bounds[2] - _bounds[0],\n          boundsH = _bounds[3] - _bounds[1];\n      var rangeW = state.range[2] - state.range[0],\n          rangeH = state.range[3] - state.range[1];\n      state.scale = [boundsW / rangeW, boundsH / rangeH];\n      state.translate = [-state.range[0] / rangeW + _bounds[0] / rangeW || 0, -state.range[1] / rangeH + _bounds[1] / rangeH || 0];\n      state.scaleFract = fract32(state.scale);\n      state.translateFract = fract32(state.translate);\n    }\n\n    if (o.dashes) {\n      var dashLength = 0.,\n          dashData;\n\n      if (!o.dashes || o.dashes.length < 2) {\n        dashLength = 1.;\n        dashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);\n      } else {\n        dashLength = 0.;\n\n        for (var _i6 = 0; _i6 < o.dashes.length; ++_i6) {\n          dashLength += o.dashes[_i6];\n        }\n\n        dashData = new Uint8Array(dashLength * Line2D.dashMult);\n        var _ptr = 0;\n        var fillColor = 255; // repeat texture two times to provide smooth 0-step\n\n        for (var k = 0; k < 2; k++) {\n          for (var _i7 = 0; _i7 < o.dashes.length; ++_i7) {\n            for (var j = 0, _l3 = o.dashes[_i7] * Line2D.dashMult * .5; j < _l3; ++j) {\n              dashData[_ptr++] = fillColor;\n            }\n\n            fillColor ^= 255;\n          }\n        }\n      }\n\n      state.dashLength = dashLength;\n      state.dashTexture({\n        channels: 1,\n        data: dashData,\n        width: dashData.length,\n        height: 1,\n        mag: 'linear',\n        min: 'linear'\n      }, 0, 0);\n    }\n\n    if (o.color) {\n      var _count = state.count;\n      var colors = o.color;\n      if (!colors) colors = 'transparent';\n      var colorData = new Uint8Array(_count * 4 + 4); // convert colors to typed arrays\n\n      if (!Array.isArray(colors) || typeof colors[0] === 'number') {\n        var c = rgba(colors, 'uint8');\n\n        for (var _i8 = 0; _i8 < _count + 1; _i8++) {\n          colorData.set(c, _i8 * 4);\n        }\n      } else {\n        for (var _i9 = 0; _i9 < _count; _i9++) {\n          var _c = rgba(colors[_i9], 'uint8');\n\n          colorData.set(_c, _i9 * 4);\n        }\n\n        colorData.set(rgba(colors[0], 'uint8'), _count * 4);\n      }\n\n      state.colorBuffer({\n        usage: 'dynamic',\n        type: 'uint8',\n        data: colorData\n      });\n    }\n  }); // remove unmentioned passes\n\n  if (options.length < this.passes.length) {\n    for (var i = options.length; i < this.passes.length; i++) {\n      var pass = this.passes[i];\n      if (!pass) continue;\n      pass.colorBuffer.destroy();\n      pass.positionBuffer.destroy();\n      pass.dashTexture.destroy();\n    }\n\n    this.passes.length = options.length;\n  } // remove null items\n\n\n  var passes = [];\n\n  for (var _i10 = 0; _i10 < this.passes.length; _i10++) {\n    if (this.passes[_i10] !== null) passes.push(this.passes[_i10]);\n  }\n\n  this.passes = passes;\n  return this;\n};\n\nLine2D.prototype.destroy = function () {\n  this.passes.forEach(function (pass) {\n    pass.colorBuffer.destroy();\n    pass.positionBuffer.destroy();\n    pass.dashTexture.destroy();\n  });\n  this.passes.length = 0;\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}